<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2024-10-10 Thu 17:26 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>dlfs</title>
<meta name="author" content="harrifeng@outlook.com" />
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="src/readtheorg_theme/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="src/readtheorg_theme/css/readtheorg.css"/>
<script type="text/javascript" src="src/lib/js/jquery.min.js"></script>
<script type="text/javascript" src="src/lib/js/bootstrap.min.js"></script>
<script type="text/javascript" src="src/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="src/readtheorg_theme/js/readtheorg.js"></script>
<script>
 window.MathJax = {
   tex: {
     ams: {
       multlineWidth: '85%'
     },
     tags: 'ams',
     tagSide: 'right',
     tagIndent: '.8em'
   },
   chtml: {
     scale: 1.0,
     displayAlign: 'center',
     displayIndent: '0em'
   },
   svg: {
     scale: 1.0,
     displayAlign: 'center',
     displayIndent: '0em'
   },
   output: {
     font: 'mathjax-modern',
     displayOverflow: 'overflow'
   }
 };
</script>

<script
  id="MathJax-script"
  async
  src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/mathjax/3.2.0/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">dlfs</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orgec2137a">1. Python 入门</a>
<ul>
<li><a href="#orga7e0ee7">1.1. Python是什么</a></li>
<li><a href="#org3f226fc">1.2. Python的安装</a>
<ul>
<li><a href="#org71743f9">1.2.1. Python版本</a></li>
<li><a href="#orgdb46d71">1.2.2. 使用的外部库</a></li>
<li><a href="#org2307ef0">1.2.3. Anaconda发行版</a></li>
</ul>
</li>
<li><a href="#orgdb50273">1.3. Python解释器</a>
<ul>
<li><a href="#org3ecc983">1.3.1. 算术计算</a></li>
<li><a href="#orge2fa4b9">1.3.2. 数据类型</a></li>
<li><a href="#org4178a8d">1.3.3. 变量</a></li>
<li><a href="#org1f5ec4e">1.3.4. 列表</a></li>
<li><a href="#org30ca080">1.3.5. 字典</a></li>
<li><a href="#org1ac8c53">1.3.6. 布尔型</a></li>
<li><a href="#org7dbc843">1.3.7. if 语句</a></li>
<li><a href="#orgec0fdb9">1.3.8. for 语句</a></li>
<li><a href="#org8d5035c">1.3.9. 函数</a></li>
</ul>
</li>
<li><a href="#org4bc42f6">1.4. Python脚本文件</a>
<ul>
<li><a href="#org62a0a67">1.4.1. 保存为文件</a></li>
<li><a href="#orgb4b62fe">1.4.2. 类</a></li>
</ul>
</li>
<li><a href="#org6eb691d">1.5. NumPy</a>
<ul>
<li><a href="#orgfab2d6b">1.5.1. 导入NumPy</a></li>
<li><a href="#org73f9bd5">1.5.2. 生成NumPy数组</a></li>
<li><a href="#org0a6b55c">1.5.3. NumPy的算术运算</a></li>
<li><a href="#org36ed73e">1.5.4. NumPy的N维数组</a></li>
<li><a href="#org498d550">1.5.5. 广播</a></li>
<li><a href="#org6606d34">1.5.6. 访问元素</a></li>
</ul>
</li>
<li><a href="#org5fe8790">1.6. Matplotlib</a>
<ul>
<li><a href="#org12718e9">1.6.1. 绘制简单图形</a></li>
<li><a href="#orgf2a475e">1.6.2. pyplot的功能</a></li>
<li><a href="#org8ff077b">1.6.3. 显示图像</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org89530a4">2. 感知机</a>
<ul>
<li><a href="#orgeda71c0">2.1. 感知机是什么</a></li>
<li><a href="#org1e752da">2.2. 简单的逻辑电路</a>
<ul>
<li><a href="#orge47bbdf">2.2.1. 与门</a></li>
<li><a href="#orgffc6c27">2.2.2. 与非门和或门</a></li>
</ul>
</li>
<li><a href="#orgaddd7b8">2.3. 感知机的实现</a>
<ul>
<li><a href="#org5398757">2.3.1. 简单的实现</a></li>
<li><a href="#org6fa0dcb">2.3.2. 导入权重和偏置</a></li>
<li><a href="#org00ad4b5">2.3.3. 使用权重和偏置的实现</a></li>
</ul>
</li>
<li><a href="#org2b68428">2.4. 感知机的局限性</a>
<ul>
<li><a href="#org11f379a">2.4.1. 异或门</a></li>
<li><a href="#orgafca20c">2.4.2. 线性和非线性</a></li>
</ul>
</li>
<li><a href="#orgba79bb3">2.5. 多层感知机</a>
<ul>
<li><a href="#orgfd99fd7">2.5.1. 已有门电路组合</a></li>
<li><a href="#org43fc911">2.5.2. 异或门的实现</a></li>
</ul>
</li>
<li><a href="#org9e5be24">2.6. 从与非门到计算机</a></li>
</ul>
</li>
<li><a href="#org2e9cf41">3. 神经网络</a>
<ul>
<li><a href="#org5cae72f">3.1. 从感知机到神经网络</a>
<ul>
<li><a href="#org6c17938">3.1.1. 神经网路的例子</a></li>
<li><a href="#orgb2713ec">3.1.2. 复习感知机</a></li>
<li><a href="#org4b5fcf2">3.1.3. 激活函数登场</a></li>
</ul>
</li>
<li><a href="#org384ecd8">3.2. 激活函数</a>
<ul>
<li><a href="#org5fefade">3.2.1. sigmoid函数</a></li>
<li><a href="#org08b66a3">3.2.2. 阶跃函数的实现</a></li>
<li><a href="#org7aaffa9">3.2.3. 阶跃函数的图形</a></li>
<li><a href="#org96237d9">3.2.4. sigmoid 函数的实现</a></li>
<li><a href="#orgc13e558">3.2.5. sigmoid函数和阶跃函数的比较</a></li>
<li><a href="#org5e3cd61">3.2.6. 非线性函数</a></li>
<li><a href="#org2c0a9d1">3.2.7. ReLU函数</a></li>
</ul>
</li>
<li><a href="#org88940b5">3.3. 多维数组的运算</a>
<ul>
<li><a href="#orgdab7f60">3.3.1. 多维数组</a></li>
<li><a href="#orga1a4533">3.3.2. 矩阵乘法</a></li>
<li><a href="#org47298d4">3.3.3. 神经网络的内机</a></li>
</ul>
</li>
<li><a href="#org22fde56">3.4. 3层神经网络的实现</a>
<ul>
<li><a href="#org0246dd8">3.4.1. 符号确认</a></li>
<li><a href="#org519c63e">3.4.2. 各层间信号传递的实现</a></li>
<li><a href="#org50645b2">3.4.3. 代码现小结</a></li>
</ul>
</li>
<li><a href="#orgf160bc2">3.5. 输出层的设计</a>
<ul>
<li><a href="#orgff00b1a">3.5.1. 恒等函数和softmax函数</a></li>
<li><a href="#org8c25494">3.5.2. 实现softmax函数时的注意事项</a></li>
<li><a href="#org489651c">3.5.3. softmax函数的特征</a></li>
<li><a href="#org3cd9544">3.5.4. 输出层的神经元数量</a></li>
</ul>
</li>
<li><a href="#orgaf758d8">3.6. 手写数字识别</a>
<ul>
<li><a href="#orgd2a8302">3.6.1. MNIST数据集</a></li>
<li><a href="#org13a4e68">3.6.2. 神经网络的推理处理</a></li>
<li><a href="#org60f9763">3.6.3. 批处理</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgd0fcc3c">4. 神经网络的学习</a>
<ul>
<li><a href="#orge76e1d6">4.1. 从数据中学习</a>
<ul>
<li><a href="#org6a1544c">4.1.1. 数据驱动</a></li>
<li><a href="#org0d40100">4.1.2. 训练数据和测试数据</a></li>
</ul>
</li>
<li><a href="#org16eb716">4.2. 损失函数</a>
<ul>
<li><a href="#org8aea2b1">4.2.1. 均方误差</a></li>
<li><a href="#org48c115f">4.2.2. 交叉熵误差</a></li>
<li><a href="#org8f092ad">4.2.3. mini-batch学习</a></li>
<li><a href="#org75e52d6">4.2.4. mini-batch版交叉熵误差的实现</a></li>
<li><a href="#org3c65921">4.2.5. 为何要设定损失函数</a></li>
</ul>
</li>
<li><a href="#org3e04a72">4.3. 数值微分</a>
<ul>
<li><a href="#org5cbcd6c">4.3.1. 导数</a></li>
<li><a href="#orgcebc8b7">4.3.2. 数值微分的例子</a></li>
<li><a href="#orgd2693d6">4.3.3. 偏导数</a></li>
</ul>
</li>
<li><a href="#orgd977d0a">4.4. 梯度</a>
<ul>
<li><a href="#orgb359ff1">4.4.1. 梯度法</a></li>
<li><a href="#orgbf3ccf3">4.4.2. 神经网络的梯度</a></li>
</ul>
</li>
<li><a href="#org5218008">4.5. 学习算法的实现</a>
<ul>
<li><a href="#org471dfcb">4.5.1. 2层神经网络的类</a></li>
<li><a href="#org50568bc">4.5.2. mini-batch的实现</a></li>
<li><a href="#org8d3c9fa">4.5.3. 基于测试数据的评价</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org1905191">5. 误差反向传播法</a></li>
<li><a href="#org0c8a4a8">6. 与学习相关的技巧</a></li>
<li><a href="#org0727760">7. 卷积神经网络</a></li>
<li><a href="#org324de53">8. 深度学习</a></li>
</ul>
</div>
</div>
<div id="outline-container-orgec2137a" class="outline-2">
<h2 id="orgec2137a"><span class="section-number-2">1.</span> Python 入门</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-orga7e0ee7" class="outline-3">
<h3 id="orga7e0ee7"><span class="section-number-3">1.1.</span> Python是什么</h3>
<div class="outline-text-3" id="text-1-1">
<ul class="org-ul">
<li>Python是机器学习事实上的默认语言</li>
</ul>
</div>
</div>
<div id="outline-container-org3f226fc" class="outline-3">
<h3 id="org3f226fc"><span class="section-number-3">1.2.</span> Python的安装</h3>
<div class="outline-text-3" id="text-1-2">
</div>
<div id="outline-container-org71743f9" class="outline-4">
<h4 id="org71743f9"><span class="section-number-4">1.2.1.</span> Python版本</h4>
<div class="outline-text-4" id="text-1-2-1">
<ul class="org-ul">
<li>本书使用Python3.x版本</li>
</ul>
</div>
</div>
<div id="outline-container-orgdb46d71" class="outline-4">
<h4 id="orgdb46d71"><span class="section-number-4">1.2.2.</span> 使用的外部库</h4>
<div class="outline-text-4" id="text-1-2-2">
<ul class="org-ul">
<li>本书目标是从零实现深度学习,所以只会依赖如下两个库:
<ul class="org-ul">
<li>NumPy: 便利我们进行科学技术和矩阵计算</li>
<li>Matplotlib: 用来画图的库</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org2307ef0" class="outline-4">
<h4 id="org2307ef0"><span class="section-number-4">1.2.3.</span> Anaconda发行版</h4>
<div class="outline-text-4" id="text-1-2-3">
<ul class="org-ul">
<li>推荐安装Anaconda发行版,这个发行版侧重于数据分析,已经包含了前面讲的,本书依赖的两个库NumPy和Matplotlib</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgdb50273" class="outline-3">
<h3 id="orgdb50273"><span class="section-number-3">1.3.</span> Python解释器</h3>
<div class="outline-text-3" id="text-1-3">
<ul class="org-ul">
<li><p>
使用如下代码确认安装的python版本
</p>
<div class="org-src-container">
<pre class="src src-shell">$ python --version
Python 3.10.8
</pre>
</div></li>
<li><p>
python是动态语言,这种语言一般都会有REPL(Read-Eval-Print-Loop),可以实时查看运行结果
</p>
<div class="org-src-container">
<pre class="src src-shell">$ python -i
Python 3.10.8 <span style="color: #3a81c3;">(</span>main, Nov 24 2022, 08:08:27<span style="color: #3a81c3;">)</span> <span style="color: #3a81c3;">[</span>Clang 14.0.6 <span style="color: #3a81c3;">]</span> on darwin
Type <span style="color: #2d9574;">"help"</span>, <span style="color: #2d9574;">"copyright"</span>, <span style="color: #2d9574;">"credits"</span> or <span style="color: #2d9574;">"license"</span> for more information.
&gt;&gt;&gt; 1 + 2
3
</pre>
</div></li>
</ul>
</div>
<div id="outline-container-org3ecc983" class="outline-4">
<h4 id="org3ecc983"><span class="section-number-4">1.3.1.</span> 算术计算</h4>
<div class="outline-text-4" id="text-1-3-1">
<ul class="org-ul">
<li><p>
一些简单的计算可用直接在REPL中进行
</p>
<div class="org-src-container">
<pre class="src src-shell">&gt;&gt;&gt; 1 - 2
-1
&gt;&gt;&gt; 4 * 5
20
&gt;&gt;&gt; 7 / 5
1.4
&gt;&gt;&gt; 3 ** 2
9
</pre>
</div></li>
<li>需要注意的是python3整数除以整数得到的是浮点数</li>
</ul>
</div>
</div>
<div id="outline-container-orge2fa4b9" class="outline-4">
<h4 id="orge2fa4b9"><span class="section-number-4">1.3.2.</span> 数据类型</h4>
<div class="outline-text-4" id="text-1-3-2">
<ul class="org-ul">
<li><p>
Python中可以使用type来判断数据的类型
</p>
<div class="org-src-container">
<pre class="src src-shell">&gt;&gt;&gt; type<span style="color: #3a81c3;">(</span>10<span style="color: #3a81c3;">)</span>
&lt;class <span style="color: #2d9574;">'int'</span>&gt;
&gt;&gt;&gt; type<span style="color: #3a81c3;">(</span>2.718<span style="color: #3a81c3;">)</span>
&lt;class <span style="color: #2d9574;">'float'</span>&gt;
&gt;&gt;&gt; type<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"hello"</span><span style="color: #3a81c3;">)</span>
&lt;class <span style="color: #2d9574;">'str'</span>&gt;
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-org4178a8d" class="outline-4">
<h4 id="org4178a8d"><span class="section-number-4">1.3.3.</span> 变量</h4>
<div class="outline-text-4" id="text-1-3-3">
<ul class="org-ul">
<li><p>
Python中变量例子如下
</p>
<div class="org-src-container">
<pre class="src src-shell">&gt;&gt;&gt; x = 10
&gt;&gt;&gt; print<span style="color: #3a81c3;">(</span>x<span style="color: #3a81c3;">)</span>
10
&gt;&gt;&gt; x = 100
&gt;&gt;&gt; print<span style="color: #3a81c3;">(</span>x<span style="color: #3a81c3;">)</span>
100
&gt;&gt;&gt; y = 3.14
&gt;&gt;&gt; x * y
314.0
&gt;&gt;&gt; type<span style="color: #3a81c3;">(</span>x*y<span style="color: #3a81c3;">)</span>
&lt;class <span style="color: #2d9574;">'float'</span>&gt;
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-org1f5ec4e" class="outline-4">
<h4 id="org1f5ec4e"><span class="section-number-4">1.3.4.</span> 列表</h4>
<div class="outline-text-4" id="text-1-3-4">
<ul class="org-ul">
<li><p>
列表是Python当中非常重要的类型,而且支持slicing,非常好用
</p>
<div class="org-src-container">
<pre class="src src-shell">&gt;&gt;&gt; a = <span style="color: #3a81c3;">[</span>1, 2, 3, 4,5<span style="color: #3a81c3;">]</span>
&gt;&gt;&gt; print<span style="color: #3a81c3;">(</span>a<span style="color: #3a81c3;">)</span>
<span style="color: #3a81c3;">[</span>1, 2, 3, 4, 5<span style="color: #3a81c3;">]</span>
&gt;&gt;&gt; len<span style="color: #3a81c3;">(</span>a<span style="color: #3a81c3;">)</span>
5
&gt;&gt;&gt; a<span style="color: #3a81c3;">[</span>0<span style="color: #3a81c3;">]</span>
1
&gt;&gt;&gt; a<span style="color: #3a81c3;">[</span>0:2<span style="color: #3a81c3;">]</span>
<span style="color: #3a81c3;">[</span>1, 2<span style="color: #3a81c3;">]</span>
&gt;&gt;&gt; a<span style="color: #3a81c3;">[</span>1:<span style="color: #3a81c3;">]</span>
<span style="color: #3a81c3;">[</span>2, 3, 4, 5<span style="color: #3a81c3;">]</span>
&gt;&gt;&gt; a<span style="color: #3a81c3;">[</span>:-2<span style="color: #3a81c3;">]</span>
<span style="color: #3a81c3;">[</span>1, 2, 3<span style="color: #3a81c3;">]</span>
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-org30ca080" class="outline-4">
<h4 id="org30ca080"><span class="section-number-4">1.3.5.</span> 字典</h4>
<div class="outline-text-4" id="text-1-3-5">
<ul class="org-ul">
<li><p>
python中的哈希表叫做字典,字典基本是最常用数据结构了
</p>
<div class="org-src-container">
<pre class="src src-shell">&gt;&gt;&gt; me = <span style="color: #3a81c3;">{</span><span style="color: #2d9574;">"height"</span>: 180<span style="color: #3a81c3;">}</span>
&gt;&gt;&gt; me<span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"height"</span><span style="color: #3a81c3;">]</span>
180
&gt;&gt;&gt; me<span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"weight"</span><span style="color: #3a81c3;">]</span> = 70
&gt;&gt;&gt; print<span style="color: #3a81c3;">(</span>me<span style="color: #3a81c3;">)</span>
<span style="color: #3a81c3;">{</span><span style="color: #2d9574;">'height'</span>: 180, <span style="color: #2d9574;">'weight'</span>: 70<span style="color: #3a81c3;">}</span>
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-org1ac8c53" class="outline-4">
<h4 id="org1ac8c53"><span class="section-number-4">1.3.6.</span> 布尔型</h4>
<div class="outline-text-4" id="text-1-3-6">
<ul class="org-ul">
<li>Python中的bool值为首字母大写的True和False</li>
<li>针对bool类型运算符有:
<ul class="org-ul">
<li>and</li>
<li>or</li>
<li>not</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org7dbc843" class="outline-4">
<h4 id="org7dbc843"><span class="section-number-4">1.3.7.</span> if 语句</h4>
<div class="outline-text-4" id="text-1-3-7">
<ul class="org-ul">
<li>if语句为级别逻辑语句</li>
</ul>
</div>
</div>
<div id="outline-container-orgec0fdb9" class="outline-4">
<h4 id="orgec0fdb9"><span class="section-number-4">1.3.8.</span> for 语句</h4>
<div class="outline-text-4" id="text-1-3-8">
<ul class="org-ul">
<li>for语句为级别循环语句</li>
</ul>
</div>
</div>
<div id="outline-container-org8d5035c" class="outline-4">
<h4 id="org8d5035c"><span class="section-number-4">1.3.9.</span> 函数</h4>
<div class="outline-text-4" id="text-1-3-9">
<ul class="org-ul">
<li>python中使用def来定义函数</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org4bc42f6" class="outline-3">
<h3 id="org4bc42f6"><span class="section-number-3">1.4.</span> Python脚本文件</h3>
<div class="outline-text-3" id="text-1-4">
</div>
<div id="outline-container-org62a0a67" class="outline-4">
<h4 id="org62a0a67"><span class="section-number-4">1.4.1.</span> 保存为文件</h4>
<div class="outline-text-4" id="text-1-4-1">
<ul class="org-ul">
<li>前面都是在解释器里面运行,但是真正的Python代码一般是保存在一个文件里面(一般以py结尾),然后运行</li>
</ul>
</div>
</div>
<div id="outline-container-orgb4b62fe" class="outline-4">
<h4 id="orgb4b62fe"><span class="section-number-4">1.4.2.</span> 类</h4>
<div class="outline-text-4" id="text-1-4-2">
<ul class="org-ul">
<li>Python中使用class来定义新的类型</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org6eb691d" class="outline-3">
<h3 id="org6eb691d"><span class="section-number-3">1.5.</span> NumPy</h3>
<div class="outline-text-3" id="text-1-5">
</div>
<div id="outline-container-orgfab2d6b" class="outline-4">
<h4 id="orgfab2d6b"><span class="section-number-4">1.5.1.</span> 导入NumPy</h4>
<div class="outline-text-4" id="text-1-5-1">
<ul class="org-ul">
<li><p>
numpy是事实上的科学计算标准,但是它不再python的标注库里面,我们通常以如下代码引入numpy
</p>
<div class="org-src-container">
<pre class="src src-shell">&gt;&gt;&gt; import numpy as np
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-org73f9bd5" class="outline-4">
<h4 id="org73f9bd5"><span class="section-number-4">1.5.2.</span> 生成NumPy数组</h4>
<div class="outline-text-4" id="text-1-5-2">
<ul class="org-ul">
<li><p>
Python的数组我们前面讲过了,叫做列表. 而NumPy的数组就叫NumPy数组,它需要使用list作为参数创建(当然也有
其他创建方式)
</p>
<div class="org-src-container">
<pre class="src src-shell">&gt;&gt;&gt; x = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>1.0,2.0,3.0<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; print<span style="color: #3a81c3;">(</span>x<span style="color: #3a81c3;">)</span>
<span style="color: #3a81c3;">[</span>1. 2. 3.<span style="color: #3a81c3;">]</span>
&gt;&gt;&gt; type<span style="color: #3a81c3;">(</span>x<span style="color: #3a81c3;">)</span>
&lt;class <span style="color: #2d9574;">'numpy.ndarray'</span>&gt;
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-org0a6b55c" class="outline-4">
<h4 id="org0a6b55c"><span class="section-number-4">1.5.3.</span> NumPy的算术运算</h4>
<div class="outline-text-4" id="text-1-5-3">
<ul class="org-ul">
<li>NumPy的运算都是element-wise的:
<ul class="org-ul">
<li><p>
如果两个numpy array进行运算,那么就是对应位置的element相互进行运算
</p>
<div class="org-src-container">
<pre class="src src-shell">&gt;&gt;&gt; x = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>1.0, 2.0, 3.0<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; y = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>2.0, 4.0, 6.0<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; x + y
<span style="color: #6c3163; font-weight: bold;">array</span><span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>3., 6., 9.<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; x * y
<span style="color: #6c3163; font-weight: bold;">array</span><span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span> 2.,  8., 18.<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; x / y
<span style="color: #6c3163; font-weight: bold;">array</span><span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>0.5, 0.5, 0.5<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
</pre>
</div></li>
<li><p>
如果一个numpy array和一个数值(标量)进行运算,那么就是array的每个element和标量进行运算
</p>
<div class="org-src-container">
<pre class="src src-shell">&gt;&gt;&gt; x = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>1.0, 2.0, 3.0<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; x / 2.0
<span style="color: #6c3163; font-weight: bold;">array</span><span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>0.5, 1. , 1.5<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org36ed73e" class="outline-4">
<h4 id="org36ed73e"><span class="section-number-4">1.5.4.</span> NumPy的N维数组</h4>
<div class="outline-text-4" id="text-1-5-4">
<ul class="org-ul">
<li>NumPy还可以生成多维数组,比如下面是一个二维数组的例子
<ul class="org-ul">
<li><p>
例子如下
</p>
<div class="org-src-container">
<pre class="src src-shell">&gt;&gt;&gt; A = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span><span style="color: #2d9574;">[</span>1,2<span style="color: #2d9574;">]</span>, <span style="color: #2d9574;">[</span>3,4<span style="color: #2d9574;">]</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; print<span style="color: #3a81c3;">(</span>A<span style="color: #3a81c3;">)</span>
<span style="color: #3a81c3;">[</span><span style="color: #6c3163;">[</span>1 2<span style="color: #6c3163;">]</span>
 <span style="color: #6c3163;">[</span>3 4<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">]</span>
&gt;&gt;&gt; A.shape
<span style="color: #3a81c3;">(</span>2, 2<span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; A.dtype
<span style="color: #6c3163; font-weight: bold;">dtype</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">'int64'</span><span style="color: #3a81c3;">)</span>
</pre>
</div></li>
<li><p>
我们可以使用shape来查看矩阵的形状, 如果是一维数组,那么只有一个维度的长度
</p>
<div class="org-src-container">
<pre class="src src-shell">&gt;&gt;&gt; a = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>1, 2, 3<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; a
<span style="color: #6c3163; font-weight: bold;">array</span><span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>1, 2, 3<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; a.shape
<span style="color: #3a81c3;">(</span>3,<span style="color: #3a81c3;">)</span>
</pre>
</div></li>
<li>我们还可以使用dtype查看成员的数据类型(这里就需要numpy array的所有成员的类型一致)</li>
</ul></li>
<li>和一维数组的是运算一样, 多维NumPy数组的运算也是element-wise的:
<ul class="org-ul">
<li><p>
一个多维数组和一个维度相同的多维数组运算和一位数组相同
</p>
<div class="org-src-container">
<pre class="src src-shell">&gt;&gt;&gt; print<span style="color: #3a81c3;">(</span>A<span style="color: #3a81c3;">)</span>
<span style="color: #3a81c3;">[</span><span style="color: #6c3163;">[</span>1 2<span style="color: #6c3163;">]</span>
 <span style="color: #6c3163;">[</span>3 4<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">]</span>
&gt;&gt;&gt; B = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span><span style="color: #2d9574;">[</span>3,0<span style="color: #2d9574;">]</span>,<span style="color: #2d9574;">[</span>0,6<span style="color: #2d9574;">]</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; A + B
<span style="color: #6c3163; font-weight: bold;">array</span><span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span><span style="color: #2d9574;">[</span> 4,  2<span style="color: #2d9574;">]</span>,
       <span style="color: #2d9574;">[</span> 3, 10<span style="color: #2d9574;">]</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; A * B
<span style="color: #6c3163; font-weight: bold;">array</span><span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span><span style="color: #2d9574;">[</span> 3,  0<span style="color: #2d9574;">]</span>,
       <span style="color: #2d9574;">[</span> 0, 24<span style="color: #2d9574;">]</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
</pre>
</div></li>
<li><p>
一个多维数组和一个标量进行运算也和一维数组相同
</p>
<div class="org-src-container">
<pre class="src src-shell">&gt;&gt;&gt; print<span style="color: #3a81c3;">(</span>A<span style="color: #3a81c3;">)</span>
<span style="color: #3a81c3;">[</span><span style="color: #6c3163;">[</span>1 2<span style="color: #6c3163;">]</span>
 <span style="color: #6c3163;">[</span>3 4<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">]</span>
&gt;&gt;&gt; A * 10
<span style="color: #6c3163; font-weight: bold;">array</span><span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span><span style="color: #2d9574;">[</span>10, 20<span style="color: #2d9574;">]</span>,
       <span style="color: #2d9574;">[</span>30, 40<span style="color: #2d9574;">]</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
</pre>
</div></li>
</ul></li>
<li>数学上,会有一些特别的名字,比如:
<ul class="org-ul">
<li>单一的数值叫做: 标量(scalar)</li>
<li>一维数组叫做: 向量(vector)</li>
<li>二维数组叫做: 矩阵(matrix)</li>
<li>三维及以上数组叫做: 张量(tensor)</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org498d550" class="outline-4">
<h4 id="org498d550"><span class="section-number-4">1.5.5.</span> 广播</h4>
<div class="outline-text-4" id="text-1-5-5">
<ul class="org-ul">
<li><p>
之前我们看到过,一维或者多维数组都可以和自己维度不同的标量进行乘(除)法运算(加减法不行),其原理是NumPy
把标量扩展成了对应的形状.比如下面的例子,标量10就被扩展成了2*2的形状
</p>

<div id="org9ec1977" class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/image/master/dlfs/1-1.png" alt="1-1.png" />
</p>
<p><span class="figure-number">Figure 1: </span>dlfs/1-1.png</p>
</div></li>
<li>这种把乘数扩展后再和被乘数进行乘法(除法)计算的方法,就叫做广播(broadcast)</li>
<li>广播定义之所以是把"乘数"扩展,而不是把标量扩展,是因为广播还支持非标量
<ul class="org-ul">
<li><p>
比如如下代码乘数是一维vector,也是支持广播操作的
</p>
<div class="org-src-container">
<pre class="src src-shell">&gt;&gt;&gt; A = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span><span style="color: #2d9574;">[</span>1,2<span style="color: #2d9574;">]</span>,<span style="color: #2d9574;">[</span>3,4<span style="color: #2d9574;">]</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; B = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>10,20<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; A * B
<span style="color: #6c3163; font-weight: bold;">array</span><span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span><span style="color: #2d9574;">[</span>10, 40<span style="color: #2d9574;">]</span>,
       <span style="color: #2d9574;">[</span>30, 80<span style="color: #2d9574;">]</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
</pre>
</div></li>
<li><p>
我们可以从下图看到,一维vector是如何被扩展的
</p>

<div id="org3d06598" class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/image/master/dlfs/1-2.png" alt="1-2.png" />
</p>
<p><span class="figure-number">Figure 2: </span>dlfs/1-2.png</p>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org6606d34" class="outline-4">
<h4 id="org6606d34"><span class="section-number-4">1.5.6.</span> 访问元素</h4>
<div class="outline-text-4" id="text-1-5-6">
<ul class="org-ul">
<li><p>
numpy数组也是从0开始,对于多维数组的访问,也是多增加几次的[]操作
</p>
<div class="org-src-container">
<pre class="src src-shell">&gt;&gt;&gt; X = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span><span style="color: #2d9574;">[</span>51,55<span style="color: #2d9574;">]</span>, <span style="color: #2d9574;">[</span>14,19<span style="color: #2d9574;">]</span>, <span style="color: #2d9574;">[</span>0, 4<span style="color: #2d9574;">]</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; print<span style="color: #3a81c3;">(</span>X<span style="color: #3a81c3;">)</span>
<span style="color: #3a81c3;">[</span><span style="color: #6c3163;">[</span>51 55<span style="color: #6c3163;">]</span>
 <span style="color: #6c3163;">[</span>14 19<span style="color: #6c3163;">]</span>
 <span style="color: #6c3163;">[</span> 0  4<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">]</span>
&gt;&gt;&gt; X<span style="color: #3a81c3;">[</span>0<span style="color: #3a81c3;">]</span>
<span style="color: #6c3163; font-weight: bold;">array</span><span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>51, 55<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; X<span style="color: #3a81c3;">[</span>0<span style="color: #3a81c3;">][</span>1<span style="color: #3a81c3;">]</span>
55
</pre>
</div></li>
<li>numpy的`[]`里面还可以放置其他的非int值,比如:
<ul class="org-ul">
<li><p>
可以放置一个numpy 数组,比如这里我们要取第1, 3, 5位的数据
</p>
<div class="org-src-container">
<pre class="src src-shell">&gt;&gt;&gt; a = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>0, 10, 20, 30, 40, 50<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; print<span style="color: #3a81c3;">(</span>a<span style="color: #3a81c3;">)</span>
<span style="color: #3a81c3;">[</span> 0 10 20 30 40 50<span style="color: #3a81c3;">]</span>
&gt;&gt;&gt; a<span style="color: #3a81c3;">[</span>np.array<span style="color: #6c3163;">(</span><span style="color: #2d9574;">[</span>1, 3, 5<span style="color: #2d9574;">]</span><span style="color: #6c3163;">)</span><span style="color: #3a81c3;">]</span>
<span style="color: #6c3163; font-weight: bold;">array</span><span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>10, 30, 50<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
</pre>
</div></li>
<li><p>
可以放置一个bool数组,我们只取其中为True的部分
</p>
<div class="org-src-container">
<pre class="src src-shell">&gt;&gt;&gt; a<span style="color: #3a81c3;">[</span>np.array<span style="color: #6c3163;">(</span><span style="color: #2d9574;">[</span>True, True, False, False, False, True<span style="color: #2d9574;">]</span><span style="color: #6c3163;">)</span><span style="color: #3a81c3;">]</span>
<span style="color: #6c3163; font-weight: bold;">array</span><span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span> 0, 10, 50<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org5fe8790" class="outline-3">
<h3 id="org5fe8790"><span class="section-number-3">1.6.</span> Matplotlib</h3>
<div class="outline-text-3" id="text-1-6">
</div>
<div id="outline-container-org12718e9" class="outline-4">
<h4 id="org12718e9"><span class="section-number-4">1.6.1.</span> 绘制简单图形</h4>
<div class="outline-text-4" id="text-1-6-1">
<ul class="org-ul">
<li>最简答的绘制sin函数曲线的例子
<ul class="org-ul">
<li><p>
代码如下
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #3a81c3; font-weight: bold;">import</span> numpy <span style="color: #3a81c3; font-weight: bold;">as</span> np
<span style="color: #3a81c3; font-weight: bold;">import</span> matplotlib.pyplot <span style="color: #3a81c3; font-weight: bold;">as</span> plt


<span style="color: #715ab1;">x</span> = np.arange<span style="color: #3a81c3;">(</span>0, 6, 0.1<span style="color: #3a81c3;">)</span>
<span style="color: #715ab1;">y</span> = np.sin<span style="color: #3a81c3;">(</span>x<span style="color: #3a81c3;">)</span>
plt.plot<span style="color: #3a81c3;">(</span>x, y<span style="color: #3a81c3;">)</span>
plt.show<span style="color: #3a81c3;">()</span>
</pre>
</div></li>
<li><p>
结果如下
</p>

<div id="orgb6c06db" class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/image/master/dlfs/1-3.png" alt="1-3.png" />
</p>
<p><span class="figure-number">Figure 3: </span>dlfs/1-3.png</p>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgf2a475e" class="outline-4">
<h4 id="orgf2a475e"><span class="section-number-4">1.6.2.</span> pyplot的功能</h4>
<div class="outline-text-4" id="text-1-6-2">
<ul class="org-ul">
<li>我们还可以在上图中加上一些标题,x轴签名等等
<ul class="org-ul">
<li><p>
代码如下
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #3a81c3; font-weight: bold;">import</span> numpy <span style="color: #3a81c3; font-weight: bold;">as</span> np
<span style="color: #3a81c3; font-weight: bold;">import</span> matplotlib.pyplot <span style="color: #3a81c3; font-weight: bold;">as</span> plt


<span style="color: #715ab1;">x</span> = np.arange<span style="color: #3a81c3;">(</span>0, 6, 0.1<span style="color: #3a81c3;">)</span>
<span style="color: #715ab1;">y1</span> = np.sin<span style="color: #3a81c3;">(</span>x<span style="color: #3a81c3;">)</span>
<span style="color: #715ab1;">y2</span> = np.cos<span style="color: #3a81c3;">(</span>x<span style="color: #3a81c3;">)</span>
plt.plot<span style="color: #3a81c3;">(</span>x, y1, label=<span style="color: #2d9574;">"sin"</span><span style="color: #3a81c3;">)</span>
plt.plot<span style="color: #3a81c3;">(</span>x, y2, linestyle=<span style="color: #2d9574;">"--"</span>, label=<span style="color: #2d9574;">"cos"</span><span style="color: #3a81c3;">)</span>
plt.xlabel<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"x"</span><span style="color: #3a81c3;">)</span>
plt.ylabel<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"y"</span><span style="color: #3a81c3;">)</span>
plt.show<span style="color: #3a81c3;">()</span>
</pre>
</div></li>
<li><p>
结果如下
</p>

<div id="org76f63dd" class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/image/master/dlfs/1-4.png" alt="1-4.png" />
</p>
<p><span class="figure-number">Figure 4: </span>dlfs/1-4.png</p>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org8ff077b" class="outline-4">
<h4 id="org8ff077b"><span class="section-number-4">1.6.3.</span> 显示图像</h4>
<div class="outline-text-4" id="text-1-6-3">
<ul class="org-ul">
<li>matplotlib还可以使用imread()方法读入图像</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org89530a4" class="outline-2">
<h2 id="org89530a4"><span class="section-number-2">2.</span> 感知机</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-orgeda71c0" class="outline-3">
<h3 id="orgeda71c0"><span class="section-number-3">2.1.</span> 感知机是什么</h3>
<div class="outline-text-3" id="text-2-1">
<ul class="org-ul">
<li>所谓感知机,是指接收多个输入信号,输出一个信号.</li>
<li>这里的信号可以想象成电流或者河流那样具备"流动性"的东西.和实际的电流不同,感知机的信号只有"流/不流"两
种取值,本书中:
<ul class="org-ul">
<li>0对应"不传递信号"</li>
<li>1对应"传递信号"</li>
</ul></li>
<li>下图是一个感知机接收两个输入信号的例子:
<ul class="org-ul">
<li><p>
图2-1
</p>

<div id="org6675ec2" class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/image/master/dlfs/2-1.png" alt="2-1.png" />
</p>
<p><span class="figure-number">Figure 5: </span>dlfs/2-1.png</p>
</div></li>
<li>x1,x2是输入信号</li>
<li>y是输出信号</li>
<li>w1,w2是权重(w是weight的首字母). 感知机的多个输入信号都有各自固有的权重,权重越大,对应该权重的信号
重要性就越高</li>
<li>图中的圆形为"神经元"或者"节点"</li>
<li>输入信号被送往神经元的时候会被乘以固定的权重(w1x1,w2x2), 神经元会计算传过来的信号的总和,当这个总
和超过某个界限(称之为阈值)时,才会输出1.输出1也被称之为"神经元被激活"</li>
<li><p>
我们把上面的图用公式表达出来就是
</p>
\begin{equation}
y =
   \begin{cases}
    0 & (w_1 x_1 + w_2 x_2 \leqslant \theta) \\
    1 & (w_1 x_1 + w_2 x_2 > \theta) \tag{2.1}
   \end{cases}
\end{equation}</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org1e752da" class="outline-3">
<h3 id="org1e752da"><span class="section-number-3">2.2.</span> 简单的逻辑电路</h3>
<div class="outline-text-3" id="text-2-2">
</div>
<div id="outline-container-orge47bbdf" class="outline-4">
<h4 id="orge47bbdf"><span class="section-number-4">2.2.1.</span> 与门</h4>
<div class="outline-text-4" id="text-2-2-1">
<ul class="org-ul">
<li>我们先考虑用感知机来解决简单的问题,比如我们用感知机来实现一下逻辑电路的与门(AND gate)</li>
<li><p>
所谓与门,是指两个输入都为1的情况下,输出为1,其他情况下输入都是0, 如下图
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">x1</th>
<th scope="col" class="org-right">x2</th>
<th scope="col" class="org-right">y</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
</tr>
</tbody>
</table></li>
<li>从我们的公式2.1分析,我们其实只要设置好 \(w_1, w_2,\theta\) 的值就可以.</li>
<li>实际上,我们肉眼就能找到很多这样的值,比如:
<ul class="org-ul">
<li>\((w_1, w_2,\theta) = (0.5,0.5,0.7)\)</li>
<li>\((w_1, w_2,\theta) = (0.5,0.5,0.8)\)</li>
<li>\((w_1, w_2,\theta) = (1.0,1.0,1.0)\)</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgffc6c27" class="outline-4">
<h4 id="orgffc6c27"><span class="section-number-4">2.2.2.</span> 与非门和或门</h4>
<div class="outline-text-4" id="text-2-2-2">
<ul class="org-ul">
<li><p>
我们再来看看另外的逻辑电路,比如与非门(NAND gate), 与非门,就是"结果颠倒了的与门",如图
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">x1</th>
<th scope="col" class="org-right">x2</th>
<th scope="col" class="org-right">y</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>
</tbody>
</table></li>
<li>对应的\(w_1, w_2,\theta\) 的值也很容易选(其实把与门的参数取反就可以),比如:
<ul class="org-ul">
<li>\((w_1, w_2,\theta) = (-0.5,-0.5,-0.7)\)</li>
<li>\((w_1, w_2,\theta) = (-0.5,-0.5,-0.8)\)</li>
<li>\((w_1, w_2,\theta) = (-1.0,-1.0,-1.0)\)</li>
</ul></li>
<li><p>
同样的,我们还可以设置或门(OR gate),其为两个输入都是0的情况下,才返回0,其他情况都返回1
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">x1</th>
<th scope="col" class="org-right">x2</th>
<th scope="col" class="org-right">y</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
</tr>
</tbody>
</table></li>
<li>实际上,我们肉眼就也能找到很多这样的值,比如:
<ul class="org-ul">
<li>\((w_1, w_2,\theta) = (0.5,0.5,-0.2)\)</li>
<li>\((w_1, w_2,\theta) = (0.5,0.5,-0.3)\)</li>
<li>\((w_1, w_2,\theta) = (1.0,1.0,-0.9)\)</li>
</ul></li>
<li>我们不厌其烦的展示了三种逻辑电路,就是想说明:
<ul class="org-ul">
<li>这三种逻辑电路的感知机构造是一样的</li>
<li>我们只需要适当的调整参数,就能把一个感知机改造成不同的角色: 与门,与非门,或门</li>
</ul></li>
<li>提前剧透一下,感知机和机器学习的不通:
<ul class="org-ul">
<li>感知机是"人类"通过看真值表,确定感知器参数</li>
<li>机器学习是让"计算机"自动的决定这些参数.所谓"学习",就是确定这是参数的过程</li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgaddd7b8" class="outline-3">
<h3 id="orgaddd7b8"><span class="section-number-3">2.3.</span> 感知机的实现</h3>
<div class="outline-text-3" id="text-2-3">
</div>
<div id="outline-container-org5398757" class="outline-4">
<h4 id="org5398757"><span class="section-number-4">2.3.1.</span> 简单的实现</h4>
<div class="outline-text-4" id="text-2-3-1">
<ul class="org-ul">
<li><p>
我们先用代码来实现一下刚才的与门
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">AND</span><span style="color: #3a81c3;">(</span>x1, x2<span style="color: #3a81c3;">)</span>:
    <span style="color: #715ab1;">w1</span>, <span style="color: #715ab1;">w2</span>, <span style="color: #715ab1;">theta</span> = 0.5, 0.5, 0.7
    <span style="color: #715ab1;">tmp</span> = x1 * w1 + x2 * w2
    <span style="color: #3a81c3; font-weight: bold;">if</span> tmp &lt;= theta:
        <span style="color: #3a81c3; font-weight: bold;">return</span> 0
    <span style="color: #3a81c3; font-weight: bold;">elif</span> tmp &gt; theta:
        <span style="color: #3a81c3; font-weight: bold;">return</span> 1


<span style="color: #3a81c3; font-weight: bold;">if</span> <span style="color: #3a81c3;">__name__</span> == <span style="color: #2d9574;">"__main__"</span>:
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>AND<span style="color: #6c3163;">(</span>0, 0<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>AND<span style="color: #6c3163;">(</span>1, 0<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>AND<span style="color: #6c3163;">(</span>0, 1<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>AND<span style="color: #6c3163;">(</span>1, 1<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">0</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">0</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">0</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">1</span>
</pre>
</div></li>
<li>与非门和或门的实现是类似的,区别只是权重参数的值.不过我们为了更好的抽象问题,我们准备改一下我们的公
式,也顺便改一下我们的实现</li>
</ul>
</div>
</div>
<div id="outline-container-org6fa0dcb" class="outline-4">
<h4 id="org6fa0dcb"><span class="section-number-4">2.3.2.</span> 导入权重和偏置</h4>
<div class="outline-text-4" id="text-2-3-2">
<ul class="org-ul">
<li>我们为了更好的抽象问题,把 \(\theta\) 换成 \(-b\)
<ul class="org-ul">
<li><p>
于是得到公式2.2
</p>
\begin{equation}
y =
   \begin{cases}
    0 & (b + w_1 x_1 + w_2 x_2 \leqslant 0) \\
    1 & (b + w_1 x_1 + w_2 x_2 > 0) \tag{2.2}
   \end{cases}
\end{equation}</li>
<li>公式2.2和公式2.1虽然有一个符号不同,但是表单是内容却是完全相同的</li>
<li>这里的b称之为偏置(bias). 偏置的值决定了神经元被激活的容易程度,比如-0.1的bias肯定比-20的bias更容易激活</li>
<li>w1,w2称之为权重(weight). 权重的值控制不同输入信号的重要性</li>
<li><b>NOTE</b> 有些上下文会把b,w1,w2统称为权重</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org00ad4b5" class="outline-4">
<h4 id="org00ad4b5"><span class="section-number-4">2.3.3.</span> 使用权重和偏置的实现</h4>
<div class="outline-text-4" id="text-2-3-3">
<ul class="org-ul">
<li>更改了公式的同时,我们也使用NumPy来实现感知机
<ul class="org-ul">
<li><p>
代码如下
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #3a81c3; font-weight: bold;">import</span> numpy <span style="color: #3a81c3; font-weight: bold;">as</span> np


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">AND</span><span style="color: #3a81c3;">(</span>x1, x2<span style="color: #3a81c3;">)</span>:
    <span style="color: #715ab1;">x</span> = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>x1, x2<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">w</span> = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>0.5, 0.5<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">b</span> = -0.7
    <span style="color: #715ab1;">tmp</span> = np.<span style="color: #3a81c3;">sum</span><span style="color: #3a81c3;">(</span>w * x<span style="color: #3a81c3;">)</span> + b
    <span style="color: #3a81c3; font-weight: bold;">if</span> tmp &lt;= 0:
        <span style="color: #3a81c3; font-weight: bold;">return</span> 0
    <span style="color: #3a81c3; font-weight: bold;">else</span>:
        <span style="color: #3a81c3; font-weight: bold;">return</span> 1


<span style="color: #3a81c3; font-weight: bold;">if</span> <span style="color: #3a81c3;">__name__</span> == <span style="color: #2d9574;">"__main__"</span>:
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>AND<span style="color: #6c3163;">(</span>0, 0<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>AND<span style="color: #6c3163;">(</span>1, 0<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>AND<span style="color: #6c3163;">(</span>0, 1<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>AND<span style="color: #6c3163;">(</span>1, 1<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">0</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">0</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">0</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">1</span>
</pre>
</div></li>
<li>这里权重和参数都是numpy array,他们相乘就是element-wise的相乘</li>
<li>相乘结果再用np.sum把结果累加,就实现了之前2-1中x1 * w1 + x2 * w2的效果</li>
<li>最后加上偏置,再和0比大小即可</li>
</ul></li>
<li><p>
我们用同样的方式可以创建成功与非门
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #3a81c3; font-weight: bold;">import</span> numpy <span style="color: #3a81c3; font-weight: bold;">as</span> np


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">NAND</span><span style="color: #3a81c3;">(</span>x1, x2<span style="color: #3a81c3;">)</span>:
    <span style="color: #715ab1;">x</span> = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>x1, x2<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">w</span> = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>-0.5, -0.5<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">b</span> = 0.7
    <span style="color: #715ab1;">tmp</span> = np.<span style="color: #3a81c3;">sum</span><span style="color: #3a81c3;">(</span>w * x<span style="color: #3a81c3;">)</span> + b
    <span style="color: #3a81c3; font-weight: bold;">if</span> tmp &lt;= 0:
        <span style="color: #3a81c3; font-weight: bold;">return</span> 0
    <span style="color: #3a81c3; font-weight: bold;">else</span>:
        <span style="color: #3a81c3; font-weight: bold;">return</span> 1


<span style="color: #3a81c3; font-weight: bold;">if</span> <span style="color: #3a81c3;">__name__</span> == <span style="color: #2d9574;">"__main__"</span>:
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>NAND<span style="color: #6c3163;">(</span>0, 0<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>NAND<span style="color: #6c3163;">(</span>1, 0<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>NAND<span style="color: #6c3163;">(</span>0, 1<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>NAND<span style="color: #6c3163;">(</span>1, 1<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">1</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">1</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">1</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">0</span>
</pre>
</div></li>
<li><p>
最后是同样的方式创建好或门
</p>
<div class="org-src-container">
<pre class="src src-python">
<span style="color: #3a81c3; font-weight: bold;">import</span> numpy <span style="color: #3a81c3; font-weight: bold;">as</span> np


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">OR</span><span style="color: #3a81c3;">(</span>x1, x2<span style="color: #3a81c3;">)</span>:
    <span style="color: #715ab1;">x</span> = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>x1, x2<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">w</span> = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>0.5, 0.5<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">b</span> = -0.2
    <span style="color: #715ab1;">tmp</span> = np.<span style="color: #3a81c3;">sum</span><span style="color: #3a81c3;">(</span>w * x<span style="color: #3a81c3;">)</span> + b
    <span style="color: #3a81c3; font-weight: bold;">if</span> tmp &lt;= 0:
        <span style="color: #3a81c3; font-weight: bold;">return</span> 0
    <span style="color: #3a81c3; font-weight: bold;">else</span>:
        <span style="color: #3a81c3; font-weight: bold;">return</span> 1


<span style="color: #3a81c3; font-weight: bold;">if</span> <span style="color: #3a81c3;">__name__</span> == <span style="color: #2d9574;">"__main__"</span>:
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>OR<span style="color: #6c3163;">(</span>0, 0<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>OR<span style="color: #6c3163;">(</span>1, 0<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>OR<span style="color: #6c3163;">(</span>0, 1<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>OR<span style="color: #6c3163;">(</span>1, 1<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">0</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">1</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">1</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">1</span>
</pre>
</div></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org2b68428" class="outline-3">
<h3 id="org2b68428"><span class="section-number-3">2.4.</span> 感知机的局限性</h3>
<div class="outline-text-3" id="text-2-4">
<ul class="org-ul">
<li>到目前为止,我们已经知道,感知机可以实现与门,与非门,或门,三种逻辑,现在我们考虑下异或门</li>
</ul>
</div>
<div id="outline-container-org11f379a" class="outline-4">
<h4 id="org11f379a"><span class="section-number-4">2.4.1.</span> 异或门</h4>
<div class="outline-text-4" id="text-2-4-1">
<ul class="org-ul">
<li><p>
所谓异或门,是指仅当x1或x2中一方为1时,才会输出1,如表格
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">x1</th>
<th scope="col" class="org-right">x2</th>
<th scope="col" class="org-right">y</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>
</tbody>
</table></li>
<li><p>
我们再次尝试使用之前的方法来寻找一个权重和偏移的组合,我们发现我们找不到这样一个组合,实际的情况是
</p>
<pre class="example" id="org1b15cd2">
用感知机是无法实现异或门的
</pre></li>
<li>为什么感知机无法实现异或门,我们可以用下面的例子来讲解一下
<ul class="org-ul">
<li><p>
我们首先将或门具体化,我们把一组可行的权重参数(b,w1,w2)=(-0.5,1.0,1.0) 带入到公式2.2,得到公式2.3
</p>
\begin{equation}
y =
   \begin{cases}
    0 & (-0.5 + w_1 x_1 + w_2 x_2 \leqslant 0) \\
    1 & (-0.5 + w_1 x_1 + w_2 x_2 > 0) \tag{2.3}
   \end{cases}
\end{equation}</li>
<li><p>
我们如果把x2看成是y的话,我们会得到这么一条直线y=-x+0.5,如图
</p>

<div id="orgbf60de8" class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/image/master/dlfs/2-6.png" alt="2-6.png" />
</p>
<p><span class="figure-number">Figure 6: </span>dlfs/2-6.png</p>
</div></li>
<li>这条直线把整个平面分成了两个部分:
<ol class="org-ol">
<li>灰色部分是感知机输出0的区域,我们看到(0,0)也在这个位置(圆圈)</li>
<li>白色部分是感知机输出1的区域,我们看到(0,1),(1,0),(1,1)都在这个区域(三角形)</li>
</ol></li>
<li><p>
我们来如法炮制,把异或门需要分开的四个点(两个圆圈,两个三角)也列在下图,我们会发现,我们找不到一个直
线能欧分割图中的圆圈和三角
</p>

<div id="org3a1b11e" class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/image/master/dlfs/2-7.png" alt="2-7.png" />
</p>
<p><span class="figure-number">Figure 7: </span>dlfs/2-7.png</p>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgafca20c" class="outline-4">
<h4 id="orgafca20c"><span class="section-number-4">2.4.2.</span> 线性和非线性</h4>
<div class="outline-text-4" id="text-2-4-2">
<ul class="org-ul">
<li><p>
图2-7是无法用一个直线来分割圆圈和三角,但是将"直线"这个限制去掉,就可以实现了,比如下图,我们使用曲线
来完成了这个区分
</p>

<div id="org7420a74" class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/image/master/dlfs/2-8.png" alt="2-8.png" />
</p>
<p><span class="figure-number">Figure 8: </span>dlfs/2-8.png</p>
</div></li>
<li>上图这种由曲线分割的区域就叫做非线性空间.之前用直线分割的区域自然就叫线性空间啦</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgba79bb3" class="outline-3">
<h3 id="orgba79bb3"><span class="section-number-3">2.5.</span> 多层感知机</h3>
<div class="outline-text-3" id="text-2-5">
<ul class="org-ul">
<li><p>
感知机无法表示异或门让人遗憾,但是感知机可以通过"叠加层"来完成这个任务
</p>
<pre class="example" id="org20b20d3">
准确的是说,应该是"单层感知机"无法表示异或门
</pre></li>
<li>我们下面通过电路来理解一下,什么是叠加层</li>
</ul>
</div>
<div id="outline-container-orgfd99fd7" class="outline-4">
<h4 id="orgfd99fd7"><span class="section-number-4">2.5.1.</span> 已有门电路组合</h4>
<div class="outline-text-4" id="text-2-5-1">
<ul class="org-ul">
<li>异或门有很多种制作方法,其中最经典的做法是组合我们前面学到的三种门:与门,与非门和或门
<ul class="org-ul">
<li><p>
我们首先以下图来表示与门,与非门和或门
</p>

<div id="orgded872d" class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/image/master/dlfs/2-9.png" alt="2-9.png" />
</p>
<p><span class="figure-number">Figure 9: </span>dlfs/2-9.png</p>
</div></li>
<li><p>
异或门就可以使用上面的元器件,如下进行组合配置,最终实现异或门
</p>

<div id="org569ea0a" class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/image/master/dlfs/2-11.png" alt="2-11.png" />
</p>
<p><span class="figure-number">Figure 10: </span>dlfs/2-11.png</p>
</div></li>
<li><p>
我们可以使用如下的真值表来确认我们的配置正确.
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">x1</th>
<th scope="col" class="org-right">x2</th>
<th scope="col" class="org-right">s1</th>
<th scope="col" class="org-right">s2</th>
<th scope="col" class="org-right">y</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>
</tbody>
</table></li>
<li>上表中:x1,x2与非得到s1, x1,x2或得到s2, s1,s2与得到y</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org43fc911" class="outline-4">
<h4 id="org43fc911"><span class="section-number-4">2.5.2.</span> 异或门的实现</h4>
<div class="outline-text-4" id="text-2-5-2">
<ul class="org-ul">
<li><p>
我们使用代码来实现2-11所示的异或门
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #3a81c3; font-weight: bold;">import</span> numpy <span style="color: #3a81c3; font-weight: bold;">as</span> np


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">AND</span><span style="color: #3a81c3;">(</span>x1, x2<span style="color: #3a81c3;">)</span>:
    <span style="color: #715ab1;">x</span> = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>x1, x2<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">w</span> = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>0.5, 0.5<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">b</span> = -0.7
    <span style="color: #715ab1;">tmp</span> = np.<span style="color: #3a81c3;">sum</span><span style="color: #3a81c3;">(</span>w * x<span style="color: #3a81c3;">)</span> + b
    <span style="color: #3a81c3; font-weight: bold;">if</span> tmp &lt;= 0:
        <span style="color: #3a81c3; font-weight: bold;">return</span> 0
    <span style="color: #3a81c3; font-weight: bold;">else</span>:
        <span style="color: #3a81c3; font-weight: bold;">return</span> 1


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">NAND</span><span style="color: #3a81c3;">(</span>x1, x2<span style="color: #3a81c3;">)</span>:
    <span style="color: #715ab1;">x</span> = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>x1, x2<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">w</span> = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>-0.5, -0.5<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">b</span> = 0.7
    <span style="color: #715ab1;">tmp</span> = np.<span style="color: #3a81c3;">sum</span><span style="color: #3a81c3;">(</span>w * x<span style="color: #3a81c3;">)</span> + b
    <span style="color: #3a81c3; font-weight: bold;">if</span> tmp &lt;= 0:
        <span style="color: #3a81c3; font-weight: bold;">return</span> 0
    <span style="color: #3a81c3; font-weight: bold;">else</span>:
        <span style="color: #3a81c3; font-weight: bold;">return</span> 1


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">OR</span><span style="color: #3a81c3;">(</span>x1, x2<span style="color: #3a81c3;">)</span>:
    <span style="color: #715ab1;">x</span> = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>x1, x2<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">w</span> = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>0.5, 0.5<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">b</span> = -0.2
    <span style="color: #715ab1;">tmp</span> = np.<span style="color: #3a81c3;">sum</span><span style="color: #3a81c3;">(</span>w * x<span style="color: #3a81c3;">)</span> + b
    <span style="color: #3a81c3; font-weight: bold;">if</span> tmp &lt;= 0:
        <span style="color: #3a81c3; font-weight: bold;">return</span> 0
    <span style="color: #3a81c3; font-weight: bold;">else</span>:
        <span style="color: #3a81c3; font-weight: bold;">return</span> 1


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">XOR</span><span style="color: #3a81c3;">(</span>x1, x2<span style="color: #3a81c3;">)</span>:
    <span style="color: #715ab1;">s1</span> = NAND<span style="color: #3a81c3;">(</span>x1, x2<span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">s2</span> = OR<span style="color: #3a81c3;">(</span>x1, x2<span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">y</span> = AND<span style="color: #3a81c3;">(</span>s1, s2<span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3; font-weight: bold;">return</span> y


<span style="color: #3a81c3; font-weight: bold;">if</span> <span style="color: #3a81c3;">__name__</span> == <span style="color: #2d9574;">"__main__"</span>:
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>XOR<span style="color: #6c3163;">(</span>0, 0<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>XOR<span style="color: #6c3163;">(</span>1, 0<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>XOR<span style="color: #6c3163;">(</span>0, 1<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>XOR<span style="color: #6c3163;">(</span>1, 1<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">0</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">1</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">1</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">0</span>
</pre>
</div></li>
<li>我们试着把电路图转换为感知机来表示
<ul class="org-ul">
<li><p>
如图2-13
</p>

<div id="org2cb6928" class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/image/master/dlfs/2-13.png" alt="2-13.png" />
</p>
<p><span class="figure-number">Figure 11: </span>dlfs/2-13.png</p>
</div></li>
<li><p>
上图和前面的与门,与非门,或门的感知机图不同.事实上之前的图都是单层感知机,而异或门是2层感知机
</p>
<pre class="example" id="org79bb41a">
也有文献把这个叫做3层感知机, 这取决于如何看待最后y是不是一层
</pre></li>
<li>这种2层感知机可以看做是流水线的组装作业.第一层的工人对传送过来的零件进行加工,完成后再传送给第二层
的工人.第二层的工作对第一层工人传递过来的零件进行加工,完成后出货(输出)</li>
<li><p>
通过这样的2层结构,感知机得以实现异或门.换句话说,就是
</p>
<pre class="example" id="orgfeb8fe3">
单层感知机无法表达的东西,通过增加一层就可以解决.也就是说,通过增加层,感知机能进行更加灵活的表示
</pre></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org9e5be24" class="outline-3">
<h3 id="org9e5be24"><span class="section-number-3">2.6.</span> 从与非门到计算机</h3>
<div class="outline-text-3" id="text-2-6">
<ul class="org-ul">
<li>人们通常认为计算机很复杂,但是令人惊讶的是,仅仅通过与非门(NAND)一个逻辑电路的不同组合,就能实现.</li>
<li>这也就说明理论上,感知机(多层)也可以表示计算机.我们只需要记住这个结论就好</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org2e9cf41" class="outline-2">
<h2 id="org2e9cf41"><span class="section-number-2">3.</span> 神经网络</h2>
<div class="outline-text-2" id="text-3">
<ul class="org-ul">
<li>上一章我们学习了感知机,关于感知机既有好消息,也有坏消息:
<ul class="org-ul">
<li>好消息是: 即便对于复杂函数,感知机也是可以通过增加层的方式来表达出来</li>
<li>坏消息是: 设定权重的工作,还是由人工进行的</li>
</ul></li>
<li>神经网络的出现,就是Eileen解决刚才的坏消息.具体来说就是,神经网络可以自动的从数据中学习到合适的权重
参数</li>
</ul>
</div>
<div id="outline-container-org5cae72f" class="outline-3">
<h3 id="org5cae72f"><span class="section-number-3">3.1.</span> 从感知机到神经网络</h3>
<div class="outline-text-3" id="text-3-1">
</div>
<div id="outline-container-org6c17938" class="outline-4">
<h4 id="org6c17938"><span class="section-number-4">3.1.1.</span> 神经网路的例子</h4>
<div class="outline-text-4" id="text-3-1-1">
<ul class="org-ul">
<li>我们用图来表示神经网路
<ul class="org-ul">
<li><p>
图3-1
</p>

<div id="org7ce60eb" class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/image/master/dlfs/3-1.png" alt="3-1.png" />
</p>
<p><span class="figure-number">Figure 12: </span>dlfs/3-1.png</p>
</div></li>
<li>上图中最左边一层是输入层.本书称之为第0层</li>
<li>最右边一层是输出层.本书称之为第1层</li>
<li>中间一层是隐藏层,"隐藏"一词的意思是,隐藏层中的神经元(和输入层,输出层不同)肉眼看不到.本书称之为第2层</li>
<li>上图中一共有三层神经网络构成,但是只有两岑神经网络有权重,所以我们本书称之为"2层网络",本书之后都是
这种做法: 根据实质上拥有权重的层数来确定名称(也就是,输入层,隐藏层,输出层总数减去1)</li>
<li><b>Note</b> 有些书会把上图的叫做"3层网络"</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgb2713ec" class="outline-4">
<h4 id="orgb2713ec"><span class="section-number-4">3.1.2.</span> 复习感知机</h4>
<div class="outline-text-4" id="text-3-1-2">
<ul class="org-ul">
<li>在观察神经网络中信号的传递方法之前,我们先复习一下感知机
<ul class="org-ul">
<li><p>
感知机如图
</p>

<div id="orge5bd002" class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/image/master/dlfs/3-2.png" alt="3-2.png" />
</p>
<p><span class="figure-number">Figure 13: </span>dlfs/3-2.png</p>
</div></li>
<li><p>
图中的感知机公式如下
</p>
\begin{equation}
y =
   \begin{cases}
    0 & (b + w_1 x_1 + w_2 x_2 \leqslant 0) \\
    1 & (b + w_1 x_1 + w_2 x_2 > 0) \tag{3.1}
   \end{cases}
\end{equation}</li>
<li>w1,w2是权重参数,b是偏置参数</li>
<li><p>
在图3-2中,并没有画出偏置b,如果要画出b,可以向下图一样,让b和w1,w2一个地位, 1和x1,x2一个地址
</p>

<div id="org4eba5ea" class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/image/master/dlfs/3-3.png" alt="3-3.png" />
</p>
<p><span class="figure-number">Figure 14: </span>dlfs/3-3.png</p>
</div></li>
</ul></li>
<li>公式3.1有两个条件,看起来不够直观(主要是 \(b+w_1x_1+w_2x_2\) 重复了两次. 现在我们把公式3.1改写一下,改
成如下两个公式:
<ul class="org-ul">
<li><p>
公式3.2,重复部分写到一块
</p>
\begin{equation}
y = h(b+w_1x_1+w_2x_2) \tag{3.2}
\end{equation}</li>
<li><p>
公式3.3, x指代 \(b+w_1x_1+w_2x_2\)
</p>
\begin{equation}
h(x) =
   \begin{cases}
    0 & (x \leqslant 0) \\
    1 & (x > 0) \tag{3.3}
   \end{cases}
\end{equation}</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org4b5fcf2" class="outline-4">
<h4 id="org4b5fcf2"><span class="section-number-4">3.1.3.</span> 激活函数登场</h4>
<div class="outline-text-4" id="text-3-1-3">
<ul class="org-ul">
<li>刚才登场的函数h(x)会将输入信号的总和转换为输出信号,这种函数一般称之为激活函数(activation function)</li>
<li>我们把上面的公式3.2再次进行拆分,得到如下两个公式:
<ul class="org-ul">
<li><p>
公式3.2的右边拆分得到公式3.4
</p>
\begin{equation}
a = b + w_1 x_1 + w_2 x_2 \tag{3.4}
\end{equation}</li>
<li><p>
公式3.2的左边拆分得到公式3.5
</p>
\begin{equation}
y = h(a) \tag{3.5}
\end{equation}</li>
<li>改成两个公式后我们可以证明理解: 权重和偏置总和记为a(3.4), 然后h()函数将a输出为y.h()函数是针对于a
的函数(而不是针对于w或者x)</li>
<li><p>
有了公式3.4和和3.5后,我们的神经元内部也可以画出内容来了,如下
</p>

<div id="org37bd188" class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/image/master/dlfs/3-4.png" alt="3-4.png" />
</p>
<p><span class="figure-number">Figure 15: </span>dlfs/3-4.png</p>
</div></li>
<li>下图是神经元前后两种画法的对比,下面的图告诉我们,神经元不一定是最后一个才有这种h()函数,作为中间神经元也可以</li>
</ul></li>
<li>下一节我们会详细介绍激活函数.激活函数是链接感知机和神经网络的桥梁:
<ul class="org-ul">
<li>感知机这个词,绝大多数情况下是指的"朴素感知机",其特点是是单层网络,且使用"阶跃函数"(突然发生跳变的
函数,比如公式3.3)作为激活函数</li>
<li>而使用多层网络,并且使用"sigmoid函数"作为激活函数的多层感知机,绝大多数情况下会使用"神经网络"这个词</li>
</ul></li>
<li><p>
我们再多提一句,上一节介绍的多层网络,其激活函数还是普通"阶跃函数". 这种多层感知机是为了理解让我们理
解如下概念,其实不具有实用性
</p>
<pre class="example" id="orgc857520">
多层感知机能够进行非线性表示
</pre></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org384ecd8" class="outline-3">
<h3 id="org384ecd8"><span class="section-number-3">3.2.</span> 激活函数</h3>
<div class="outline-text-3" id="text-3-2">
<ul class="org-ul">
<li><p>
上一章说到,朴素感知机使用的激活函数为阶跃函数(公式3.3就是一个阶跃函数), 所谓阶跃函数, 其定义如下.
</p>
<pre class="example" id="orga89b921">
阶跃函数，指函数值突然发生跳变的函数。例如从0突然变成100，从0突然变成正无穷，
从负无穷突然变成正无穷，都可以叫阶跃函数。
</pre></li>
<li>朴素感知机如果使用了其他函数作为激活函数会怎样? 从定义看来,如果使用了非阶跃函数作为激活函数,那么就
不能再叫朴素感知机了,而是应该叫神经网络了(当然如果层数在多一层,神经网络的名字,就更准确了)</li>
<li>作为激活函数的非阶跃函数,最出名的,就是sigmoid函数了</li>
</ul>
</div>
<div id="outline-container-org5fefade" class="outline-4">
<h4 id="org5fefade"><span class="section-number-4">3.2.1.</span> sigmoid函数</h4>
<div class="outline-text-4" id="text-3-2-1">
<ul class="org-ul">
<li>神经网络中最经常使用的一个激活函数就是sigmoid函数:
<ul class="org-ul">
<li><p>
公式如下
</p>
\begin{equation}
h(x) = \frac{1}{1 + \exp(-x)} \tag{3.6}
\end{equation}</li>
<li>公式中的 \(\exp(-x)\) 是 \(e^{-x}\) 的意思</li>
<li>e是纳皮尔常数2.7182&#x2026;</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org08b66a3" class="outline-4">
<h4 id="org08b66a3"><span class="section-number-4">3.2.2.</span> 阶跃函数的实现</h4>
<div class="outline-text-4" id="text-3-2-2">
<ul class="org-ul">
<li><p>
前面已经说了,公式3.3就是阶跃函数,我们可以使用python很容易的实现这个阶跃函数
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">step_function</span><span style="color: #3a81c3;">(</span>x<span style="color: #3a81c3;">)</span>:
    <span style="color: #3a81c3; font-weight: bold;">if</span> x &gt; 0:
        <span style="color: #3a81c3; font-weight: bold;">return</span> 1
    <span style="color: #3a81c3; font-weight: bold;">else</span>:
        <span style="color: #3a81c3; font-weight: bold;">return</span> 0
</pre>
</div></li>
<li>我们后面要把激活函数打印出来,那么输入就必须要支持数组(这里是numpy数组),所以我们要升级下我们的函数
让它支持numpy数组作为参数.当然输出也就是相同长度的numpy数组啦
<ul class="org-ul">
<li><p>
代码如下
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #3a81c3; font-weight: bold;">import</span> numpy <span style="color: #3a81c3; font-weight: bold;">as</span> np


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">step_function</span><span style="color: #3a81c3;">(</span>x<span style="color: #3a81c3;">)</span>:
    <span style="color: #715ab1;">y</span> = x &gt; 0
    <span style="color: #3a81c3; font-weight: bold;">return</span> y.astype<span style="color: #3a81c3;">(</span>np.int64<span style="color: #3a81c3;">)</span>


<span style="color: #3a81c3; font-weight: bold;">if</span> <span style="color: #3a81c3;">__name__</span> == <span style="color: #2d9574;">"__main__"</span>:
    <span style="color: #715ab1;">x</span> = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>-1.0, 1.0, 2.0<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"""|x|=&gt;"""</span>, x<span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">y</span> = x &gt; 0
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"""|y|=&gt;"""</span>, y<span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">z</span> = y.astype<span style="color: #3a81c3;">(</span>np.int64<span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"""|z|=&gt;"""</span>, z<span style="color: #3a81c3;">)</span>

    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"""|step_function(x)|=&gt;"""</span>, step_function<span style="color: #6c3163;">(</span>x<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org7aaffa9" class="outline-4">
<h4 id="org7aaffa9"><span class="section-number-4">3.2.3.</span> 阶跃函数的图形</h4>
<div class="outline-text-4" id="text-3-2-3">
<ul class="org-ul">
<li>我们现在就使用matplotlib库来打印阶跃函数的图形(刚才的支持numpy array输入就起到作用了)
<ul class="org-ul">
<li><p>
代码如下
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #3a81c3; font-weight: bold;">import</span> numpy <span style="color: #3a81c3; font-weight: bold;">as</span> np
<span style="color: #3a81c3; font-weight: bold;">import</span> matplotlib.pyplot <span style="color: #3a81c3; font-weight: bold;">as</span> plt


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">step_function</span><span style="color: #3a81c3;">(</span>x<span style="color: #3a81c3;">)</span>:
    <span style="color: #3a81c3; font-weight: bold;">return</span> np.array<span style="color: #3a81c3;">(</span>x &gt; 0, dtype=np.int64<span style="color: #3a81c3;">)</span>


<span style="color: #715ab1;">x</span> = np.arange<span style="color: #3a81c3;">(</span>-5.0, 5.0, 0.1<span style="color: #3a81c3;">)</span>
<span style="color: #715ab1;">y</span> = step_function<span style="color: #3a81c3;">(</span>x<span style="color: #3a81c3;">)</span>
plt.plot<span style="color: #3a81c3;">(</span>x, y<span style="color: #3a81c3;">)</span>
plt.ylim<span style="color: #3a81c3;">(</span>-0.1, 1.1<span style="color: #3a81c3;">)</span>  <span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">range for y-axis</span>
plt.show<span style="color: #3a81c3;">()</span>
</pre>
</div></li>
<li><p>
图形如下
</p>

<div id="orgf0217c3" class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/image/master/dlfs/3-6.png" alt="3-6.png" />
</p>
<p><span class="figure-number">Figure 16: </span>dlfs/3-6.png</p>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org96237d9" class="outline-4">
<h4 id="org96237d9"><span class="section-number-4">3.2.4.</span> sigmoid 函数的实现</h4>
<div class="outline-text-4" id="text-3-2-4">
<ul class="org-ul">
<li>我们还可以使用类似代码来完成sigmod的图形
<ul class="org-ul">
<li><p>
代码如下,注意标量(1)和numpy array无论进行加法还是除法都可以"先把标量扩展成向量"在和向量进行计算.
这是numpy库的广播特性其了作用
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #3a81c3; font-weight: bold;">import</span> numpy <span style="color: #3a81c3; font-weight: bold;">as</span> np
<span style="color: #3a81c3; font-weight: bold;">import</span> matplotlib.pyplot <span style="color: #3a81c3; font-weight: bold;">as</span> plt


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">sigmoid</span><span style="color: #3a81c3;">(</span>x<span style="color: #3a81c3;">)</span>:
    <span style="color: #3a81c3; font-weight: bold;">return</span> 1 / <span style="color: #3a81c3;">(</span>1 + np.exp<span style="color: #6c3163;">(</span>-x<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>


<span style="color: #715ab1;">x</span> = np.arange<span style="color: #3a81c3;">(</span>-5.0, 5.0, 0.1<span style="color: #3a81c3;">)</span>
<span style="color: #715ab1;">y</span> = sigmoid<span style="color: #3a81c3;">(</span>x<span style="color: #3a81c3;">)</span>
plt.plot<span style="color: #3a81c3;">(</span>x, y<span style="color: #3a81c3;">)</span>
plt.ylim<span style="color: #3a81c3;">(</span>-0.1, 1.1<span style="color: #3a81c3;">)</span>  <span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">range for y-axis</span>
plt.show<span style="color: #3a81c3;">()</span>
</pre>
</div></li>

<li><p>
图形如下
</p>

<div id="orga2abfde" class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/image/master/dlfs/3-7.png" alt="3-7.png" />
</p>
<p><span class="figure-number">Figure 17: </span>dlfs/3-7.png</p>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgc13e558" class="outline-4">
<h4 id="orgc13e558"><span class="section-number-4">3.2.5.</span> sigmoid函数和阶跃函数的比较</h4>
<div class="outline-text-4" id="text-3-2-5">
<ul class="org-ul">
<li>我们现在比较一下sigmod函数和阶跃函数
<ul class="org-ul">
<li><p>
把两者的图放到同一个坐标后如下
</p>

<div id="orgc8c0833" class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/image/master/dlfs/3-8.png" alt="3-8.png" />
</p>
<p><span class="figure-number">Figure 18: </span>dlfs/3-8.png</p>
</div></li>
<li>首先注意到的是,两者的"平滑性"不同:
<ul class="org-ul">
<li>阶跃函数以0为界,输出发生剧烈变化</li>
<li>sigmoid函数是一条平滑的曲线,输出随着输入发生连续性的变化. sigmoid函数的平滑性对于神经网络的学
习有重要的意义</li>
</ul></li>
<li>两者另外的不同在于返回值:
<ul class="org-ul">
<li>阶跃函数只能返回1,0,使用阶跃函数的感知机中神经元之间流动的是二元信号(0,1)</li>
<li>sigmoid函数能够返回0.731, 0.880等实数,使用sigmoid的神经网络中神经元之间流动的就是连续的实数的
信号</li>
</ul></li>
<li><p>
两者的第一个共同点在于其形状相似,两者都能做到
</p>
<pre class="example" id="org5f7a453">
输入小时,输出接近0(为0), 随着输入增大,输出像1靠近(变成1)
</pre></li>
<li>两者的第二个共同点是不管输入信号多大或者多小,输出信号的值都在0和1之间</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org5e3cd61" class="outline-4">
<h4 id="org5e3cd61"><span class="section-number-4">3.2.6.</span> 非线性函数</h4>
<div class="outline-text-4" id="text-3-2-6">
<ul class="org-ul">
<li>阶跃函数和sigmoid函数的最重要相同点,是他们都是非线性函数</li>
<li><p>
我们定义一下线性函数,那么为什么阶跃函数和sigmoid函数都是非线性函数就很明显了
</p>
<pre class="example" id="org76ca3da">
所谓线性函数,就是输出值是输入值的常数倍,比如人h(x)=cx.因此线性函数是一条笔直的直线
</pre></li>
<li>由于阶跃函数和sigmoid函数都没有像线性函数一样"呈现出一条直线",所以他们都是非线性函数</li>
<li>神经网络的激活函数必须使用非线性函数,换句话说,在神经网络里,激活函数不能使用线性函数</li>
<li>为什么会有这个规定呢?
<ul class="org-ul">
<li>首先神经网络的定义,就是必须要多层的感知机,一层的是朴素感知机(朴素感知机是可以使用线性函数的)</li>
<li>多层肯定是为了表达能力更强,但是如果使用了线性函数的话,加深神经网络的层数就没有意义了</li>
</ul></li>
<li>为什么使用了线性函数加深网络层数就没有意义了呢?
<ul class="org-ul">
<li>我们举个反例,假设把线性函数 \(h(x) = cx\) 作为激活函数,把 \(y(x)=h(h(h(x)))\) 运算,对应3层神经网络,
这个就相当于 \(y(x) = c \times c \times c \times x\) , 那其实就是 \(y(x)=ax (a = c^3)\)</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org2c0a9d1" class="outline-4">
<h4 id="org2c0a9d1"><span class="section-number-4">3.2.7.</span> ReLU函数</h4>
<div class="outline-text-4" id="text-3-2-7">
<ul class="org-ul">
<li>神经网络的发展史上,早期使用sigmoid函数比较多,而最近则主要使用ReLU函数</li>
<li>ReLU函数在输入大于0的时候,直接输出该值,在输入小于等于0的时候,输出0
<ul class="org-ul">
<li><p>
其公式如下
</p>
\begin{equation}
h(x) =
   \begin{cases}
    x & (x > 0) \\
    0 & (x \leqslant 0) \tag{3.7}
   \end{cases}
\end{equation}</li>
<li><p>
其python实现如下
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #3a81c3; font-weight: bold;">import</span> numpy <span style="color: #3a81c3; font-weight: bold;">as</span> np


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">relu</span><span style="color: #3a81c3;">(</span>x<span style="color: #3a81c3;">)</span>:
    <span style="color: #3a81c3; font-weight: bold;">return</span> np.maximum<span style="color: #3a81c3;">(</span>0, x<span style="color: #3a81c3;">)</span>
</pre>
</div></li>
<li><p>
其绘图如下
</p>

<div id="org2b17a1e" class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/image/master/dlfs/3-9.png" alt="3-9.png" />
</p>
<p><span class="figure-number">Figure 19: </span>dlfs/3-9.png</p>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org88940b5" class="outline-3">
<h3 id="org88940b5"><span class="section-number-3">3.3.</span> 多维数组的运算</h3>
<div class="outline-text-3" id="text-3-3">
<ul class="org-ul">
<li>numpy的多维数组运算能够高效的实现神经网络,所以我们这里停下来先学习一下numpy多维数组的运算</li>
</ul>
</div>
<div id="outline-container-orgdab7f60" class="outline-4">
<h4 id="orgdab7f60"><span class="section-number-4">3.3.1.</span> 多维数组</h4>
<div class="outline-text-4" id="text-3-3-1">
<ul class="org-ul">
<li>超过1维的数组就是多维数组.但是为了实现的一致性,从1维到n维,numpy的接口都是一样的,比如:
<ul class="org-ul">
<li>都有shape函数,返回一个tuple,来获取多维数组在某个维度上面成员的数目,对于一维数组也是返回元祖,只不
过,这个元祖只有一个成员</li>
<li>都有可以通过np.ndim()函数(或者ndim成员变量)获取其维度</li>
<li><p>
一维数组例子如下
</p>
<div class="org-src-container">
<pre class="src src-shell">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; A = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>1, 2, 3, 4<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; print<span style="color: #3a81c3;">(</span>A<span style="color: #3a81c3;">)</span>
<span style="color: #3a81c3;">[</span>1 2 3 4<span style="color: #3a81c3;">]</span>
&gt;&gt;&gt; A.ndim
1
&gt;&gt;&gt; np.ndim<span style="color: #3a81c3;">(</span>A<span style="color: #3a81c3;">)</span>
1
&gt;&gt;&gt; A.shape
<span style="color: #3a81c3;">(</span>4,<span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; A.shape<span style="color: #3a81c3;">[</span>0<span style="color: #3a81c3;">]</span>
4
</pre>
</div></li>
<li><p>
二维数组的例子如下
</p>
<div class="org-src-container">
<pre class="src src-shell">&gt;&gt;&gt; B = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span><span style="color: #2d9574;">[</span>1, 2<span style="color: #2d9574;">]</span>, <span style="color: #2d9574;">[</span>3, 4<span style="color: #2d9574;">]</span>, <span style="color: #2d9574;">[</span>5, 6<span style="color: #2d9574;">]</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; print<span style="color: #3a81c3;">(</span>B<span style="color: #3a81c3;">)</span>
<span style="color: #3a81c3;">[</span><span style="color: #6c3163;">[</span>1 2<span style="color: #6c3163;">]</span>
 <span style="color: #6c3163;">[</span>3 4<span style="color: #6c3163;">]</span>
 <span style="color: #6c3163;">[</span>5 6<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">]</span>
&gt;&gt;&gt; np.ndim<span style="color: #3a81c3;">(</span>B<span style="color: #3a81c3;">)</span>
2
&gt;&gt;&gt; B.ndim
2
&gt;&gt;&gt; B.shape
<span style="color: #3a81c3;">(</span>3, 2<span style="color: #3a81c3;">)</span>&gt;&gt;&gt; B = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span><span style="color: #2d9574;">[</span>1, 2<span style="color: #2d9574;">]</span>, <span style="color: #2d9574;">[</span>3, 4<span style="color: #2d9574;">]</span>, <span style="color: #2d9574;">[</span>5, 6<span style="color: #2d9574;">]</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; print<span style="color: #3a81c3;">(</span>B<span style="color: #3a81c3;">)</span>
<span style="color: #3a81c3;">[</span><span style="color: #6c3163;">[</span>1 2<span style="color: #6c3163;">]</span>
 <span style="color: #6c3163;">[</span>3 4<span style="color: #6c3163;">]</span>
 <span style="color: #6c3163;">[</span>5 6<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">]</span>
&gt;&gt;&gt; np.ndim<span style="color: #3a81c3;">(</span>B<span style="color: #3a81c3;">)</span>
2
&gt;&gt;&gt; B.ndim
2
&gt;&gt;&gt; B.shape
<span style="color: #3a81c3;">(</span>3, 2<span style="color: #3a81c3;">)</span>
</pre>
</div></li>
<li>这里生成了一个 \(3 \times 2\) 的数组. \(3 \times 2\) 的数组表示第一个维度有3个成员,第二个维度有2个成
员.</li>
<li><p>
二维数组也称为矩阵(matrix),横向为行(row),纵向为列(column),如下图
</p>

<div id="org15e9adb" class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/image/master/dlfs/3-10.png" alt="3-10.png" />
</p>
<p><span class="figure-number">Figure 20: </span>dlfs/3-10.png</p>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orga1a4533" class="outline-4">
<h4 id="orga1a4533"><span class="section-number-4">3.3.2.</span> 矩阵乘法</h4>
<div class="outline-text-4" id="text-3-3-2">
<ul class="org-ul">
<li>下面我们来介绍矩阵(二维数组)乘法
<ul class="org-ul">
<li><p>
如图3-11,就是两个 \(2 \times 2\) 的矩阵相乘
</p>

<div id="org78fae53" class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/image/master/dlfs/3-11.png" alt="3-11.png" />
</p>
<p><span class="figure-number">Figure 21: </span>dlfs/3-11.png</p>
</div></li>
<li>本书中矩阵使用黑色斜体大写表示,比如矩阵 \(\boldsymbol{A}\) 和矩阵 \(\boldsymbol{B}\)</li>
<li>matrix乘法的第M行第N列是由 $\boldsymbol{A}$的第M行乘以$\boldsymbol{B}$的第N列得到的结果.比如
\(\boldsymbol{A}\) 的第2行和 \(\boldsymbol{B}\) 的第1列相乘,就是新矩阵的第2行第1列的元素</li>
<li><p>
上述过程用python表示如下
</p>
<div class="org-src-container">
<pre class="src src-shell">Type <span style="color: #2d9574;">"help"</span>, <span style="color: #2d9574;">"copyright"</span>, <span style="color: #2d9574;">"credits"</span> or <span style="color: #2d9574;">"license"</span> for more information.
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; A = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span><span style="color: #2d9574;">[</span>1, 2<span style="color: #2d9574;">]</span>, <span style="color: #2d9574;">[</span>3, 4<span style="color: #2d9574;">]</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; A.shape
<span style="color: #3a81c3;">(</span>2, 2<span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; B = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span><span style="color: #2d9574;">[</span>5, 6<span style="color: #2d9574;">]</span>, <span style="color: #2d9574;">[</span>7,8<span style="color: #2d9574;">]</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; B.shape
<span style="color: #3a81c3;">(</span>2, 2<span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; np.dot<span style="color: #3a81c3;">(</span>A,B<span style="color: #3a81c3;">)</span>
<span style="color: #6c3163; font-weight: bold;">array</span><span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span><span style="color: #2d9574;">[</span>19, 22<span style="color: #2d9574;">]</span>,
       <span style="color: #2d9574;">[</span>43, 50<span style="color: #2d9574;">]</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt;
</pre>
</div></li>
</ul></li>
<li>上面的例子是相乘的两个矩阵的shape完全一致的情况,但是很多时候相乘的矩阵的shape是不一致的.不一样shape
的两个矩阵只有一种情况可以相乘: 那就是第一个矩阵Shape的最后一个维度,要和下一个矩阵的第一个维度相同
<ul class="org-ul">
<li><p>
矩阵A是 \(3 \times 2\), 矩阵B是 \(2 \times 3\), 两者可以相乘
</p>

<div id="orgdbcc8d8" class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/image/master/dlfs/3-12.png" alt="3-12.png" />
</p>
<p><span class="figure-number">Figure 22: </span>dlfs/3-12.png</p>
</div></li>
</ul></li>
<li>第二个例子就比较特别了,那就是当矩阵A是二维矩阵,而B是一个一维数组的情况.
<ul class="org-ul">
<li><p>
先看图
</p>

<div id="org6ca3057" class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/image/master/dlfs/3-13.png" alt="3-13.png" />
</p>
<p><span class="figure-number">Figure 23: </span>dlfs/3-13.png</p>
</div></li>
<li><p>
再看代码
</p>
<div class="org-src-container">
<pre class="src src-shell">&gt;&gt;&gt; A = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span><span style="color: #2d9574;">[</span>1,2<span style="color: #2d9574;">]</span>, <span style="color: #2d9574;">[</span>3,4<span style="color: #2d9574;">]</span>, <span style="color: #2d9574;">[</span>5,6<span style="color: #2d9574;">]</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; A.shape
<span style="color: #3a81c3;">(</span>3, 2<span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; B = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>7,8<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; B.shape
<span style="color: #3a81c3;">(</span>2,<span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; np.dot<span style="color: #3a81c3;">(</span>A, B<span style="color: #3a81c3;">)</span>
<span style="color: #6c3163; font-weight: bold;">array</span><span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>23, 53, 83<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
</pre>
</div></li>
</ul></li>
<li>上面的这个二维矩阵和一位数组相乘的例子看似简单,但是其实隐藏着numpy的非常重要的内部逻辑,我们需要详
细说一下</li>
<li><p>
其实对于矩阵来说,只能是矩阵和矩阵相乘.比如shape为(3,2)的只能和(2,x)的相乘,那么上面的例子中A和B就
不能相乘,A只能和一个shape为(2,x)的C相乘,例子如下
</p>
<div class="org-src-container">
<pre class="src src-shell">&gt;&gt;&gt; A
<span style="color: #6c3163; font-weight: bold;">array</span><span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span><span style="color: #2d9574;">[</span>1, 2<span style="color: #2d9574;">]</span>,
       <span style="color: #2d9574;">[</span>3, 4<span style="color: #2d9574;">]</span>,
       <span style="color: #2d9574;">[</span>5, 6<span style="color: #2d9574;">]</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; A.shape
<span style="color: #3a81c3;">(</span>3, 2<span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; C = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span><span style="color: #2d9574;">[</span>7<span style="color: #2d9574;">]</span>,<span style="color: #2d9574;">[</span>8<span style="color: #2d9574;">]</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; C
<span style="color: #6c3163; font-weight: bold;">array</span><span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span><span style="color: #2d9574;">[</span>7<span style="color: #2d9574;">]</span>,
       <span style="color: #2d9574;">[</span>8<span style="color: #2d9574;">]</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; C.shape
<span style="color: #3a81c3;">(</span>2, 1<span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; np.dot<span style="color: #3a81c3;">(</span>A,C<span style="color: #3a81c3;">)</span>
<span style="color: #6c3163; font-weight: bold;">array</span><span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span><span style="color: #2d9574;">[</span>23<span style="color: #2d9574;">]</span>,
       <span style="color: #2d9574;">[</span>53<span style="color: #2d9574;">]</span>,
       <span style="color: #2d9574;">[</span>83<span style="color: #2d9574;">]</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; np.dot<span style="color: #3a81c3;">(</span>A,C<span style="color: #3a81c3;">)</span>.shape
<span style="color: #3a81c3;">(</span>3, 1<span style="color: #3a81c3;">)</span>
</pre>
</div></li>
<li>但是这样就太不方便了,我们的一维数组要转换成shape为(N,1)的二维数组.然后再乘以(X,N)的矩阵.我们的numpy
是不答应的.numpy想了一个办法,更改了规则:
<ul class="org-ul">
<li><p>
数学角度讲,需要两个维度(就是ndim属性)相同的张量,且第一个张量的最后一位等于第二个张量第一位的两个张量相乘
</p>
<div class="org-src-container">
<pre class="src src-shell">&gt;&gt;&gt; A
<span style="color: #6c3163; font-weight: bold;">array</span><span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span><span style="color: #2d9574;">[</span>1, 2<span style="color: #2d9574;">]</span>,
       <span style="color: #2d9574;">[</span>3, 4<span style="color: #2d9574;">]</span>,
       <span style="color: #2d9574;">[</span>5, 6<span style="color: #2d9574;">]</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; A.ndim
2
&gt;&gt;&gt; A.shape
<span style="color: #3a81c3;">(</span>3, 2<span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; C
<span style="color: #6c3163; font-weight: bold;">array</span><span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span><span style="color: #2d9574;">[</span>7<span style="color: #2d9574;">]</span>,
       <span style="color: #2d9574;">[</span>8<span style="color: #2d9574;">]</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; C.ndim
2
&gt;&gt;&gt; C.shape
<span style="color: #3a81c3;">(</span>2, 1<span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; R = np.dot<span style="color: #3a81c3;">(</span>A, C<span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; R.shape
<span style="color: #3a81c3;">(</span>3, 1<span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; R.ndim
2
</pre>
</div></li>
<li><p>
numpy从自己的角度讲, 把"需要两个维度(ndim)相同"这个前提条件给去掉了.只需要第二个条件"第一个张
量的最后一位等于第二个张量第一位", 那么我就可以举一个例子了ndim为3的张量和ndim为2的矩阵的乘法
</p>
<div class="org-src-container">
<pre class="src src-shell">&gt;&gt;&gt; A
<span style="color: #6c3163; font-weight: bold;">array</span><span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span><span style="color: #2d9574;">[</span>1, 2<span style="color: #2d9574;">]</span>,
       <span style="color: #2d9574;">[</span>3, 4<span style="color: #2d9574;">]</span>,
       <span style="color: #2d9574;">[</span>5, 6<span style="color: #2d9574;">]</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; A.ndim
2
&gt;&gt;&gt; A.shape
<span style="color: #3a81c3;">(</span>3, 2<span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; D = np.ones<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">(</span>3, 3, 3<span style="color: #6c3163;">)</span>, <span style="color: #715ab1;">dtype</span>=int<span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; D
<span style="color: #6c3163; font-weight: bold;">array</span><span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span><span style="color: #2d9574;">[</span><span style="color: #67b11d;">[</span>1, 1, 1<span style="color: #67b11d;">]</span>,
        <span style="color: #67b11d;">[</span>1, 1, 1<span style="color: #67b11d;">]</span>,
        <span style="color: #67b11d;">[</span>1, 1, 1<span style="color: #67b11d;">]</span><span style="color: #2d9574;">]</span>,

       <span style="color: #2d9574;">[</span><span style="color: #67b11d;">[</span>1, 1, 1<span style="color: #67b11d;">]</span>,
        <span style="color: #67b11d;">[</span>1, 1, 1<span style="color: #67b11d;">]</span>,
        <span style="color: #67b11d;">[</span>1, 1, 1<span style="color: #67b11d;">]</span><span style="color: #2d9574;">]</span>,

       <span style="color: #2d9574;">[</span><span style="color: #67b11d;">[</span>1, 1, 1<span style="color: #67b11d;">]</span>,
        <span style="color: #67b11d;">[</span>1, 1, 1<span style="color: #67b11d;">]</span>,
        <span style="color: #67b11d;">[</span>1, 1, 1<span style="color: #67b11d;">]</span><span style="color: #2d9574;">]</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; D.ndim
3
&gt;&gt;&gt; D.shape
<span style="color: #3a81c3;">(</span>3, 3, 3<span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; np.dot<span style="color: #3a81c3;">(</span>D, A<span style="color: #3a81c3;">)</span>
<span style="color: #6c3163; font-weight: bold;">array</span><span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span><span style="color: #2d9574;">[</span><span style="color: #67b11d;">[</span> 9, 12<span style="color: #67b11d;">]</span>,
        <span style="color: #67b11d;">[</span> 9, 12<span style="color: #67b11d;">]</span>,
        <span style="color: #67b11d;">[</span> 9, 12<span style="color: #67b11d;">]</span><span style="color: #2d9574;">]</span>,

       <span style="color: #2d9574;">[</span><span style="color: #67b11d;">[</span> 9, 12<span style="color: #67b11d;">]</span>,
        <span style="color: #67b11d;">[</span> 9, 12<span style="color: #67b11d;">]</span>,
        <span style="color: #67b11d;">[</span> 9, 12<span style="color: #67b11d;">]</span><span style="color: #2d9574;">]</span>,

       <span style="color: #2d9574;">[</span><span style="color: #67b11d;">[</span> 9, 12<span style="color: #67b11d;">]</span>,
        <span style="color: #67b11d;">[</span> 9, 12<span style="color: #67b11d;">]</span>,
        <span style="color: #67b11d;">[</span> 9, 12<span style="color: #67b11d;">]</span><span style="color: #2d9574;">]</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>


&gt;&gt;&gt; np.dot<span style="color: #3a81c3;">(</span>D, A<span style="color: #3a81c3;">)</span>.ndim
3
&gt;&gt;&gt; np.dot<span style="color: #3a81c3;">(</span>D, A<span style="color: #3a81c3;">)</span>.shape
<span style="color: #3a81c3;">(</span>3, 3, 2<span style="color: #3a81c3;">)</span>
</pre>
</div></li>
</ul></li>
<li>把"需要两个维度(ndim)相同"这个前提条件给去掉了之后,受到实惠最大的是shape长度我1的一维数组,因为它shape
只有一个成员:
<ul class="org-ul">
<li><p>
既可以作为第一位和前面的numpy array进行匹配
</p>
<div class="org-src-container">
<pre class="src src-shell">&gt;&gt;&gt; A
<span style="color: #6c3163; font-weight: bold;">array</span><span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span><span style="color: #2d9574;">[</span>1, 2<span style="color: #2d9574;">]</span>,
       <span style="color: #2d9574;">[</span>3, 4<span style="color: #2d9574;">]</span>,
       <span style="color: #2d9574;">[</span>5, 6<span style="color: #2d9574;">]</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; A.ndim
2
&gt;&gt;&gt; A.shape
<span style="color: #3a81c3;">(</span>3, 2<span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; B = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>7,8<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; B
<span style="color: #6c3163; font-weight: bold;">array</span><span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>7, 8<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; B.ndim
1
&gt;&gt;&gt; B.shape
<span style="color: #3a81c3;">(</span>2,<span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; np.dot<span style="color: #3a81c3;">(</span>A,B<span style="color: #3a81c3;">)</span>
<span style="color: #6c3163; font-weight: bold;">array</span><span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>23, 53, 83<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; np.dot<span style="color: #3a81c3;">(</span>A,B<span style="color: #3a81c3;">)</span>.ndim
1
&gt;&gt;&gt; np.dot<span style="color: #3a81c3;">(</span>A,B<span style="color: #3a81c3;">)</span>.shape
<span style="color: #3a81c3;">(</span>3,<span style="color: #3a81c3;">)</span>
</pre>
</div></li>
<li><p>
也可以作为最后一位和后面的numpy array进行匹配
</p>
<div class="org-src-container">
<pre class="src src-shell">&gt;&gt;&gt; B
<span style="color: #6c3163; font-weight: bold;">array</span><span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>7, 8<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; B.ndim
1
&gt;&gt;&gt; B.shape
<span style="color: #3a81c3;">(</span>2,<span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; C = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span><span style="color: #2d9574;">[</span>1, 2, 3<span style="color: #2d9574;">]</span>, <span style="color: #2d9574;">[</span>4, 5, 6<span style="color: #2d9574;">]</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; C
<span style="color: #6c3163; font-weight: bold;">array</span><span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span><span style="color: #2d9574;">[</span>1, 2, 3<span style="color: #2d9574;">]</span>,
       <span style="color: #2d9574;">[</span>4, 5, 6<span style="color: #2d9574;">]</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; C.ndim
2
&gt;&gt;&gt; C.shape
<span style="color: #3a81c3;">(</span>2, 3<span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; np.dot<span style="color: #3a81c3;">(</span>B, C<span style="color: #3a81c3;">)</span>
<span style="color: #6c3163; font-weight: bold;">array</span><span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>39, 54, 69<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; np.dot<span style="color: #3a81c3;">(</span>B, C<span style="color: #3a81c3;">)</span>.ndim
1
&gt;&gt;&gt; np.dot<span style="color: #3a81c3;">(</span>B, C<span style="color: #3a81c3;">)</span>.shape
<span style="color: #3a81c3;">(</span>3,<span style="color: #3a81c3;">)</span>
&gt;&gt;&gt;
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org47298d4" class="outline-4">
<h4 id="org47298d4"><span class="section-number-4">3.3.3.</span> 神经网络的内机</h4>
<div class="outline-text-4" id="text-3-3-3">
<ul class="org-ul">
<li>理解了numpy的乘法机制,以及其对乘法的优化(放弃相乘两者必须是同一个ndim).那么对如何使用numpy矩阵来实
现神经网络就十分轻松了.</li>
<li>下面的例子省略了偏置和激活函数,主要为了让大家理解如何将 \(x_n\) 和 \(w_n\) 进行匹配的
<ul class="org-ul">
<li><p>
如图
</p>

<div id="org3d75533" class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/image/master/dlfs/3-14.png" alt="3-14.png" />
</p>
<p><span class="figure-number">Figure 24: </span>dlfs/3-14.png</p>
</div></li>
<li>我们注意到矩阵X的shape是(2,), 那么它这里就作为最后一位和后面的矩阵W的第一位匹配即可</li>
<li>最终得到的结果矩阵Y其shape是(3,)</li>
<li><p>
代码如下
</p>
<div class="org-src-container">
<pre class="src src-shell">&gt;&gt;&gt; X = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>1,2<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; X.shape
<span style="color: #3a81c3;">(</span>2,<span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; W = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span><span style="color: #2d9574;">[</span>1, 3, 5<span style="color: #2d9574;">]</span>, <span style="color: #2d9574;">[</span>2, 4, 6<span style="color: #2d9574;">]</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; W
<span style="color: #6c3163; font-weight: bold;">array</span><span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span><span style="color: #2d9574;">[</span>1, 3, 5<span style="color: #2d9574;">]</span>,
       <span style="color: #2d9574;">[</span>2, 4, 6<span style="color: #2d9574;">]</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; W.shape
<span style="color: #3a81c3;">(</span>2, 3<span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; Y = np.dot<span style="color: #3a81c3;">(</span>X, W<span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; Y
<span style="color: #6c3163; font-weight: bold;">array</span><span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span> 5, 11, 17<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; Y.shape
<span style="color: #3a81c3;">(</span>3,<span style="color: #3a81c3;">)</span>
</pre>
</div></li>
<li>通过上面的例子我们知道,即便矩阵Y有一千个元素,那么仅仅通过一次运算也就算出来了.这极大的简化了运算,
在实现上面有巨大意义</li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org22fde56" class="outline-3">
<h3 id="org22fde56"><span class="section-number-3">3.4.</span> 3层神经网络的实现</h3>
<div class="outline-text-3" id="text-3-4">
<ul class="org-ul">
<li>神经网络问题(或者更广义上的机器学习问题),可以分成如下两个阶段:
<ul class="org-ul">
<li>学习:首先,在学习阶段,就是进行模型的学习. 所谓模型的学习,就是使用已知的训练数据自动调参得到无数浮
点参数组成的模型</li>
<li>推理:然后,在推理阶段,用学到的模型对未知的数据进行推理(回归或者分类)</li>
</ul></li>
<li>本章我们先了解一下"推理"阶段,这个阶段理解起来比较直接."推理"阶段在"学习"阶段之后,自然我们是已经在
已知数据上面习得了新的模型(浮点数参数集合).</li>
<li>新的模型存储在numpy数组里面,我们要推理的数据,也在numpy数组里面,通过我们上节学到的numpy数组的计算,
最终得到推理的结果(回归或者分类)</li>
<li>我们的例子是一个三层神经网络
<ul class="org-ul">
<li><p>
如图
</p>

<div id="org4fcb529" class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/image/master/dlfs/3-15.png" alt="3-15.png" />
</p>
<p><span class="figure-number">Figure 25: </span>dlfs/3-15.png</p>
</div></li>
</ul></li>
</ul>
</div>
<div id="outline-container-org0246dd8" class="outline-4">
<h4 id="org0246dd8"><span class="section-number-4">3.4.1.</span> 符号确认</h4>
<div class="outline-text-4" id="text-3-4-1">
<ul class="org-ul">
<li>为了能够清晰的理解推理过程,我们给参数进行了一些特殊定义:
<ul class="org-ul">
<li><p>
如图
</p>

<div id="orgb326c38" class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/image/master/dlfs/3-16.png" alt="3-16.png" />
</p>
<p><span class="figure-number">Figure 26: </span>dlfs/3-16.png</p>
</div></li>
<li>权重(w)和隐藏层神经元的右上角有一个"(1)", 这个表示权重(w)和神经元的层号</li>
<li>权重的右下角有两个数组: 第一个是后一层神经元的index, 第二个是前一层神经元的index,比如 \(w_{12}^{(1)}\)
表示前一层的第2个神经元 \(x_2\) 到 后一层第1个神经元 \(a_1^{(1)}\) 的权重</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org519c63e" class="outline-4">
<h4 id="org519c63e"><span class="section-number-4">3.4.2.</span> 各层间信号传递的实现</h4>
<div class="outline-text-4" id="text-3-4-2">
<ul class="org-ul">
<li>我们现在看一下从输入层到第一层第一个神经元的信号传递过程
<ul class="org-ul">
<li><p>
如图
</p>

<div id="orgf90d042" class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/image/master/dlfs/3-17.png" alt="3-17.png" />
</p>
<p><span class="figure-number">Figure 27: </span>dlfs/3-17.png</p>
</div></li>
<li>图中增加了表示偏置(bias)的神经元"1", 注意偏置的右下角只有一个标记(也就是目的地), 因为偏置神经元(神经
元"1")只有一个</li>
<li>上面偏置右下角只有一个标记,这也就解释了为什么权重要把目的地写前面了(一般目的地都写后面)&#x2013;因为偏置
只有目的地, 为了偏置和权重使用一套符号,所以把目的地写第一个位置</li>
<li><p>
上图所谓的第一层第一个神经元,用我们的符号表示的话,其实就是 \(a_1^{(1)}\), 我们使用数学公式来表达下
计算第一层第一个神经元的公式
</p>
\begin{equation}
a_1^{(1)} = w_{11}^{(1)} x_1 + w_{12}^{(1)} x_2 + b_1^{(1)} \tag{3.8}
\end{equation}</li>
</ul></li>
<li>有了第一层第一个神经元的计算公式,我们可以进一步把第一层的计算方式列出来:
<ul class="org-ul">
<li><p>
总体公式如下
</p>
\begin{equation}
\boldsymbol{A}^{(1)} = \boldsymbol{X} \boldsymbol{W}^{(1)} + \boldsymbol{B}^{(1)} \tag{3.9}
\end{equation}</li>
<li><p>
其中 \(\boldsymbol{A}^{(1)}\) 如下
</p>
\begin{equation}
\boldsymbol{A}^{(1)} = \left(a_1^{(1)} \; a_2^{(1)} \; a_3^{(1)} \right) \notag
\end{equation}</li>
<li><p>
其中 \(\boldsymbol{X}\) 如下
</p>
\begin{equation}
\boldsymbol{X} = \left( x_1, x_2 \right) \notag
\end{equation}</li>
<li><p>
其中 \(\boldsymbol{B}^{(1)}\) 如下
</p>
\begin{equation}
\boldsymbol{B}^{(1)} = \left(b_1^{(1)} \; b_2^{(1)} \; b_3^{(1)} \right) \notag
\end{equation}</li>
<li><p>
其中 \(\boldsymbol{W}^{(1)}\) 如下
</p>
\begin{equation}
\boldsymbol{W}^{(1)} = \begin{pmatrix}
                           w_{11}^{(1)} & w_{21}^{(1)} & w_{31}^{(1)} \\
                           w_{12}^{(1)} & w_{22}^{(1)} & w_{32}^{(1)}
                       \end{pmatrix} \notag
\end{equation}</li>
<li><p>
最后,我们使用numpy多维数组来实现公式3.9,其中权重,偏置,X值都是随机的
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #3a81c3; font-weight: bold;">import</span> numpy <span style="color: #3a81c3; font-weight: bold;">as</span> np

<span style="color: #715ab1;">X</span> = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>1.0, 0.5<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
<span style="color: #715ab1;">W1</span> = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span><span style="color: #2d9574;">[</span>0.1, 0.3, 0.5<span style="color: #2d9574;">]</span>, <span style="color: #2d9574;">[</span>0.2, 0.4, 0.6<span style="color: #2d9574;">]</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
<span style="color: #715ab1;">B1</span> = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>0.1, 0.2, 0.3<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>


<span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>W1.shape<span style="color: #3a81c3;">)</span>
<span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>X.shape<span style="color: #3a81c3;">)</span>
<span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>B1.shape<span style="color: #3a81c3;">)</span>

<span style="color: #715ab1;">A1</span> = np.dot<span style="color: #3a81c3;">(</span>X, W1<span style="color: #3a81c3;">)</span> + B1
</pre>
</div></li>
</ul></li>
<li>下面我们来看看激活过程
<ul class="org-ul">
<li><p>
如图
</p>

<div id="org701271b" class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/image/master/dlfs/3-18.png" alt="3-18.png" />
</p>
<p><span class="figure-number">Figure 28: </span>dlfs/3-18.png</p>
</div></li>
<li>隐藏层的加权和(加权信号和偏置的总和)用a表示</li>
<li>被激活函数转换后的信号用z表示</li>
<li><p>
\(h()\) 表示激活函数,我们这里使用的是sigmoid函数,从输入到激活成功的总体代码如下
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #3a81c3; font-weight: bold;">import</span> numpy <span style="color: #3a81c3; font-weight: bold;">as</span> np


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">sigmoid</span><span style="color: #3a81c3;">(</span>x<span style="color: #3a81c3;">)</span>:
    <span style="color: #3a81c3; font-weight: bold;">return</span> 1 / <span style="color: #3a81c3;">(</span>1 + np.exp<span style="color: #6c3163;">(</span>-x<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>


<span style="color: #715ab1;">X</span> = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>1.0, 0.5<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
<span style="color: #715ab1;">W1</span> = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span><span style="color: #2d9574;">[</span>0.1, 0.3, 0.5<span style="color: #2d9574;">]</span>, <span style="color: #2d9574;">[</span>0.2, 0.4, 0.6<span style="color: #2d9574;">]</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
<span style="color: #715ab1;">B1</span> = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>0.1, 0.2, 0.3<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>


<span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>W1.shape<span style="color: #3a81c3;">)</span>
<span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>X.shape<span style="color: #3a81c3;">)</span>
<span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>B1.shape<span style="color: #3a81c3;">)</span>

<span style="color: #715ab1;">A1</span> = np.dot<span style="color: #3a81c3;">(</span>X, W1<span style="color: #3a81c3;">)</span> + B1
<span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>A1<span style="color: #3a81c3;">)</span>


<span style="color: #715ab1;">Z1</span> = sigmoid<span style="color: #3a81c3;">(</span>A1<span style="color: #3a81c3;">)</span>
<span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>Z1<span style="color: #3a81c3;">)</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">(2, 3)</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">(2,)</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">(3,)</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[0.3 0.7 1.1]</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[0.57444252 0.66818777 0.75026011]</span>
</pre>
</div></li>
</ul></li>
<li>下面再来看看第一层到第二层的信号传递
<ul class="org-ul">
<li><p>
如图
</p>

<div id="orgf57f43c" class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/image/master/dlfs/3-19.png" alt="3-19.png" />
</p>
<p><span class="figure-number">Figure 29: </span>dlfs/3-19.png</p>
</div></li>
<li><p>
代码和前面只有些许不同, 把一层的输出Z作为了第二层的输入
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #3a81c3; font-weight: bold;">import</span> numpy <span style="color: #3a81c3; font-weight: bold;">as</span> np


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">sigmoid</span><span style="color: #3a81c3;">(</span>x<span style="color: #3a81c3;">)</span>:
    <span style="color: #3a81c3; font-weight: bold;">return</span> 1 / <span style="color: #3a81c3;">(</span>1 + np.exp<span style="color: #6c3163;">(</span>-x<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>


<span style="color: #715ab1;">X</span> = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>1.0, 0.5<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
<span style="color: #715ab1;">W1</span> = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span><span style="color: #2d9574;">[</span>0.1, 0.3, 0.5<span style="color: #2d9574;">]</span>, <span style="color: #2d9574;">[</span>0.2, 0.4, 0.6<span style="color: #2d9574;">]</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
<span style="color: #715ab1;">B1</span> = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>0.1, 0.2, 0.3<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>


<span style="color: #715ab1;">A1</span> = np.dot<span style="color: #3a81c3;">(</span>X, W1<span style="color: #3a81c3;">)</span> + B1
<span style="color: #715ab1;">Z1</span> = sigmoid<span style="color: #3a81c3;">(</span>A1<span style="color: #3a81c3;">)</span>

<span style="color: #715ab1;">W2</span> = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span><span style="color: #2d9574;">[</span>0.1, 0.4<span style="color: #2d9574;">]</span>, <span style="color: #2d9574;">[</span>0.2, 0.5<span style="color: #2d9574;">]</span>, <span style="color: #2d9574;">[</span>0.3, 0.6<span style="color: #2d9574;">]</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
<span style="color: #715ab1;">B2</span> = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>0.1, 0.2<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>

<span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>Z1.shape<span style="color: #3a81c3;">)</span>
<span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>W2.shape<span style="color: #3a81c3;">)</span>
<span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>B2.shape<span style="color: #3a81c3;">)</span>

<span style="color: #715ab1;">A2</span> = np.dot<span style="color: #3a81c3;">(</span>Z1, W2<span style="color: #3a81c3;">)</span> + B2
<span style="color: #715ab1;">Z2</span> = sigmoid<span style="color: #3a81c3;">(</span>A2<span style="color: #3a81c3;">)</span>
<span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>A2<span style="color: #3a81c3;">)</span>
<span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>Z2<span style="color: #3a81c3;">)</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">(3,)</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">(3, 2)</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">(2,)</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[0.51615984 1.21402696]</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[0.62624937 0.7710107 ]</span>
</pre>
</div></li>
</ul></li>
<li>最后一步是第2层到输出层的信号传递
<ul class="org-ul">
<li><p>
如图
</p>

<div id="orgf6efa6c" class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/image/master/dlfs/3-20.png" alt="3-20.png" />
</p>
<p><span class="figure-number">Figure 30: </span>dlfs/3-20.png</p>
</div></li>
<li><p>
代码如下
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #3a81c3; font-weight: bold;">import</span> numpy <span style="color: #3a81c3; font-weight: bold;">as</span> np


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">sigmoid</span><span style="color: #3a81c3;">(</span>x<span style="color: #3a81c3;">)</span>:
    <span style="color: #3a81c3; font-weight: bold;">return</span> 1 / <span style="color: #3a81c3;">(</span>1 + np.exp<span style="color: #6c3163;">(</span>-x<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>


<span style="color: #715ab1;">X</span> = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>1.0, 0.5<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
<span style="color: #715ab1;">W1</span> = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span><span style="color: #2d9574;">[</span>0.1, 0.3, 0.5<span style="color: #2d9574;">]</span>, <span style="color: #2d9574;">[</span>0.2, 0.4, 0.6<span style="color: #2d9574;">]</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
<span style="color: #715ab1;">B1</span> = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>0.1, 0.2, 0.3<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>


<span style="color: #715ab1;">A1</span> = np.dot<span style="color: #3a81c3;">(</span>X, W1<span style="color: #3a81c3;">)</span> + B1
<span style="color: #715ab1;">Z1</span> = sigmoid<span style="color: #3a81c3;">(</span>A1<span style="color: #3a81c3;">)</span>

<span style="color: #715ab1;">W2</span> = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span><span style="color: #2d9574;">[</span>0.1, 0.4<span style="color: #2d9574;">]</span>, <span style="color: #2d9574;">[</span>0.2, 0.5<span style="color: #2d9574;">]</span>, <span style="color: #2d9574;">[</span>0.3, 0.6<span style="color: #2d9574;">]</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
<span style="color: #715ab1;">B2</span> = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>0.1, 0.2<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>

<span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>Z1.shape<span style="color: #3a81c3;">)</span>
<span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>W2.shape<span style="color: #3a81c3;">)</span>
<span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>B2.shape<span style="color: #3a81c3;">)</span>

<span style="color: #715ab1;">A2</span> = np.dot<span style="color: #3a81c3;">(</span>Z1, W2<span style="color: #3a81c3;">)</span> + B2
<span style="color: #715ab1;">Z2</span> = sigmoid<span style="color: #3a81c3;">(</span>A2<span style="color: #3a81c3;">)</span>
<span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>A2<span style="color: #3a81c3;">)</span>
<span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>Z2<span style="color: #3a81c3;">)</span>


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">identity_function</span><span style="color: #3a81c3;">(</span>x<span style="color: #3a81c3;">)</span>:
    <span style="color: #3a81c3; font-weight: bold;">return</span> x

<span style="color: #715ab1;">W3</span> = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span><span style="color: #2d9574;">[</span>0.1, 0.3<span style="color: #2d9574;">]</span>, <span style="color: #2d9574;">[</span>0.2, 0.4<span style="color: #2d9574;">]</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
<span style="color: #715ab1;">B3</span> = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>0.1, 0.2<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>

<span style="color: #715ab1;">A3</span> = np.dot<span style="color: #3a81c3;">(</span>Z2, W3<span style="color: #3a81c3;">)</span> + B3
<span style="color: #715ab1;">Y</span> = identity_function<span style="color: #3a81c3;">(</span>A3<span style="color: #3a81c3;">)</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">(3,)</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">(3, 2)</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">(2,)</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[0.51615984 1.21402696]</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[0.62624937 0.7710107 ]</span>
</pre>
</div></li>
<li>这里Z2是输入</li>
<li>我们这里定义了identity_function()函数,并且作为输出层的激活函数.这个函数其实什么都没干,我们也只是
为了和之前的流程保持一致,所以加了这个函数.</li>
<li>输出层所用的激活函数,要根据求解问题的性质决定:
<ol class="org-ol">
<li>回归问题可以用恒等函数,因为回顾问题本来就是求一个浮点数</li>
<li>二元分类问题可以使用sigmoid函数</li>
<li>多元分类问题可以使用softmax函数</li>
</ol></li>
<li>identity_function()这个函数对应于图3-20中的 \(\sigma()\)</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org50645b2" class="outline-4">
<h4 id="org50645b2"><span class="section-number-4">3.4.3.</span> 代码现小结</h4>
<div class="outline-text-4" id="text-3-4-3">
<ul class="org-ul">
<li>我们可以把前面几个步骤重新整理一下
<ul class="org-ul">
<li><p>
完整的代码如下
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #3a81c3; font-weight: bold;">import</span> numpy <span style="color: #3a81c3; font-weight: bold;">as</span> np


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">sigmoid</span><span style="color: #3a81c3;">(</span>x<span style="color: #3a81c3;">)</span>:
    <span style="color: #3a81c3; font-weight: bold;">return</span> 1 / <span style="color: #3a81c3;">(</span>1 + np.exp<span style="color: #6c3163;">(</span>-x<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">identity_function</span><span style="color: #3a81c3;">(</span>x<span style="color: #3a81c3;">)</span>:
    <span style="color: #3a81c3; font-weight: bold;">return</span> x


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">init_network</span><span style="color: #3a81c3;">()</span>:
    <span style="color: #715ab1;">network</span> = <span style="color: #3a81c3;">{}</span>
    <span style="color: #715ab1;">network</span><span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"W1"</span><span style="color: #3a81c3;">]</span> = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span><span style="color: #2d9574;">[</span>0.1, 0.3, 0.5<span style="color: #2d9574;">]</span>, <span style="color: #2d9574;">[</span>0.2, 0.4, 0.6<span style="color: #2d9574;">]</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">network</span><span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"b1"</span><span style="color: #3a81c3;">]</span> = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>0.1, 0.2, 0.3<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">network</span><span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"W2"</span><span style="color: #3a81c3;">]</span> = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span><span style="color: #2d9574;">[</span>0.1, 0.4<span style="color: #2d9574;">]</span>, <span style="color: #2d9574;">[</span>0.2, 0.5<span style="color: #2d9574;">]</span>, <span style="color: #2d9574;">[</span>0.3, 0.6<span style="color: #2d9574;">]</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">network</span><span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"b2"</span><span style="color: #3a81c3;">]</span> = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>0.1, 0.2<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">network</span><span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"W3"</span><span style="color: #3a81c3;">]</span> = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span><span style="color: #2d9574;">[</span>0.1, 0.3<span style="color: #2d9574;">]</span>, <span style="color: #2d9574;">[</span>0.2, 0.4<span style="color: #2d9574;">]</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">network</span><span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"b3"</span><span style="color: #3a81c3;">]</span> = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>0.1, 0.2<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3; font-weight: bold;">return</span> network


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">forward</span><span style="color: #3a81c3;">(</span>network, x<span style="color: #3a81c3;">)</span>:
    <span style="color: #715ab1;">W1</span>, <span style="color: #715ab1;">W2</span>, <span style="color: #715ab1;">W3</span> = network<span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"W1"</span><span style="color: #3a81c3;">]</span>, network<span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"W2"</span><span style="color: #3a81c3;">]</span>, network<span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"W3"</span><span style="color: #3a81c3;">]</span>
    <span style="color: #715ab1;">b1</span>, <span style="color: #715ab1;">b2</span>, <span style="color: #715ab1;">b3</span> = network<span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"b1"</span><span style="color: #3a81c3;">]</span>, network<span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"b2"</span><span style="color: #3a81c3;">]</span>, network<span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"b3"</span><span style="color: #3a81c3;">]</span>

    <span style="color: #715ab1;">a1</span> = np.dot<span style="color: #3a81c3;">(</span>x, W1<span style="color: #3a81c3;">)</span> + b1
    <span style="color: #715ab1;">z1</span> = sigmoid<span style="color: #3a81c3;">(</span>a1<span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">a2</span> = np.dot<span style="color: #3a81c3;">(</span>z1, W2<span style="color: #3a81c3;">)</span> + b2
    <span style="color: #715ab1;">z2</span> = sigmoid<span style="color: #3a81c3;">(</span>a2<span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">a3</span> = np.dot<span style="color: #3a81c3;">(</span>z2, W3<span style="color: #3a81c3;">)</span> + b3
    <span style="color: #715ab1;">y</span> = identity_function<span style="color: #3a81c3;">(</span>a3<span style="color: #3a81c3;">)</span>

    <span style="color: #3a81c3; font-weight: bold;">return</span> y


<span style="color: #715ab1;">network</span> = init_network<span style="color: #3a81c3;">()</span>
<span style="color: #715ab1;">x</span> = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>1.0, 0.5<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
<span style="color: #715ab1;">y</span> = forward<span style="color: #3a81c3;">(</span>network, x<span style="color: #3a81c3;">)</span>
<span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>y<span style="color: #3a81c3;">)</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[0.31682708 0.69627909]</span>
</pre>
</div></li>
<li>我们这里引入了init_network()函数来初始化权重和偏置</li>
<li>这里的forward()函数则封装了将输入信号转换为输出信号的过程. forward的前项,指的是从输入到输出方向的
传递处理.后面在介绍"训练"阶段的时候,我们将介绍backward(后向:从输出到输入)的处理</li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgf160bc2" class="outline-3">
<h3 id="orgf160bc2"><span class="section-number-3">3.5.</span> 输出层的设计</h3>
<div class="outline-text-3" id="text-3-5">
<ul class="org-ul">
<li>神经网络可以用在如下两种问题上:
<ul class="org-ul">
<li>回归问题(比如区分图形中的人是男性还是女性): 一般使用恒等函数</li>
<li>分类问题(根据一个人的图像预测这个人的体重): 一般使用softmax函数</li>
</ul></li>
</ul>
</div>
<div id="outline-container-orgff00b1a" class="outline-4">
<h4 id="orgff00b1a"><span class="section-number-4">3.5.1.</span> 恒等函数和softmax函数</h4>
<div class="outline-text-4" id="text-3-5-1">
<ul class="org-ul">
<li>恒等函数就非常直接了,在输出层使用恒等函数的时候,输入信号会原封不动地被输出
<ul class="org-ul">
<li><p>
如图
</p>

<div id="org576fb35" class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/image/master/dlfs/3-21.png" alt="3-21.png" />
</p>
<p><span class="figure-number">Figure 31: </span>dlfs/3-21.png</p>
</div></li>
<li>上图的 \(\sigma()\) 就是恒等函数.我们可以看到恒等函数转换的时候 \(y_n\) 只跟 \(a_n\) 有关系(两者通过箭
头相连,表示转换的时候有关系)</li>
</ul></li>
<li>分类问题使用的softmax函数可以用下面的公式表示
<ul class="org-ul">
<li><p>
公式如下
</p>
\begin{equation}
 y_k = \frac{\exp(a_k)}{  \displaystyle \sum_{i=1}^{n} \exp(a_i) } \tag{3.10}
\end{equation}</li>
<li>\(\exp(x)\) 是表示 \(\mathrm{e}^x\) 的指数函数( \(\mathrm{e}\) 是纳皮尔常数2.7182&#x2026;)</li>
<li>上述公式表示假设输出层有n个神经元,计算第k个神经元的输出 \(y_k\)</li>
<li>softmax函数的分子是输入信号 \(a_k\) 的指数函数,分母是所有输入信号的指数函数的和</li>
<li><p>
用图表示如下
</p>

<div id="org1b25a0b" class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/image/master/dlfs/3-22.png" alt="3-22.png" />
</p>
<p><span class="figure-number">Figure 32: </span>dlfs/3-22.png</p>
</div></li>
<li>这里箭头还是和图3-21一样表示计算时候有关联,那么我们可以看到:图3-22输出层每个神经元都受到所有输入信号的影响</li>
</ul></li>
<li>我们使用python来实现一遍softmax函数
<ul class="org-ul">
<li><p>
代码如下
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #3a81c3; font-weight: bold;">import</span> numpy <span style="color: #3a81c3; font-weight: bold;">as</span> np

<span style="color: #715ab1;">a</span> = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>0.3, 2.9, 4.0<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
<span style="color: #715ab1;">exp_a</span> = np.exp<span style="color: #3a81c3;">(</span>a<span style="color: #3a81c3;">)</span>
<span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"""|exp_a|=&gt;"""</span>, exp_a<span style="color: #3a81c3;">)</span>

<span style="color: #715ab1;">sum_exp_a</span> = np.<span style="color: #3a81c3;">sum</span><span style="color: #3a81c3;">(</span>exp_a<span style="color: #3a81c3;">)</span>
<span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"""|sum_exp_a|=&gt;"""</span>, sum_exp_a<span style="color: #3a81c3;">)</span>
<span style="color: #715ab1;">y</span> = exp_a / sum_exp_a
<span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"""|y|=&gt;"""</span>, y<span style="color: #3a81c3;">)</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">|exp_a|=&gt; [ 1.34985881 18.17414537 54.59815003]</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">|sum_exp_a|=&gt; 74.1221542101633</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">|y|=&gt; [0.01821127 0.24519181 0.73659691]</span>
</pre>
</div></li>
<li>我们可以看到,softmax的数组结果加起来为1</li>
<li><p>
考虑到后面还要使用这段代码，我们把函数实现总结如下
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #3a81c3; font-weight: bold;">import</span> numpy <span style="color: #3a81c3; font-weight: bold;">as</span> np


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">softmax</span><span style="color: #3a81c3;">(</span>a<span style="color: #3a81c3;">)</span>:
    <span style="color: #715ab1;">exp_a</span> = np.exp<span style="color: #3a81c3;">(</span>a<span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">sum_exp_a</span> = np.<span style="color: #3a81c3;">sum</span><span style="color: #3a81c3;">(</span>exp_a<span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">y</span> = exp_a / sum_exp_a
    <span style="color: #3a81c3; font-weight: bold;">return</span> y
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org8c25494" class="outline-4">
<h4 id="org8c25494"><span class="section-number-4">3.5.2.</span> 实现softmax函数时的注意事项</h4>
<div class="outline-text-4" id="text-3-5-2">
<ul class="org-ul">
<li>上面的softmax函数的实现虽然正确的描述了公式3.10, 但是在计算的时候有一定的缺陷,因为函数的中间值可能
会变的非常大,比如:
<ul class="org-ul">
<li><p>
np.exp(10)就会超过2000
</p>
<div class="org-src-container">
<pre class="src src-python">&gt;&gt;&gt; np.exp<span style="color: #3a81c3;">(</span>10<span style="color: #3a81c3;">)</span>
22026.465794806718
</pre>
</div></li>
<li><p>
np.exp(100)会变成有40多个0 的超大值
</p>
<div class="org-src-container">
<pre class="src src-python">&gt;&gt;&gt; np.exp<span style="color: #3a81c3;">(</span>100<span style="color: #3a81c3;">)</span>
2.6881171418161356e+43
</pre>
</div></li>
<li><p>
np.exp(1000) 的结果会溢出
</p>
<div class="org-src-container">
<pre class="src src-python">&gt;&gt;&gt; np.exp<span style="color: #3a81c3;">(</span>1000<span style="color: #3a81c3;">)</span>
&lt;stdin&gt;:1: <span style="color: #ba2f59; font-weight: bold;">RuntimeWarning</span>: overflow encountered <span style="color: #3a81c3; font-weight: bold;">in</span> exp
inf
</pre>
</div></li>
</ul></li>
<li>为了让我们的计算过程中间值不要出现溢出(或者超大值,因为超大值之间的计算也可能出现问题),我们需要对公
式3.10进行改造
<ul class="org-ul">
<li><p>
新公式如下
</p>
\begin{align}
y_k    = \frac{\exp(a_k)}{\displaystyle \sum_{i=1}^{n} \exp(a_i)} &= \frac{\mathrm{C} \exp(a_k)}{\mathrm{C} \displaystyle \sum_{i=1}^{n} \exp(a_i)} \notag \\
     &  =  \frac{ \exp(a_k + \mathrm{log \;C})}{ \displaystyle \sum_{i=1}^{n} \exp(a_i + \mathrm{log \; C})} \notag \\
     &  =  \frac{ \exp(a_k + \mathrm{C'})}{ \displaystyle \sum_{i=1}^{n} \exp(a_i + \mathrm{C'})} \tag{3.11}
\end{align}</li>
<li>分子分母都乘以常数C,结果不变</li>
<li>把C移动到指数函数exp中,记作logC(也就是C')</li>
<li>公式3.11说明,在进行softmax函数计算的时候,加上或者减去一个常数不会改变结果,并且C'可以是任意值</li>
<li><p>
虽然C'可以是任意值,通常情况下,为了防止再出现溢出,我们会选择输入vector中最大的值来作为C'(这样np.exp
的参数最大的只可能是0),例子如下
</p>
<div class="org-src-container">
<pre class="src src-shell">&gt;&gt;&gt; a = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>1010, 1000, 990<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; np.exp<span style="color: #3a81c3;">(</span>a<span style="color: #3a81c3;">)</span> / np.sum<span style="color: #3a81c3;">(</span>np.exp<span style="color: #6c3163;">(</span>a<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
&lt;stdin&gt;:1: RuntimeWarning: invalid value encountered<span style="color: #3a81c3; font-weight: bold;"> in</span> divide
<span style="color: #6c3163; font-weight: bold;">array</span><span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>nan, nan, nan<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; c = np.max<span style="color: #3a81c3;">(</span>a<span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; c
1010
&gt;&gt;&gt; a - c
<span style="color: #6c3163; font-weight: bold;">array</span><span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>  0, -10, -20<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; np.exp<span style="color: #3a81c3;">(</span>a-c<span style="color: #3a81c3;">)</span> / np.sum<span style="color: #3a81c3;">(</span>np.exp<span style="color: #6c3163;">(</span>a-c<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
<span style="color: #6c3163; font-weight: bold;">array</span><span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>9.99954600e-01, 4.53978686e-05, 2.06106005e-09<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
</pre>
</div></li>
<li><p>
公式3.11对应的代码如下
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #3a81c3; font-weight: bold;">import</span> numpy <span style="color: #3a81c3; font-weight: bold;">as</span> np


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">softmax</span><span style="color: #3a81c3;">(</span>a<span style="color: #3a81c3;">)</span>:
    <span style="color: #715ab1;">c</span> = np.<span style="color: #3a81c3;">max</span><span style="color: #3a81c3;">(</span>a<span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">exp_a</span> = np.exp<span style="color: #3a81c3;">(</span>a - c<span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">sum_exp_a</span> = np.<span style="color: #3a81c3;">sum</span><span style="color: #3a81c3;">(</span>exp_a<span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">y</span> = exp_a / sum_exp_a
    <span style="color: #3a81c3; font-weight: bold;">return</span> y
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org489651c" class="outline-4">
<h4 id="org489651c"><span class="section-number-4">3.5.3.</span> softmax函数的特征</h4>
<div class="outline-text-4" id="text-3-5-3">
<ul class="org-ul">
<li>我们模拟一个输入[0.3, 2.9, 4.0], 看看softmax函数的输出有什么特点
<ul class="org-ul">
<li><p>
代码如下
</p>
<div class="org-src-container">
<pre class="src src-python">&gt;&gt;&gt; a = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>0.3, 2.9, 4.0<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; y = softmax<span style="color: #3a81c3;">(</span>a<span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>y<span style="color: #3a81c3;">)</span>
<span style="color: #3a81c3;">[</span>0.01821127 0.24519181 0.73659691<span style="color: #3a81c3;">]</span>
&gt;&gt;&gt; np.<span style="color: #3a81c3;">sum</span><span style="color: #3a81c3;">(</span>y<span style="color: #3a81c3;">)</span>
1.0
</pre>
</div></li>
<li>如上所述,softmax函数的输出是0.0到1.0之间的实数</li>
<li><p>
softmax函数的输出值总和是1."输出值总和为1"是softmax函数的重要特征,正因为有了这个特征,我们才可以
把softmax邯郸的输出解释为"概率",比如上面的例子就可以从概率的角度解释为
</p>
<pre class="example" id="orgb25d5d7">
有74%的概率是第2个类别,有25%的概率是第一个类别,有1%的概率是第0个类别
</pre></li>
<li>这里需要注意的是,即便使用了softmax函数,各个元素之间的大小关系也不会改变,因为指数函数( \(y = \exp(x)\) )
是单调递增函数. 比如上个例子中输入(也就是a)中最大的是第2个,输出(也就是y)中最大的也是第2个</li>
<li>一般而言,神经网络只把输出值最大的神经元所对应的类别作为识别结果,比如上面数组a就已经说明第2个元素
最大了,softmax计算过后选出来的还是第2个元素,那么再耗费计算资源去计算softmax就没有意义了.所以,我们
说:
<ol class="org-ol">
<li>在(模型已经创建好后)再进行分类,回归等"推理"阶段的时候,我们不计算softmax,因为没有意义</li>
<li>在(模型还在探索的)"学习"阶段,我们是要使用softmax函数的,具体信息我们后面会看到</li>
</ol></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org3cd9544" class="outline-4">
<h4 id="org3cd9544"><span class="section-number-4">3.5.4.</span> 输出层的神经元数量</h4>
<div class="outline-text-4" id="text-3-5-4">
<ul class="org-ul">
<li><p>
输出层神经元的数量要根据待解决的问题来定:
</p>
<pre class="example" id="org0821337">
对于分类问题,输出层的神经元数量一般设定为类别的数量
</pre></li>
<li>比如对于某个输入图像,预测图中数字是0-9中哪个数字的问题,我们将输出层神经元设定为10个
<ul class="org-ul">
<li><p>
如图
</p>

<div id="orgd39b803" class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/image/master/dlfs/3-23.png" alt="3-23.png" />
</p>
<p><span class="figure-number">Figure 33: </span>dlfs/3-23.png</p>
</div></li>
<li>上图中神经元从上到下以此对应数字0-9</li>
<li>图中输出层神经元的值用不同灰度表示,颜色越深,输出值越大.上图中y2的颜色最深,表示这个神经元预测手写
输入的结果是y2对应的类别,也就是"2"</li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgaf758d8" class="outline-3">
<h3 id="orgaf758d8"><span class="section-number-3">3.6.</span> 手写数字识别</h3>
<div class="outline-text-3" id="text-3-6">
<ul class="org-ul">
<li><p>
我们本节来看一个神经网络的例子. 这个例子假设神经网络的"学习阶段"已经完成(也就是模型参数也存储下来了),
我们利用存储下来的模型参数来进行"推理阶段",推理一个模型没见过的新的输入.
</p>
<pre class="example" id="orgd0fa87c">
已知模型参数,对位置问题进行推理的过程,也被称为神经网络的前向传播(forward progagation)
</pre></li>
</ul>
</div>
<div id="outline-container-orgd2a8302" class="outline-4">
<h4 id="orgd2a8302"><span class="section-number-4">3.6.1.</span> MNIST数据集</h4>
<div class="outline-text-4" id="text-3-6-1">
<ul class="org-ul">
<li>MNIST数据集是由0到9的数字图像构成,其中:
<ul class="org-ul">
<li>训练图像有6万张</li>
<li>测试图像有1万张</li>
</ul></li>
<li>MNIST的图像数据是28像素*28像素的灰度图像,灰阶力度在0-255之间</li>
<li><p>
每个数据都相应的标记了"7","2", "1"等标签,如下图
</p>

<div id="orga5b9852" class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/image/master/dlfs/3-24.png" alt="3-24.png" />
</p>
<p><span class="figure-number">Figure 34: </span>dlfs/3-24.png</p>
</div></li>
<li>本书提供了一个脚本下载mnist数据
<ul class="org-ul">
<li><p>
例子如下
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #3a81c3; font-weight: bold;">try</span>:
    <span style="color: #3a81c3; font-weight: bold;">import</span> urllib.request
<span style="color: #3a81c3; font-weight: bold;">except</span> <span style="color: #ba2f59; font-weight: bold;">ImportError</span>:
    <span style="color: #3a81c3; font-weight: bold;">raise</span> <span style="color: #ba2f59; font-weight: bold;">ImportError</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"You should use Python 3.x"</span><span style="color: #3a81c3;">)</span>
<span style="color: #3a81c3; font-weight: bold;">import</span> os.path
<span style="color: #3a81c3; font-weight: bold;">import</span> gzip
<span style="color: #3a81c3; font-weight: bold;">import</span> pickle
<span style="color: #3a81c3; font-weight: bold;">import</span> os
<span style="color: #3a81c3; font-weight: bold;">import</span> numpy <span style="color: #3a81c3; font-weight: bold;">as</span> np


<span style="color: #715ab1;">url_base</span> = <span style="color: #2d9574;">"http://yann.lecun.com/exdb/mnist/"</span>
<span style="color: #715ab1;">key_file</span> = <span style="color: #3a81c3;">{</span>
    <span style="color: #2d9574;">"train_img"</span>: <span style="color: #2d9574;">"train-images-idx3-ubyte.gz"</span>,
    <span style="color: #2d9574;">"train_label"</span>: <span style="color: #2d9574;">"train-labels-idx1-ubyte.gz"</span>,
    <span style="color: #2d9574;">"test_img"</span>: <span style="color: #2d9574;">"t10k-images-idx3-ubyte.gz"</span>,
    <span style="color: #2d9574;">"test_label"</span>: <span style="color: #2d9574;">"t10k-labels-idx1-ubyte.gz"</span>,
<span style="color: #3a81c3;">}</span>

<span style="color: #715ab1;">dataset_dir</span> = os.path.dirname<span style="color: #3a81c3;">(</span>os.path.abspath<span style="color: #6c3163;">(</span>__file__<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
<span style="color: #715ab1;">save_file</span> = dataset_dir + <span style="color: #2d9574;">"/mnist.pkl"</span>

<span style="color: #715ab1;">train_num</span> = 60000
<span style="color: #715ab1;">test_num</span> = 10000
<span style="color: #715ab1;">img_dim</span> = <span style="color: #3a81c3;">(</span>1, 28, 28<span style="color: #3a81c3;">)</span>
<span style="color: #715ab1;">img_size</span> = 784


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">_download</span><span style="color: #3a81c3;">(</span>file_name<span style="color: #3a81c3;">)</span>:
    <span style="color: #715ab1;">file_path</span> = dataset_dir + <span style="color: #2d9574;">"/"</span> + file_name

    <span style="color: #3a81c3; font-weight: bold;">if</span> os.path.exists<span style="color: #3a81c3;">(</span>file_path<span style="color: #3a81c3;">)</span>:
        <span style="color: #3a81c3; font-weight: bold;">return</span>

    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Downloading "</span> + file_name + <span style="color: #2d9574;">" ... "</span><span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">headers</span> = <span style="color: #3a81c3;">{</span>
        <span style="color: #2d9574;">"User-Agent"</span>: <span style="color: #2d9574;">"Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:47.0) Gecko/20100101 Firefox/47.0"</span>
    <span style="color: #3a81c3;">}</span>
    <span style="color: #715ab1;">request</span> = urllib.request.Request<span style="color: #3a81c3;">(</span>url_base + file_name, headers=headers<span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">response</span> = urllib.request.urlopen<span style="color: #3a81c3;">(</span>request<span style="color: #3a81c3;">)</span>.read<span style="color: #3a81c3;">()</span>
    <span style="color: #3a81c3; font-weight: bold;">with</span> <span style="color: #3a81c3;">open</span><span style="color: #3a81c3;">(</span>file_path, mode=<span style="color: #2d9574;">"wb"</span><span style="color: #3a81c3;">)</span> <span style="color: #3a81c3; font-weight: bold;">as</span> f:
        f.write<span style="color: #3a81c3;">(</span>response<span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Done"</span><span style="color: #3a81c3;">)</span>


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">download_mnist</span><span style="color: #3a81c3;">()</span>:
    <span style="color: #3a81c3; font-weight: bold;">for</span> v <span style="color: #3a81c3; font-weight: bold;">in</span> key_file.values<span style="color: #3a81c3;">()</span>:
        _download<span style="color: #3a81c3;">(</span>v<span style="color: #3a81c3;">)</span>


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">_load_label</span><span style="color: #3a81c3;">(</span>file_name<span style="color: #3a81c3;">)</span>:
    <span style="color: #715ab1;">file_path</span> = dataset_dir + <span style="color: #2d9574;">"/"</span> + file_name

    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Converting "</span> + file_name + <span style="color: #2d9574;">" to NumPy Array ..."</span><span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3; font-weight: bold;">with</span> gzip.<span style="color: #3a81c3;">open</span><span style="color: #3a81c3;">(</span>file_path, <span style="color: #2d9574;">"rb"</span><span style="color: #3a81c3;">)</span> <span style="color: #3a81c3; font-weight: bold;">as</span> f:
        <span style="color: #715ab1;">labels</span> = np.frombuffer<span style="color: #3a81c3;">(</span>f.read<span style="color: #6c3163;">()</span>, np.uint8, offset=8<span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Done"</span><span style="color: #3a81c3;">)</span>

    <span style="color: #3a81c3; font-weight: bold;">return</span> labels


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">_load_img</span><span style="color: #3a81c3;">(</span>file_name<span style="color: #3a81c3;">)</span>:
    <span style="color: #715ab1;">file_path</span> = dataset_dir + <span style="color: #2d9574;">"/"</span> + file_name

    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Converting "</span> + file_name + <span style="color: #2d9574;">" to NumPy Array ..."</span><span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3; font-weight: bold;">with</span> gzip.<span style="color: #3a81c3;">open</span><span style="color: #3a81c3;">(</span>file_path, <span style="color: #2d9574;">"rb"</span><span style="color: #3a81c3;">)</span> <span style="color: #3a81c3; font-weight: bold;">as</span> f:
        <span style="color: #715ab1;">data</span> = np.frombuffer<span style="color: #3a81c3;">(</span>f.read<span style="color: #6c3163;">()</span>, np.uint8, offset=16<span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">data</span> = data.reshape<span style="color: #3a81c3;">(</span>-1, img_size<span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Done"</span><span style="color: #3a81c3;">)</span>

    <span style="color: #3a81c3; font-weight: bold;">return</span> data


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">_convert_numpy</span><span style="color: #3a81c3;">()</span>:
    <span style="color: #715ab1;">dataset</span> = <span style="color: #3a81c3;">{}</span>
    <span style="color: #715ab1;">dataset</span><span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"train_img"</span><span style="color: #3a81c3;">]</span> = _load_img<span style="color: #3a81c3;">(</span>key_file<span style="color: #6c3163;">[</span><span style="color: #2d9574;">"train_img"</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">dataset</span><span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"train_label"</span><span style="color: #3a81c3;">]</span> = _load_label<span style="color: #3a81c3;">(</span>key_file<span style="color: #6c3163;">[</span><span style="color: #2d9574;">"train_label"</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">dataset</span><span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"test_img"</span><span style="color: #3a81c3;">]</span> = _load_img<span style="color: #3a81c3;">(</span>key_file<span style="color: #6c3163;">[</span><span style="color: #2d9574;">"test_img"</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">dataset</span><span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"test_label"</span><span style="color: #3a81c3;">]</span> = _load_label<span style="color: #3a81c3;">(</span>key_file<span style="color: #6c3163;">[</span><span style="color: #2d9574;">"test_label"</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>

    <span style="color: #3a81c3; font-weight: bold;">return</span> dataset


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">init_mnist</span><span style="color: #3a81c3;">()</span>:
    download_mnist<span style="color: #3a81c3;">()</span>
    <span style="color: #715ab1;">dataset</span> = _convert_numpy<span style="color: #3a81c3;">()</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Creating pickle file ..."</span><span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3; font-weight: bold;">with</span> <span style="color: #3a81c3;">open</span><span style="color: #3a81c3;">(</span>save_file, <span style="color: #2d9574;">"wb"</span><span style="color: #3a81c3;">)</span> <span style="color: #3a81c3; font-weight: bold;">as</span> f:
        pickle.dump<span style="color: #3a81c3;">(</span>dataset, f, -1<span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Done!"</span><span style="color: #3a81c3;">)</span>


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">_change_one_hot_label</span><span style="color: #3a81c3;">(</span>X<span style="color: #3a81c3;">)</span>:
    <span style="color: #715ab1;">T</span> = np.zeros<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">(</span>X.size, 10<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3; font-weight: bold;">for</span> idx, row <span style="color: #3a81c3; font-weight: bold;">in</span> <span style="color: #3a81c3;">enumerate</span><span style="color: #3a81c3;">(</span>T<span style="color: #3a81c3;">)</span>:
        row<span style="color: #3a81c3;">[</span>X<span style="color: #6c3163;">[</span>idx<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">]</span> = 1

    <span style="color: #3a81c3; font-weight: bold;">return</span> T


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">load_mnist</span><span style="color: #3a81c3;">(</span>normalize=<span style="color: #4e3163;">True</span>, flatten=<span style="color: #4e3163;">True</span>, one_hot_label=<span style="color: #4e3163;">False</span><span style="color: #3a81c3;">)</span>:
    <span style="color: #3a81c3; font-weight: bold;">if</span> <span style="color: #3a81c3; font-weight: bold;">not</span> os.path.exists<span style="color: #3a81c3;">(</span>save_file<span style="color: #3a81c3;">)</span>:
        init_mnist<span style="color: #3a81c3;">()</span>

    <span style="color: #3a81c3; font-weight: bold;">with</span> <span style="color: #3a81c3;">open</span><span style="color: #3a81c3;">(</span>save_file, <span style="color: #2d9574;">"rb"</span><span style="color: #3a81c3;">)</span> <span style="color: #3a81c3; font-weight: bold;">as</span> f:
        <span style="color: #715ab1;">dataset</span> = pickle.load<span style="color: #3a81c3;">(</span>f<span style="color: #3a81c3;">)</span>

    <span style="color: #3a81c3; font-weight: bold;">if</span> normalize:
        <span style="color: #3a81c3; font-weight: bold;">for</span> key <span style="color: #3a81c3; font-weight: bold;">in</span> <span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"train_img"</span>, <span style="color: #2d9574;">"test_img"</span><span style="color: #3a81c3;">)</span>:
            <span style="color: #715ab1;">dataset</span><span style="color: #3a81c3;">[</span>key<span style="color: #3a81c3;">]</span> = dataset<span style="color: #3a81c3;">[</span>key<span style="color: #3a81c3;">]</span>.astype<span style="color: #3a81c3;">(</span>np.float32<span style="color: #3a81c3;">)</span>
            <span style="color: #715ab1;">dataset</span><span style="color: #3a81c3;">[</span>key<span style="color: #3a81c3;">]</span> /= 255.0

    <span style="color: #3a81c3; font-weight: bold;">if</span> one_hot_label:
        <span style="color: #715ab1;">dataset</span><span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"train_label"</span><span style="color: #3a81c3;">]</span> = _change_one_hot_label<span style="color: #3a81c3;">(</span>dataset<span style="color: #6c3163;">[</span><span style="color: #2d9574;">"train_label"</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
        <span style="color: #715ab1;">dataset</span><span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"test_label"</span><span style="color: #3a81c3;">]</span> = _change_one_hot_label<span style="color: #3a81c3;">(</span>dataset<span style="color: #6c3163;">[</span><span style="color: #2d9574;">"test_label"</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>

    <span style="color: #3a81c3; font-weight: bold;">if</span> <span style="color: #3a81c3; font-weight: bold;">not</span> flatten:
        <span style="color: #3a81c3; font-weight: bold;">for</span> key <span style="color: #3a81c3; font-weight: bold;">in</span> <span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"train_img"</span>, <span style="color: #2d9574;">"test_img"</span><span style="color: #3a81c3;">)</span>:
            <span style="color: #715ab1;">dataset</span><span style="color: #3a81c3;">[</span>key<span style="color: #3a81c3;">]</span> = dataset<span style="color: #3a81c3;">[</span>key<span style="color: #3a81c3;">]</span>.reshape<span style="color: #3a81c3;">(</span>-1, 1, 28, 28<span style="color: #3a81c3;">)</span>

    <span style="color: #3a81c3; font-weight: bold;">return</span> <span style="color: #3a81c3;">(</span>dataset<span style="color: #6c3163;">[</span><span style="color: #2d9574;">"train_img"</span><span style="color: #6c3163;">]</span>, dataset<span style="color: #6c3163;">[</span><span style="color: #2d9574;">"train_label"</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>, <span style="color: #3a81c3;">(</span>
        dataset<span style="color: #6c3163;">[</span><span style="color: #2d9574;">"test_img"</span><span style="color: #6c3163;">]</span>,
        dataset<span style="color: #6c3163;">[</span><span style="color: #2d9574;">"test_label"</span><span style="color: #6c3163;">]</span>,
    <span style="color: #3a81c3;">)</span>


<span style="color: #3a81c3; font-weight: bold;">if</span> <span style="color: #3a81c3;">__name__</span> == <span style="color: #2d9574;">"__main__"</span>:
    <span style="color: #3a81c3;">(</span>x_train, t_train<span style="color: #3a81c3;">)</span>, <span style="color: #3a81c3;">(</span><span style="color: #715ab1;">x_test</span>, <span style="color: #715ab1;">t_test</span><span style="color: #3a81c3;">)</span> = load_mnist<span style="color: #3a81c3;">(</span>flatten=<span style="color: #4e3163;">True</span>, normalize=<span style="color: #4e3163;">False</span><span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>x_train.shape<span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>t_train.shape<span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>x_test.shape<span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>t_test.shape<span style="color: #3a81c3;">)</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Downloading train-images-idx3-ubyte.gz ...</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Done</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Downloading train-labels-idx1-ubyte.gz ...</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Done</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Downloading t10k-images-idx3-ubyte.gz ...</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Done</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Downloading t10k-labels-idx1-ubyte.gz ...</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Done</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Converting train-images-idx3-ubyte.gz to NumPy Array ...</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Done</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Converting train-labels-idx1-ubyte.gz to NumPy Array ...</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Done</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Converting t10k-images-idx3-ubyte.gz to NumPy Array ...</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Done</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Converting t10k-labels-idx1-ubyte.gz to NumPy Array ...</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Done</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Creating pickle file ...</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Done!</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">(60000, 784)</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">(60000,)</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">(10000, 784)</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">(10000,)</span>
</pre>
</div></li>
<li>我们的load_mnist有三个参数:
<ol class="org-ol">
<li>normalize=True, 默认参数要正则化，也就是说图像像素数组（无论是一维还是二维）不再是0-255,而是0.0-1.0, 我们选择不要正则化</li>
<li>flattern=True, 默认图像数组是打扁的，也就是一维数组成员是784个，成员数据为0-255或者是0.0-1.0</li>
<li>one_hot_label=False，默认标签是不要one-hot的，而是7,2这种数字</li>
</ol></li>
<li>由于我们选择了flatten为true，所以我们的结果是一个打扁了的图像文件总像素是784</li>
<li><p>
这个例子第一次会下载数据到本地，也就是如下几个压缩文件
</p>
<pre class="example" id="org23ea7cc">
t10k-images-idx3-ubyte.gz
t10k-labels-idx1-ubyte.gz
train-images-idx3-ubyte.gz
train-labels-idx1-ubyte.gz
</pre></li>
<li><p>
然后，程序还会把这些压缩文件存储到pickle文件（这是python默认的二进制导出文件）
</p>
<pre class="example" id="orgf82c669">
mnist.pkl
</pre></li>
</ul></li>
<li>我们下面为了体验一下数据，选择训练集的第一个数据，打印出来
<ul class="org-ul">
<li><p>
代码如下
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #3a81c3; font-weight: bold;">try</span>:
    <span style="color: #3a81c3; font-weight: bold;">import</span> urllib.request
<span style="color: #3a81c3; font-weight: bold;">except</span> <span style="color: #ba2f59; font-weight: bold;">ImportError</span>:
    <span style="color: #3a81c3; font-weight: bold;">raise</span> <span style="color: #ba2f59; font-weight: bold;">ImportError</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"You should use Python 3.x"</span><span style="color: #3a81c3;">)</span>
<span style="color: #3a81c3; font-weight: bold;">import</span> os.path
<span style="color: #3a81c3; font-weight: bold;">import</span> gzip
<span style="color: #3a81c3; font-weight: bold;">import</span> pickle
<span style="color: #3a81c3; font-weight: bold;">import</span> os
<span style="color: #3a81c3; font-weight: bold;">import</span> numpy <span style="color: #3a81c3; font-weight: bold;">as</span> np


<span style="color: #715ab1;">url_base</span> = <span style="color: #2d9574;">"http://yann.lecun.com/exdb/mnist/"</span>
<span style="color: #715ab1;">key_file</span> = <span style="color: #3a81c3;">{</span>
    <span style="color: #2d9574;">"train_img"</span>: <span style="color: #2d9574;">"train-images-idx3-ubyte.gz"</span>,
    <span style="color: #2d9574;">"train_label"</span>: <span style="color: #2d9574;">"train-labels-idx1-ubyte.gz"</span>,
    <span style="color: #2d9574;">"test_img"</span>: <span style="color: #2d9574;">"t10k-images-idx3-ubyte.gz"</span>,
    <span style="color: #2d9574;">"test_label"</span>: <span style="color: #2d9574;">"t10k-labels-idx1-ubyte.gz"</span>,
<span style="color: #3a81c3;">}</span>

<span style="color: #715ab1;">dataset_dir</span> = os.path.dirname<span style="color: #3a81c3;">(</span>os.path.abspath<span style="color: #6c3163;">(</span>__file__<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
<span style="color: #715ab1;">save_file</span> = dataset_dir + <span style="color: #2d9574;">"/mnist.pkl"</span>

<span style="color: #715ab1;">train_num</span> = 60000
<span style="color: #715ab1;">test_num</span> = 10000
<span style="color: #715ab1;">img_dim</span> = <span style="color: #3a81c3;">(</span>1, 28, 28<span style="color: #3a81c3;">)</span>
<span style="color: #715ab1;">img_size</span> = 784


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">_download</span><span style="color: #3a81c3;">(</span>file_name<span style="color: #3a81c3;">)</span>:
    <span style="color: #715ab1;">file_path</span> = dataset_dir + <span style="color: #2d9574;">"/"</span> + file_name

    <span style="color: #3a81c3; font-weight: bold;">if</span> os.path.exists<span style="color: #3a81c3;">(</span>file_path<span style="color: #3a81c3;">)</span>:
        <span style="color: #3a81c3; font-weight: bold;">return</span>

    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Downloading "</span> + file_name + <span style="color: #2d9574;">" ... "</span><span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">headers</span> = <span style="color: #3a81c3;">{</span>
        <span style="color: #2d9574;">"User-Agent"</span>: <span style="color: #2d9574;">"Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:47.0) Gecko/20100101 Firefox/47.0"</span>
    <span style="color: #3a81c3;">}</span>
    <span style="color: #715ab1;">request</span> = urllib.request.Request<span style="color: #3a81c3;">(</span>url_base + file_name, headers=headers<span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">response</span> = urllib.request.urlopen<span style="color: #3a81c3;">(</span>request<span style="color: #3a81c3;">)</span>.read<span style="color: #3a81c3;">()</span>
    <span style="color: #3a81c3; font-weight: bold;">with</span> <span style="color: #3a81c3;">open</span><span style="color: #3a81c3;">(</span>file_path, mode=<span style="color: #2d9574;">"wb"</span><span style="color: #3a81c3;">)</span> <span style="color: #3a81c3; font-weight: bold;">as</span> f:
        f.write<span style="color: #3a81c3;">(</span>response<span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Done"</span><span style="color: #3a81c3;">)</span>


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">download_mnist</span><span style="color: #3a81c3;">()</span>:
    <span style="color: #3a81c3; font-weight: bold;">for</span> v <span style="color: #3a81c3; font-weight: bold;">in</span> key_file.values<span style="color: #3a81c3;">()</span>:
        _download<span style="color: #3a81c3;">(</span>v<span style="color: #3a81c3;">)</span>


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">_load_label</span><span style="color: #3a81c3;">(</span>file_name<span style="color: #3a81c3;">)</span>:
    <span style="color: #715ab1;">file_path</span> = dataset_dir + <span style="color: #2d9574;">"/"</span> + file_name

    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Converting "</span> + file_name + <span style="color: #2d9574;">" to NumPy Array ..."</span><span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3; font-weight: bold;">with</span> gzip.<span style="color: #3a81c3;">open</span><span style="color: #3a81c3;">(</span>file_path, <span style="color: #2d9574;">"rb"</span><span style="color: #3a81c3;">)</span> <span style="color: #3a81c3; font-weight: bold;">as</span> f:
        <span style="color: #715ab1;">labels</span> = np.frombuffer<span style="color: #3a81c3;">(</span>f.read<span style="color: #6c3163;">()</span>, np.uint8, offset=8<span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Done"</span><span style="color: #3a81c3;">)</span>

    <span style="color: #3a81c3; font-weight: bold;">return</span> labels


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">_load_img</span><span style="color: #3a81c3;">(</span>file_name<span style="color: #3a81c3;">)</span>:
    <span style="color: #715ab1;">file_path</span> = dataset_dir + <span style="color: #2d9574;">"/"</span> + file_name

    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Converting "</span> + file_name + <span style="color: #2d9574;">" to NumPy Array ..."</span><span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3; font-weight: bold;">with</span> gzip.<span style="color: #3a81c3;">open</span><span style="color: #3a81c3;">(</span>file_path, <span style="color: #2d9574;">"rb"</span><span style="color: #3a81c3;">)</span> <span style="color: #3a81c3; font-weight: bold;">as</span> f:
        <span style="color: #715ab1;">data</span> = np.frombuffer<span style="color: #3a81c3;">(</span>f.read<span style="color: #6c3163;">()</span>, np.uint8, offset=16<span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">data</span> = data.reshape<span style="color: #3a81c3;">(</span>-1, img_size<span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Done"</span><span style="color: #3a81c3;">)</span>

    <span style="color: #3a81c3; font-weight: bold;">return</span> data


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">_convert_numpy</span><span style="color: #3a81c3;">()</span>:
    <span style="color: #715ab1;">dataset</span> = <span style="color: #3a81c3;">{}</span>
    <span style="color: #715ab1;">dataset</span><span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"train_img"</span><span style="color: #3a81c3;">]</span> = _load_img<span style="color: #3a81c3;">(</span>key_file<span style="color: #6c3163;">[</span><span style="color: #2d9574;">"train_img"</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">dataset</span><span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"train_label"</span><span style="color: #3a81c3;">]</span> = _load_label<span style="color: #3a81c3;">(</span>key_file<span style="color: #6c3163;">[</span><span style="color: #2d9574;">"train_label"</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">dataset</span><span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"test_img"</span><span style="color: #3a81c3;">]</span> = _load_img<span style="color: #3a81c3;">(</span>key_file<span style="color: #6c3163;">[</span><span style="color: #2d9574;">"test_img"</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">dataset</span><span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"test_label"</span><span style="color: #3a81c3;">]</span> = _load_label<span style="color: #3a81c3;">(</span>key_file<span style="color: #6c3163;">[</span><span style="color: #2d9574;">"test_label"</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>

    <span style="color: #3a81c3; font-weight: bold;">return</span> dataset


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">init_mnist</span><span style="color: #3a81c3;">()</span>:
    download_mnist<span style="color: #3a81c3;">()</span>
    <span style="color: #715ab1;">dataset</span> = _convert_numpy<span style="color: #3a81c3;">()</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Creating pickle file ..."</span><span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3; font-weight: bold;">with</span> <span style="color: #3a81c3;">open</span><span style="color: #3a81c3;">(</span>save_file, <span style="color: #2d9574;">"wb"</span><span style="color: #3a81c3;">)</span> <span style="color: #3a81c3; font-weight: bold;">as</span> f:
        pickle.dump<span style="color: #3a81c3;">(</span>dataset, f, -1<span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Done!"</span><span style="color: #3a81c3;">)</span>


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">_change_one_hot_label</span><span style="color: #3a81c3;">(</span>X<span style="color: #3a81c3;">)</span>:
    <span style="color: #715ab1;">T</span> = np.zeros<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">(</span>X.size, 10<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3; font-weight: bold;">for</span> idx, row <span style="color: #3a81c3; font-weight: bold;">in</span> <span style="color: #3a81c3;">enumerate</span><span style="color: #3a81c3;">(</span>T<span style="color: #3a81c3;">)</span>:
        row<span style="color: #3a81c3;">[</span>X<span style="color: #6c3163;">[</span>idx<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">]</span> = 1

    <span style="color: #3a81c3; font-weight: bold;">return</span> T


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">load_mnist</span><span style="color: #3a81c3;">(</span>normalize=<span style="color: #4e3163;">True</span>, flatten=<span style="color: #4e3163;">True</span>, one_hot_label=<span style="color: #4e3163;">False</span><span style="color: #3a81c3;">)</span>:
    <span style="color: #3a81c3; font-weight: bold;">if</span> <span style="color: #3a81c3; font-weight: bold;">not</span> os.path.exists<span style="color: #3a81c3;">(</span>save_file<span style="color: #3a81c3;">)</span>:
        init_mnist<span style="color: #3a81c3;">()</span>

    <span style="color: #3a81c3; font-weight: bold;">with</span> <span style="color: #3a81c3;">open</span><span style="color: #3a81c3;">(</span>save_file, <span style="color: #2d9574;">"rb"</span><span style="color: #3a81c3;">)</span> <span style="color: #3a81c3; font-weight: bold;">as</span> f:
        <span style="color: #715ab1;">dataset</span> = pickle.load<span style="color: #3a81c3;">(</span>f<span style="color: #3a81c3;">)</span>

    <span style="color: #3a81c3; font-weight: bold;">if</span> normalize:
        <span style="color: #3a81c3; font-weight: bold;">for</span> key <span style="color: #3a81c3; font-weight: bold;">in</span> <span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"train_img"</span>, <span style="color: #2d9574;">"test_img"</span><span style="color: #3a81c3;">)</span>:
            <span style="color: #715ab1;">dataset</span><span style="color: #3a81c3;">[</span>key<span style="color: #3a81c3;">]</span> = dataset<span style="color: #3a81c3;">[</span>key<span style="color: #3a81c3;">]</span>.astype<span style="color: #3a81c3;">(</span>np.float32<span style="color: #3a81c3;">)</span>
            <span style="color: #715ab1;">dataset</span><span style="color: #3a81c3;">[</span>key<span style="color: #3a81c3;">]</span> /= 255.0

    <span style="color: #3a81c3; font-weight: bold;">if</span> one_hot_label:
        <span style="color: #715ab1;">dataset</span><span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"train_label"</span><span style="color: #3a81c3;">]</span> = _change_one_hot_label<span style="color: #3a81c3;">(</span>dataset<span style="color: #6c3163;">[</span><span style="color: #2d9574;">"train_label"</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
        <span style="color: #715ab1;">dataset</span><span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"test_label"</span><span style="color: #3a81c3;">]</span> = _change_one_hot_label<span style="color: #3a81c3;">(</span>dataset<span style="color: #6c3163;">[</span><span style="color: #2d9574;">"test_label"</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>

    <span style="color: #3a81c3; font-weight: bold;">if</span> <span style="color: #3a81c3; font-weight: bold;">not</span> flatten:
        <span style="color: #3a81c3; font-weight: bold;">for</span> key <span style="color: #3a81c3; font-weight: bold;">in</span> <span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"train_img"</span>, <span style="color: #2d9574;">"test_img"</span><span style="color: #3a81c3;">)</span>:
            <span style="color: #715ab1;">dataset</span><span style="color: #3a81c3;">[</span>key<span style="color: #3a81c3;">]</span> = dataset<span style="color: #3a81c3;">[</span>key<span style="color: #3a81c3;">]</span>.reshape<span style="color: #3a81c3;">(</span>-1, 1, 28, 28<span style="color: #3a81c3;">)</span>

    <span style="color: #3a81c3; font-weight: bold;">return</span> <span style="color: #3a81c3;">(</span>dataset<span style="color: #6c3163;">[</span><span style="color: #2d9574;">"train_img"</span><span style="color: #6c3163;">]</span>, dataset<span style="color: #6c3163;">[</span><span style="color: #2d9574;">"train_label"</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>, <span style="color: #3a81c3;">(</span>
        dataset<span style="color: #6c3163;">[</span><span style="color: #2d9574;">"test_img"</span><span style="color: #6c3163;">]</span>,
        dataset<span style="color: #6c3163;">[</span><span style="color: #2d9574;">"test_label"</span><span style="color: #6c3163;">]</span>,
    <span style="color: #3a81c3;">)</span>


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">img_show</span><span style="color: #3a81c3;">(</span>img<span style="color: #3a81c3;">)</span>:
    <span style="color: #3a81c3; font-weight: bold;">from</span> PIL <span style="color: #3a81c3; font-weight: bold;">import</span> Image

    <span style="color: #715ab1;">pil_img</span> = Image.fromarray<span style="color: #3a81c3;">(</span>np.uint8<span style="color: #6c3163;">(</span>img<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
    pil_img.show<span style="color: #3a81c3;">()</span>


<span style="color: #3a81c3; font-weight: bold;">if</span> <span style="color: #3a81c3;">__name__</span> == <span style="color: #2d9574;">"__main__"</span>:
    <span style="color: #3a81c3;">(</span>x_train, t_train<span style="color: #3a81c3;">)</span>, <span style="color: #3a81c3;">(</span><span style="color: #715ab1;">x_test</span>, <span style="color: #715ab1;">t_test</span><span style="color: #3a81c3;">)</span> = load_mnist<span style="color: #3a81c3;">(</span>flatten=<span style="color: #4e3163;">True</span>, normalize=<span style="color: #4e3163;">False</span><span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">img</span> = x_train<span style="color: #3a81c3;">[</span>0<span style="color: #3a81c3;">]</span>
    <span style="color: #715ab1;">label</span> = t_train<span style="color: #3a81c3;">[</span>0<span style="color: #3a81c3;">]</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>label<span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>img.shape<span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">img</span> = img.reshape<span style="color: #3a81c3;">(</span>28, 28<span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>img.shape<span style="color: #3a81c3;">)</span>
    img_show<span style="color: #3a81c3;">(</span>img<span style="color: #3a81c3;">)</span>


<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;"># &lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">5</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">(784,)</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">(28, 28)</span>
</pre>
</div></li>
<li>我们从训练集的label可以看到，这个图的正确结果是一个5</li>
<li>我们想打印这个数据，但是因为我们flattern过，所以我们要reshape之后，再打印，我们在命令行运行会看到
一个图像5</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org13a4e68" class="outline-4">
<h4 id="org13a4e68"><span class="section-number-4">3.6.2.</span> 神经网络的推理处理</h4>
<div class="outline-text-4" id="text-3-6-2">
<ul class="org-ul">
<li>我们下面对这个MNIST数据集进行推理处理:
<ul class="org-ul">
<li>首先还是要注意,推理处理是在已经学习到"参数"的情况下进行的,我们的代码使用了之前已经学习好的参数,
并且把他们存储在了sample_weight.pkl</li>
<li>识别一个MNIST图像,就要把图像分解成像素.我们这里把输入的像素打平成一维数组,长度是784,那么我们的神
经网络的输入层就是有784个神经元</li>
<li>而我们识别的目的是0-9这个十个数字,所以我们的输出层就是有10个神经元</li>
<li>因为我们使用了已有的"参数"(存储在sample_weight.pkl),这个"参数"为整个神经网络设计了两个隐藏层:
<ol class="org-ol">
<li>第一个隐藏层有50个神经元</li>
<li>第二个隐藏层有100个单元</li>
</ol></li>
<li>设计几个隐藏层,每层有多少个神经元是一个玄学,我们称之为"超参"</li>
<li><p>
整个过程的全部代码如下
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #3a81c3; font-weight: bold;">import</span> urllib.request
<span style="color: #3a81c3; font-weight: bold;">import</span> gzip
<span style="color: #3a81c3; font-weight: bold;">import</span> numpy <span style="color: #3a81c3; font-weight: bold;">as</span> np
<span style="color: #3a81c3; font-weight: bold;">import</span> os
<span style="color: #3a81c3; font-weight: bold;">import</span> pickle

<span style="color: #715ab1;">url_base</span> = <span style="color: #2d9574;">"http://yann.lecun.com/exdb/mnist/"</span>
<span style="color: #715ab1;">key_file</span> = <span style="color: #3a81c3;">{</span>
    <span style="color: #2d9574;">"train_img"</span>: <span style="color: #2d9574;">"train-images-idx3-ubyte.gz"</span>,
    <span style="color: #2d9574;">"train_label"</span>: <span style="color: #2d9574;">"train-labels-idx1-ubyte.gz"</span>,
    <span style="color: #2d9574;">"test_img"</span>: <span style="color: #2d9574;">"t10k-images-idx3-ubyte.gz"</span>,
    <span style="color: #2d9574;">"test_label"</span>: <span style="color: #2d9574;">"t10k-labels-idx1-ubyte.gz"</span>,
<span style="color: #3a81c3;">}</span>

<span style="color: #715ab1;">dataset_dir</span> = os.path.dirname<span style="color: #3a81c3;">(</span>os.path.abspath<span style="color: #6c3163;">(</span>__file__<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
<span style="color: #715ab1;">save_file</span> = dataset_dir + <span style="color: #2d9574;">"/mnist.pkl"</span>

<span style="color: #715ab1;">train_num</span> = 60000
<span style="color: #715ab1;">test_num</span> = 10000
<span style="color: #715ab1;">img_dim</span> = <span style="color: #3a81c3;">(</span>1, 28, 28<span style="color: #3a81c3;">)</span>
<span style="color: #715ab1;">img_size</span> = 784


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">_download</span><span style="color: #3a81c3;">(</span>file_name<span style="color: #3a81c3;">)</span>:
    <span style="color: #715ab1;">file_path</span> = dataset_dir + <span style="color: #2d9574;">"/"</span> + file_name

    <span style="color: #3a81c3; font-weight: bold;">if</span> os.path.exists<span style="color: #3a81c3;">(</span>file_path<span style="color: #3a81c3;">)</span>:
        <span style="color: #3a81c3; font-weight: bold;">return</span>

    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Downloading "</span> + file_name + <span style="color: #2d9574;">" ... "</span><span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">headers</span> = <span style="color: #3a81c3;">{</span>
        <span style="color: #2d9574;">"User-Agent"</span>: <span style="color: #2d9574;">"Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:47.0) Gecko/20100101 Firefox/47.0"</span>
    <span style="color: #3a81c3;">}</span>
    <span style="color: #715ab1;">request</span> = urllib.request.Request<span style="color: #3a81c3;">(</span>url_base + file_name, headers=headers<span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">response</span> = urllib.request.urlopen<span style="color: #3a81c3;">(</span>request<span style="color: #3a81c3;">)</span>.read<span style="color: #3a81c3;">()</span>
    <span style="color: #3a81c3; font-weight: bold;">with</span> <span style="color: #3a81c3;">open</span><span style="color: #3a81c3;">(</span>file_path, mode=<span style="color: #2d9574;">"wb"</span><span style="color: #3a81c3;">)</span> <span style="color: #3a81c3; font-weight: bold;">as</span> f:
        f.write<span style="color: #3a81c3;">(</span>response<span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Done"</span><span style="color: #3a81c3;">)</span>


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">download_mnist</span><span style="color: #3a81c3;">()</span>:
    <span style="color: #3a81c3; font-weight: bold;">for</span> v <span style="color: #3a81c3; font-weight: bold;">in</span> key_file.values<span style="color: #3a81c3;">()</span>:
        _download<span style="color: #3a81c3;">(</span>v<span style="color: #3a81c3;">)</span>


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">_load_label</span><span style="color: #3a81c3;">(</span>file_name<span style="color: #3a81c3;">)</span>:
    <span style="color: #715ab1;">file_path</span> = dataset_dir + <span style="color: #2d9574;">"/"</span> + file_name

    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Converting "</span> + file_name + <span style="color: #2d9574;">" to NumPy Array ..."</span><span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3; font-weight: bold;">with</span> gzip.<span style="color: #3a81c3;">open</span><span style="color: #3a81c3;">(</span>file_path, <span style="color: #2d9574;">"rb"</span><span style="color: #3a81c3;">)</span> <span style="color: #3a81c3; font-weight: bold;">as</span> f:
        <span style="color: #715ab1;">labels</span> = np.frombuffer<span style="color: #3a81c3;">(</span>f.read<span style="color: #6c3163;">()</span>, np.uint8, offset=8<span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Done"</span><span style="color: #3a81c3;">)</span>

    <span style="color: #3a81c3; font-weight: bold;">return</span> labels


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">_load_img</span><span style="color: #3a81c3;">(</span>file_name<span style="color: #3a81c3;">)</span>:
    <span style="color: #715ab1;">file_path</span> = dataset_dir + <span style="color: #2d9574;">"/"</span> + file_name

    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Converting "</span> + file_name + <span style="color: #2d9574;">" to NumPy Array ..."</span><span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3; font-weight: bold;">with</span> gzip.<span style="color: #3a81c3;">open</span><span style="color: #3a81c3;">(</span>file_path, <span style="color: #2d9574;">"rb"</span><span style="color: #3a81c3;">)</span> <span style="color: #3a81c3; font-weight: bold;">as</span> f:
        <span style="color: #715ab1;">data</span> = np.frombuffer<span style="color: #3a81c3;">(</span>f.read<span style="color: #6c3163;">()</span>, np.uint8, offset=16<span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">data</span> = data.reshape<span style="color: #3a81c3;">(</span>-1, img_size<span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Done"</span><span style="color: #3a81c3;">)</span>

    <span style="color: #3a81c3; font-weight: bold;">return</span> data


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">_convert_numpy</span><span style="color: #3a81c3;">()</span>:
    <span style="color: #715ab1;">dataset</span> = <span style="color: #3a81c3;">{}</span>
    <span style="color: #715ab1;">dataset</span><span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"train_img"</span><span style="color: #3a81c3;">]</span> = _load_img<span style="color: #3a81c3;">(</span>key_file<span style="color: #6c3163;">[</span><span style="color: #2d9574;">"train_img"</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">dataset</span><span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"train_label"</span><span style="color: #3a81c3;">]</span> = _load_label<span style="color: #3a81c3;">(</span>key_file<span style="color: #6c3163;">[</span><span style="color: #2d9574;">"train_label"</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">dataset</span><span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"test_img"</span><span style="color: #3a81c3;">]</span> = _load_img<span style="color: #3a81c3;">(</span>key_file<span style="color: #6c3163;">[</span><span style="color: #2d9574;">"test_img"</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">dataset</span><span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"test_label"</span><span style="color: #3a81c3;">]</span> = _load_label<span style="color: #3a81c3;">(</span>key_file<span style="color: #6c3163;">[</span><span style="color: #2d9574;">"test_label"</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>

    <span style="color: #3a81c3; font-weight: bold;">return</span> dataset


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">init_mnist</span><span style="color: #3a81c3;">()</span>:
    download_mnist<span style="color: #3a81c3;">()</span>
    <span style="color: #715ab1;">dataset</span> = _convert_numpy<span style="color: #3a81c3;">()</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Creating pickle file ..."</span><span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3; font-weight: bold;">with</span> <span style="color: #3a81c3;">open</span><span style="color: #3a81c3;">(</span>save_file, <span style="color: #2d9574;">"wb"</span><span style="color: #3a81c3;">)</span> <span style="color: #3a81c3; font-weight: bold;">as</span> f:
        pickle.dump<span style="color: #3a81c3;">(</span>dataset, f, -1<span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Done!"</span><span style="color: #3a81c3;">)</span>


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">_change_one_hot_label</span><span style="color: #3a81c3;">(</span>X<span style="color: #3a81c3;">)</span>:
    <span style="color: #715ab1;">T</span> = np.zeros<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">(</span>X.size, 10<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3; font-weight: bold;">for</span> idx, row <span style="color: #3a81c3; font-weight: bold;">in</span> <span style="color: #3a81c3;">enumerate</span><span style="color: #3a81c3;">(</span>T<span style="color: #3a81c3;">)</span>:
        row<span style="color: #3a81c3;">[</span>X<span style="color: #6c3163;">[</span>idx<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">]</span> = 1

    <span style="color: #3a81c3; font-weight: bold;">return</span> T


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">load_mnist</span><span style="color: #3a81c3;">(</span>normalize=<span style="color: #4e3163;">True</span>, flatten=<span style="color: #4e3163;">True</span>, one_hot_label=<span style="color: #4e3163;">False</span><span style="color: #3a81c3;">)</span>:
    <span style="color: #3a81c3; font-weight: bold;">if</span> <span style="color: #3a81c3; font-weight: bold;">not</span> os.path.exists<span style="color: #3a81c3;">(</span>save_file<span style="color: #3a81c3;">)</span>:
        init_mnist<span style="color: #3a81c3;">()</span>

    <span style="color: #3a81c3; font-weight: bold;">with</span> <span style="color: #3a81c3;">open</span><span style="color: #3a81c3;">(</span>save_file, <span style="color: #2d9574;">"rb"</span><span style="color: #3a81c3;">)</span> <span style="color: #3a81c3; font-weight: bold;">as</span> f:
        <span style="color: #715ab1;">dataset</span> = pickle.load<span style="color: #3a81c3;">(</span>f<span style="color: #3a81c3;">)</span>

    <span style="color: #3a81c3; font-weight: bold;">if</span> normalize:
        <span style="color: #3a81c3; font-weight: bold;">for</span> key <span style="color: #3a81c3; font-weight: bold;">in</span> <span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"train_img"</span>, <span style="color: #2d9574;">"test_img"</span><span style="color: #3a81c3;">)</span>:
            <span style="color: #715ab1;">dataset</span><span style="color: #3a81c3;">[</span>key<span style="color: #3a81c3;">]</span> = dataset<span style="color: #3a81c3;">[</span>key<span style="color: #3a81c3;">]</span>.astype<span style="color: #3a81c3;">(</span>np.float32<span style="color: #3a81c3;">)</span>
            <span style="color: #715ab1;">dataset</span><span style="color: #3a81c3;">[</span>key<span style="color: #3a81c3;">]</span> /= 255.0

    <span style="color: #3a81c3; font-weight: bold;">if</span> one_hot_label:
        <span style="color: #715ab1;">dataset</span><span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"train_label"</span><span style="color: #3a81c3;">]</span> = _change_one_hot_label<span style="color: #3a81c3;">(</span>dataset<span style="color: #6c3163;">[</span><span style="color: #2d9574;">"train_label"</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
        <span style="color: #715ab1;">dataset</span><span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"test_label"</span><span style="color: #3a81c3;">]</span> = _change_one_hot_label<span style="color: #3a81c3;">(</span>dataset<span style="color: #6c3163;">[</span><span style="color: #2d9574;">"test_label"</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>

    <span style="color: #3a81c3; font-weight: bold;">if</span> <span style="color: #3a81c3; font-weight: bold;">not</span> flatten:
        <span style="color: #3a81c3; font-weight: bold;">for</span> key <span style="color: #3a81c3; font-weight: bold;">in</span> <span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"train_img"</span>, <span style="color: #2d9574;">"test_img"</span><span style="color: #3a81c3;">)</span>:
            <span style="color: #715ab1;">dataset</span><span style="color: #3a81c3;">[</span>key<span style="color: #3a81c3;">]</span> = dataset<span style="color: #3a81c3;">[</span>key<span style="color: #3a81c3;">]</span>.reshape<span style="color: #3a81c3;">(</span>-1, 1, 28, 28<span style="color: #3a81c3;">)</span>

    <span style="color: #3a81c3; font-weight: bold;">return</span> <span style="color: #3a81c3;">(</span>dataset<span style="color: #6c3163;">[</span><span style="color: #2d9574;">"train_img"</span><span style="color: #6c3163;">]</span>, dataset<span style="color: #6c3163;">[</span><span style="color: #2d9574;">"train_label"</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>, <span style="color: #3a81c3;">(</span>
        dataset<span style="color: #6c3163;">[</span><span style="color: #2d9574;">"test_img"</span><span style="color: #6c3163;">]</span>,
        dataset<span style="color: #6c3163;">[</span><span style="color: #2d9574;">"test_label"</span><span style="color: #6c3163;">]</span>,
    <span style="color: #3a81c3;">)</span>


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">sigmoid</span><span style="color: #3a81c3;">(</span>x<span style="color: #3a81c3;">)</span>:
    <span style="color: #3a81c3; font-weight: bold;">return</span> 1 / <span style="color: #3a81c3;">(</span>1 + np.exp<span style="color: #6c3163;">(</span>-x<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">softmax</span><span style="color: #3a81c3;">(</span>x<span style="color: #3a81c3;">)</span>:
    <span style="color: #715ab1;">x</span> = x - np.<span style="color: #3a81c3;">max</span><span style="color: #3a81c3;">(</span>x, axis=-1, keepdims=<span style="color: #4e3163;">True</span><span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3; font-weight: bold;">return</span> np.exp<span style="color: #3a81c3;">(</span>x<span style="color: #3a81c3;">)</span> / np.<span style="color: #3a81c3;">sum</span><span style="color: #3a81c3;">(</span>np.exp<span style="color: #6c3163;">(</span>x<span style="color: #6c3163;">)</span>, axis=-1, keepdims=<span style="color: #4e3163;">True</span><span style="color: #3a81c3;">)</span>


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">get_data</span><span style="color: #3a81c3;">()</span>:
    <span style="color: #3a81c3;">(</span>x_train, t_train<span style="color: #3a81c3;">)</span>, <span style="color: #3a81c3;">(</span><span style="color: #715ab1;">x_test</span>, <span style="color: #715ab1;">t_test</span><span style="color: #3a81c3;">)</span> = load_mnist<span style="color: #3a81c3;">(</span>
        normalize=<span style="color: #4e3163;">True</span>, flatten=<span style="color: #4e3163;">True</span>, one_hot_label=<span style="color: #4e3163;">False</span>
    <span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3; font-weight: bold;">return</span> x_test, t_test


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">init_network</span><span style="color: #3a81c3;">()</span>:
    <span style="color: #3a81c3; font-weight: bold;">with</span> <span style="color: #3a81c3;">open</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"sample_weight.pkl"</span>, <span style="color: #2d9574;">"rb"</span><span style="color: #3a81c3;">)</span> <span style="color: #3a81c3; font-weight: bold;">as</span> f:
        <span style="color: #715ab1;">network</span> = pickle.load<span style="color: #3a81c3;">(</span>f<span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3; font-weight: bold;">return</span> network


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">predict</span><span style="color: #3a81c3;">(</span>network, x<span style="color: #3a81c3;">)</span>:
    <span style="color: #715ab1;">W1</span>, <span style="color: #715ab1;">W2</span>, <span style="color: #715ab1;">W3</span> = network<span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"W1"</span><span style="color: #3a81c3;">]</span>, network<span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"W2"</span><span style="color: #3a81c3;">]</span>, network<span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"W3"</span><span style="color: #3a81c3;">]</span>
    <span style="color: #715ab1;">b1</span>, <span style="color: #715ab1;">b2</span>, <span style="color: #715ab1;">b3</span> = network<span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"b1"</span><span style="color: #3a81c3;">]</span>, network<span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"b2"</span><span style="color: #3a81c3;">]</span>, network<span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"b3"</span><span style="color: #3a81c3;">]</span>

    <span style="color: #715ab1;">a1</span> = np.dot<span style="color: #3a81c3;">(</span>x, W1<span style="color: #3a81c3;">)</span> + b1
    <span style="color: #715ab1;">z1</span> = sigmoid<span style="color: #3a81c3;">(</span>a1<span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">a2</span> = np.dot<span style="color: #3a81c3;">(</span>z1, W2<span style="color: #3a81c3;">)</span> + b2
    <span style="color: #715ab1;">z2</span> = sigmoid<span style="color: #3a81c3;">(</span>a2<span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">a3</span> = np.dot<span style="color: #3a81c3;">(</span>z2, W3<span style="color: #3a81c3;">)</span> + b3
    <span style="color: #715ab1;">y</span> = softmax<span style="color: #3a81c3;">(</span>a3<span style="color: #3a81c3;">)</span>

    <span style="color: #3a81c3; font-weight: bold;">return</span> y


<span style="color: #3a81c3; font-weight: bold;">if</span> <span style="color: #3a81c3;">__name__</span> == <span style="color: #2d9574;">"__main__"</span>:
    <span style="color: #715ab1;">x</span>, <span style="color: #715ab1;">t</span> = get_data<span style="color: #3a81c3;">()</span>
    <span style="color: #715ab1;">network</span> = init_network<span style="color: #3a81c3;">()</span>
    <span style="color: #715ab1;">accuracy_cnt</span> = 0
    <span style="color: #3a81c3; font-weight: bold;">for</span> i <span style="color: #3a81c3; font-weight: bold;">in</span> <span style="color: #3a81c3;">range</span><span style="color: #3a81c3;">(</span><span style="color: #3a81c3;">len</span><span style="color: #6c3163;">(</span>x<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>:
        <span style="color: #715ab1;">y</span> = predict<span style="color: #3a81c3;">(</span>network, x<span style="color: #6c3163;">[</span>i<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
        <span style="color: #715ab1;">p</span> = np.argmax<span style="color: #3a81c3;">(</span>y<span style="color: #3a81c3;">)</span>
        <span style="color: #3a81c3; font-weight: bold;">if</span> p == t<span style="color: #3a81c3;">[</span>i<span style="color: #3a81c3;">]</span>:
            <span style="color: #715ab1;">accuracy_cnt</span> += 1

    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Accuracy:"</span> + <span style="color: #3a81c3;">str</span><span style="color: #6c3163;">(</span><span style="color: #3a81c3;">float</span><span style="color: #2d9574;">(</span>accuracy_cnt<span style="color: #2d9574;">)</span> / <span style="color: #3a81c3;">len</span><span style="color: #2d9574;">(</span>x<span style="color: #2d9574;">)</span><span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Accuracy:0.9352</span>
</pre>
</div></li>
<li><p>
"推理"一个图像属于哪个数字的代码如下(输入是一个长度为784的数组,输出是一个长度为10的数组,表明图像是0-9的概率)
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">get_data</span><span style="color: #3a81c3;">()</span>:
    <span style="color: #3a81c3;">(</span>x_train, t_train<span style="color: #3a81c3;">)</span>, <span style="color: #3a81c3;">(</span><span style="color: #715ab1;">x_test</span>, <span style="color: #715ab1;">t_test</span><span style="color: #3a81c3;">)</span> = load_mnist<span style="color: #3a81c3;">(</span>
        normalize=<span style="color: #4e3163;">True</span>, flatten=<span style="color: #4e3163;">True</span>, one_hot_label=<span style="color: #4e3163;">False</span>
    <span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3; font-weight: bold;">return</span> x_test, t_test


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">init_network</span><span style="color: #3a81c3;">()</span>:
    <span style="color: #3a81c3; font-weight: bold;">with</span> <span style="color: #3a81c3;">open</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"sample_weight.pkl"</span>, <span style="color: #2d9574;">"rb"</span><span style="color: #3a81c3;">)</span> <span style="color: #3a81c3; font-weight: bold;">as</span> f:
        <span style="color: #715ab1;">network</span> = pickle.load<span style="color: #3a81c3;">(</span>f<span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3; font-weight: bold;">return</span> network


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">predict</span><span style="color: #3a81c3;">(</span>network, x<span style="color: #3a81c3;">)</span>:
    <span style="color: #715ab1;">W1</span>, <span style="color: #715ab1;">W2</span>, <span style="color: #715ab1;">W3</span> = network<span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"W1"</span><span style="color: #3a81c3;">]</span>, network<span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"W2"</span><span style="color: #3a81c3;">]</span>, network<span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"W3"</span><span style="color: #3a81c3;">]</span>
    <span style="color: #715ab1;">b1</span>, <span style="color: #715ab1;">b2</span>, <span style="color: #715ab1;">b3</span> = network<span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"b1"</span><span style="color: #3a81c3;">]</span>, network<span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"b2"</span><span style="color: #3a81c3;">]</span>, network<span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"b3"</span><span style="color: #3a81c3;">]</span>

    <span style="color: #715ab1;">a1</span> = np.dot<span style="color: #3a81c3;">(</span>x, W1<span style="color: #3a81c3;">)</span> + b1
    <span style="color: #715ab1;">z1</span> = sigmoid<span style="color: #3a81c3;">(</span>a1<span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">a2</span> = np.dot<span style="color: #3a81c3;">(</span>z1, W2<span style="color: #3a81c3;">)</span> + b2
    <span style="color: #715ab1;">z2</span> = sigmoid<span style="color: #3a81c3;">(</span>a2<span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">a3</span> = np.dot<span style="color: #3a81c3;">(</span>z2, W3<span style="color: #3a81c3;">)</span> + b3
    <span style="color: #715ab1;">y</span> = softmax<span style="color: #3a81c3;">(</span>a3<span style="color: #3a81c3;">)</span>

    <span style="color: #3a81c3; font-weight: bold;">return</span> y
</pre>
</div></li>
<li><p>
"参数"并不是我们训练的,我们只是用这个"参数"来进行"推理",判定这个"参数"好不好的标志,就是看看这个
参数判断100个(没见过的)图像能判断对几个.首先获取"没见过的图像"
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">get_data</span><span style="color: #3a81c3;">()</span>:
    <span style="color: #3a81c3;">(</span>x_train, t_train<span style="color: #3a81c3;">)</span>, <span style="color: #3a81c3;">(</span><span style="color: #715ab1;">x_test</span>, <span style="color: #715ab1;">t_test</span><span style="color: #3a81c3;">)</span> = load_mnist<span style="color: #3a81c3;">(</span>
        normalize=<span style="color: #4e3163;">True</span>, flatten=<span style="color: #4e3163;">True</span>, one_hot_label=<span style="color: #4e3163;">False</span>
    <span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3; font-weight: bold;">return</span> x_test, t_test
</pre>
</div></li>
<li><p>
然后我们在main函数里面就是判定"参数"能够在"没见过"的图像里面,正确的认识几个:通过 np.argmax(y) 获
取到概率最大的数字,并且和标签t[i]进行比较,相等算"推理"成功一个
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #3a81c3; font-weight: bold;">if</span> <span style="color: #3a81c3;">__name__</span> == <span style="color: #2d9574;">"__main__"</span>:
    <span style="color: #715ab1;">x</span>, <span style="color: #715ab1;">t</span> = get_data<span style="color: #3a81c3;">()</span>
    <span style="color: #715ab1;">network</span> = init_network<span style="color: #3a81c3;">()</span>
    <span style="color: #715ab1;">accuracy_cnt</span> = 0
    <span style="color: #3a81c3; font-weight: bold;">for</span> i <span style="color: #3a81c3; font-weight: bold;">in</span> <span style="color: #3a81c3;">range</span><span style="color: #3a81c3;">(</span><span style="color: #3a81c3;">len</span><span style="color: #6c3163;">(</span>x<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>:
        <span style="color: #715ab1;">y</span> = predict<span style="color: #3a81c3;">(</span>network, x<span style="color: #6c3163;">[</span>i<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
        <span style="color: #715ab1;">p</span> = np.argmax<span style="color: #3a81c3;">(</span>y<span style="color: #3a81c3;">)</span>
        <span style="color: #3a81c3; font-weight: bold;">if</span> p == t<span style="color: #3a81c3;">[</span>i<span style="color: #3a81c3;">]</span>:
            <span style="color: #715ab1;">accuracy_cnt</span> += 1

    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Accuracy:"</span> + <span style="color: #3a81c3;">str</span><span style="color: #6c3163;">(</span><span style="color: #3a81c3;">float</span><span style="color: #2d9574;">(</span>accuracy_cnt<span style="color: #2d9574;">)</span> / <span style="color: #3a81c3;">len</span><span style="color: #2d9574;">(</span>x<span style="color: #2d9574;">)</span><span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Accuracy:0.9352</span>
</pre>
</div></li>
<li><p>
还有一点,我们在load_mnist的时候把normalize设置成了True,这就意味着数组的784个成员,每个都是0-1.0,
像这样吧数据限定到某个范围内的处理称之为正规化(normalization),正规化能够提高深度学习模型的性能
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #3a81c3;">(</span>x_train, t_train<span style="color: #3a81c3;">)</span>, <span style="color: #3a81c3;">(</span><span style="color: #715ab1;">x_test</span>, <span style="color: #715ab1;">t_test</span><span style="color: #3a81c3;">)</span> = load_mnist<span style="color: #3a81c3;">(</span>
    normalize=<span style="color: #4e3163;">True</span>, flatten=<span style="color: #4e3163;">True</span>, one_hot_label=<span style="color: #4e3163;">False</span>
<span style="color: #3a81c3;">)</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org60f9763" class="outline-4">
<h4 id="org60f9763"><span class="section-number-4">3.6.3.</span> 批处理</h4>
<div class="outline-text-4" id="text-3-6-3">
<ul class="org-ul">
<li>上述是一次性处理一个image的情况,最终的输出是一个一维数组,长度是10,分别代表image为0-9的概率
<ul class="org-ul">
<li><p>
一次性处理一个image的参数列表如下
</p>

<div id="org6c49dbe" class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/image/master/dlfs/3-26.png" alt="3-26.png" />
</p>
<p><span class="figure-number">Figure 35: </span>dlfs/3-26.png</p>
</div></li>
<li>我们可以看到,我们的输入参数可以理解为1*784,输出是1*10</li>
<li><p>
那么如果我们每次传入100张图片呢?其实就是输入变成了100*784,我们的"参数"完全不用更改,最后的结果也
变了,变成了100*10,如下图
</p>

<div id="org09508b5" class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/image/master/dlfs/3-27.png" alt="3-27.png" />
</p>
<p><span class="figure-number">Figure 36: </span>dlfs/3-27.png</p>
</div></li>
<li>输入变成一百个,输出也相应变成100个,这得益于矩阵的特性.这种打包式的输入称之为批(batch)</li>
</ul></li>
<li>批处理只会更改部分代码
<ul class="org-ul">
<li><p>
总体代码如下
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #3a81c3; font-weight: bold;">import</span> urllib.request
<span style="color: #3a81c3; font-weight: bold;">import</span> gzip
<span style="color: #3a81c3; font-weight: bold;">import</span> numpy <span style="color: #3a81c3; font-weight: bold;">as</span> np
<span style="color: #3a81c3; font-weight: bold;">import</span> os
<span style="color: #3a81c3; font-weight: bold;">import</span> pickle

<span style="color: #715ab1;">url_base</span> = <span style="color: #2d9574;">"http://yann.lecun.com/exdb/mnist/"</span>
<span style="color: #715ab1;">key_file</span> = <span style="color: #3a81c3;">{</span>
    <span style="color: #2d9574;">"train_img"</span>: <span style="color: #2d9574;">"train-images-idx3-ubyte.gz"</span>,
    <span style="color: #2d9574;">"train_label"</span>: <span style="color: #2d9574;">"train-labels-idx1-ubyte.gz"</span>,
    <span style="color: #2d9574;">"test_img"</span>: <span style="color: #2d9574;">"t10k-images-idx3-ubyte.gz"</span>,
    <span style="color: #2d9574;">"test_label"</span>: <span style="color: #2d9574;">"t10k-labels-idx1-ubyte.gz"</span>,
<span style="color: #3a81c3;">}</span>

<span style="color: #715ab1;">dataset_dir</span> = os.path.dirname<span style="color: #3a81c3;">(</span>os.path.abspath<span style="color: #6c3163;">(</span>__file__<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
<span style="color: #715ab1;">save_file</span> = dataset_dir + <span style="color: #2d9574;">"/mnist.pkl"</span>

<span style="color: #715ab1;">train_num</span> = 60000
<span style="color: #715ab1;">test_num</span> = 10000
<span style="color: #715ab1;">img_dim</span> = <span style="color: #3a81c3;">(</span>1, 28, 28<span style="color: #3a81c3;">)</span>
<span style="color: #715ab1;">img_size</span> = 784


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">_download</span><span style="color: #3a81c3;">(</span>file_name<span style="color: #3a81c3;">)</span>:
    <span style="color: #715ab1;">file_path</span> = dataset_dir + <span style="color: #2d9574;">"/"</span> + file_name

    <span style="color: #3a81c3; font-weight: bold;">if</span> os.path.exists<span style="color: #3a81c3;">(</span>file_path<span style="color: #3a81c3;">)</span>:
        <span style="color: #3a81c3; font-weight: bold;">return</span>

    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Downloading "</span> + file_name + <span style="color: #2d9574;">" ... "</span><span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">headers</span> = <span style="color: #3a81c3;">{</span>
        <span style="color: #2d9574;">"User-Agent"</span>: <span style="color: #2d9574;">"Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:47.0) Gecko/20100101 Firefox/47.0"</span>
    <span style="color: #3a81c3;">}</span>
    <span style="color: #715ab1;">request</span> = urllib.request.Request<span style="color: #3a81c3;">(</span>url_base + file_name, headers=headers<span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">response</span> = urllib.request.urlopen<span style="color: #3a81c3;">(</span>request<span style="color: #3a81c3;">)</span>.read<span style="color: #3a81c3;">()</span>
    <span style="color: #3a81c3; font-weight: bold;">with</span> <span style="color: #3a81c3;">open</span><span style="color: #3a81c3;">(</span>file_path, mode=<span style="color: #2d9574;">"wb"</span><span style="color: #3a81c3;">)</span> <span style="color: #3a81c3; font-weight: bold;">as</span> f:
        f.write<span style="color: #3a81c3;">(</span>response<span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Done"</span><span style="color: #3a81c3;">)</span>


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">download_mnist</span><span style="color: #3a81c3;">()</span>:
    <span style="color: #3a81c3; font-weight: bold;">for</span> v <span style="color: #3a81c3; font-weight: bold;">in</span> key_file.values<span style="color: #3a81c3;">()</span>:
        _download<span style="color: #3a81c3;">(</span>v<span style="color: #3a81c3;">)</span>


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">_load_label</span><span style="color: #3a81c3;">(</span>file_name<span style="color: #3a81c3;">)</span>:
    <span style="color: #715ab1;">file_path</span> = dataset_dir + <span style="color: #2d9574;">"/"</span> + file_name

    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Converting "</span> + file_name + <span style="color: #2d9574;">" to NumPy Array ..."</span><span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3; font-weight: bold;">with</span> gzip.<span style="color: #3a81c3;">open</span><span style="color: #3a81c3;">(</span>file_path, <span style="color: #2d9574;">"rb"</span><span style="color: #3a81c3;">)</span> <span style="color: #3a81c3; font-weight: bold;">as</span> f:
        <span style="color: #715ab1;">labels</span> = np.frombuffer<span style="color: #3a81c3;">(</span>f.read<span style="color: #6c3163;">()</span>, np.uint8, offset=8<span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Done"</span><span style="color: #3a81c3;">)</span>

    <span style="color: #3a81c3; font-weight: bold;">return</span> labels


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">_load_img</span><span style="color: #3a81c3;">(</span>file_name<span style="color: #3a81c3;">)</span>:
    <span style="color: #715ab1;">file_path</span> = dataset_dir + <span style="color: #2d9574;">"/"</span> + file_name

    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Converting "</span> + file_name + <span style="color: #2d9574;">" to NumPy Array ..."</span><span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3; font-weight: bold;">with</span> gzip.<span style="color: #3a81c3;">open</span><span style="color: #3a81c3;">(</span>file_path, <span style="color: #2d9574;">"rb"</span><span style="color: #3a81c3;">)</span> <span style="color: #3a81c3; font-weight: bold;">as</span> f:
        <span style="color: #715ab1;">data</span> = np.frombuffer<span style="color: #3a81c3;">(</span>f.read<span style="color: #6c3163;">()</span>, np.uint8, offset=16<span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">data</span> = data.reshape<span style="color: #3a81c3;">(</span>-1, img_size<span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Done"</span><span style="color: #3a81c3;">)</span>

    <span style="color: #3a81c3; font-weight: bold;">return</span> data


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">_convert_numpy</span><span style="color: #3a81c3;">()</span>:
    <span style="color: #715ab1;">dataset</span> = <span style="color: #3a81c3;">{}</span>
    <span style="color: #715ab1;">dataset</span><span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"train_img"</span><span style="color: #3a81c3;">]</span> = _load_img<span style="color: #3a81c3;">(</span>key_file<span style="color: #6c3163;">[</span><span style="color: #2d9574;">"train_img"</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">dataset</span><span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"train_label"</span><span style="color: #3a81c3;">]</span> = _load_label<span style="color: #3a81c3;">(</span>key_file<span style="color: #6c3163;">[</span><span style="color: #2d9574;">"train_label"</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">dataset</span><span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"test_img"</span><span style="color: #3a81c3;">]</span> = _load_img<span style="color: #3a81c3;">(</span>key_file<span style="color: #6c3163;">[</span><span style="color: #2d9574;">"test_img"</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">dataset</span><span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"test_label"</span><span style="color: #3a81c3;">]</span> = _load_label<span style="color: #3a81c3;">(</span>key_file<span style="color: #6c3163;">[</span><span style="color: #2d9574;">"test_label"</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>

    <span style="color: #3a81c3; font-weight: bold;">return</span> dataset


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">init_mnist</span><span style="color: #3a81c3;">()</span>:
    download_mnist<span style="color: #3a81c3;">()</span>
    <span style="color: #715ab1;">dataset</span> = _convert_numpy<span style="color: #3a81c3;">()</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Creating pickle file ..."</span><span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3; font-weight: bold;">with</span> <span style="color: #3a81c3;">open</span><span style="color: #3a81c3;">(</span>save_file, <span style="color: #2d9574;">"wb"</span><span style="color: #3a81c3;">)</span> <span style="color: #3a81c3; font-weight: bold;">as</span> f:
        pickle.dump<span style="color: #3a81c3;">(</span>dataset, f, -1<span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Done!"</span><span style="color: #3a81c3;">)</span>


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">_change_one_hot_label</span><span style="color: #3a81c3;">(</span>X<span style="color: #3a81c3;">)</span>:
    <span style="color: #715ab1;">T</span> = np.zeros<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">(</span>X.size, 10<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3; font-weight: bold;">for</span> idx, row <span style="color: #3a81c3; font-weight: bold;">in</span> <span style="color: #3a81c3;">enumerate</span><span style="color: #3a81c3;">(</span>T<span style="color: #3a81c3;">)</span>:
        row<span style="color: #3a81c3;">[</span>X<span style="color: #6c3163;">[</span>idx<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">]</span> = 1

    <span style="color: #3a81c3; font-weight: bold;">return</span> T


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">load_mnist</span><span style="color: #3a81c3;">(</span>normalize=<span style="color: #4e3163;">True</span>, flatten=<span style="color: #4e3163;">True</span>, one_hot_label=<span style="color: #4e3163;">False</span><span style="color: #3a81c3;">)</span>:
    <span style="color: #3a81c3; font-weight: bold;">if</span> <span style="color: #3a81c3; font-weight: bold;">not</span> os.path.exists<span style="color: #3a81c3;">(</span>save_file<span style="color: #3a81c3;">)</span>:
        init_mnist<span style="color: #3a81c3;">()</span>

    <span style="color: #3a81c3; font-weight: bold;">with</span> <span style="color: #3a81c3;">open</span><span style="color: #3a81c3;">(</span>save_file, <span style="color: #2d9574;">"rb"</span><span style="color: #3a81c3;">)</span> <span style="color: #3a81c3; font-weight: bold;">as</span> f:
        <span style="color: #715ab1;">dataset</span> = pickle.load<span style="color: #3a81c3;">(</span>f<span style="color: #3a81c3;">)</span>

    <span style="color: #3a81c3; font-weight: bold;">if</span> normalize:
        <span style="color: #3a81c3; font-weight: bold;">for</span> key <span style="color: #3a81c3; font-weight: bold;">in</span> <span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"train_img"</span>, <span style="color: #2d9574;">"test_img"</span><span style="color: #3a81c3;">)</span>:
            <span style="color: #715ab1;">dataset</span><span style="color: #3a81c3;">[</span>key<span style="color: #3a81c3;">]</span> = dataset<span style="color: #3a81c3;">[</span>key<span style="color: #3a81c3;">]</span>.astype<span style="color: #3a81c3;">(</span>np.float32<span style="color: #3a81c3;">)</span>
            <span style="color: #715ab1;">dataset</span><span style="color: #3a81c3;">[</span>key<span style="color: #3a81c3;">]</span> /= 255.0

    <span style="color: #3a81c3; font-weight: bold;">if</span> one_hot_label:
        <span style="color: #715ab1;">dataset</span><span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"train_label"</span><span style="color: #3a81c3;">]</span> = _change_one_hot_label<span style="color: #3a81c3;">(</span>dataset<span style="color: #6c3163;">[</span><span style="color: #2d9574;">"train_label"</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
        <span style="color: #715ab1;">dataset</span><span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"test_label"</span><span style="color: #3a81c3;">]</span> = _change_one_hot_label<span style="color: #3a81c3;">(</span>dataset<span style="color: #6c3163;">[</span><span style="color: #2d9574;">"test_label"</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>

    <span style="color: #3a81c3; font-weight: bold;">if</span> <span style="color: #3a81c3; font-weight: bold;">not</span> flatten:
        <span style="color: #3a81c3; font-weight: bold;">for</span> key <span style="color: #3a81c3; font-weight: bold;">in</span> <span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"train_img"</span>, <span style="color: #2d9574;">"test_img"</span><span style="color: #3a81c3;">)</span>:
            <span style="color: #715ab1;">dataset</span><span style="color: #3a81c3;">[</span>key<span style="color: #3a81c3;">]</span> = dataset<span style="color: #3a81c3;">[</span>key<span style="color: #3a81c3;">]</span>.reshape<span style="color: #3a81c3;">(</span>-1, 1, 28, 28<span style="color: #3a81c3;">)</span>

    <span style="color: #3a81c3; font-weight: bold;">return</span> <span style="color: #3a81c3;">(</span>dataset<span style="color: #6c3163;">[</span><span style="color: #2d9574;">"train_img"</span><span style="color: #6c3163;">]</span>, dataset<span style="color: #6c3163;">[</span><span style="color: #2d9574;">"train_label"</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>, <span style="color: #3a81c3;">(</span>
        dataset<span style="color: #6c3163;">[</span><span style="color: #2d9574;">"test_img"</span><span style="color: #6c3163;">]</span>,
        dataset<span style="color: #6c3163;">[</span><span style="color: #2d9574;">"test_label"</span><span style="color: #6c3163;">]</span>,
    <span style="color: #3a81c3;">)</span>


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">sigmoid</span><span style="color: #3a81c3;">(</span>x<span style="color: #3a81c3;">)</span>:
    <span style="color: #3a81c3; font-weight: bold;">return</span> 1 / <span style="color: #3a81c3;">(</span>1 + np.exp<span style="color: #6c3163;">(</span>-x<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">softmax</span><span style="color: #3a81c3;">(</span>x<span style="color: #3a81c3;">)</span>:
    <span style="color: #715ab1;">x</span> = x - np.<span style="color: #3a81c3;">max</span><span style="color: #3a81c3;">(</span>x, axis=-1, keepdims=<span style="color: #4e3163;">True</span><span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3; font-weight: bold;">return</span> np.exp<span style="color: #3a81c3;">(</span>x<span style="color: #3a81c3;">)</span> / np.<span style="color: #3a81c3;">sum</span><span style="color: #3a81c3;">(</span>np.exp<span style="color: #6c3163;">(</span>x<span style="color: #6c3163;">)</span>, axis=-1, keepdims=<span style="color: #4e3163;">True</span><span style="color: #3a81c3;">)</span>


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">get_data</span><span style="color: #3a81c3;">()</span>:
    <span style="color: #3a81c3;">(</span>x_train, t_train<span style="color: #3a81c3;">)</span>, <span style="color: #3a81c3;">(</span><span style="color: #715ab1;">x_test</span>, <span style="color: #715ab1;">t_test</span><span style="color: #3a81c3;">)</span> = load_mnist<span style="color: #3a81c3;">(</span>
        normalize=<span style="color: #4e3163;">True</span>, flatten=<span style="color: #4e3163;">True</span>, one_hot_label=<span style="color: #4e3163;">False</span>
    <span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3; font-weight: bold;">return</span> x_test, t_test


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">init_network</span><span style="color: #3a81c3;">()</span>:
    <span style="color: #3a81c3; font-weight: bold;">with</span> <span style="color: #3a81c3;">open</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"sample_weight.pkl"</span>, <span style="color: #2d9574;">"rb"</span><span style="color: #3a81c3;">)</span> <span style="color: #3a81c3; font-weight: bold;">as</span> f:
        <span style="color: #715ab1;">network</span> = pickle.load<span style="color: #3a81c3;">(</span>f<span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3; font-weight: bold;">return</span> network


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">predict</span><span style="color: #3a81c3;">(</span>network, x<span style="color: #3a81c3;">)</span>:
    <span style="color: #715ab1;">W1</span>, <span style="color: #715ab1;">W2</span>, <span style="color: #715ab1;">W3</span> = network<span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"W1"</span><span style="color: #3a81c3;">]</span>, network<span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"W2"</span><span style="color: #3a81c3;">]</span>, network<span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"W3"</span><span style="color: #3a81c3;">]</span>
    <span style="color: #715ab1;">b1</span>, <span style="color: #715ab1;">b2</span>, <span style="color: #715ab1;">b3</span> = network<span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"b1"</span><span style="color: #3a81c3;">]</span>, network<span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"b2"</span><span style="color: #3a81c3;">]</span>, network<span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"b3"</span><span style="color: #3a81c3;">]</span>

    <span style="color: #715ab1;">a1</span> = np.dot<span style="color: #3a81c3;">(</span>x, W1<span style="color: #3a81c3;">)</span> + b1
    <span style="color: #715ab1;">z1</span> = sigmoid<span style="color: #3a81c3;">(</span>a1<span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">a2</span> = np.dot<span style="color: #3a81c3;">(</span>z1, W2<span style="color: #3a81c3;">)</span> + b2
    <span style="color: #715ab1;">z2</span> = sigmoid<span style="color: #3a81c3;">(</span>a2<span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">a3</span> = np.dot<span style="color: #3a81c3;">(</span>z2, W3<span style="color: #3a81c3;">)</span> + b3
    <span style="color: #715ab1;">y</span> = softmax<span style="color: #3a81c3;">(</span>a3<span style="color: #3a81c3;">)</span>

    <span style="color: #3a81c3; font-weight: bold;">return</span> y


<span style="color: #3a81c3; font-weight: bold;">if</span> <span style="color: #3a81c3;">__name__</span> == <span style="color: #2d9574;">"__main__"</span>:
    <span style="color: #715ab1;">x</span>, <span style="color: #715ab1;">t</span> = get_data<span style="color: #3a81c3;">()</span>
    <span style="color: #715ab1;">network</span> = init_network<span style="color: #3a81c3;">()</span>

    <span style="color: #715ab1;">batch_size</span> = 100
    <span style="color: #715ab1;">accuracy_cnt</span> = 0

    <span style="color: #3a81c3; font-weight: bold;">for</span> i <span style="color: #3a81c3; font-weight: bold;">in</span> <span style="color: #3a81c3;">range</span><span style="color: #3a81c3;">(</span>0, <span style="color: #3a81c3;">len</span><span style="color: #6c3163;">(</span>x<span style="color: #6c3163;">)</span>, batch_size<span style="color: #3a81c3;">)</span>:
        <span style="color: #715ab1;">x_batch</span> = x<span style="color: #3a81c3;">[</span>i : i + batch_size<span style="color: #3a81c3;">]</span>
        <span style="color: #715ab1;">y_batch</span> = predict<span style="color: #3a81c3;">(</span>network, x_batch<span style="color: #3a81c3;">)</span>
        <span style="color: #715ab1;">p</span> = np.argmax<span style="color: #3a81c3;">(</span>y_batch, axis=1<span style="color: #3a81c3;">)</span>
        <span style="color: #715ab1;">accuracy_cnt</span> += np.<span style="color: #3a81c3;">sum</span><span style="color: #3a81c3;">(</span>p == t<span style="color: #6c3163;">[</span>i : i + batch_size<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>

    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Accuracy:"</span> + <span style="color: #3a81c3;">str</span><span style="color: #6c3163;">(</span><span style="color: #3a81c3;">float</span><span style="color: #2d9574;">(</span>accuracy_cnt<span style="color: #2d9574;">)</span> / <span style="color: #3a81c3;">len</span><span style="color: #2d9574;">(</span>x<span style="color: #2d9574;">)</span><span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">#  </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Accuracy:0.9352</span>

</pre>
</div></li>
<li><p>
和之前代码不一样的地方如下
</p>
<div class="org-src-container">
<pre class="src src-diff"> if __name__ == "__main__":
     x, t = get_data()
     network = init_network()
<span style="color: #67b11d;">+</span>
<span style="color: #67b11d;">+</span><span style="color: #67b11d;">    batch_size = 100</span>
     accuracy_cnt = 0
<span style="color: #f2241f;">-</span><span style="color: #f2241f;">    for i in range(len(x)):</span>
<span style="color: #f2241f;">-</span><span style="color: #f2241f;">        y = predict(network, x[i])</span>
<span style="color: #f2241f;">-</span><span style="color: #f2241f;">        p = np.argmax(y)</span>
<span style="color: #f2241f;">-</span><span style="color: #f2241f;">        if p == t[i]:</span>
<span style="color: #f2241f;">-</span><span style="color: #f2241f;">            accuracy_cnt += 1</span>
<span style="color: #67b11d;">+</span>
<span style="color: #67b11d;">+</span><span style="color: #67b11d;">    for i in range(0, len(x), batch_size):</span>
<span style="color: #67b11d;">+</span><span style="color: #67b11d;">        x_batch = x[i : i + batch_size]</span>
<span style="color: #67b11d;">+</span><span style="color: #67b11d;">        y_batch = predict(network, x_batch)</span>
<span style="color: #67b11d;">+</span><span style="color: #67b11d;">        p = np.argmax(y_batch, axis=1)</span>
<span style="color: #67b11d;">+</span><span style="color: #67b11d;">        accuracy_cnt += np.sum(p == t[i : i + batch_size])</span>

     print("Accuracy:" + str(float(accuracy_cnt) / len(x)))
</pre>
</div></li>
<li><p>
其中的range()函数加了第三个参数是step,这样每次循环的开始位置会不一样
</p>
<div class="org-src-container">
<pre class="src src-shell"> &gt;&gt;&gt; list<span style="color: #3a81c3;">(</span>range<span style="color: #6c3163;">(</span>0, 10<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
<span style="color: #3a81c3;">[</span>0, 1, 2, 3, 4, 5, 6, 7, 8, 9<span style="color: #3a81c3;">]</span>
&gt;&gt;&gt; list<span style="color: #3a81c3;">(</span>range<span style="color: #6c3163;">(</span>0, 10, 3<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
<span style="color: #3a81c3;">[</span>0, 3, 6, 9<span style="color: #3a81c3;">]</span>
</pre>
</div></li>
<li><p>
agrmax()这里也多了一个参数axis=1,也就是要沿着第1维的方向找到最大index(也就是每个子数组的最大index)
</p>
<div class="org-src-container">
<pre class="src src-python">&gt;&gt;&gt; <span style="color: #3a81c3; font-weight: bold;">import</span> numpy <span style="color: #3a81c3; font-weight: bold;">as</span> np
&gt;&gt;&gt; x = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span><span style="color: #2d9574;">[</span>0.1, 0.8, 0.1<span style="color: #2d9574;">]</span>, <span style="color: #2d9574;">[</span>0.3, 0.1, 0.6<span style="color: #2d9574;">]</span>, <span style="color: #2d9574;">[</span>0.2, 0.5, 0.3<span style="color: #2d9574;">]</span>, <span style="color: #2d9574;">[</span>0.8, 0.1, 0.1<span style="color: #2d9574;">]</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; y = np.argmax<span style="color: #3a81c3;">(</span>x, axis=1<span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>y<span style="color: #3a81c3;">)</span>
<span style="color: #3a81c3;">[</span>1 2 1 0<span style="color: #3a81c3;">]</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-orgd0fcc3c" class="outline-2">
<h2 id="orgd0fcc3c"><span class="section-number-2">4.</span> 神经网络的学习</h2>
<div class="outline-text-2" id="text-4">
</div>
<div id="outline-container-orge76e1d6" class="outline-3">
<h3 id="orge76e1d6"><span class="section-number-3">4.1.</span> 从数据中学习</h3>
<div class="outline-text-3" id="text-4-1">
<ul class="org-ul">
<li>神经网络的特征就是可以从数据中学习.所谓"从数据中学习",是指可以由数据自动决定"参数"</li>
<li>如果由人来决定"参数"的话,是典型的statistical learning(也叫机器学习),而神经网络是让数据自己来决定参
数.比机器学习更"深",所以叫"深度学习"</li>
</ul>
</div>
<div id="outline-container-org6a1544c" class="outline-4">
<h4 id="org6a1544c"><span class="section-number-4">4.1.1.</span> 数据驱动</h4>
<div class="outline-text-4" id="text-4-1-1">
<ul class="org-ul">
<li>我们要解决的问题是识别图片:
<ul class="org-ul">
<li>对于人来说,我们可以简单的识别出5,但是却很难明确说出是基于何种规律而识别出了5</li>
<li>利用数据来解决这个问题的话,就会有两个思路:
<ol class="org-ol">
<li>机器学习</li>
<li>深度学习</li>
</ol></li>
</ul></li>
<li>机器学习和深度学习都是使用数据来让计算机判断图片,但是两者却有着很大的差别:
<ul class="org-ul">
<li><p>
如图
</p>

<div id="org346779d" class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/image/master/dlfs/4-2.png" alt="4-2.png" />
</p>
<p><span class="figure-number">Figure 37: </span>dlfs/4-2.png</p>
</div></li>
<li>白色部分是需要人参与的, 灰色的部分是计算机自动可以完成的</li>
<li>我们可以看到机器学习方法是介于"纯人工"和"纯自动化"之间的一种方法:虽然SVM,KNN等分类器可以自动学得
参数,但是这些分类器的"向量"确是需要通过经验来选取特点的方法(SIFT,HOG等)把image转换后获得</li>
<li>深度学习则是完全"自动化的",连重要的特征量也是有机器来学习的</li>
<li>神经网络的优点是对所有的问题都可以使用同样的流程来解决,比如不管要求求解的问题是识别5,还是识别狗,
神经网络都是通过不断地学习所提供的数据,尝试发现待求解问题的模式.换句话说,神经网络可以将数据直接
作为原始数据,进行"端对端"的学习,而与待处理的问题无关</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org0d40100" class="outline-4">
<h4 id="org0d40100"><span class="section-number-4">4.1.2.</span> 训练数据和测试数据</h4>
<div class="outline-text-4" id="text-4-1-2">
<ul class="org-ul">
<li>机器学习中,一般将数据分为如下两个部分:
<ul class="org-ul">
<li>训练数据:首先使用训练数据进行学习,寻找最优的"参数"</li>
<li>测试数据:然后使用测试数据评价"参数"的实际能力</li>
</ul></li>
<li>为什么要将数据分成训练数据和测试数据:
<ul class="org-ul">
<li>因为我们追求的是模型的泛化能力,只有划分中训练数据和测试数据,才能正确评价模型的泛化能力</li>
<li>所谓"泛化能力",是指处理未被观察过的数据(也就是训练时候没有见过的数据)的能力</li>
<li>训练数据页可以称之为监督数据(所谓监督,是在训练模型的时候才需要监督)</li>
<li>对某个数据集过度拟合的状态称之为过拟合(overfitting),避免过拟合也是机器学习的一个重要课题</li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org16eb716" class="outline-3">
<h3 id="org16eb716"><span class="section-number-3">4.2.</span> 损失函数</h3>
<div class="outline-text-3" id="text-4-2">
<ul class="org-ul">
<li>如果有人问你现在有多幸福
<ul class="org-ul">
<li>一般人可能回答"还可以吧", "很幸福"等笼统的回答</li>
<li>如果有人用数值来评判自己的幸福程度(比如"我现在的幸福指数是10.23"),那么可能会把人吓一跳,因为他用
数值来评价自己的幸福程度</li>
<li><p>
其实神经网络就是在做同样的事情:
</p>
<pre class="example" id="orgb91112b">
通过某个指标来表示当前的状态,然后,以这个指标为基准,寻找最优权重参数
</pre></li>
<li>神经网络的"某个指标",其实是一个损失函数(loss function), 通常使用如下两种函数:
<ol class="org-ol">
<li>均方误差</li>
<li>交叉熵误差</li>
</ol></li>
</ul></li>
<li>损失函数是表示神经网络性能的"恶劣程度"的指标,也就是说当前的神经网络对监督数据在多大程度上不拟合,在
多大程度上不一致(注意是监督数据,我们关于训练,所有的数据都是监督数据,没有测试数据什么事)</li>
<li>以"性能的恶劣程度"为指标可能让人感觉不自然,但是我们如果给损失函数乘以一个-1,那么就可以解释为"性能
的优秀程度",也就是"性能有多好"</li>
<li>损失函数可以使用任意函数,但一般使用均方误差和交叉熵误差等函数</li>
</ul>
</div>
<div id="outline-container-org8aea2b1" class="outline-4">
<h4 id="org8aea2b1"><span class="section-number-4">4.2.1.</span> 均方误差</h4>
<div class="outline-text-4" id="text-4-2-1">
<ul class="org-ul">
<li>损失函数中最有名的就是均方误差(mean sauared error)
<ul class="org-ul">
<li><p>
其公式如下
</p>
\begin{equation}
E = \frac{1}{2} \sum_{k} \left( y_{k} - t_{k} \right)^{2}
\end{equation}</li>
<li>\(y_k\) 表示神经网络的输出</li>
<li>\(t_k\) 表示监督数据</li>
<li>\(k\) 表示数据的维度</li>
</ul></li>
<li>比如,上一章最后的手写识别项目中:
<ul class="org-ul">
<li><p>
\(y_k\) 如下: 表示当前图像为0的概率是0.1, 为1的概率是0.05, 为2的概率是0.6,等等
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #715ab1;">y</span> = <span style="color: #3a81c3;">[</span>0.1, 0.05, 0.6, 0.0, 0.05, 0.1, 0.0, 0.1, 0.0, 0.0<span style="color: #3a81c3;">]</span>
</pre>
</div></li>
<li><p>
\(t_k\) 如下: 表示正确的结果应该是2(只有第2位是1, 这种将正确标签表示为1,其他为0的方法称之为one-hot表示)
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #715ab1;">t</span> = <span style="color: #3a81c3;">[</span>0, 0, 1, 0, 0, 0, 0, 0, 0, 0<span style="color: #3a81c3;">]</span>
</pre>
</div></li>
<li>\(k\) 就是10</li>
</ul></li>
<li>我们使用numpy能够非常容易的计算均方差
<ul class="org-ul">
<li><p>
代码如下
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">mean_squared_error</span><span style="color: #3a81c3;">(</span>y, t<span style="color: #3a81c3;">)</span>:
    <span style="color: #3a81c3; font-weight: bold;">return</span> 0.5 * np.<span style="color: #3a81c3;">sum</span><span style="color: #3a81c3;">(</span><span style="color: #6c3163;">(</span>y - t<span style="color: #6c3163;">)</span> ** 2<span style="color: #3a81c3;">)</span>
</pre>
</div></li>
<li><p>
我们的标签是不变的
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #715ab1;">t</span> = <span style="color: #3a81c3;">[</span>0, 0, 1, 0, 0, 0, 0, 0, 0, 0<span style="color: #3a81c3;">]</span>
</pre>
</div></li>
<li><p>
一个和标签比较吻合的结果("2"的概率最高的情况),得到的均方差值较小
</p>
<div class="org-src-container">
<pre class="src src-shell">&gt;&gt;&gt; y = <span style="color: #3a81c3;">[</span>0.1, 0.05, 0.6, 0.0, 0.05, 0.1, 0.0, 0.1, 0.0, 0.0<span style="color: #3a81c3;">]</span>
&gt;&gt;&gt; mean_squared_error<span style="color: #3a81c3;">(</span>np.array<span style="color: #6c3163;">(</span>y<span style="color: #6c3163;">)</span>, np.array<span style="color: #6c3163;">(</span>t<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
0.09750000000000003
</pre>
</div></li>
<li><p>
一个和标签不太吻合的结果("7"的概率最高的情况),得到的均方差值较大
</p>
<div class="org-src-container">
<pre class="src src-shell">&gt;&gt;&gt; y2 = <span style="color: #3a81c3;">[</span>0.1, 0.05, 0.1, 0.0, 0.05, 0.1, 0.0, 0.6, 0.0, 0.0<span style="color: #3a81c3;">]</span>
&gt;&gt;&gt; mean_squared_error<span style="color: #3a81c3;">(</span>np.array<span style="color: #6c3163;">(</span>y2<span style="color: #6c3163;">)</span>, np.array<span style="color: #6c3163;">(</span>t<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
0.5975
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org48c115f" class="outline-4">
<h4 id="org48c115f"><span class="section-number-4">4.2.2.</span> 交叉熵误差</h4>
<div class="outline-text-4" id="text-4-2-2">
<ul class="org-ul">
<li>除了均方误差外,交叉熵误差(cross entropy error)也经常被用作损失函数:
<ul class="org-ul">
<li><p>
其公式如下
</p>
\begin{equation}
E = - \sum_{k} t_{k} \log y_{k}, \tag{4.2}
\end{equation}</li>
<li>这里log表示以e为底的自然对数</li>
<li>\(y_k\) 是神经网络的输出</li>
<li>\(t_k\) 是正确解标签,其中只有正确解标签的索引为1,其他都是0(one-hot表示),所以上述式4-2实际上只计算
正确解标签的输出的自然对数</li>
<li><p>
举例,假设正确解标签的索引值是2(也就是图像其实是2,index2的 \(t_k\) 值为1, 其他全部都是0),index2对应的神经网络输出值 \(y_k\)
为0.6,则交叉熵误差是-log0.6=0.51
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #715ab1;">t</span> = <span style="color: #3a81c3;">[</span>0, 0, 1, 0, 0, 0, 0, 0, 0, 0<span style="color: #3a81c3;">]</span>
<span style="color: #715ab1;">y</span> = <span style="color: #3a81c3;">[</span>0.1, 0.05, 0.6, 0.0, 0.05, 0.1, 0.0, 0.1, 0.0, 0.0<span style="color: #3a81c3;">]</span>
</pre>
</div></li>
<li><p>
举例,假设正确解标签的索引值是2(也就是图像其实是2,index2的 \(t_k\) 值为1, 其他全部都是0),index2对应的神经网络输出值 \(y_k\)
为0.1,则交叉熵误差是-log0.1=2.30
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #715ab1;">t</span> = <span style="color: #3a81c3;">[</span>0, 0, 1, 0, 0, 0, 0, 0, 0, 0<span style="color: #3a81c3;">]</span>
<span style="color: #715ab1;">y2</span> = <span style="color: #3a81c3;">[</span>0.1, 0.05, 0.1, 0.0, 0.05, 0.1, 0.0, 0.6, 0.0, 0.0<span style="color: #3a81c3;">]</span>
</pre>
</div></li>
</ul></li>
<li>通过上面的例子我们很自然想到,如果正确的index值对应的概率越接近1,那么交叉熵误差就越接近0,效果也就是越好
<ul class="org-ul">
<li><p>
如下图
</p>

<div id="orgf37373d" class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/image/master/dlfs/4-3.png" alt="4-3.png" />
</p>
<p><span class="figure-number">Figure 38: </span>dlfs/4-3.png</p>
</div></li>
<li>当x等于1的时候,y等于0(效果最好)</li>
<li>随着x向0靠近,y逐渐变小(效果越来越差)</li>
</ul></li>
<li>下面我们来实现一下交叉熵误差:
<ul class="org-ul">
<li><p>
代码如下
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">cross_entropy_error</span><span style="color: #3a81c3;">(</span>y, t<span style="color: #3a81c3;">)</span>:
    <span style="color: #715ab1;">delta</span> = 1e-7
    <span style="color: #3a81c3; font-weight: bold;">return</span> -np.<span style="color: #3a81c3;">sum</span><span style="color: #3a81c3;">(</span>t * np.log<span style="color: #6c3163;">(</span>y + delta<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
</pre>
</div></li>
<li>这里的参数y和t是numpy数组</li>
<li>在计算np.log时,加上了一个微小的delta,这是防止出现np.log(0),这会导致一个无限大的-inf</li>
<li><p>
我们把上一章的标签和数据集拿来使用cross_entropy_error计算后得到的结果如下
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #3a81c3; font-weight: bold;">import</span> numpy <span style="color: #3a81c3; font-weight: bold;">as</span> np


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">cross_entropy_eror</span><span style="color: #3a81c3;">(</span>y, t<span style="color: #3a81c3;">)</span>:
    <span style="color: #715ab1;">delta</span> = 1e-7
    <span style="color: #3a81c3; font-weight: bold;">return</span> -np.<span style="color: #3a81c3;">sum</span><span style="color: #3a81c3;">(</span>t * np.log<span style="color: #6c3163;">(</span>y + delta<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>


<span style="color: #715ab1;">t</span> = <span style="color: #3a81c3;">[</span>0, 0, 1, 0, 0, 0, 0, 0, 0, 0<span style="color: #3a81c3;">]</span>
<span style="color: #715ab1;">y</span> = <span style="color: #3a81c3;">[</span>0.1, 0.05, 0.6, 0.0, 0.05, 0.1, 0.0, 0.1, 0.0, 0.0<span style="color: #3a81c3;">]</span>
<span style="color: #715ab1;">y2</span> = <span style="color: #3a81c3;">[</span>0.1, 0.05, 0.1, 0.0, 0.05, 0.1, 0.0, 0.6, 0.0, 0.0<span style="color: #3a81c3;">]</span>

<span style="color: #715ab1;">v1</span> = cross_entropy_eror<span style="color: #3a81c3;">(</span>np.array<span style="color: #6c3163;">(</span>y<span style="color: #6c3163;">)</span>, np.array<span style="color: #6c3163;">(</span>t<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
<span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"""|v1|=&gt;"""</span>, v1<span style="color: #3a81c3;">)</span>

<span style="color: #715ab1;">v2</span> = cross_entropy_eror<span style="color: #3a81c3;">(</span>np.array<span style="color: #6c3163;">(</span>y2<span style="color: #6c3163;">)</span>, np.array<span style="color: #6c3163;">(</span>t<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
<span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"""|v2|=&gt;"""</span>, v2<span style="color: #3a81c3;">)</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">|v1|=&gt; 0.510825457099338</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">|v2|=&gt; 2.302584092994546</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org8f092ad" class="outline-4">
<h4 id="org8f092ad"><span class="section-number-4">4.2.3.</span> mini-batch学习</h4>
<div class="outline-text-4" id="text-4-2-3">
<ul class="org-ul">
<li>机器学习使用训练数据进行学习,损失函数也应该是将所有的训练数据作为对象,也就是说,如果训练数据有100个
的话,我们要把这100个损失函数的总和作为学习的指标</li>
<li>上一节的例子是拿一个数据来计算损失的.如果是要求所有训练数据的损失函数的总和,那么:
<ul class="org-ul">
<li><p>
公式应该如下
</p>
\begin{equation}
E = - \frac{1}{N} \sum_{n} \sum_{k} t_{nk} \log y_{nk}, \tag{4.3}
\end{equation}</li>
<li>这里假设数据有N个</li>
<li>式子虽然复杂,但是,其实就是把式4-2扩大了N倍,最终再除以N进行正规化</li>
</ul></li>
<li><p>
当数据集比较小的时候,我们把数据整体的损失算出来再除以N还能接受,如果遇到大数据,数据量会有百万千万级,
这种情况下以全部数据为对象计算损失函数是不现实的.这种情况下我们的应对方案是
</p>
<pre class="example" id="orgd893efe">
从全部数据中选出一部分,作为全部数据的"近似"
</pre></li>
<li>从训练数据中选出小批量的数据进行学习,就叫做mini-batch学习,因为mini-batch就是小批量的意思
<ul class="org-ul">
<li><p>
下面的代码就是从训练数据中随机选择指定个数数据进行mini-batch学习的代码
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #715ab1;">batch_mask</span> = np.random.choice<span style="color: #3a81c3;">(</span>train_size, batch_size<span style="color: #3a81c3;">)</span>
<span style="color: #715ab1;">x_batch</span> = x_train<span style="color: #3a81c3;">[</span>batch_mask<span style="color: #3a81c3;">]</span>
<span style="color: #715ab1;">t_batch</span> = t_train<span style="color: #3a81c3;">[</span>batch_mask<span style="color: #3a81c3;">]</span>
</pre>
</div></li>
<li><p>
这段代码的核心就是np.random.choice,它能从第一个参数确定的区间里面,随机获得N个数字(N为第一个参数
设置)
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #3a81c3; font-weight: bold;">import</span> numpy <span style="color: #3a81c3; font-weight: bold;">as</span> np

<span style="color: #715ab1;">ret</span> = np.random.choice<span style="color: #3a81c3;">(</span>6000, 10<span style="color: #3a81c3;">)</span>
<span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"""|ret|=&gt;"""</span>, ret<span style="color: #3a81c3;">)</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">|ret|=&gt; [1952 5938 1093  456 2108 5936  596 3343 1663 3691]</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org75e52d6" class="outline-4">
<h4 id="org75e52d6"><span class="section-number-4">4.2.4.</span> mini-batch版交叉熵误差的实现</h4>
<div class="outline-text-4" id="text-4-2-4">
<ul class="org-ul">
<li>为了能够实现mini-batch的交叉熵误差,我们需要改良一下之前的代码:
<ul class="org-ul">
<li><p>
改良之前的代码:只支持ndim为1的y和t
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">cross_entropy_eror</span><span style="color: #3a81c3;">(</span>y, t<span style="color: #3a81c3;">)</span>:
    <span style="color: #715ab1;">delta</span> = 1e-7
    <span style="color: #3a81c3; font-weight: bold;">return</span> -np.<span style="color: #3a81c3;">sum</span><span style="color: #3a81c3;">(</span>t * np.log<span style="color: #6c3163;">(</span>y + delta<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
</pre>
</div></li>
<li><p>
改良之后的代码,支持ndim为任意值的y和t. 如果ye和t的ndim还是1的话,要把这两个的ndim扩展成2,也就是
shape为(1,size)的格式,方便后面用同样的逻辑进行计算
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">cross_entropy_error</span><span style="color: #3a81c3;">(</span>y, t<span style="color: #3a81c3;">)</span>:
    <span style="color: #3a81c3; font-weight: bold;">if</span> y.ndim == 1:
        <span style="color: #715ab1;">t</span> = t.reshape<span style="color: #3a81c3;">(</span>1, t.size<span style="color: #3a81c3;">)</span>
        <span style="color: #715ab1;">y</span> = y.reshape<span style="color: #3a81c3;">(</span>1, y.size<span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">batch_size</span> = y.shape<span style="color: #3a81c3;">[</span>0<span style="color: #3a81c3;">]</span>
    <span style="color: #3a81c3; font-weight: bold;">return</span> -np.<span style="color: #3a81c3;">sum</span><span style="color: #3a81c3;">(</span>t * np.log<span style="color: #6c3163;">(</span>y + 1e-7<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span> / batch_size
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org3c65921" class="outline-4">
<h4 id="org3c65921"><span class="section-number-4">4.2.5.</span> 为何要设定损失函数</h4>
<div class="outline-text-4" id="text-4-2-5">
<ul class="org-ul">
<li><p>
我们之所以要设计损失函数,是因为识别精度不能作为指标,总结起来就是
</p>
<pre class="example" id="org6ca2999">
在进行神经网络的学习时,不能将识别精度作为指标,因为如果以识别精度为指标,
则参数的导数在大多数地方都会变为0
</pre></li>
<li>神经网络的学习同样不能以阶跃函数作为激活函数.
<ul class="org-ul">
<li><p>
如下图. 阶跃函数的导数在绝大多数地方均为0
</p>

<div id="org1dd3f70" class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/image/master/dlfs/4-4.png" alt="4-4.png" />
</p>
<p><span class="figure-number">Figure 39: </span>dlfs/4-4.png</p>
</div></li>
<li>换句话说,如果使用了阶跃函数,那么即便将损失函数作为指标,参数的微小变化也会被阶跃函数抹杀,导致损失
函数的值不会产生任何变化</li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org3e04a72" class="outline-3">
<h3 id="org3e04a72"><span class="section-number-3">4.3.</span> 数值微分</h3>
<div class="outline-text-3" id="text-4-3">
</div>
<div id="outline-container-org5cbcd6c" class="outline-4">
<h4 id="org5cbcd6c"><span class="section-number-4">4.3.1.</span> 导数</h4>
<div class="outline-text-4" id="text-4-3-1">
<ul class="org-ul">
<li>加入你是全程马拉松选手,在最开始的十分钟内跑了两千米,我们想计算速度,那就是2/10=0.2[千米/分]</li>
<li>严格的讲,刚才的计算得出的结果是一个10分钟内的平均速度.而如果我们想要知道某个瞬间的速度,那么就要用到导数
<ul class="org-ul">
<li><p>
导数的定义如下
</p>
\begin{equation}
\frac{df(x)}{dx} = \lim_{h \to 0} \frac{f(x + h) - f(x)}{h}, \tag{4.4}
\end{equation}</li>
<li>左边的 \(\frac{df(x)}{dx}\) 表示 f(x) 关于x的导数, 即f(x)相对于x的变化程度</li>
<li>右边的h是一个无线趋近于0的数字,表示为 \(\lim_{h \to 0}\),在h趋近于0的情况下f(x+h)-fx(x)除以h,就是
这个瞬间的速度</li>
</ul></li>
<li>接下来,我们想计算一下公式4-4,这里就有一些要说的故事:
<ul class="org-ul">
<li>我们曾经都学过导数,在高等数学里面,我们是可以通过一系列公式来计算导数的.比如 \(y=x^2\) 的导数就是2x</li>
<li>但是,在计算机的世界里面,很多情况下不是这么计算导数的.这是因为:
<ol class="org-ol">
<li>在计算机世界(特别是深度学习世界)我们很难得到 \(y=x^2\) 这种清晰的函数</li>
<li>就算得到了较为清晰的函数,比起真的给一个"极小值"去计算,使用公式获得"完美"导数的情况,也会更加的消耗cpu</li>
</ol></li>
</ul></li>
<li>所以,在计算机世界(准确的说是深度学习世界),我们是代入一个"极小值"来计算导数的
<ul class="org-ul">
<li><p>
比如下面的例子
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">numerical_diff</span><span style="color: #3a81c3;">(</span>f, x<span style="color: #3a81c3;">)</span>:
    <span style="color: #715ab1;">h</span> = 10e-50
    <span style="color: #3a81c3; font-weight: bold;">return</span> <span style="color: #3a81c3;">(</span>f<span style="color: #6c3163;">(</span>x + h<span style="color: #6c3163;">)</span> - f<span style="color: #6c3163;">(</span>x<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span> / h
</pre>
</div></li>
<li>函数numerical_diff的名字就是数值微分的英文</li>
<li>numerical_diff有两个参数:
<ol class="org-ol">
<li>函数f</li>
<li>函数f的参数x</li>
</ol></li>
</ul></li>
<li>这个例子有两个问题:
<ul class="org-ul">
<li><p>
第一个就是"极小值"(1e-50)太小了,在python里面会产生摄入误差,最终在python里面就是0.0了,这里我们要
把极小值改成10e-4就够了
</p>
<div class="org-src-container">
<pre class="src src-python">&gt;&gt;&gt; np.float32<span style="color: #3a81c3;">(</span>1e-50<span style="color: #3a81c3;">)</span>
np.float32<span style="color: #3a81c3;">(</span>0.0<span style="color: #3a81c3;">)</span>
</pre>
</div></li>
<li><p>
第二个问题是我们能提高计算的"导数"的精度:我们计算的导数其实是有误差的,如下图
</p>

<div id="org5bcd42e" class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/image/master/dlfs/4-5.png" alt="4-5.png" />
</p>
<p><span class="figure-number">Figure 40: </span>dlfs/4-5.png</p>
</div></li>
<li>"真的导数"对应函数在x处的斜率(真的切线),但是我们计算出来的是那个"近似切线",所以我们有误差,如果想
缩小这个误差,那么通过一系列的数学证明(证明略),我们可以使用"中心差值法",来减小误差</li>
<li><p>
所谓"中心差值法",就是"以x为中心,计算它左右两边的差分",代码如下
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">numerical_diff</span><span style="color: #3a81c3;">(</span>f, x<span style="color: #3a81c3;">)</span>:
    <span style="color: #715ab1;">h</span> = 1e-4
    <span style="color: #3a81c3; font-weight: bold;">return</span> <span style="color: #3a81c3;">(</span>f<span style="color: #6c3163;">(</span>x + h<span style="color: #6c3163;">)</span> - f<span style="color: #6c3163;">(</span>x - h<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span> / <span style="color: #3a81c3;">(</span>2 * h<span style="color: #3a81c3;">)</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgcebc8b7" class="outline-4">
<h4 id="orgcebc8b7"><span class="section-number-4">4.3.2.</span> 数值微分的例子</h4>
<div class="outline-text-4" id="text-4-3-2">
<ul class="org-ul">
<li>我们通过一个例子来加深一下"使用python来计算导数"这件事的印象:
<ul class="org-ul">
<li>首先,我们使用代码来实现一个函数,并且打印出来</li>
<li><p>
打印出来的图像如下
</p>

<div id="orgd180dd7" class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/image/master/dlfs/4-6.png" alt="4-6.png" />
</p>
<p><span class="figure-number">Figure 41: </span>dlfs/4-6.png</p>
</div></li>
<li><p>
我们再结合上节的数值微分的代码,计算在x=5和x=10两个点的导数
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">numerical_diff</span><span style="color: #3a81c3;">(</span>f, x<span style="color: #3a81c3;">)</span>:
    <span style="color: #715ab1;">h</span> = 1e-4
    <span style="color: #3a81c3; font-weight: bold;">return</span> <span style="color: #3a81c3;">(</span>f<span style="color: #6c3163;">(</span>x + h<span style="color: #6c3163;">)</span> - f<span style="color: #6c3163;">(</span>x - h<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span> / <span style="color: #3a81c3;">(</span>2 * h<span style="color: #3a81c3;">)</span>


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">function_1</span><span style="color: #3a81c3;">(</span>x<span style="color: #3a81c3;">)</span>:
    <span style="color: #3a81c3; font-weight: bold;">return</span> 0.01 * x**2 + 0.1 * x


<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">derivative on 5</span>
<span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"""|numerical_diff(function_1, 5)|=&gt;"""</span>, numerical_diff<span style="color: #6c3163;">(</span>function_1, 5<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">derivative on 10</span>
<span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"""|numerical_diff(function_1, 10)|=&gt;"""</span>, numerical_diff<span style="color: #6c3163;">(</span>function_1, 10<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">|numerical_diff(function_1, 5)|=&gt; 0.1999999999990898</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">|numerical_diff(function_1, 10)|=&gt; 0.2999999999986347</span>
</pre>
</div></li>
<li><p>
我们的原始函数使用公式表达如下
</p>
\begin{equation}
y = 0.01x^2 + 0.1x \tag{4.5}
\end{equation}</li>
<li><p>
由于这个公式非常简单,我们可以通过"导数计算公式"得到它的导数解析值如下
</p>
\begin{equation}
\frac{\mathrm{d} f(x)}{\mathrm{d} x} = 0.02x + 0.1 \notag
\end{equation}</li>
<li>我们由此可以计算出在x=5和x=10两点的导数:
<ol class="org-ol">
<li>x = 5时真实导数为0.2: 我们计算值为:0.1999999999990898,误差小到可以认为是相等</li>
<li>x = 10时真实导数为0.3: 我们计算值为0.2999999999986347,误差小到可以认为是相等</li>
</ol></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgd2693d6" class="outline-4">
<h4 id="orgd2693d6"><span class="section-number-4">4.3.3.</span> 偏导数</h4>
<div class="outline-text-4" id="text-4-3-3">
<ul class="org-ul">
<li>所谓偏导数,是指"多个变量函数的导数"</li>
<li>先看一个"多个变量的函数"的例子
<ul class="org-ul">
<li><p>
公式如下
</p>
\begin{equation}
f(x_0, x_1) = x_0^2 + x_1^2 \tag{4.6}
\end{equation}</li>
<li><p>
使用代码表示如下
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #3a81c3; font-weight: bold;">import</span> numpy <span style="color: #3a81c3; font-weight: bold;">as</span> np
<span style="color: #3a81c3; font-weight: bold;">import</span> matplotlib.pyplot <span style="color: #3a81c3; font-weight: bold;">as</span> plt
<span style="color: #3a81c3; font-weight: bold;">from</span> mpl_toolkits.mplot3d <span style="color: #3a81c3; font-weight: bold;">import</span> Axes3D


<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&#23450;&#20041;&#20989;&#25968; function_2</span>
<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">function_2</span><span style="color: #3a81c3;">(</span>x<span style="color: #3a81c3;">)</span>:
    <span style="color: #3a81c3; font-weight: bold;">return</span> x<span style="color: #3a81c3;">[</span>0<span style="color: #3a81c3;">]</span> ** 2 + x<span style="color: #3a81c3;">[</span>1<span style="color: #3a81c3;">]</span> ** 2


<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&#21019;&#24314; x &#21644; y &#30340;&#32593;&#26684;</span>
<span style="color: #715ab1;">x</span> = np.linspace<span style="color: #3a81c3;">(</span>-10, 10, 400<span style="color: #3a81c3;">)</span>
<span style="color: #715ab1;">y</span> = np.linspace<span style="color: #3a81c3;">(</span>-10, 10, 400<span style="color: #3a81c3;">)</span>
<span style="color: #715ab1;">X</span>, <span style="color: #715ab1;">Y</span> = np.meshgrid<span style="color: #3a81c3;">(</span>x, y<span style="color: #3a81c3;">)</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&#35745;&#31639;&#27599;&#20010;&#32593;&#26684;&#28857;&#30340;&#20989;&#25968;&#20540;</span>
<span style="color: #715ab1;">Z</span> = function_2<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>X, Y<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&#20351;&#29992; matplotlib &#30011;&#20986;&#19977;&#32500;&#22270;&#20687;</span>
<span style="color: #715ab1;">fig</span> = plt.figure<span style="color: #3a81c3;">()</span>
<span style="color: #715ab1;">ax</span> = fig.add_subplot<span style="color: #3a81c3;">(</span>111, projection=<span style="color: #2d9574;">"3d"</span><span style="color: #3a81c3;">)</span>
ax.plot_surface<span style="color: #3a81c3;">(</span>X, Y, Z, cmap=<span style="color: #2d9574;">"viridis"</span><span style="color: #3a81c3;">)</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&#28155;&#21152;&#26631;&#39064;&#21644;&#36724;&#26631;&#31614;</span>
ax.set_title<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"3D plot of function_2"</span><span style="color: #3a81c3;">)</span>
ax.set_xlabel<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"x0"</span><span style="color: #3a81c3;">)</span>
ax.set_ylabel<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"x1"</span><span style="color: #3a81c3;">)</span>
ax.set_zlabel<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"f(x)"</span><span style="color: #3a81c3;">)</span>

plt.show<span style="color: #3a81c3;">()</span>
</pre>
</div></li>
<li><p>
用python打印出来的三维图像如下
</p>

<div id="org0091176" class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/image/master/dlfs/4-8.png" alt="4-8.png" />
</p>
<p><span class="figure-number">Figure 42: </span>dlfs/4-8.png</p>
</div></li>
</ul></li>
<li>了解完"多个变量的函数"之后,我们来试着给"多个变量的函数"求导,因为公式4-6有两个变量,所以有必要区分对
哪个变量求导(也就是针对 \(x_0\) 还是 \(x_1\) 求导),在数学上,我们这样区分:
<ul class="org-ul">
<li>对 \(x_0\) 的求导,可以写成 \(\frac{\partial f}{\partial x_0}\)</li>
<li>对 \(x_1\) 的求导,可以写成 \(\frac{\partial f}{\partial x_1}\)</li>
</ul></li>
<li>在计算机领域,我们计算偏导数,只需要把一个变量看做常量得到一个新的函数,然后用上节课讲的numerical_diff
来计算这个新函数的导数就可以了:
<ul class="org-ul">
<li><p>
比如,我们可以计算 \(x_0 =3, x_1 = 4\) 时候的关于 \(x_0\) 的偏导(这个时候 \(x_1\) 就应该先看成常量), 我
们用代码求出来的偏导数为6.00000000000378,实际值为6
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #3a81c3; font-weight: bold;">import</span> numpy <span style="color: #3a81c3; font-weight: bold;">as</span> np


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">numerical_diff</span><span style="color: #3a81c3;">(</span>f, x<span style="color: #3a81c3;">)</span>:
    <span style="color: #715ab1;">h</span> = 1e-4
    <span style="color: #3a81c3; font-weight: bold;">return</span> <span style="color: #3a81c3;">(</span>f<span style="color: #6c3163;">(</span>x + h<span style="color: #6c3163;">)</span> - f<span style="color: #6c3163;">(</span>x - h<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span> / <span style="color: #3a81c3;">(</span>2 * h<span style="color: #3a81c3;">)</span>


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">function_tmp1</span><span style="color: #3a81c3;">(</span>x0<span style="color: #3a81c3;">)</span>:
    <span style="color: #3a81c3; font-weight: bold;">return</span> x0 * x0 + 4.0**2.0


<span style="color: #715ab1;">nd1</span> = numerical_diff<span style="color: #3a81c3;">(</span>function_tmp1, 3.0<span style="color: #3a81c3;">)</span>

<span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"""|nd1|=&gt;"""</span>, nd1<span style="color: #3a81c3;">)</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">|nd1|=&gt; 6.00000000000378</span>
</pre>
</div></li>
<li><p>
比如,我们可以计算 \(x_0 =3, x_1 = 4\) 时候的关于 \(x_1\) 的偏导(这个时候 \(x_0\) 就应该先看成常量), 我
们用代码求出来的偏导数为7.999999999999119,实际值为8
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #3a81c3; font-weight: bold;">import</span> numpy <span style="color: #3a81c3; font-weight: bold;">as</span> np


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">numerical_diff</span><span style="color: #3a81c3;">(</span>f, x<span style="color: #3a81c3;">)</span>:
    <span style="color: #715ab1;">h</span> = 1e-4
    <span style="color: #3a81c3; font-weight: bold;">return</span> <span style="color: #3a81c3;">(</span>f<span style="color: #6c3163;">(</span>x + h<span style="color: #6c3163;">)</span> - f<span style="color: #6c3163;">(</span>x - h<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span> / <span style="color: #3a81c3;">(</span>2 * h<span style="color: #3a81c3;">)</span>


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">function_tmp2</span><span style="color: #3a81c3;">(</span>x1<span style="color: #3a81c3;">)</span>:
    <span style="color: #3a81c3; font-weight: bold;">return</span> 3.0**2 + x1 * x1


<span style="color: #715ab1;">nd2</span> = numerical_diff<span style="color: #3a81c3;">(</span>function_tmp2, 4.0<span style="color: #3a81c3;">)</span>

<span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"""|nd2|=&gt;"""</span>, nd2<span style="color: #3a81c3;">)</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">|nd2|=&gt; 7.999999999999119</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgd977d0a" class="outline-3">
<h3 id="orgd977d0a"><span class="section-number-3">4.4.</span> 梯度</h3>
<div class="outline-text-3" id="text-4-4">
</div>
<div id="outline-container-orgb359ff1" class="outline-4">
<h4 id="orgb359ff1"><span class="section-number-4">4.4.1.</span> 梯度法</h4>
</div>
<div id="outline-container-orgbf3ccf3" class="outline-4">
<h4 id="orgbf3ccf3"><span class="section-number-4">4.4.2.</span> 神经网络的梯度</h4>
</div>
</div>
<div id="outline-container-org5218008" class="outline-3">
<h3 id="org5218008"><span class="section-number-3">4.5.</span> 学习算法的实现</h3>
<div class="outline-text-3" id="text-4-5">
</div>
<div id="outline-container-org471dfcb" class="outline-4">
<h4 id="org471dfcb"><span class="section-number-4">4.5.1.</span> 2层神经网络的类</h4>
</div>
<div id="outline-container-org50568bc" class="outline-4">
<h4 id="org50568bc"><span class="section-number-4">4.5.2.</span> mini-batch的实现</h4>
</div>
<div id="outline-container-org8d3c9fa" class="outline-4">
<h4 id="org8d3c9fa"><span class="section-number-4">4.5.3.</span> 基于测试数据的评价</h4>
</div>
</div>
</div>
<div id="outline-container-org1905191" class="outline-2">
<h2 id="org1905191"><span class="section-number-2">5.</span> 误差反向传播法</h2>
</div>
<div id="outline-container-org0c8a4a8" class="outline-2">
<h2 id="org0c8a4a8"><span class="section-number-2">6.</span> 与学习相关的技巧</h2>
</div>
<div id="outline-container-org0727760" class="outline-2">
<h2 id="org0727760"><span class="section-number-2">7.</span> 卷积神经网络</h2>
</div>
<div id="outline-container-org324de53" class="outline-2">
<h2 id="org324de53"><span class="section-number-2">8.</span> 深度学习</h2>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: harrifeng@outlook.com</p>
<p class="date">Created: 2024-10-10 Thu 17:26</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
