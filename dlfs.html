<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2024-08-06 Tue 16:50 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>dlfs</title>
<meta name="author" content="harrifeng@outlook.com" />
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="src/readtheorg_theme/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="src/readtheorg_theme/css/readtheorg.css"/>
<script type="text/javascript" src="src/lib/js/jquery.min.js"></script>
<script type="text/javascript" src="src/lib/js/bootstrap.min.js"></script>
<script type="text/javascript" src="src/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="src/readtheorg_theme/js/readtheorg.js"></script>
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">dlfs</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orgc3bc411">1. Python 入门</a>
<ul>
<li><a href="#org7df861b">1.1. Python是什么</a></li>
<li><a href="#org042b2f4">1.2. Python的安装</a>
<ul>
<li><a href="#org9623b59">1.2.1. Python版本</a></li>
<li><a href="#org9969b8a">1.2.2. 使用的外部库</a></li>
<li><a href="#org1b9eb2b">1.2.3. Anaconda发行版</a></li>
</ul>
</li>
<li><a href="#org10acb5f">1.3. Python解释器</a>
<ul>
<li><a href="#org20aad8d">1.3.1. 算术计算</a></li>
<li><a href="#orgb1c9533">1.3.2. 数据类型</a></li>
<li><a href="#org9dd44b4">1.3.3. 变量</a></li>
<li><a href="#orgf0ec149">1.3.4. 列表</a></li>
<li><a href="#org8e37e61">1.3.5. 字典</a></li>
<li><a href="#orgbc9bbfb">1.3.6. 布尔型</a></li>
<li><a href="#orgc9cd1ac">1.3.7. if 语句</a></li>
<li><a href="#org6323c0f">1.3.8. for 语句</a></li>
<li><a href="#orgadfc3d6">1.3.9. 函数</a></li>
</ul>
</li>
<li><a href="#org03df3ce">1.4. Python脚本文件</a>
<ul>
<li><a href="#org26349f4">1.4.1. 保存为文件</a></li>
<li><a href="#org171de21">1.4.2. 类</a></li>
</ul>
</li>
<li><a href="#orgecfcdd9">1.5. NumPy</a>
<ul>
<li><a href="#org8a7b105">1.5.1. 导入NumPy</a></li>
<li><a href="#org4052329">1.5.2. 生成NumPy数组</a></li>
<li><a href="#org56b3400">1.5.3. NumPy的算术运算</a></li>
<li><a href="#org749dac2">1.5.4. NumPy的N维数组</a></li>
<li><a href="#org31230cb">1.5.5. 广播</a></li>
<li><a href="#org665d299">1.5.6. 访问元素</a></li>
</ul>
</li>
<li><a href="#orgdb6c981">1.6. Matplotlib</a>
<ul>
<li><a href="#org8c92ba0">1.6.1. 绘制简单图形</a></li>
<li><a href="#orgcb6724a">1.6.2. pyplot的功能</a></li>
<li><a href="#orgde1bb7d">1.6.3. 显示图像</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org2eb6216">2. 感知机</a>
<ul>
<li><a href="#org760255b">2.1. 感知机是什么</a></li>
<li><a href="#orgd875d24">2.2. 简单的逻辑电路</a>
<ul>
<li><a href="#org5469448">2.2.1. 与门</a></li>
<li><a href="#org9ad00d2">2.2.2. 与非门和或门</a></li>
</ul>
</li>
<li><a href="#org774e664">2.3. 感知机的实现</a>
<ul>
<li><a href="#org860f3df">2.3.1. 简单的实现</a></li>
<li><a href="#orge1c6a3f">2.3.2. 导入权重和偏置</a></li>
<li><a href="#orgb4156bd">2.3.3. 使用权重和偏置的实现</a></li>
</ul>
</li>
<li><a href="#org99353ca">2.4. 感知机的局限性</a>
<ul>
<li><a href="#orgb9a8034">2.4.1. 异或门</a></li>
<li><a href="#org71d2a30">2.4.2. 线性和非线性</a></li>
</ul>
</li>
<li><a href="#orge342f3d">2.5. 多层感知机</a>
<ul>
<li><a href="#orgcd9b8d0">2.5.1. 已有门电路组合</a></li>
<li><a href="#org377950e">2.5.2. 异或门的实现</a></li>
</ul>
</li>
<li><a href="#org421ac61">2.6. 从与非门到计算机</a></li>
</ul>
</li>
<li><a href="#org51067c6">3. 神经网络</a>
<ul>
<li><a href="#orgbe754e9">3.1. 从感知机到神经网络</a>
<ul>
<li><a href="#org8057827">3.1.1. 神经网路的例子</a></li>
<li><a href="#org34fc53a">3.1.2. 复习感知机</a></li>
<li><a href="#org7ac327f">3.1.3. 激活函数登场</a></li>
</ul>
</li>
<li><a href="#org0675d07">3.2. 激活函数</a>
<ul>
<li><a href="#orgfcc4d97">3.2.1. sigmoid函数</a></li>
<li><a href="#orgb500cb7">3.2.2. 阶跃函数的实现</a></li>
<li><a href="#org92d6ef4">3.2.3. 阶跃函数的图形</a></li>
<li><a href="#org29de1b4">3.2.4. sigmoid 函数的实现</a></li>
<li><a href="#orge1e4c9d">3.2.5. sigmoid函数和阶跃函数的比较</a></li>
<li><a href="#orgc64745b">3.2.6. 非线性函数</a></li>
<li><a href="#org6d5b75d">3.2.7. ReLU函数</a></li>
</ul>
</li>
<li><a href="#org04bf13e">3.3. 多维数组的运算</a>
<ul>
<li><a href="#orgaa428ae">3.3.1. 多维数组</a></li>
<li><a href="#orgcf2bc8e">3.3.2. 矩阵乘法</a></li>
<li><a href="#org59396be">3.3.3. 神经网络的内机</a></li>
</ul>
</li>
<li><a href="#org171f924">3.4. 3层神经网络的实现</a>
<ul>
<li><a href="#org8437333">3.4.1. 符号确认</a></li>
<li><a href="#orga82f5f0">3.4.2. 各层间信号传递的实现</a></li>
<li><a href="#org7d95554">3.4.3. 代码现小结</a></li>
</ul>
</li>
<li><a href="#org7537037">3.5. 输出层的设计</a>
<ul>
<li><a href="#org9cc28e5">3.5.1. 恒等函数和softmax函数</a></li>
<li><a href="#orgf3af941">3.5.2. 实现softmax函数时的注意事项</a></li>
<li><a href="#org4ba3a61">3.5.3. softmax函数的特征</a></li>
<li><a href="#org94b07f5">3.5.4. 输出层的神经元数量</a></li>
</ul>
</li>
<li><a href="#orgc4d3cee">3.6. 手写数字识别</a>
<ul>
<li><a href="#org66e4d9c">3.6.1. MNIST数据集</a></li>
<li><a href="#org5fbbef6">3.6.2. 神经网络的推理处理</a></li>
<li><a href="#org69f1270">3.6.3. 批处理</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgaf56dc6">4. 神经网络的学习</a>
<ul>
<li><a href="#orgf9e21ce">4.1. 从数据中学习</a>
<ul>
<li><a href="#orge0c7502">4.1.1. 数据驱动</a></li>
<li><a href="#org53414a2">4.1.2. 训练数据和测试数据</a></li>
</ul>
</li>
<li><a href="#orgdff7024">4.2. 损失函数</a>
<ul>
<li><a href="#org374012f">4.2.1. 均方误差</a></li>
<li><a href="#org7a7f03a">4.2.2. 交叉熵误差</a></li>
<li><a href="#orge4c0747">4.2.3. mini-batch学习</a></li>
<li><a href="#orgd546388">4.2.4. mini-batch版交叉熵误差的实现</a></li>
<li><a href="#org869cc14">4.2.5. 为何要设定损失函数</a></li>
</ul>
</li>
<li><a href="#orge2b3b2e">4.3. 数值微分</a>
<ul>
<li><a href="#org6dafa6c">4.3.1. 导数</a></li>
<li><a href="#orgc9662e0">4.3.2. 数值微分的例子</a></li>
<li><a href="#orgb4358f8">4.3.3. 偏导数</a></li>
</ul>
</li>
<li><a href="#orged7fe70">4.4. 梯度</a>
<ul>
<li><a href="#org485e77c">4.4.1. 梯度法</a></li>
<li><a href="#orge128751">4.4.2. 神经网络的梯度</a></li>
</ul>
</li>
<li><a href="#org2264024">4.5. 学习算法的实现</a>
<ul>
<li><a href="#orge6dd2b1">4.5.1. 2层神经网络的类</a></li>
<li><a href="#org87b0655">4.5.2. mini-batch的实现</a></li>
<li><a href="#orgb193f2e">4.5.3. 基于测试数据的评价</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org239d768">5. 误差反向传播法</a></li>
<li><a href="#org3e3d374">6. 与学习相关的技巧</a></li>
<li><a href="#orga5b6f60">7. 卷积神经网络</a></li>
<li><a href="#org2377641">8. 深度学习</a></li>
</ul>
</div>
</div>
<div id="outline-container-orgc3bc411" class="outline-2">
<h2 id="orgc3bc411"><span class="section-number-2">1.</span> Python 入门</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org7df861b" class="outline-3">
<h3 id="org7df861b"><span class="section-number-3">1.1.</span> Python是什么</h3>
<div class="outline-text-3" id="text-1-1">
<ul class="org-ul">
<li>Python是机器学习事实上的默认语言</li>
</ul>
</div>
</div>
<div id="outline-container-org042b2f4" class="outline-3">
<h3 id="org042b2f4"><span class="section-number-3">1.2.</span> Python的安装</h3>
<div class="outline-text-3" id="text-1-2">
</div>
<div id="outline-container-org9623b59" class="outline-4">
<h4 id="org9623b59"><span class="section-number-4">1.2.1.</span> Python版本</h4>
<div class="outline-text-4" id="text-1-2-1">
<ul class="org-ul">
<li>本书使用Python3.x版本</li>
</ul>
</div>
</div>
<div id="outline-container-org9969b8a" class="outline-4">
<h4 id="org9969b8a"><span class="section-number-4">1.2.2.</span> 使用的外部库</h4>
<div class="outline-text-4" id="text-1-2-2">
<ul class="org-ul">
<li>本书目标是从零实现深度学习,所以只会依赖如下两个库:
<ul class="org-ul">
<li>NumPy: 便利我们进行科学技术和矩阵计算</li>
<li>Matplotlib: 用来画图的库</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org1b9eb2b" class="outline-4">
<h4 id="org1b9eb2b"><span class="section-number-4">1.2.3.</span> Anaconda发行版</h4>
<div class="outline-text-4" id="text-1-2-3">
<ul class="org-ul">
<li>推荐安装Anaconda发行版,这个发行版侧重于数据分析,已经包含了前面讲的,本书依赖的两个库NumPy和Matplotlib</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org10acb5f" class="outline-3">
<h3 id="org10acb5f"><span class="section-number-3">1.3.</span> Python解释器</h3>
<div class="outline-text-3" id="text-1-3">
<ul class="org-ul">
<li><p>
使用如下代码确认安装的python版本
</p>
<div class="org-src-container">
<pre class="src src-shell">$ python --version
Python 3.10.8
</pre>
</div></li>
<li><p>
python是动态语言,这种语言一般都会有REPL(Read-Eval-Print-Loop),可以实时查看运行结果
</p>
<div class="org-src-container">
<pre class="src src-shell">$ python -i
Python 3.10.8 <span style="color: #3a81c3;">(</span>main, Nov 24 2022, 08:08:27<span style="color: #3a81c3;">)</span> <span style="color: #3a81c3;">[</span>Clang 14.0.6 <span style="color: #3a81c3;">]</span> on darwin
Type <span style="color: #2d9574;">"help"</span>, <span style="color: #2d9574;">"copyright"</span>, <span style="color: #2d9574;">"credits"</span> or <span style="color: #2d9574;">"license"</span> for more information.
&gt;&gt;&gt; 1 + 2
3
</pre>
</div></li>
</ul>
</div>
<div id="outline-container-org20aad8d" class="outline-4">
<h4 id="org20aad8d"><span class="section-number-4">1.3.1.</span> 算术计算</h4>
<div class="outline-text-4" id="text-1-3-1">
<ul class="org-ul">
<li><p>
一些简单的计算可用直接在REPL中进行
</p>
<div class="org-src-container">
<pre class="src src-shell">&gt;&gt;&gt; 1 - 2
-1
&gt;&gt;&gt; 4 * 5
20
&gt;&gt;&gt; 7 / 5
1.4
&gt;&gt;&gt; 3 ** 2
9
</pre>
</div></li>
<li>需要注意的是python3整数除以整数得到的是浮点数</li>
</ul>
</div>
</div>
<div id="outline-container-orgb1c9533" class="outline-4">
<h4 id="orgb1c9533"><span class="section-number-4">1.3.2.</span> 数据类型</h4>
<div class="outline-text-4" id="text-1-3-2">
<ul class="org-ul">
<li><p>
Python中可以使用type来判断数据的类型
</p>
<div class="org-src-container">
<pre class="src src-shell">&gt;&gt;&gt; type<span style="color: #3a81c3;">(</span>10<span style="color: #3a81c3;">)</span>
&lt;class <span style="color: #2d9574;">'int'</span>&gt;
&gt;&gt;&gt; type<span style="color: #3a81c3;">(</span>2.718<span style="color: #3a81c3;">)</span>
&lt;class <span style="color: #2d9574;">'float'</span>&gt;
&gt;&gt;&gt; type<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"hello"</span><span style="color: #3a81c3;">)</span>
&lt;class <span style="color: #2d9574;">'str'</span>&gt;
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-org9dd44b4" class="outline-4">
<h4 id="org9dd44b4"><span class="section-number-4">1.3.3.</span> 变量</h4>
<div class="outline-text-4" id="text-1-3-3">
<ul class="org-ul">
<li><p>
Python中变量例子如下
</p>
<div class="org-src-container">
<pre class="src src-shell">&gt;&gt;&gt; x = 10
&gt;&gt;&gt; print<span style="color: #3a81c3;">(</span>x<span style="color: #3a81c3;">)</span>
10
&gt;&gt;&gt; x = 100
&gt;&gt;&gt; print<span style="color: #3a81c3;">(</span>x<span style="color: #3a81c3;">)</span>
100
&gt;&gt;&gt; y = 3.14
&gt;&gt;&gt; x * y
314.0
&gt;&gt;&gt; type<span style="color: #3a81c3;">(</span>x*y<span style="color: #3a81c3;">)</span>
&lt;class <span style="color: #2d9574;">'float'</span>&gt;
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-orgf0ec149" class="outline-4">
<h4 id="orgf0ec149"><span class="section-number-4">1.3.4.</span> 列表</h4>
<div class="outline-text-4" id="text-1-3-4">
<ul class="org-ul">
<li><p>
列表是Python当中非常重要的类型,而且支持slicing,非常好用
</p>
<div class="org-src-container">
<pre class="src src-shell">&gt;&gt;&gt; a = <span style="color: #3a81c3;">[</span>1, 2, 3, 4,5<span style="color: #3a81c3;">]</span>
&gt;&gt;&gt; print<span style="color: #3a81c3;">(</span>a<span style="color: #3a81c3;">)</span>
<span style="color: #3a81c3;">[</span>1, 2, 3, 4, 5<span style="color: #3a81c3;">]</span>
&gt;&gt;&gt; len<span style="color: #3a81c3;">(</span>a<span style="color: #3a81c3;">)</span>
5
&gt;&gt;&gt; a<span style="color: #3a81c3;">[</span>0<span style="color: #3a81c3;">]</span>
1
&gt;&gt;&gt; a<span style="color: #3a81c3;">[</span>0:2<span style="color: #3a81c3;">]</span>
<span style="color: #3a81c3;">[</span>1, 2<span style="color: #3a81c3;">]</span>
&gt;&gt;&gt; a<span style="color: #3a81c3;">[</span>1:<span style="color: #3a81c3;">]</span>
<span style="color: #3a81c3;">[</span>2, 3, 4, 5<span style="color: #3a81c3;">]</span>
&gt;&gt;&gt; a<span style="color: #3a81c3;">[</span>:-2<span style="color: #3a81c3;">]</span>
<span style="color: #3a81c3;">[</span>1, 2, 3<span style="color: #3a81c3;">]</span>
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-org8e37e61" class="outline-4">
<h4 id="org8e37e61"><span class="section-number-4">1.3.5.</span> 字典</h4>
<div class="outline-text-4" id="text-1-3-5">
<ul class="org-ul">
<li><p>
python中的哈希表叫做字典,字典基本是最常用数据结构了
</p>
<div class="org-src-container">
<pre class="src src-shell">&gt;&gt;&gt; me = <span style="color: #3a81c3;">{</span><span style="color: #2d9574;">"height"</span>: 180<span style="color: #3a81c3;">}</span>
&gt;&gt;&gt; me<span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"height"</span><span style="color: #3a81c3;">]</span>
180
&gt;&gt;&gt; me<span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"weight"</span><span style="color: #3a81c3;">]</span> = 70
&gt;&gt;&gt; print<span style="color: #3a81c3;">(</span>me<span style="color: #3a81c3;">)</span>
<span style="color: #3a81c3;">{</span><span style="color: #2d9574;">'height'</span>: 180, <span style="color: #2d9574;">'weight'</span>: 70<span style="color: #3a81c3;">}</span>
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-orgbc9bbfb" class="outline-4">
<h4 id="orgbc9bbfb"><span class="section-number-4">1.3.6.</span> 布尔型</h4>
<div class="outline-text-4" id="text-1-3-6">
<ul class="org-ul">
<li>Python中的bool值为首字母大写的True和False</li>
<li>针对bool类型运算符有:
<ul class="org-ul">
<li>and</li>
<li>or</li>
<li>not</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgc9cd1ac" class="outline-4">
<h4 id="orgc9cd1ac"><span class="section-number-4">1.3.7.</span> if 语句</h4>
<div class="outline-text-4" id="text-1-3-7">
<ul class="org-ul">
<li>if语句为级别逻辑语句</li>
</ul>
</div>
</div>
<div id="outline-container-org6323c0f" class="outline-4">
<h4 id="org6323c0f"><span class="section-number-4">1.3.8.</span> for 语句</h4>
<div class="outline-text-4" id="text-1-3-8">
<ul class="org-ul">
<li>for语句为级别循环语句</li>
</ul>
</div>
</div>
<div id="outline-container-orgadfc3d6" class="outline-4">
<h4 id="orgadfc3d6"><span class="section-number-4">1.3.9.</span> 函数</h4>
<div class="outline-text-4" id="text-1-3-9">
<ul class="org-ul">
<li>python中使用def来定义函数</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org03df3ce" class="outline-3">
<h3 id="org03df3ce"><span class="section-number-3">1.4.</span> Python脚本文件</h3>
<div class="outline-text-3" id="text-1-4">
</div>
<div id="outline-container-org26349f4" class="outline-4">
<h4 id="org26349f4"><span class="section-number-4">1.4.1.</span> 保存为文件</h4>
<div class="outline-text-4" id="text-1-4-1">
<ul class="org-ul">
<li>前面都是在解释器里面运行,但是真正的Python代码一般是保存在一个文件里面(一般以py结尾),然后运行</li>
</ul>
</div>
</div>
<div id="outline-container-org171de21" class="outline-4">
<h4 id="org171de21"><span class="section-number-4">1.4.2.</span> 类</h4>
<div class="outline-text-4" id="text-1-4-2">
<ul class="org-ul">
<li>Python中使用class来定义新的类型</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgecfcdd9" class="outline-3">
<h3 id="orgecfcdd9"><span class="section-number-3">1.5.</span> NumPy</h3>
<div class="outline-text-3" id="text-1-5">
</div>
<div id="outline-container-org8a7b105" class="outline-4">
<h4 id="org8a7b105"><span class="section-number-4">1.5.1.</span> 导入NumPy</h4>
<div class="outline-text-4" id="text-1-5-1">
<ul class="org-ul">
<li><p>
numpy是事实上的科学计算标准,但是它不再python的标注库里面,我们通常以如下代码引入numpy
</p>
<div class="org-src-container">
<pre class="src src-shell">&gt;&gt;&gt; import numpy as np
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-org4052329" class="outline-4">
<h4 id="org4052329"><span class="section-number-4">1.5.2.</span> 生成NumPy数组</h4>
<div class="outline-text-4" id="text-1-5-2">
<ul class="org-ul">
<li><p>
Python的数组我们前面讲过了,叫做列表. 而NumPy的数组就叫NumPy数组,它需要使用list作为参数创建(当然也有
其他创建方式)
</p>
<div class="org-src-container">
<pre class="src src-shell">&gt;&gt;&gt; x = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>1.0,2.0,3.0<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; print<span style="color: #3a81c3;">(</span>x<span style="color: #3a81c3;">)</span>
<span style="color: #3a81c3;">[</span>1. 2. 3.<span style="color: #3a81c3;">]</span>
&gt;&gt;&gt; type<span style="color: #3a81c3;">(</span>x<span style="color: #3a81c3;">)</span>
&lt;class <span style="color: #2d9574;">'numpy.ndarray'</span>&gt;
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-org56b3400" class="outline-4">
<h4 id="org56b3400"><span class="section-number-4">1.5.3.</span> NumPy的算术运算</h4>
<div class="outline-text-4" id="text-1-5-3">
<ul class="org-ul">
<li>NumPy的运算都是element-wise的:
<ul class="org-ul">
<li><p>
如果两个numpy array进行运算,那么就是对应位置的element相互进行运算
</p>
<div class="org-src-container">
<pre class="src src-shell">&gt;&gt;&gt; x = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>1.0, 2.0, 3.0<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; y = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>2.0, 4.0, 6.0<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; x + y
<span style="color: #6c3163; font-weight: bold;">array</span><span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>3., 6., 9.<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; x * y
<span style="color: #6c3163; font-weight: bold;">array</span><span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span> 2.,  8., 18.<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; x / y
<span style="color: #6c3163; font-weight: bold;">array</span><span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>0.5, 0.5, 0.5<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
</pre>
</div></li>
<li><p>
如果一个numpy array和一个数值(标量)进行运算,那么就是array的每个element和标量进行运算
</p>
<div class="org-src-container">
<pre class="src src-shell">&gt;&gt;&gt; x = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>1.0, 2.0, 3.0<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; x / 2.0
<span style="color: #6c3163; font-weight: bold;">array</span><span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>0.5, 1. , 1.5<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org749dac2" class="outline-4">
<h4 id="org749dac2"><span class="section-number-4">1.5.4.</span> NumPy的N维数组</h4>
<div class="outline-text-4" id="text-1-5-4">
<ul class="org-ul">
<li>NumPy还可以生成多维数组,比如下面是一个二维数组的例子
<ul class="org-ul">
<li><p>
例子如下
</p>
<div class="org-src-container">
<pre class="src src-shell">&gt;&gt;&gt; A = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span><span style="color: #2d9574;">[</span>1,2<span style="color: #2d9574;">]</span>, <span style="color: #2d9574;">[</span>3,4<span style="color: #2d9574;">]</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; print<span style="color: #3a81c3;">(</span>A<span style="color: #3a81c3;">)</span>
<span style="color: #3a81c3;">[</span><span style="color: #6c3163;">[</span>1 2<span style="color: #6c3163;">]</span>
 <span style="color: #6c3163;">[</span>3 4<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">]</span>
&gt;&gt;&gt; A.shape
<span style="color: #3a81c3;">(</span>2, 2<span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; A.dtype
<span style="color: #6c3163; font-weight: bold;">dtype</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">'int64'</span><span style="color: #3a81c3;">)</span>
</pre>
</div></li>
<li><p>
我们可以使用shape来查看矩阵的形状, 如果是一维数组,那么只有一个维度的长度
</p>
<div class="org-src-container">
<pre class="src src-shell">&gt;&gt;&gt; a = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>1, 2, 3<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; a
<span style="color: #6c3163; font-weight: bold;">array</span><span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>1, 2, 3<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; a.shape
<span style="color: #3a81c3;">(</span>3,<span style="color: #3a81c3;">)</span>
</pre>
</div></li>
<li>我们还可以使用dtype查看成员的数据类型(这里就需要numpy array的所有成员的类型一致)</li>
</ul></li>
<li>和一维数组的是运算一样, 多维NumPy数组的运算也是element-wise的:
<ul class="org-ul">
<li><p>
一个多维数组和一个维度相同的多维数组运算和一位数组相同
</p>
<div class="org-src-container">
<pre class="src src-shell">&gt;&gt;&gt; print<span style="color: #3a81c3;">(</span>A<span style="color: #3a81c3;">)</span>
<span style="color: #3a81c3;">[</span><span style="color: #6c3163;">[</span>1 2<span style="color: #6c3163;">]</span>
 <span style="color: #6c3163;">[</span>3 4<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">]</span>
&gt;&gt;&gt; B = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span><span style="color: #2d9574;">[</span>3,0<span style="color: #2d9574;">]</span>,<span style="color: #2d9574;">[</span>0,6<span style="color: #2d9574;">]</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; A + B
<span style="color: #6c3163; font-weight: bold;">array</span><span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span><span style="color: #2d9574;">[</span> 4,  2<span style="color: #2d9574;">]</span>,
       <span style="color: #2d9574;">[</span> 3, 10<span style="color: #2d9574;">]</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; A * B
<span style="color: #6c3163; font-weight: bold;">array</span><span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span><span style="color: #2d9574;">[</span> 3,  0<span style="color: #2d9574;">]</span>,
       <span style="color: #2d9574;">[</span> 0, 24<span style="color: #2d9574;">]</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
</pre>
</div></li>
<li><p>
一个多维数组和一个标量进行运算也和一维数组相同
</p>
<div class="org-src-container">
<pre class="src src-shell">&gt;&gt;&gt; print<span style="color: #3a81c3;">(</span>A<span style="color: #3a81c3;">)</span>
<span style="color: #3a81c3;">[</span><span style="color: #6c3163;">[</span>1 2<span style="color: #6c3163;">]</span>
 <span style="color: #6c3163;">[</span>3 4<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">]</span>
&gt;&gt;&gt; A * 10
<span style="color: #6c3163; font-weight: bold;">array</span><span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span><span style="color: #2d9574;">[</span>10, 20<span style="color: #2d9574;">]</span>,
       <span style="color: #2d9574;">[</span>30, 40<span style="color: #2d9574;">]</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
</pre>
</div></li>
</ul></li>
<li>数学上,会有一些特别的名字,比如:
<ul class="org-ul">
<li>单一的数值叫做: 标量(scalar)</li>
<li>一维数组叫做: 向量(vector)</li>
<li>二维数组叫做: 矩阵(matrix)</li>
<li>三维及以上数组叫做: 张量(tensor)</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org31230cb" class="outline-4">
<h4 id="org31230cb"><span class="section-number-4">1.5.5.</span> 广播</h4>
<div class="outline-text-4" id="text-1-5-5">
<ul class="org-ul">
<li><p>
之前我们看到过,一维或者多维数组都可以和自己维度不同的标量进行乘(除)法运算(加减法不行),其原理是NumPy
把标量扩展成了对应的形状.比如下面的例子,标量10就被扩展成了2*2的形状
</p>

<div id="org2a0971b" class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/image/master/dlfs/1-1.png" alt="1-1.png" />
</p>
<p><span class="figure-number">Figure 1: </span>dlfs/1-1.png</p>
</div></li>
<li>这种把乘数扩展后再和被乘数进行乘法(除法)计算的方法,就叫做广播(broadcast)</li>
<li>广播定义之所以是把"乘数"扩展,而不是把标量扩展,是因为广播还支持非标量
<ul class="org-ul">
<li><p>
比如如下代码乘数是一维vector,也是支持广播操作的
</p>
<div class="org-src-container">
<pre class="src src-shell">&gt;&gt;&gt; A = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span><span style="color: #2d9574;">[</span>1,2<span style="color: #2d9574;">]</span>,<span style="color: #2d9574;">[</span>3,4<span style="color: #2d9574;">]</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; B = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>10,20<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; A * B
<span style="color: #6c3163; font-weight: bold;">array</span><span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span><span style="color: #2d9574;">[</span>10, 40<span style="color: #2d9574;">]</span>,
       <span style="color: #2d9574;">[</span>30, 80<span style="color: #2d9574;">]</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
</pre>
</div></li>
<li><p>
我们可以从下图看到,一维vector是如何被扩展的
</p>

<div id="orgeea94a2" class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/image/master/dlfs/1-2.png" alt="1-2.png" />
</p>
<p><span class="figure-number">Figure 2: </span>dlfs/1-2.png</p>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org665d299" class="outline-4">
<h4 id="org665d299"><span class="section-number-4">1.5.6.</span> 访问元素</h4>
<div class="outline-text-4" id="text-1-5-6">
<ul class="org-ul">
<li><p>
numpy数组也是从0开始,对于多维数组的访问,也是多增加几次的[]操作
</p>
<div class="org-src-container">
<pre class="src src-shell">&gt;&gt;&gt; X = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span><span style="color: #2d9574;">[</span>51,55<span style="color: #2d9574;">]</span>, <span style="color: #2d9574;">[</span>14,19<span style="color: #2d9574;">]</span>, <span style="color: #2d9574;">[</span>0, 4<span style="color: #2d9574;">]</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; print<span style="color: #3a81c3;">(</span>X<span style="color: #3a81c3;">)</span>
<span style="color: #3a81c3;">[</span><span style="color: #6c3163;">[</span>51 55<span style="color: #6c3163;">]</span>
 <span style="color: #6c3163;">[</span>14 19<span style="color: #6c3163;">]</span>
 <span style="color: #6c3163;">[</span> 0  4<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">]</span>
&gt;&gt;&gt; X<span style="color: #3a81c3;">[</span>0<span style="color: #3a81c3;">]</span>
<span style="color: #6c3163; font-weight: bold;">array</span><span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>51, 55<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; X<span style="color: #3a81c3;">[</span>0<span style="color: #3a81c3;">][</span>1<span style="color: #3a81c3;">]</span>
55
</pre>
</div></li>
<li>numpy的`[]`里面还可以放置其他的非int值,比如:
<ul class="org-ul">
<li><p>
可以放置一个numpy 数组,比如这里我们要取第1, 3, 5位的数据
</p>
<div class="org-src-container">
<pre class="src src-shell">&gt;&gt;&gt; a = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>0, 10, 20, 30, 40, 50<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; print<span style="color: #3a81c3;">(</span>a<span style="color: #3a81c3;">)</span>
<span style="color: #3a81c3;">[</span> 0 10 20 30 40 50<span style="color: #3a81c3;">]</span>
&gt;&gt;&gt; a<span style="color: #3a81c3;">[</span>np.array<span style="color: #6c3163;">(</span><span style="color: #2d9574;">[</span>1, 3, 5<span style="color: #2d9574;">]</span><span style="color: #6c3163;">)</span><span style="color: #3a81c3;">]</span>
<span style="color: #6c3163; font-weight: bold;">array</span><span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>10, 30, 50<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
</pre>
</div></li>
<li><p>
可以放置一个bool数组,我们只取其中为True的部分
</p>
<div class="org-src-container">
<pre class="src src-shell">&gt;&gt;&gt; a<span style="color: #3a81c3;">[</span>np.array<span style="color: #6c3163;">(</span><span style="color: #2d9574;">[</span>True, True, False, False, False, True<span style="color: #2d9574;">]</span><span style="color: #6c3163;">)</span><span style="color: #3a81c3;">]</span>
<span style="color: #6c3163; font-weight: bold;">array</span><span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span> 0, 10, 50<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgdb6c981" class="outline-3">
<h3 id="orgdb6c981"><span class="section-number-3">1.6.</span> Matplotlib</h3>
<div class="outline-text-3" id="text-1-6">
</div>
<div id="outline-container-org8c92ba0" class="outline-4">
<h4 id="org8c92ba0"><span class="section-number-4">1.6.1.</span> 绘制简单图形</h4>
<div class="outline-text-4" id="text-1-6-1">
<ul class="org-ul">
<li>最简答的绘制sin函数曲线的例子
<ul class="org-ul">
<li><p>
代码如下
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #3a81c3; font-weight: bold;">import</span> numpy <span style="color: #3a81c3; font-weight: bold;">as</span> np
<span style="color: #3a81c3; font-weight: bold;">import</span> matplotlib.pyplot <span style="color: #3a81c3; font-weight: bold;">as</span> plt


<span style="color: #715ab1;">x</span> = np.arange<span style="color: #3a81c3;">(</span>0, 6, 0.1<span style="color: #3a81c3;">)</span>
<span style="color: #715ab1;">y</span> = np.sin<span style="color: #3a81c3;">(</span>x<span style="color: #3a81c3;">)</span>
plt.plot<span style="color: #3a81c3;">(</span>x, y<span style="color: #3a81c3;">)</span>
plt.show<span style="color: #3a81c3;">()</span>
</pre>
</div></li>
<li><p>
结果如下
</p>

<div id="orgb13c8d4" class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/image/master/dlfs/1-3.png" alt="1-3.png" />
</p>
<p><span class="figure-number">Figure 3: </span>dlfs/1-3.png</p>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgcb6724a" class="outline-4">
<h4 id="orgcb6724a"><span class="section-number-4">1.6.2.</span> pyplot的功能</h4>
<div class="outline-text-4" id="text-1-6-2">
<ul class="org-ul">
<li>我们还可以在上图中加上一些标题,x轴签名等等
<ul class="org-ul">
<li><p>
代码如下
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #3a81c3; font-weight: bold;">import</span> numpy <span style="color: #3a81c3; font-weight: bold;">as</span> np
<span style="color: #3a81c3; font-weight: bold;">import</span> matplotlib.pyplot <span style="color: #3a81c3; font-weight: bold;">as</span> plt


<span style="color: #715ab1;">x</span> = np.arange<span style="color: #3a81c3;">(</span>0, 6, 0.1<span style="color: #3a81c3;">)</span>
<span style="color: #715ab1;">y1</span> = np.sin<span style="color: #3a81c3;">(</span>x<span style="color: #3a81c3;">)</span>
<span style="color: #715ab1;">y2</span> = np.cos<span style="color: #3a81c3;">(</span>x<span style="color: #3a81c3;">)</span>
plt.plot<span style="color: #3a81c3;">(</span>x, y1, label=<span style="color: #2d9574;">"sin"</span><span style="color: #3a81c3;">)</span>
plt.plot<span style="color: #3a81c3;">(</span>x, y2, linestyle=<span style="color: #2d9574;">"--"</span>, label=<span style="color: #2d9574;">"cos"</span><span style="color: #3a81c3;">)</span>
plt.xlabel<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"x"</span><span style="color: #3a81c3;">)</span>
plt.ylabel<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"y"</span><span style="color: #3a81c3;">)</span>
plt.show<span style="color: #3a81c3;">()</span>
</pre>
</div></li>
<li><p>
结果如下
</p>

<div id="org9905656" class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/image/master/dlfs/1-4.png" alt="1-4.png" />
</p>
<p><span class="figure-number">Figure 4: </span>dlfs/1-4.png</p>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgde1bb7d" class="outline-4">
<h4 id="orgde1bb7d"><span class="section-number-4">1.6.3.</span> 显示图像</h4>
<div class="outline-text-4" id="text-1-6-3">
<ul class="org-ul">
<li>matplotlib还可以使用imread()方法读入图像</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org2eb6216" class="outline-2">
<h2 id="org2eb6216"><span class="section-number-2">2.</span> 感知机</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-org760255b" class="outline-3">
<h3 id="org760255b"><span class="section-number-3">2.1.</span> 感知机是什么</h3>
<div class="outline-text-3" id="text-2-1">
<ul class="org-ul">
<li>所谓感知机,是指接收多个输入信号,输出一个信号.</li>
<li>这里的信号可以想象成电流或者河流那样具备"流动性"的东西.和实际的电流不同,感知机的信号只有"流/不流"两
种取值,本书中:
<ul class="org-ul">
<li>0对应"不传递信号"</li>
<li>1对应"传递信号"</li>
</ul></li>
<li>下图是一个感知机接收两个输入信号的例子:
<ul class="org-ul">
<li><p>
图2-1
</p>

<div id="orgcf0bd56" class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/image/master/dlfs/2-1.png" alt="2-1.png" />
</p>
<p><span class="figure-number">Figure 5: </span>dlfs/2-1.png</p>
</div></li>
<li>x1,x2是输入信号</li>
<li>y是输出信号</li>
<li>w1,w2是权重(w是weight的首字母). 感知机的多个输入信号都有各自固有的权重,权重越大,对应该权重的信号
重要性就越高</li>
<li>图中的圆形为"神经元"或者"节点"</li>
<li>输入信号被送往神经元的时候会被乘以固定的权重(w1x1,w2x2), 神经元会计算传过来的信号的总和,当这个总
和超过某个界限(称之为阈值)时,才会输出1.输出1也被称之为"神经元被激活"</li>
<li><p>
我们把上面的图用公式表达出来就是
</p>
\begin{equation}
y =
   \begin{cases}
    0 & (w_1 x_1 + w_2 x_2 \leqslant \theta) \\
    1 & (w_1 x_1 + w_2 x_2 > \theta) \tag{2.1}
   \end{cases}
\end{equation}</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgd875d24" class="outline-3">
<h3 id="orgd875d24"><span class="section-number-3">2.2.</span> 简单的逻辑电路</h3>
<div class="outline-text-3" id="text-2-2">
</div>
<div id="outline-container-org5469448" class="outline-4">
<h4 id="org5469448"><span class="section-number-4">2.2.1.</span> 与门</h4>
<div class="outline-text-4" id="text-2-2-1">
<ul class="org-ul">
<li>我们先考虑用感知机来解决简单的问题,比如我们用感知机来实现一下逻辑电路的与门(AND gate)</li>
<li><p>
所谓与门,是指两个输入都为1的情况下,输出为1,其他情况下输入都是0, 如下图
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">x1</th>
<th scope="col" class="org-right">x2</th>
<th scope="col" class="org-right">y</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
</tr>
</tbody>
</table></li>
<li>从我们的公式2.1分析,我们其实只要设置好 \(w_1, w_2,\theta\) 的值就可以.</li>
<li>实际上,我们肉眼就能找到很多这样的值,比如:
<ul class="org-ul">
<li>\((w_1, w_2,\theta) = (0.5,0.5,0.7)\)</li>
<li>\((w_1, w_2,\theta) = (0.5,0.5,0.8)\)</li>
<li>\((w_1, w_2,\theta) = (1.0,1.0,1.0)\)</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org9ad00d2" class="outline-4">
<h4 id="org9ad00d2"><span class="section-number-4">2.2.2.</span> 与非门和或门</h4>
<div class="outline-text-4" id="text-2-2-2">
<ul class="org-ul">
<li><p>
我们再来看看另外的逻辑电路,比如与非门(NAND gate), 与非门,就是"结果颠倒了的与门",如图
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">x1</th>
<th scope="col" class="org-right">x2</th>
<th scope="col" class="org-right">y</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>
</tbody>
</table></li>
<li>对应的\(w_1, w_2,\theta\) 的值也很容易选(其实把与门的参数取反就可以),比如:
<ul class="org-ul">
<li>\((w_1, w_2,\theta) = (-0.5,-0.5,-0.7)\)</li>
<li>\((w_1, w_2,\theta) = (-0.5,-0.5,-0.8)\)</li>
<li>\((w_1, w_2,\theta) = (-1.0,-1.0,-1.0)\)</li>
</ul></li>
<li><p>
同样的,我们还可以设置或门(OR gate),其为两个输入都是0的情况下,才返回0,其他情况都返回1
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">x1</th>
<th scope="col" class="org-right">x2</th>
<th scope="col" class="org-right">y</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
</tr>
</tbody>
</table></li>
<li>实际上,我们肉眼就也能找到很多这样的值,比如:
<ul class="org-ul">
<li>\((w_1, w_2,\theta) = (0.5,0.5,-0.2)\)</li>
<li>\((w_1, w_2,\theta) = (0.5,0.5,-0.3)\)</li>
<li>\((w_1, w_2,\theta) = (1.0,1.0,-0.9)\)</li>
</ul></li>
<li>我们不厌其烦的展示了三种逻辑电路,就是想说明:
<ul class="org-ul">
<li>这三种逻辑电路的感知机构造是一样的</li>
<li>我们只需要适当的调整参数,就能把一个感知机改造成不同的角色: 与门,与非门,或门</li>
</ul></li>
<li>提前剧透一下,感知机和机器学习的不通:
<ul class="org-ul">
<li>感知机是"人类"通过看真值表,确定感知器参数</li>
<li>机器学习是让"计算机"自动的决定这些参数.所谓"学习",就是确定这是参数的过程</li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org774e664" class="outline-3">
<h3 id="org774e664"><span class="section-number-3">2.3.</span> 感知机的实现</h3>
<div class="outline-text-3" id="text-2-3">
</div>
<div id="outline-container-org860f3df" class="outline-4">
<h4 id="org860f3df"><span class="section-number-4">2.3.1.</span> 简单的实现</h4>
<div class="outline-text-4" id="text-2-3-1">
<ul class="org-ul">
<li><p>
我们先用代码来实现一下刚才的与门
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">AND</span><span style="color: #3a81c3;">(</span>x1, x2<span style="color: #3a81c3;">)</span>:
    <span style="color: #715ab1;">w1</span>, <span style="color: #715ab1;">w2</span>, <span style="color: #715ab1;">theta</span> = 0.5, 0.5, 0.7
    <span style="color: #715ab1;">tmp</span> = x1 * w1 + x2 * w2
    <span style="color: #3a81c3; font-weight: bold;">if</span> tmp &lt;= theta:
        <span style="color: #3a81c3; font-weight: bold;">return</span> 0
    <span style="color: #3a81c3; font-weight: bold;">elif</span> tmp &gt; theta:
        <span style="color: #3a81c3; font-weight: bold;">return</span> 1


<span style="color: #3a81c3; font-weight: bold;">if</span> <span style="color: #3a81c3;">__name__</span> == <span style="color: #2d9574;">"__main__"</span>:
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>AND<span style="color: #6c3163;">(</span>0, 0<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>AND<span style="color: #6c3163;">(</span>1, 0<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>AND<span style="color: #6c3163;">(</span>0, 1<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>AND<span style="color: #6c3163;">(</span>1, 1<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">0</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">0</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">0</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">1</span>
</pre>
</div></li>
<li>与非门和或门的实现是类似的,区别只是权重参数的值.不过我们为了更好的抽象问题,我们准备改一下我们的公
式,也顺便改一下我们的实现</li>
</ul>
</div>
</div>
<div id="outline-container-orge1c6a3f" class="outline-4">
<h4 id="orge1c6a3f"><span class="section-number-4">2.3.2.</span> 导入权重和偏置</h4>
<div class="outline-text-4" id="text-2-3-2">
<ul class="org-ul">
<li>我们为了更好的抽象问题,把 \(\theta\) 换成 \(-b\)
<ul class="org-ul">
<li><p>
于是得到公式2.2
</p>
\begin{equation}
y =
   \begin{cases}
    0 & (b + w_1 x_1 + w_2 x_2 \leqslant 0) \\
    1 & (b + w_1 x_1 + w_2 x_2 > 0) \tag{2.2}
   \end{cases}
\end{equation}</li>
<li>公式2.2和公式2.1虽然有一个符号不同,但是表单是内容却是完全相同的</li>
<li>这里的b称之为偏置(bias). 偏置的值决定了神经元被激活的容易程度,比如-0.1的bias肯定比-20的bias更容易激活</li>
<li>w1,w2称之为权重(weight). 权重的值控制不同输入信号的重要性</li>
<li><b>NOTE</b> 有些上下文会把b,w1,w2统称为权重</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgb4156bd" class="outline-4">
<h4 id="orgb4156bd"><span class="section-number-4">2.3.3.</span> 使用权重和偏置的实现</h4>
<div class="outline-text-4" id="text-2-3-3">
<ul class="org-ul">
<li>更改了公式的同时,我们也使用NumPy来实现感知机
<ul class="org-ul">
<li><p>
代码如下
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #3a81c3; font-weight: bold;">import</span> numpy <span style="color: #3a81c3; font-weight: bold;">as</span> np


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">AND</span><span style="color: #3a81c3;">(</span>x1, x2<span style="color: #3a81c3;">)</span>:
    <span style="color: #715ab1;">x</span> = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>x1, x2<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">w</span> = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>0.5, 0.5<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">b</span> = -0.7
    <span style="color: #715ab1;">tmp</span> = np.<span style="color: #3a81c3;">sum</span><span style="color: #3a81c3;">(</span>w * x<span style="color: #3a81c3;">)</span> + b
    <span style="color: #3a81c3; font-weight: bold;">if</span> tmp &lt;= 0:
        <span style="color: #3a81c3; font-weight: bold;">return</span> 0
    <span style="color: #3a81c3; font-weight: bold;">else</span>:
        <span style="color: #3a81c3; font-weight: bold;">return</span> 1


<span style="color: #3a81c3; font-weight: bold;">if</span> <span style="color: #3a81c3;">__name__</span> == <span style="color: #2d9574;">"__main__"</span>:
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>AND<span style="color: #6c3163;">(</span>0, 0<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>AND<span style="color: #6c3163;">(</span>1, 0<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>AND<span style="color: #6c3163;">(</span>0, 1<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>AND<span style="color: #6c3163;">(</span>1, 1<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">0</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">0</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">0</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">1</span>
</pre>
</div></li>
<li>这里权重和参数都是numpy array,他们相乘就是element-wise的相乘</li>
<li>相乘结果再用np.sum把结果累加,就实现了之前2-1中x1 * w1 + x2 * w2的效果</li>
<li>最后加上偏置,再和0比大小即可</li>
</ul></li>
<li><p>
我们用同样的方式可以创建成功与非门
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #3a81c3; font-weight: bold;">import</span> numpy <span style="color: #3a81c3; font-weight: bold;">as</span> np


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">NAND</span><span style="color: #3a81c3;">(</span>x1, x2<span style="color: #3a81c3;">)</span>:
    <span style="color: #715ab1;">x</span> = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>x1, x2<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">w</span> = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>-0.5, -0.5<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">b</span> = 0.7
    <span style="color: #715ab1;">tmp</span> = np.<span style="color: #3a81c3;">sum</span><span style="color: #3a81c3;">(</span>w * x<span style="color: #3a81c3;">)</span> + b
    <span style="color: #3a81c3; font-weight: bold;">if</span> tmp &lt;= 0:
        <span style="color: #3a81c3; font-weight: bold;">return</span> 0
    <span style="color: #3a81c3; font-weight: bold;">else</span>:
        <span style="color: #3a81c3; font-weight: bold;">return</span> 1


<span style="color: #3a81c3; font-weight: bold;">if</span> <span style="color: #3a81c3;">__name__</span> == <span style="color: #2d9574;">"__main__"</span>:
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>NAND<span style="color: #6c3163;">(</span>0, 0<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>NAND<span style="color: #6c3163;">(</span>1, 0<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>NAND<span style="color: #6c3163;">(</span>0, 1<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>NAND<span style="color: #6c3163;">(</span>1, 1<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">1</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">1</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">1</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">0</span>
</pre>
</div></li>
<li><p>
最后是同样的方式创建好或门
</p>
<div class="org-src-container">
<pre class="src src-python">
<span style="color: #3a81c3; font-weight: bold;">import</span> numpy <span style="color: #3a81c3; font-weight: bold;">as</span> np


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">OR</span><span style="color: #3a81c3;">(</span>x1, x2<span style="color: #3a81c3;">)</span>:
    <span style="color: #715ab1;">x</span> = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>x1, x2<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">w</span> = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>0.5, 0.5<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">b</span> = -0.2
    <span style="color: #715ab1;">tmp</span> = np.<span style="color: #3a81c3;">sum</span><span style="color: #3a81c3;">(</span>w * x<span style="color: #3a81c3;">)</span> + b
    <span style="color: #3a81c3; font-weight: bold;">if</span> tmp &lt;= 0:
        <span style="color: #3a81c3; font-weight: bold;">return</span> 0
    <span style="color: #3a81c3; font-weight: bold;">else</span>:
        <span style="color: #3a81c3; font-weight: bold;">return</span> 1


<span style="color: #3a81c3; font-weight: bold;">if</span> <span style="color: #3a81c3;">__name__</span> == <span style="color: #2d9574;">"__main__"</span>:
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>OR<span style="color: #6c3163;">(</span>0, 0<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>OR<span style="color: #6c3163;">(</span>1, 0<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>OR<span style="color: #6c3163;">(</span>0, 1<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>OR<span style="color: #6c3163;">(</span>1, 1<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">0</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">1</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">1</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">1</span>
</pre>
</div></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org99353ca" class="outline-3">
<h3 id="org99353ca"><span class="section-number-3">2.4.</span> 感知机的局限性</h3>
<div class="outline-text-3" id="text-2-4">
<ul class="org-ul">
<li>到目前为止,我们已经知道,感知机可以实现与门,与非门,或门,三种逻辑,现在我们考虑下异或门</li>
</ul>
</div>
<div id="outline-container-orgb9a8034" class="outline-4">
<h4 id="orgb9a8034"><span class="section-number-4">2.4.1.</span> 异或门</h4>
<div class="outline-text-4" id="text-2-4-1">
<ul class="org-ul">
<li><p>
所谓异或门,是指仅当x1或x2中一方为1时,才会输出1,如表格
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">x1</th>
<th scope="col" class="org-right">x2</th>
<th scope="col" class="org-right">y</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>
</tbody>
</table></li>
<li><p>
我们再次尝试使用之前的方法来寻找一个权重和偏移的组合,我们发现我们找不到这样一个组合,实际的情况是
</p>
<pre class="example" id="orgade1845">
用感知机是无法实现异或门的
</pre></li>
<li>为什么感知机无法实现异或门,我们可以用下面的例子来讲解一下
<ul class="org-ul">
<li><p>
我们首先将或门具体化,我们把一组可行的权重参数(b,w1,w2)=(-0.5,1.0,1.0) 带入到公式2.2,得到公式2.3
</p>
\begin{equation}
y =
   \begin{cases}
    0 & (-0.5 + w_1 x_1 + w_2 x_2 \leqslant 0) \\
    1 & (-0.5 + w_1 x_1 + w_2 x_2 > 0) \tag{2.3}
   \end{cases}
\end{equation}</li>
<li><p>
我们如果把x2看成是y的话,我们会得到这么一条直线y=-x+0.5,如图
</p>

<div id="org86feea9" class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/image/master/dlfs/2-6.png" alt="2-6.png" />
</p>
<p><span class="figure-number">Figure 6: </span>dlfs/2-6.png</p>
</div></li>
<li>这条直线把整个平面分成了两个部分:
<ol class="org-ol">
<li>灰色部分是感知机输出0的区域,我们看到(0,0)也在这个位置(圆圈)</li>
<li>白色部分是感知机输出1的区域,我们看到(0,1),(1,0),(1,1)都在这个区域(三角形)</li>
</ol></li>
<li><p>
我们来如法炮制,把异或门需要分开的四个点(两个圆圈,两个三角)也列在下图,我们会发现,我们找不到一个直
线能欧分割图中的圆圈和三角
</p>

<div id="org8e802ca" class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/image/master/dlfs/2-7.png" alt="2-7.png" />
</p>
<p><span class="figure-number">Figure 7: </span>dlfs/2-7.png</p>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org71d2a30" class="outline-4">
<h4 id="org71d2a30"><span class="section-number-4">2.4.2.</span> 线性和非线性</h4>
<div class="outline-text-4" id="text-2-4-2">
<ul class="org-ul">
<li><p>
图2-7是无法用一个直线来分割圆圈和三角,但是将"直线"这个限制去掉,就可以实现了,比如下图,我们使用曲线
来完成了这个区分
</p>

<div id="orge029242" class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/image/master/dlfs/2-8.png" alt="2-8.png" />
</p>
<p><span class="figure-number">Figure 8: </span>dlfs/2-8.png</p>
</div></li>
<li>上图这种由曲线分割的区域就叫做非线性空间.之前用直线分割的区域自然就叫线性空间啦</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orge342f3d" class="outline-3">
<h3 id="orge342f3d"><span class="section-number-3">2.5.</span> 多层感知机</h3>
<div class="outline-text-3" id="text-2-5">
<ul class="org-ul">
<li><p>
感知机无法表示异或门让人遗憾,但是感知机可以通过"叠加层"来完成这个任务
</p>
<pre class="example" id="org12e5051">
准确的是说,应该是"单层感知机"无法表示异或门
</pre></li>
<li>我们下面通过电路来理解一下,什么是叠加层</li>
</ul>
</div>
<div id="outline-container-orgcd9b8d0" class="outline-4">
<h4 id="orgcd9b8d0"><span class="section-number-4">2.5.1.</span> 已有门电路组合</h4>
<div class="outline-text-4" id="text-2-5-1">
<ul class="org-ul">
<li>异或门有很多种制作方法,其中最经典的做法是组合我们前面学到的三种门:与门,与非门和或门
<ul class="org-ul">
<li><p>
我们首先以下图来表示与门,与非门和或门
</p>

<div id="org9da7acc" class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/image/master/dlfs/2-9.png" alt="2-9.png" />
</p>
<p><span class="figure-number">Figure 9: </span>dlfs/2-9.png</p>
</div></li>
<li><p>
异或门就可以使用上面的元器件,如下进行组合配置,最终实现异或门
</p>

<div id="orgb1b8e19" class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/image/master/dlfs/2-11.png" alt="2-11.png" />
</p>
<p><span class="figure-number">Figure 10: </span>dlfs/2-11.png</p>
</div></li>
<li><p>
我们可以使用如下的真值表来确认我们的配置正确.
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">x1</th>
<th scope="col" class="org-right">x2</th>
<th scope="col" class="org-right">s1</th>
<th scope="col" class="org-right">s2</th>
<th scope="col" class="org-right">y</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>
</tbody>
</table></li>
<li>上表中:x1,x2与非得到s1, x1,x2或得到s2, s1,s2与得到y</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org377950e" class="outline-4">
<h4 id="org377950e"><span class="section-number-4">2.5.2.</span> 异或门的实现</h4>
<div class="outline-text-4" id="text-2-5-2">
<ul class="org-ul">
<li><p>
我们使用代码来实现2-11所示的异或门
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #3a81c3; font-weight: bold;">import</span> numpy <span style="color: #3a81c3; font-weight: bold;">as</span> np


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">AND</span><span style="color: #3a81c3;">(</span>x1, x2<span style="color: #3a81c3;">)</span>:
    <span style="color: #715ab1;">x</span> = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>x1, x2<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">w</span> = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>0.5, 0.5<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">b</span> = -0.7
    <span style="color: #715ab1;">tmp</span> = np.<span style="color: #3a81c3;">sum</span><span style="color: #3a81c3;">(</span>w * x<span style="color: #3a81c3;">)</span> + b
    <span style="color: #3a81c3; font-weight: bold;">if</span> tmp &lt;= 0:
        <span style="color: #3a81c3; font-weight: bold;">return</span> 0
    <span style="color: #3a81c3; font-weight: bold;">else</span>:
        <span style="color: #3a81c3; font-weight: bold;">return</span> 1


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">NAND</span><span style="color: #3a81c3;">(</span>x1, x2<span style="color: #3a81c3;">)</span>:
    <span style="color: #715ab1;">x</span> = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>x1, x2<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">w</span> = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>-0.5, -0.5<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">b</span> = 0.7
    <span style="color: #715ab1;">tmp</span> = np.<span style="color: #3a81c3;">sum</span><span style="color: #3a81c3;">(</span>w * x<span style="color: #3a81c3;">)</span> + b
    <span style="color: #3a81c3; font-weight: bold;">if</span> tmp &lt;= 0:
        <span style="color: #3a81c3; font-weight: bold;">return</span> 0
    <span style="color: #3a81c3; font-weight: bold;">else</span>:
        <span style="color: #3a81c3; font-weight: bold;">return</span> 1


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">OR</span><span style="color: #3a81c3;">(</span>x1, x2<span style="color: #3a81c3;">)</span>:
    <span style="color: #715ab1;">x</span> = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>x1, x2<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">w</span> = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>0.5, 0.5<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">b</span> = -0.2
    <span style="color: #715ab1;">tmp</span> = np.<span style="color: #3a81c3;">sum</span><span style="color: #3a81c3;">(</span>w * x<span style="color: #3a81c3;">)</span> + b
    <span style="color: #3a81c3; font-weight: bold;">if</span> tmp &lt;= 0:
        <span style="color: #3a81c3; font-weight: bold;">return</span> 0
    <span style="color: #3a81c3; font-weight: bold;">else</span>:
        <span style="color: #3a81c3; font-weight: bold;">return</span> 1


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">XOR</span><span style="color: #3a81c3;">(</span>x1, x2<span style="color: #3a81c3;">)</span>:
    <span style="color: #715ab1;">s1</span> = NAND<span style="color: #3a81c3;">(</span>x1, x2<span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">s2</span> = OR<span style="color: #3a81c3;">(</span>x1, x2<span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">y</span> = AND<span style="color: #3a81c3;">(</span>s1, s2<span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3; font-weight: bold;">return</span> y


<span style="color: #3a81c3; font-weight: bold;">if</span> <span style="color: #3a81c3;">__name__</span> == <span style="color: #2d9574;">"__main__"</span>:
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>XOR<span style="color: #6c3163;">(</span>0, 0<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>XOR<span style="color: #6c3163;">(</span>1, 0<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>XOR<span style="color: #6c3163;">(</span>0, 1<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>XOR<span style="color: #6c3163;">(</span>1, 1<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">0</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">1</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">1</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">0</span>
</pre>
</div></li>
<li>我们试着把电路图转换为感知机来表示
<ul class="org-ul">
<li><p>
如图2-13
</p>

<div id="orgfc6cd8c" class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/image/master/dlfs/2-13.png" alt="2-13.png" />
</p>
<p><span class="figure-number">Figure 11: </span>dlfs/2-13.png</p>
</div></li>
<li><p>
上图和前面的与门,与非门,或门的感知机图不同.事实上之前的图都是单层感知机,而异或门是2层感知机
</p>
<pre class="example" id="orgc2573c4">
也有文献把这个叫做3层感知机, 这取决于如何看待最后y是不是一层
</pre></li>
<li>这种2层感知机可以看做是流水线的组装作业.第一层的工人对传送过来的零件进行加工,完成后再传送给第二层
的工人.第二层的工作对第一层工人传递过来的零件进行加工,完成后出货(输出)</li>
<li><p>
通过这样的2层结构,感知机得以实现异或门.换句话说,就是
</p>
<pre class="example" id="org8ed8b96">
单层感知机无法表达的东西,通过增加一层就可以解决.也就是说,通过增加层,感知机能进行更加灵活的表示
</pre></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org421ac61" class="outline-3">
<h3 id="org421ac61"><span class="section-number-3">2.6.</span> 从与非门到计算机</h3>
<div class="outline-text-3" id="text-2-6">
<ul class="org-ul">
<li>人们通常认为计算机很复杂,但是令人惊讶的是,仅仅通过与非门(NAND)一个逻辑电路的不同组合,就能实现.</li>
<li>这也就说明理论上,感知机(多层)也可以表示计算机.我们只需要记住这个结论就好</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org51067c6" class="outline-2">
<h2 id="org51067c6"><span class="section-number-2">3.</span> 神经网络</h2>
<div class="outline-text-2" id="text-3">
<ul class="org-ul">
<li>上一章我们学习了感知机,关于感知机既有好消息,也有坏消息:
<ul class="org-ul">
<li>好消息是: 即便对于复杂函数,感知机也是可以通过增加层的方式来表达出来</li>
<li>坏消息是: 设定权重的工作,还是由人工进行的</li>
</ul></li>
<li>神经网络的出现,就是Eileen解决刚才的坏消息.具体来说就是,神经网络可以自动的从数据中学习到合适的权重
参数</li>
</ul>
</div>
<div id="outline-container-orgbe754e9" class="outline-3">
<h3 id="orgbe754e9"><span class="section-number-3">3.1.</span> 从感知机到神经网络</h3>
<div class="outline-text-3" id="text-3-1">
</div>
<div id="outline-container-org8057827" class="outline-4">
<h4 id="org8057827"><span class="section-number-4">3.1.1.</span> 神经网路的例子</h4>
<div class="outline-text-4" id="text-3-1-1">
<ul class="org-ul">
<li>我们用图来表示神经网路
<ul class="org-ul">
<li><p>
图3-1
</p>

<div id="org9aac87b" class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/image/master/dlfs/3-1.png" alt="3-1.png" />
</p>
<p><span class="figure-number">Figure 12: </span>dlfs/3-1.png</p>
</div></li>
<li>上图中最左边一层是输入层.本书称之为第0层</li>
<li>最右边一层是输出层.本书称之为第1层</li>
<li>中间一层是隐藏层,"隐藏"一词的意思是,隐藏层中的神经元(和输入层,输出层不同)肉眼看不到.本书称之为第2层</li>
<li>上图中一共有三层神经网络构成,但是只有两岑神经网络有权重,所以我们本书称之为"2层网络",本书之后都是
这种做法: 根据实质上拥有权重的层数来确定名称(也就是,输入层,隐藏层,输出层总数减去1)</li>
<li><b>Note</b> 有些书会把上图的叫做"3层网络"</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org34fc53a" class="outline-4">
<h4 id="org34fc53a"><span class="section-number-4">3.1.2.</span> 复习感知机</h4>
<div class="outline-text-4" id="text-3-1-2">
<ul class="org-ul">
<li>在观察神经网络中信号的传递方法之前,我们先复习一下感知机
<ul class="org-ul">
<li><p>
感知机如图
</p>

<div id="orgbd471dc" class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/image/master/dlfs/3-2.png" alt="3-2.png" />
</p>
<p><span class="figure-number">Figure 13: </span>dlfs/3-2.png</p>
</div></li>
<li><p>
图中的感知机公式如下
</p>
\begin{equation}
y =
   \begin{cases}
    0 & (b + w_1 x_1 + w_2 x_2 \leqslant 0) \\
    1 & (b + w_1 x_1 + w_2 x_2 > 0) \tag{3.1}
   \end{cases}
\end{equation}</li>
<li>w1,w2是权重参数,b是偏置参数</li>
<li><p>
在图3-2中,并没有画出偏置b,如果要画出b,可以向下图一样,让b和w1,w2一个地位, 1和x1,x2一个地址
</p>

<div id="org24afdaa" class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/image/master/dlfs/3-3.png" alt="3-3.png" />
</p>
<p><span class="figure-number">Figure 14: </span>dlfs/3-3.png</p>
</div></li>
</ul></li>
<li>公式3.1有两个条件,看起来不够直观(主要是 \(b+w_1x_1+w_2x_2\) 重复了两次. 现在我们把公式3.1改写一下,改
成如下两个公式:
<ul class="org-ul">
<li><p>
公式3.2,重复部分写到一块
</p>
\begin{equation}
y = h(b+w_1x_1+w_2x_2) \tag{3.2}
\end{equation}</li>
<li><p>
公式3.3, x指代 \(b+w_1x_1+w_2x_2\)
</p>
\begin{equation}
h(x) =
   \begin{cases}
    0 & (x \leqslant 0) \\
    1 & (x > 0) \tag{3.3}
   \end{cases}
\end{equation}</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org7ac327f" class="outline-4">
<h4 id="org7ac327f"><span class="section-number-4">3.1.3.</span> 激活函数登场</h4>
<div class="outline-text-4" id="text-3-1-3">
<ul class="org-ul">
<li>刚才登场的函数h(x)会将输入信号的总和转换为输出信号,这种函数一般称之为激活函数(activation function)</li>
<li>我们把上面的公式3.2再次进行拆分,得到如下两个公式:
<ul class="org-ul">
<li><p>
公式3.2的右边拆分得到公式3.4
</p>
\begin{equation}
a = b + w_1 x_1 + w_2 x_2 \tag{3.4}
\end{equation}</li>
<li><p>
公式3.2的左边拆分得到公式3.5
</p>
\begin{equation}
y = h(a) \tag{3.5}
\end{equation}</li>
<li>改成两个公式后我们可以证明理解: 权重和偏置总和记为a(3.4), 然后h()函数将a输出为y.h()函数是针对于a
的函数(而不是针对于w或者x)</li>
<li><p>
有了公式3.4和和3.5后,我们的神经元内部也可以画出内容来了,如下
</p>

<div id="org4ca24eb" class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/image/master/dlfs/3-4.png" alt="3-4.png" />
</p>
<p><span class="figure-number">Figure 15: </span>dlfs/3-4.png</p>
</div></li>
<li>下图是神经元前后两种画法的对比,下面的图告诉我们,神经元不一定是最后一个才有这种h()函数,作为中间神经元也可以</li>
</ul></li>
<li>下一节我们会详细介绍激活函数.激活函数是链接感知机和神经网络的桥梁:
<ul class="org-ul">
<li>感知机这个词,绝大多数情况下是指的"朴素感知机",其特点是是单层网络,且使用"阶跃函数"(突然发生跳变的
函数,比如公式3.3)作为激活函数</li>
<li>而使用多层网络,并且使用"sigmoid函数"作为激活函数的多层感知机,绝大多数情况下会使用"神经网络"这个词</li>
</ul></li>
<li><p>
我们再多提一句,上一节介绍的多层网络,其激活函数还是普通"阶跃函数". 这种多层感知机是为了理解让我们理
解如下概念,其实不具有实用性
</p>
<pre class="example" id="orgbebc577">
多层感知机能够进行非线性表示
</pre></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org0675d07" class="outline-3">
<h3 id="org0675d07"><span class="section-number-3">3.2.</span> 激活函数</h3>
<div class="outline-text-3" id="text-3-2">
<ul class="org-ul">
<li><p>
上一章说到,朴素感知机使用的激活函数为阶跃函数(公式3.3就是一个阶跃函数), 所谓阶跃函数, 其定义如下.
</p>
<pre class="example" id="orgc34d2c7">
阶跃函数，指函数值突然发生跳变的函数。例如从0突然变成100，从0突然变成正无穷，
从负无穷突然变成正无穷，都可以叫阶跃函数。
</pre></li>
<li>朴素感知机如果使用了其他函数作为激活函数会怎样? 从定义看来,如果使用了非阶跃函数作为激活函数,那么就
不能再叫朴素感知机了,而是应该叫神经网络了(当然如果层数在多一层,神经网络的名字,就更准确了)</li>
<li>作为激活函数的非阶跃函数,最出名的,就是sigmoid函数了</li>
</ul>
</div>
<div id="outline-container-orgfcc4d97" class="outline-4">
<h4 id="orgfcc4d97"><span class="section-number-4">3.2.1.</span> sigmoid函数</h4>
<div class="outline-text-4" id="text-3-2-1">
<ul class="org-ul">
<li>神经网络中最经常使用的一个激活函数就是sigmoid函数:
<ul class="org-ul">
<li><p>
公式如下
</p>
\begin{equation}
h(x) = \frac{1}{1 + \exp(-x)} \tag{3.6}
\end{equation}</li>
<li>公式中的 \(\exp(-x)\) 是 \(e^{-x}\) 的意思</li>
<li>e是纳皮尔常数2.7182&#x2026;</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgb500cb7" class="outline-4">
<h4 id="orgb500cb7"><span class="section-number-4">3.2.2.</span> 阶跃函数的实现</h4>
<div class="outline-text-4" id="text-3-2-2">
<ul class="org-ul">
<li><p>
前面已经说了,公式3.3就是阶跃函数,我们可以使用python很容易的实现这个阶跃函数
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">step_function</span><span style="color: #3a81c3;">(</span>x<span style="color: #3a81c3;">)</span>:
    <span style="color: #3a81c3; font-weight: bold;">if</span> x &gt; 0:
        <span style="color: #3a81c3; font-weight: bold;">return</span> 1
    <span style="color: #3a81c3; font-weight: bold;">else</span>:
        <span style="color: #3a81c3; font-weight: bold;">return</span> 0
</pre>
</div></li>
<li>我们后面要把激活函数打印出来,那么输入就必须要支持数组(这里是numpy数组),所以我们要升级下我们的函数
让它支持numpy数组作为参数.当然输出也就是相同长度的numpy数组啦
<ul class="org-ul">
<li><p>
代码如下
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #3a81c3; font-weight: bold;">import</span> numpy <span style="color: #3a81c3; font-weight: bold;">as</span> np


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">step_function</span><span style="color: #3a81c3;">(</span>x<span style="color: #3a81c3;">)</span>:
    <span style="color: #715ab1;">y</span> = x &gt; 0
    <span style="color: #3a81c3; font-weight: bold;">return</span> y.astype<span style="color: #3a81c3;">(</span>np.int64<span style="color: #3a81c3;">)</span>


<span style="color: #3a81c3; font-weight: bold;">if</span> <span style="color: #3a81c3;">__name__</span> == <span style="color: #2d9574;">"__main__"</span>:
    <span style="color: #715ab1;">x</span> = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>-1.0, 1.0, 2.0<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"""|x|=&gt;"""</span>, x<span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">y</span> = x &gt; 0
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"""|y|=&gt;"""</span>, y<span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">z</span> = y.astype<span style="color: #3a81c3;">(</span>np.int64<span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"""|z|=&gt;"""</span>, z<span style="color: #3a81c3;">)</span>

    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"""|step_function(x)|=&gt;"""</span>, step_function<span style="color: #6c3163;">(</span>x<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org92d6ef4" class="outline-4">
<h4 id="org92d6ef4"><span class="section-number-4">3.2.3.</span> 阶跃函数的图形</h4>
<div class="outline-text-4" id="text-3-2-3">
<ul class="org-ul">
<li>我们现在就使用matplotlib库来打印阶跃函数的图形(刚才的支持numpy array输入就起到作用了)
<ul class="org-ul">
<li><p>
代码如下
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #3a81c3; font-weight: bold;">import</span> numpy <span style="color: #3a81c3; font-weight: bold;">as</span> np
<span style="color: #3a81c3; font-weight: bold;">import</span> matplotlib.pyplot <span style="color: #3a81c3; font-weight: bold;">as</span> plt


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">step_function</span><span style="color: #3a81c3;">(</span>x<span style="color: #3a81c3;">)</span>:
    <span style="color: #3a81c3; font-weight: bold;">return</span> np.array<span style="color: #3a81c3;">(</span>x &gt; 0, dtype=np.int64<span style="color: #3a81c3;">)</span>


<span style="color: #715ab1;">x</span> = np.arange<span style="color: #3a81c3;">(</span>-5.0, 5.0, 0.1<span style="color: #3a81c3;">)</span>
<span style="color: #715ab1;">y</span> = step_function<span style="color: #3a81c3;">(</span>x<span style="color: #3a81c3;">)</span>
plt.plot<span style="color: #3a81c3;">(</span>x, y<span style="color: #3a81c3;">)</span>
plt.ylim<span style="color: #3a81c3;">(</span>-0.1, 1.1<span style="color: #3a81c3;">)</span>  <span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">range for y-axis</span>
plt.show<span style="color: #3a81c3;">()</span>
</pre>
</div></li>
<li><p>
图形如下
</p>

<div id="orga295407" class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/image/master/dlfs/3-6.png" alt="3-6.png" />
</p>
<p><span class="figure-number">Figure 16: </span>dlfs/3-6.png</p>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org29de1b4" class="outline-4">
<h4 id="org29de1b4"><span class="section-number-4">3.2.4.</span> sigmoid 函数的实现</h4>
<div class="outline-text-4" id="text-3-2-4">
<ul class="org-ul">
<li>我们还可以使用类似代码来完成sigmod的图形
<ul class="org-ul">
<li><p>
代码如下,注意标量(1)和numpy array无论进行加法还是除法都可以"先把标量扩展成向量"在和向量进行计算.
这是numpy库的广播特性其了作用
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #3a81c3; font-weight: bold;">import</span> numpy <span style="color: #3a81c3; font-weight: bold;">as</span> np
<span style="color: #3a81c3; font-weight: bold;">import</span> matplotlib.pyplot <span style="color: #3a81c3; font-weight: bold;">as</span> plt


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">sigmoid</span><span style="color: #3a81c3;">(</span>x<span style="color: #3a81c3;">)</span>:
    <span style="color: #3a81c3; font-weight: bold;">return</span> 1 / <span style="color: #3a81c3;">(</span>1 + np.exp<span style="color: #6c3163;">(</span>-x<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>


<span style="color: #715ab1;">x</span> = np.arange<span style="color: #3a81c3;">(</span>-5.0, 5.0, 0.1<span style="color: #3a81c3;">)</span>
<span style="color: #715ab1;">y</span> = sigmoid<span style="color: #3a81c3;">(</span>x<span style="color: #3a81c3;">)</span>
plt.plot<span style="color: #3a81c3;">(</span>x, y<span style="color: #3a81c3;">)</span>
plt.ylim<span style="color: #3a81c3;">(</span>-0.1, 1.1<span style="color: #3a81c3;">)</span>  <span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">range for y-axis</span>
plt.show<span style="color: #3a81c3;">()</span>
</pre>
</div></li>

<li><p>
图形如下
</p>

<div id="org2888c73" class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/image/master/dlfs/3-7.png" alt="3-7.png" />
</p>
<p><span class="figure-number">Figure 17: </span>dlfs/3-7.png</p>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orge1e4c9d" class="outline-4">
<h4 id="orge1e4c9d"><span class="section-number-4">3.2.5.</span> sigmoid函数和阶跃函数的比较</h4>
<div class="outline-text-4" id="text-3-2-5">
<ul class="org-ul">
<li>我们现在比较一下sigmod函数和阶跃函数
<ul class="org-ul">
<li><p>
把两者的图放到同一个坐标后如下
</p>

<div id="orgf111825" class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/image/master/dlfs/3-8.png" alt="3-8.png" />
</p>
<p><span class="figure-number">Figure 18: </span>dlfs/3-8.png</p>
</div></li>
<li>首先注意到的是,两者的"平滑性"不同:
<ul class="org-ul">
<li>阶跃函数以0为界,输出发生剧烈变化</li>
<li>sigmoid函数是一条平滑的曲线,输出随着输入发生连续性的变化. sigmoid函数的平滑性对于神经网络的学
习有重要的意义</li>
</ul></li>
<li>两者另外的不同在于返回值:
<ul class="org-ul">
<li>阶跃函数只能返回1,0,使用阶跃函数的感知机中神经元之间流动的是二元信号(0,1)</li>
<li>sigmoid函数能够返回0.731, 0.880等实数,使用sigmoid的神经网络中神经元之间流动的就是连续的实数的
信号</li>
</ul></li>
<li><p>
两者的第一个共同点在于其形状相似,两者都能做到
</p>
<pre class="example" id="org9627124">
输入小时,输出接近0(为0), 随着输入增大,输出像1靠近(变成1)
</pre></li>
<li>两者的第二个共同点是不管输入信号多大或者多小,输出信号的值都在0和1之间</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgc64745b" class="outline-4">
<h4 id="orgc64745b"><span class="section-number-4">3.2.6.</span> 非线性函数</h4>
<div class="outline-text-4" id="text-3-2-6">
<ul class="org-ul">
<li>阶跃函数和sigmoid函数的最重要相同点,是他们都是非线性函数</li>
<li><p>
我们定义一下线性函数,那么为什么阶跃函数和sigmoid函数都是非线性函数就很明显了
</p>
<pre class="example" id="org07b107a">
所谓线性函数,就是输出值是输入值的常数倍,比如人h(x)=cx.因此线性函数是一条笔直的直线
</pre></li>
<li>由于阶跃函数和sigmoid函数都没有像线性函数一样"呈现出一条直线",所以他们都是非线性函数</li>
<li>神经网络的激活函数必须使用非线性函数,换句话说,在神经网络里,激活函数不能使用线性函数</li>
<li>为什么会有这个规定呢?
<ul class="org-ul">
<li>首先神经网络的定义,就是必须要多层的感知机,一层的是朴素感知机(朴素感知机是可以使用线性函数的)</li>
<li>多层肯定是为了表达能力更强,但是如果使用了线性函数的话,加深神经网络的层数就没有意义了</li>
</ul></li>
<li>为什么使用了线性函数加深网络层数就没有意义了呢?
<ul class="org-ul">
<li>我们举个反例,假设把线性函数 \(h(x) = cx\) 作为激活函数,把 \(y(x)=h(h(h(x)))\) 运算,对应3层神经网络,
这个就相当于 \(y(x) = c \times c \times c \times x\) , 那其实就是 \(y(x)=ax (a = c^3)\)</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org6d5b75d" class="outline-4">
<h4 id="org6d5b75d"><span class="section-number-4">3.2.7.</span> ReLU函数</h4>
<div class="outline-text-4" id="text-3-2-7">
<ul class="org-ul">
<li>神经网络的发展史上,早期使用sigmoid函数比较多,而最近则主要使用ReLU函数</li>
<li>ReLU函数在输入大于0的时候,直接输出该值,在输入小于等于0的时候,输出0
<ul class="org-ul">
<li><p>
其公式如下
</p>
\begin{equation}
h(x) =
   \begin{cases}
    x & (x > 0) \\
    0 & (x \leqslant 0) \tag{3.7}
   \end{cases}
\end{equation}</li>
<li><p>
其python实现如下
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #3a81c3; font-weight: bold;">import</span> numpy <span style="color: #3a81c3; font-weight: bold;">as</span> np


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">relu</span><span style="color: #3a81c3;">(</span>x<span style="color: #3a81c3;">)</span>:
    <span style="color: #3a81c3; font-weight: bold;">return</span> np.maximum<span style="color: #3a81c3;">(</span>0, x<span style="color: #3a81c3;">)</span>
</pre>
</div></li>
<li><p>
其绘图如下
</p>

<div id="orgf25ef34" class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/image/master/dlfs/3-9.png" alt="3-9.png" />
</p>
<p><span class="figure-number">Figure 19: </span>dlfs/3-9.png</p>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org04bf13e" class="outline-3">
<h3 id="org04bf13e"><span class="section-number-3">3.3.</span> 多维数组的运算</h3>
<div class="outline-text-3" id="text-3-3">
<ul class="org-ul">
<li>numpy的多维数组运算能够高效的实现神经网络,所以我们这里停下来先学习一下numpy多维数组的运算</li>
</ul>
</div>
<div id="outline-container-orgaa428ae" class="outline-4">
<h4 id="orgaa428ae"><span class="section-number-4">3.3.1.</span> 多维数组</h4>
<div class="outline-text-4" id="text-3-3-1">
<ul class="org-ul">
<li>超过1维的数组就是多维数组.但是为了实现的一致性,从1维到n维,numpy的接口都是一样的,比如:
<ul class="org-ul">
<li>都有shape函数,返回一个tuple,来获取多维数组在某个维度上面成员的数目,对于一维数组也是返回元祖,只不
过,这个元祖只有一个成员</li>
<li>都有可以通过np.ndim()函数(或者ndim成员变量)获取其维度</li>
<li><p>
一维数组例子如下
</p>
<div class="org-src-container">
<pre class="src src-shell">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; A = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>1, 2, 3, 4<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; print<span style="color: #3a81c3;">(</span>A<span style="color: #3a81c3;">)</span>
<span style="color: #3a81c3;">[</span>1 2 3 4<span style="color: #3a81c3;">]</span>
&gt;&gt;&gt; A.ndim
1
&gt;&gt;&gt; np.ndim<span style="color: #3a81c3;">(</span>A<span style="color: #3a81c3;">)</span>
1
&gt;&gt;&gt; A.shape
<span style="color: #3a81c3;">(</span>4,<span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; A.shape<span style="color: #3a81c3;">[</span>0<span style="color: #3a81c3;">]</span>
4
</pre>
</div></li>
<li><p>
二维数组的例子如下
</p>
<div class="org-src-container">
<pre class="src src-shell">&gt;&gt;&gt; B = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span><span style="color: #2d9574;">[</span>1, 2<span style="color: #2d9574;">]</span>, <span style="color: #2d9574;">[</span>3, 4<span style="color: #2d9574;">]</span>, <span style="color: #2d9574;">[</span>5, 6<span style="color: #2d9574;">]</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; print<span style="color: #3a81c3;">(</span>B<span style="color: #3a81c3;">)</span>
<span style="color: #3a81c3;">[</span><span style="color: #6c3163;">[</span>1 2<span style="color: #6c3163;">]</span>
 <span style="color: #6c3163;">[</span>3 4<span style="color: #6c3163;">]</span>
 <span style="color: #6c3163;">[</span>5 6<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">]</span>
&gt;&gt;&gt; np.ndim<span style="color: #3a81c3;">(</span>B<span style="color: #3a81c3;">)</span>
2
&gt;&gt;&gt; B.ndim
2
&gt;&gt;&gt; B.shape
<span style="color: #3a81c3;">(</span>3, 2<span style="color: #3a81c3;">)</span>&gt;&gt;&gt; B = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span><span style="color: #2d9574;">[</span>1, 2<span style="color: #2d9574;">]</span>, <span style="color: #2d9574;">[</span>3, 4<span style="color: #2d9574;">]</span>, <span style="color: #2d9574;">[</span>5, 6<span style="color: #2d9574;">]</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; print<span style="color: #3a81c3;">(</span>B<span style="color: #3a81c3;">)</span>
<span style="color: #3a81c3;">[</span><span style="color: #6c3163;">[</span>1 2<span style="color: #6c3163;">]</span>
 <span style="color: #6c3163;">[</span>3 4<span style="color: #6c3163;">]</span>
 <span style="color: #6c3163;">[</span>5 6<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">]</span>
&gt;&gt;&gt; np.ndim<span style="color: #3a81c3;">(</span>B<span style="color: #3a81c3;">)</span>
2
&gt;&gt;&gt; B.ndim
2
&gt;&gt;&gt; B.shape
<span style="color: #3a81c3;">(</span>3, 2<span style="color: #3a81c3;">)</span>
</pre>
</div></li>
<li>这里生成了一个 \(3 \times 2\) 的数组. \(3 \times 2\) 的数组表示第一个维度有3个成员,第二个维度有2个成
员.</li>
<li><p>
二维数组也称为矩阵(matrix),横向为行(row),纵向为列(column),如下图
</p>

<div id="org11311f3" class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/image/master/dlfs/3-10.png" alt="3-10.png" />
</p>
<p><span class="figure-number">Figure 20: </span>dlfs/3-10.png</p>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgcf2bc8e" class="outline-4">
<h4 id="orgcf2bc8e"><span class="section-number-4">3.3.2.</span> 矩阵乘法</h4>
<div class="outline-text-4" id="text-3-3-2">
<ul class="org-ul">
<li>下面我们来介绍矩阵(二维数组)乘法
<ul class="org-ul">
<li><p>
如图3-11,就是两个 \(2 \times 2\) 的矩阵相乘
</p>

<div id="orgf3f76db" class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/image/master/dlfs/3-11.png" alt="3-11.png" />
</p>
<p><span class="figure-number">Figure 21: </span>dlfs/3-11.png</p>
</div></li>
<li>本书中矩阵使用黑色斜体大写表示,比如矩阵 \(\boldsymbol{A}\) 和矩阵 \(\boldsymbol{B}\)</li>
<li>matrix乘法的第M行第N列是由 $\boldsymbol{A}$的第M行乘以$\boldsymbol{B}$的第N列得到的结果.比如
\(\boldsymbol{A}\) 的第2行和 \(\boldsymbol{B}\) 的第1列相乘,就是新矩阵的第2行第1列的元素</li>
<li><p>
上述过程用python表示如下
</p>
<div class="org-src-container">
<pre class="src src-shell">Type <span style="color: #2d9574;">"help"</span>, <span style="color: #2d9574;">"copyright"</span>, <span style="color: #2d9574;">"credits"</span> or <span style="color: #2d9574;">"license"</span> for more information.
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; A = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span><span style="color: #2d9574;">[</span>1, 2<span style="color: #2d9574;">]</span>, <span style="color: #2d9574;">[</span>3, 4<span style="color: #2d9574;">]</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; A.shape
<span style="color: #3a81c3;">(</span>2, 2<span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; B = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span><span style="color: #2d9574;">[</span>5, 6<span style="color: #2d9574;">]</span>, <span style="color: #2d9574;">[</span>7,8<span style="color: #2d9574;">]</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; B.shape
<span style="color: #3a81c3;">(</span>2, 2<span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; np.dot<span style="color: #3a81c3;">(</span>A,B<span style="color: #3a81c3;">)</span>
<span style="color: #6c3163; font-weight: bold;">array</span><span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span><span style="color: #2d9574;">[</span>19, 22<span style="color: #2d9574;">]</span>,
       <span style="color: #2d9574;">[</span>43, 50<span style="color: #2d9574;">]</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt;
</pre>
</div></li>
</ul></li>
<li>上面的例子是相乘的两个矩阵的shape完全一致的情况,但是很多时候相乘的矩阵的shape是不一致的.不一样shape
的两个矩阵只有一种情况可以相乘: 那就是第一个矩阵Shape的最后一个维度,要和下一个矩阵的第一个维度相同
<ul class="org-ul">
<li><p>
矩阵A是 \(3 \times 2\), 矩阵B是 \(2 \times 3\), 两者可以相乘
</p>

<div id="org23601ce" class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/image/master/dlfs/3-12.png" alt="3-12.png" />
</p>
<p><span class="figure-number">Figure 22: </span>dlfs/3-12.png</p>
</div></li>
</ul></li>
<li>第二个例子就比较特别了,那就是当矩阵A是二维矩阵,而B是一个一维数组的情况.
<ul class="org-ul">
<li><p>
先看图
</p>

<div id="org50327f3" class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/image/master/dlfs/3-13.png" alt="3-13.png" />
</p>
<p><span class="figure-number">Figure 23: </span>dlfs/3-13.png</p>
</div></li>
<li><p>
再看代码
</p>
<div class="org-src-container">
<pre class="src src-shell">&gt;&gt;&gt; A = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span><span style="color: #2d9574;">[</span>1,2<span style="color: #2d9574;">]</span>, <span style="color: #2d9574;">[</span>3,4<span style="color: #2d9574;">]</span>, <span style="color: #2d9574;">[</span>5,6<span style="color: #2d9574;">]</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; A.shape
<span style="color: #3a81c3;">(</span>3, 2<span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; B = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>7,8<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; B.shape
<span style="color: #3a81c3;">(</span>2,<span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; np.dot<span style="color: #3a81c3;">(</span>A, B<span style="color: #3a81c3;">)</span>
<span style="color: #6c3163; font-weight: bold;">array</span><span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>23, 53, 83<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
</pre>
</div></li>
</ul></li>
<li>上面的这个二维矩阵和一位数组相乘的例子看似简单,但是其实隐藏着numpy的非常重要的内部逻辑,我们需要详
细说一下</li>
<li><p>
其实对于矩阵来说,只能是矩阵和矩阵相乘.比如shape为(3,2)的只能和(2,x)的相乘,那么上面的例子中A和B就
不能相乘,A只能和一个shape为(2,x)的C相乘,例子如下
</p>
<div class="org-src-container">
<pre class="src src-shell">&gt;&gt;&gt; A
<span style="color: #6c3163; font-weight: bold;">array</span><span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span><span style="color: #2d9574;">[</span>1, 2<span style="color: #2d9574;">]</span>,
       <span style="color: #2d9574;">[</span>3, 4<span style="color: #2d9574;">]</span>,
       <span style="color: #2d9574;">[</span>5, 6<span style="color: #2d9574;">]</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; A.shape
<span style="color: #3a81c3;">(</span>3, 2<span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; C = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span><span style="color: #2d9574;">[</span>7<span style="color: #2d9574;">]</span>,<span style="color: #2d9574;">[</span>8<span style="color: #2d9574;">]</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; C
<span style="color: #6c3163; font-weight: bold;">array</span><span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span><span style="color: #2d9574;">[</span>7<span style="color: #2d9574;">]</span>,
       <span style="color: #2d9574;">[</span>8<span style="color: #2d9574;">]</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; C.shape
<span style="color: #3a81c3;">(</span>2, 1<span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; np.dot<span style="color: #3a81c3;">(</span>A,C<span style="color: #3a81c3;">)</span>
<span style="color: #6c3163; font-weight: bold;">array</span><span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span><span style="color: #2d9574;">[</span>23<span style="color: #2d9574;">]</span>,
       <span style="color: #2d9574;">[</span>53<span style="color: #2d9574;">]</span>,
       <span style="color: #2d9574;">[</span>83<span style="color: #2d9574;">]</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; np.dot<span style="color: #3a81c3;">(</span>A,C<span style="color: #3a81c3;">)</span>.shape
<span style="color: #3a81c3;">(</span>3, 1<span style="color: #3a81c3;">)</span>
</pre>
</div></li>
<li>但是这样就太不方便了,我们的一维数组要转换成shape为(N,1)的二维数组.然后再乘以(X,N)的矩阵.我们的numpy
是不答应的.numpy想了一个办法,更改了规则:
<ul class="org-ul">
<li><p>
数学角度讲,需要两个维度(就是ndim属性)相同的张量,且第一个张量的最后一位等于第二个张量第一位的两个张量相乘
</p>
<div class="org-src-container">
<pre class="src src-shell">&gt;&gt;&gt; A
<span style="color: #6c3163; font-weight: bold;">array</span><span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span><span style="color: #2d9574;">[</span>1, 2<span style="color: #2d9574;">]</span>,
       <span style="color: #2d9574;">[</span>3, 4<span style="color: #2d9574;">]</span>,
       <span style="color: #2d9574;">[</span>5, 6<span style="color: #2d9574;">]</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; A.ndim
2
&gt;&gt;&gt; A.shape
<span style="color: #3a81c3;">(</span>3, 2<span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; C
<span style="color: #6c3163; font-weight: bold;">array</span><span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span><span style="color: #2d9574;">[</span>7<span style="color: #2d9574;">]</span>,
       <span style="color: #2d9574;">[</span>8<span style="color: #2d9574;">]</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; C.ndim
2
&gt;&gt;&gt; C.shape
<span style="color: #3a81c3;">(</span>2, 1<span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; R = np.dot<span style="color: #3a81c3;">(</span>A, C<span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; R.shape
<span style="color: #3a81c3;">(</span>3, 1<span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; R.ndim
2
</pre>
</div></li>
<li><p>
numpy从自己的角度讲, 把"需要两个维度(ndim)相同"这个前提条件给去掉了.只需要第二个条件"第一个张
量的最后一位等于第二个张量第一位", 那么我就可以举一个例子了ndim为3的张量和ndim为2的矩阵的乘法
</p>
<div class="org-src-container">
<pre class="src src-shell">&gt;&gt;&gt; A
<span style="color: #6c3163; font-weight: bold;">array</span><span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span><span style="color: #2d9574;">[</span>1, 2<span style="color: #2d9574;">]</span>,
       <span style="color: #2d9574;">[</span>3, 4<span style="color: #2d9574;">]</span>,
       <span style="color: #2d9574;">[</span>5, 6<span style="color: #2d9574;">]</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; A.ndim
2
&gt;&gt;&gt; A.shape
<span style="color: #3a81c3;">(</span>3, 2<span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; D = np.ones<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">(</span>3, 3, 3<span style="color: #6c3163;">)</span>, <span style="color: #715ab1;">dtype</span>=int<span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; D
<span style="color: #6c3163; font-weight: bold;">array</span><span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span><span style="color: #2d9574;">[</span><span style="color: #67b11d;">[</span>1, 1, 1<span style="color: #67b11d;">]</span>,
        <span style="color: #67b11d;">[</span>1, 1, 1<span style="color: #67b11d;">]</span>,
        <span style="color: #67b11d;">[</span>1, 1, 1<span style="color: #67b11d;">]</span><span style="color: #2d9574;">]</span>,

       <span style="color: #2d9574;">[</span><span style="color: #67b11d;">[</span>1, 1, 1<span style="color: #67b11d;">]</span>,
        <span style="color: #67b11d;">[</span>1, 1, 1<span style="color: #67b11d;">]</span>,
        <span style="color: #67b11d;">[</span>1, 1, 1<span style="color: #67b11d;">]</span><span style="color: #2d9574;">]</span>,

       <span style="color: #2d9574;">[</span><span style="color: #67b11d;">[</span>1, 1, 1<span style="color: #67b11d;">]</span>,
        <span style="color: #67b11d;">[</span>1, 1, 1<span style="color: #67b11d;">]</span>,
        <span style="color: #67b11d;">[</span>1, 1, 1<span style="color: #67b11d;">]</span><span style="color: #2d9574;">]</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; D.ndim
3
&gt;&gt;&gt; D.shape
<span style="color: #3a81c3;">(</span>3, 3, 3<span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; np.dot<span style="color: #3a81c3;">(</span>D, A<span style="color: #3a81c3;">)</span>
<span style="color: #6c3163; font-weight: bold;">array</span><span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span><span style="color: #2d9574;">[</span><span style="color: #67b11d;">[</span> 9, 12<span style="color: #67b11d;">]</span>,
        <span style="color: #67b11d;">[</span> 9, 12<span style="color: #67b11d;">]</span>,
        <span style="color: #67b11d;">[</span> 9, 12<span style="color: #67b11d;">]</span><span style="color: #2d9574;">]</span>,

       <span style="color: #2d9574;">[</span><span style="color: #67b11d;">[</span> 9, 12<span style="color: #67b11d;">]</span>,
        <span style="color: #67b11d;">[</span> 9, 12<span style="color: #67b11d;">]</span>,
        <span style="color: #67b11d;">[</span> 9, 12<span style="color: #67b11d;">]</span><span style="color: #2d9574;">]</span>,

       <span style="color: #2d9574;">[</span><span style="color: #67b11d;">[</span> 9, 12<span style="color: #67b11d;">]</span>,
        <span style="color: #67b11d;">[</span> 9, 12<span style="color: #67b11d;">]</span>,
        <span style="color: #67b11d;">[</span> 9, 12<span style="color: #67b11d;">]</span><span style="color: #2d9574;">]</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>


&gt;&gt;&gt; np.dot<span style="color: #3a81c3;">(</span>D, A<span style="color: #3a81c3;">)</span>.ndim
3
&gt;&gt;&gt; np.dot<span style="color: #3a81c3;">(</span>D, A<span style="color: #3a81c3;">)</span>.shape
<span style="color: #3a81c3;">(</span>3, 3, 2<span style="color: #3a81c3;">)</span>
</pre>
</div></li>
</ul></li>
<li>把"需要两个维度(ndim)相同"这个前提条件给去掉了之后,受到实惠最大的是shape长度我1的一维数组,因为它shape
只有一个成员:
<ul class="org-ul">
<li><p>
既可以作为第一位和前面的numpy array进行匹配
</p>
<div class="org-src-container">
<pre class="src src-shell">&gt;&gt;&gt; A
<span style="color: #6c3163; font-weight: bold;">array</span><span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span><span style="color: #2d9574;">[</span>1, 2<span style="color: #2d9574;">]</span>,
       <span style="color: #2d9574;">[</span>3, 4<span style="color: #2d9574;">]</span>,
       <span style="color: #2d9574;">[</span>5, 6<span style="color: #2d9574;">]</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; A.ndim
2
&gt;&gt;&gt; A.shape
<span style="color: #3a81c3;">(</span>3, 2<span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; B = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>7,8<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; B
<span style="color: #6c3163; font-weight: bold;">array</span><span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>7, 8<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; B.ndim
1
&gt;&gt;&gt; B.shape
<span style="color: #3a81c3;">(</span>2,<span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; np.dot<span style="color: #3a81c3;">(</span>A,B<span style="color: #3a81c3;">)</span>
<span style="color: #6c3163; font-weight: bold;">array</span><span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>23, 53, 83<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; np.dot<span style="color: #3a81c3;">(</span>A,B<span style="color: #3a81c3;">)</span>.ndim
1
&gt;&gt;&gt; np.dot<span style="color: #3a81c3;">(</span>A,B<span style="color: #3a81c3;">)</span>.shape
<span style="color: #3a81c3;">(</span>3,<span style="color: #3a81c3;">)</span>
</pre>
</div></li>
<li><p>
也可以作为最后一位和后面的numpy array进行匹配
</p>
<div class="org-src-container">
<pre class="src src-shell">&gt;&gt;&gt; B
<span style="color: #6c3163; font-weight: bold;">array</span><span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>7, 8<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; B.ndim
1
&gt;&gt;&gt; B.shape
<span style="color: #3a81c3;">(</span>2,<span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; C = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span><span style="color: #2d9574;">[</span>1, 2, 3<span style="color: #2d9574;">]</span>, <span style="color: #2d9574;">[</span>4, 5, 6<span style="color: #2d9574;">]</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; C
<span style="color: #6c3163; font-weight: bold;">array</span><span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span><span style="color: #2d9574;">[</span>1, 2, 3<span style="color: #2d9574;">]</span>,
       <span style="color: #2d9574;">[</span>4, 5, 6<span style="color: #2d9574;">]</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; C.ndim
2
&gt;&gt;&gt; C.shape
<span style="color: #3a81c3;">(</span>2, 3<span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; np.dot<span style="color: #3a81c3;">(</span>B, C<span style="color: #3a81c3;">)</span>
<span style="color: #6c3163; font-weight: bold;">array</span><span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>39, 54, 69<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; np.dot<span style="color: #3a81c3;">(</span>B, C<span style="color: #3a81c3;">)</span>.ndim
1
&gt;&gt;&gt; np.dot<span style="color: #3a81c3;">(</span>B, C<span style="color: #3a81c3;">)</span>.shape
<span style="color: #3a81c3;">(</span>3,<span style="color: #3a81c3;">)</span>
&gt;&gt;&gt;
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org59396be" class="outline-4">
<h4 id="org59396be"><span class="section-number-4">3.3.3.</span> 神经网络的内机</h4>
<div class="outline-text-4" id="text-3-3-3">
<ul class="org-ul">
<li>理解了numpy的乘法机制,以及其对乘法的优化(放弃相乘两者必须是同一个ndim).那么对如何使用numpy矩阵来实
现神经网络就十分轻松了.</li>
<li>下面的例子省略了偏置和激活函数,主要为了让大家理解如何将 \(x_n\) 和 \(w_n\) 进行匹配的
<ul class="org-ul">
<li><p>
如图
</p>

<div id="org50352f8" class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/image/master/dlfs/3-14.png" alt="3-14.png" />
</p>
<p><span class="figure-number">Figure 24: </span>dlfs/3-14.png</p>
</div></li>
<li>我们注意到矩阵X的shape是(2,), 那么它这里就作为最后一位和后面的矩阵W的第一位匹配即可</li>
<li>最终得到的结果矩阵Y其shape是(3,)</li>
<li><p>
代码如下
</p>
<div class="org-src-container">
<pre class="src src-shell">&gt;&gt;&gt; X = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>1,2<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; X.shape
<span style="color: #3a81c3;">(</span>2,<span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; W = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span><span style="color: #2d9574;">[</span>1, 3, 5<span style="color: #2d9574;">]</span>, <span style="color: #2d9574;">[</span>2, 4, 6<span style="color: #2d9574;">]</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; W
<span style="color: #6c3163; font-weight: bold;">array</span><span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span><span style="color: #2d9574;">[</span>1, 3, 5<span style="color: #2d9574;">]</span>,
       <span style="color: #2d9574;">[</span>2, 4, 6<span style="color: #2d9574;">]</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; W.shape
<span style="color: #3a81c3;">(</span>2, 3<span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; Y = np.dot<span style="color: #3a81c3;">(</span>X, W<span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; Y
<span style="color: #6c3163; font-weight: bold;">array</span><span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span> 5, 11, 17<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; Y.shape
<span style="color: #3a81c3;">(</span>3,<span style="color: #3a81c3;">)</span>
</pre>
</div></li>
<li>通过上面的例子我们知道,即便矩阵Y有一千个元素,那么仅仅通过一次运算也就算出来了.这极大的简化了运算,
在实现上面有巨大意义</li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org171f924" class="outline-3">
<h3 id="org171f924"><span class="section-number-3">3.4.</span> 3层神经网络的实现</h3>
<div class="outline-text-3" id="text-3-4">
<ul class="org-ul">
<li>神经网络问题(或者更广义上的机器学习问题),可以分成如下两个阶段:
<ul class="org-ul">
<li>学习:首先,在学习阶段,就是进行模型的学习. 所谓模型的学习,就是使用已知的训练数据自动调参得到无数浮
点参数组成的模型</li>
<li>推理:然后,在推理阶段,用学到的模型对未知的数据进行推理(回归或者分类)</li>
</ul></li>
<li>本章我们先了解一下"推理"阶段,这个阶段理解起来比较直接."推理"阶段在"学习"阶段之后,自然我们是已经在
已知数据上面习得了新的模型(浮点数参数集合).</li>
<li>新的模型存储在numpy数组里面,我们要推理的数据,也在numpy数组里面,通过我们上节学到的numpy数组的计算,
最终得到推理的结果(回归或者分类)</li>
<li>我们的例子是一个三层神经网络
<ul class="org-ul">
<li><p>
如图
</p>

<div id="org1010bdf" class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/image/master/dlfs/3-15.png" alt="3-15.png" />
</p>
<p><span class="figure-number">Figure 25: </span>dlfs/3-15.png</p>
</div></li>
</ul></li>
</ul>
</div>
<div id="outline-container-org8437333" class="outline-4">
<h4 id="org8437333"><span class="section-number-4">3.4.1.</span> 符号确认</h4>
<div class="outline-text-4" id="text-3-4-1">
<ul class="org-ul">
<li>为了能够清晰的理解推理过程,我们给参数进行了一些特殊定义:
<ul class="org-ul">
<li><p>
如图
</p>

<div id="orgf34476e" class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/image/master/dlfs/3-16.png" alt="3-16.png" />
</p>
<p><span class="figure-number">Figure 26: </span>dlfs/3-16.png</p>
</div></li>
<li>权重(w)和隐藏层神经元的右上角有一个"(1)", 这个表示权重(w)和神经元的层号</li>
<li>权重的右下角有两个数组: 第一个是后一层神经元的index, 第二个是前一层神经元的index,比如 \(w_{12}^{(1)}\)
表示前一层的第2个神经元 \(x_2\) 到 后一层第1个神经元 \(a_1^{(1)}\) 的权重</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orga82f5f0" class="outline-4">
<h4 id="orga82f5f0"><span class="section-number-4">3.4.2.</span> 各层间信号传递的实现</h4>
<div class="outline-text-4" id="text-3-4-2">
<ul class="org-ul">
<li>我们现在看一下从输入层到第一层第一个神经元的信号传递过程
<ul class="org-ul">
<li><p>
如图
</p>

<div id="org25967f8" class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/image/master/dlfs/3-17.png" alt="3-17.png" />
</p>
<p><span class="figure-number">Figure 27: </span>dlfs/3-17.png</p>
</div></li>
<li>图中增加了表示偏置(bias)的神经元"1", 注意偏置的右下角只有一个标记(也就是目的地), 因为偏置神经元(神经
元"1")只有一个</li>
<li>上面偏置右下角只有一个标记,这也就解释了为什么权重要把目的地写前面了(一般目的地都写后面)&#x2013;因为偏置
只有目的地, 为了偏置和权重使用一套符号,所以把目的地写第一个位置</li>
<li><p>
上图所谓的第一层第一个神经元,用我们的符号表示的话,其实就是 \(a_1^{(1)}\), 我们使用数学公式来表达下
计算第一层第一个神经元的公式
</p>
\begin{equation}
a_1^{(1)} = w_{11}^{(1)} x_1 + w_{12}^{(1)} x_2 + b_1^{(1)} \tag{3.8}
\end{equation}</li>
</ul></li>
<li>有了第一层第一个神经元的计算公式,我们可以进一步把第一层的计算方式列出来:
<ul class="org-ul">
<li><p>
总体公式如下
</p>
\begin{equation}
\boldsymbol{A}^{(1)} = \boldsymbol{X} \boldsymbol{W}^{(1)} + \boldsymbol{B}^{(1)} \tag{3.9}
\end{equation}</li>
<li><p>
其中 \(\boldsymbol{A}^{(1)}\) 如下
</p>
\begin{equation}
\boldsymbol{A}^{(1)} = \left(a_1^{(1)} \; a_2^{(1)} \; a_3^{(1)} \right) \notag
\end{equation}</li>
<li><p>
其中 \(\boldsymbol{X}\) 如下
</p>
\begin{equation}
\boldsymbol{X} = \left( x_1, x_2 \right) \notag
\end{equation}</li>
<li><p>
其中 \(\boldsymbol{B}^{(1)}\) 如下
</p>
\begin{equation}
\boldsymbol{B}^{(1)} = \left(b_1^{(1)} \; b_2^{(1)} \; b_3^{(1)} \right) \notag
\end{equation}</li>
<li><p>
其中 \(\boldsymbol{W}^{(1)}\) 如下
</p>
\begin{equation}
\boldsymbol{W}^{(1)} = \begin{pmatrix}
                           w_{11}^{(1)} & w_{21}^{(1)} & w_{31}^{(1)} \\
                           w_{12}^{(1)} & w_{22}^{(1)} & w_{32}^{(1)}
                       \end{pmatrix} \notag
\end{equation}</li>
<li><p>
最后,我们使用numpy多维数组来实现公式3.9,其中权重,偏置,X值都是随机的
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #3a81c3; font-weight: bold;">import</span> numpy <span style="color: #3a81c3; font-weight: bold;">as</span> np

<span style="color: #715ab1;">X</span> = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>1.0, 0.5<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
<span style="color: #715ab1;">W1</span> = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span><span style="color: #2d9574;">[</span>0.1, 0.3, 0.5<span style="color: #2d9574;">]</span>, <span style="color: #2d9574;">[</span>0.2, 0.4, 0.6<span style="color: #2d9574;">]</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
<span style="color: #715ab1;">B1</span> = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>0.1, 0.2, 0.3<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>


<span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>W1.shape<span style="color: #3a81c3;">)</span>
<span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>X.shape<span style="color: #3a81c3;">)</span>
<span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>B1.shape<span style="color: #3a81c3;">)</span>

<span style="color: #715ab1;">A1</span> = np.dot<span style="color: #3a81c3;">(</span>X, W1<span style="color: #3a81c3;">)</span> + B1
</pre>
</div></li>
</ul></li>
<li>下面我们来看看激活过程
<ul class="org-ul">
<li><p>
如图
</p>

<div id="org6d63dd6" class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/image/master/dlfs/3-18.png" alt="3-18.png" />
</p>
<p><span class="figure-number">Figure 28: </span>dlfs/3-18.png</p>
</div></li>
<li>隐藏层的加权和(加权信号和偏置的总和)用a表示</li>
<li>被激活函数转换后的信号用z表示</li>
<li><p>
\(h()\) 表示激活函数,我们这里使用的是sigmoid函数,从输入到激活成功的总体代码如下
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #3a81c3; font-weight: bold;">import</span> numpy <span style="color: #3a81c3; font-weight: bold;">as</span> np


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">sigmoid</span><span style="color: #3a81c3;">(</span>x<span style="color: #3a81c3;">)</span>:
    <span style="color: #3a81c3; font-weight: bold;">return</span> 1 / <span style="color: #3a81c3;">(</span>1 + np.exp<span style="color: #6c3163;">(</span>-x<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>


<span style="color: #715ab1;">X</span> = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>1.0, 0.5<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
<span style="color: #715ab1;">W1</span> = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span><span style="color: #2d9574;">[</span>0.1, 0.3, 0.5<span style="color: #2d9574;">]</span>, <span style="color: #2d9574;">[</span>0.2, 0.4, 0.6<span style="color: #2d9574;">]</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
<span style="color: #715ab1;">B1</span> = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>0.1, 0.2, 0.3<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>


<span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>W1.shape<span style="color: #3a81c3;">)</span>
<span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>X.shape<span style="color: #3a81c3;">)</span>
<span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>B1.shape<span style="color: #3a81c3;">)</span>

<span style="color: #715ab1;">A1</span> = np.dot<span style="color: #3a81c3;">(</span>X, W1<span style="color: #3a81c3;">)</span> + B1
<span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>A1<span style="color: #3a81c3;">)</span>


<span style="color: #715ab1;">Z1</span> = sigmoid<span style="color: #3a81c3;">(</span>A1<span style="color: #3a81c3;">)</span>
<span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>Z1<span style="color: #3a81c3;">)</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">(2, 3)</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">(2,)</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">(3,)</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[0.3 0.7 1.1]</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[0.57444252 0.66818777 0.75026011]</span>
</pre>
</div></li>
</ul></li>
<li>下面再来看看第一层到第二层的信号传递
<ul class="org-ul">
<li><p>
如图
</p>

<div id="orgbe83efb" class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/image/master/dlfs/3-19.png" alt="3-19.png" />
</p>
<p><span class="figure-number">Figure 29: </span>dlfs/3-19.png</p>
</div></li>
<li><p>
代码和前面只有些许不同, 把一层的输出Z作为了第二层的输入
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #3a81c3; font-weight: bold;">import</span> numpy <span style="color: #3a81c3; font-weight: bold;">as</span> np


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">sigmoid</span><span style="color: #3a81c3;">(</span>x<span style="color: #3a81c3;">)</span>:
    <span style="color: #3a81c3; font-weight: bold;">return</span> 1 / <span style="color: #3a81c3;">(</span>1 + np.exp<span style="color: #6c3163;">(</span>-x<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>


<span style="color: #715ab1;">X</span> = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>1.0, 0.5<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
<span style="color: #715ab1;">W1</span> = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span><span style="color: #2d9574;">[</span>0.1, 0.3, 0.5<span style="color: #2d9574;">]</span>, <span style="color: #2d9574;">[</span>0.2, 0.4, 0.6<span style="color: #2d9574;">]</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
<span style="color: #715ab1;">B1</span> = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>0.1, 0.2, 0.3<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>


<span style="color: #715ab1;">A1</span> = np.dot<span style="color: #3a81c3;">(</span>X, W1<span style="color: #3a81c3;">)</span> + B1
<span style="color: #715ab1;">Z1</span> = sigmoid<span style="color: #3a81c3;">(</span>A1<span style="color: #3a81c3;">)</span>

<span style="color: #715ab1;">W2</span> = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span><span style="color: #2d9574;">[</span>0.1, 0.4<span style="color: #2d9574;">]</span>, <span style="color: #2d9574;">[</span>0.2, 0.5<span style="color: #2d9574;">]</span>, <span style="color: #2d9574;">[</span>0.3, 0.6<span style="color: #2d9574;">]</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
<span style="color: #715ab1;">B2</span> = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>0.1, 0.2<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>

<span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>Z1.shape<span style="color: #3a81c3;">)</span>
<span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>W2.shape<span style="color: #3a81c3;">)</span>
<span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>B2.shape<span style="color: #3a81c3;">)</span>

<span style="color: #715ab1;">A2</span> = np.dot<span style="color: #3a81c3;">(</span>Z1, W2<span style="color: #3a81c3;">)</span> + B2
<span style="color: #715ab1;">Z2</span> = sigmoid<span style="color: #3a81c3;">(</span>A2<span style="color: #3a81c3;">)</span>
<span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>A2<span style="color: #3a81c3;">)</span>
<span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>Z2<span style="color: #3a81c3;">)</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">(3,)</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">(3, 2)</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">(2,)</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[0.51615984 1.21402696]</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[0.62624937 0.7710107 ]</span>
</pre>
</div></li>
</ul></li>
<li>最后一步是第2层到输出层的信号传递
<ul class="org-ul">
<li><p>
如图
</p>

<div id="orgfa56ef7" class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/image/master/dlfs/3-20.png" alt="3-20.png" />
</p>
<p><span class="figure-number">Figure 30: </span>dlfs/3-20.png</p>
</div></li>
<li><p>
代码如下
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #3a81c3; font-weight: bold;">import</span> numpy <span style="color: #3a81c3; font-weight: bold;">as</span> np


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">sigmoid</span><span style="color: #3a81c3;">(</span>x<span style="color: #3a81c3;">)</span>:
    <span style="color: #3a81c3; font-weight: bold;">return</span> 1 / <span style="color: #3a81c3;">(</span>1 + np.exp<span style="color: #6c3163;">(</span>-x<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>


<span style="color: #715ab1;">X</span> = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>1.0, 0.5<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
<span style="color: #715ab1;">W1</span> = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span><span style="color: #2d9574;">[</span>0.1, 0.3, 0.5<span style="color: #2d9574;">]</span>, <span style="color: #2d9574;">[</span>0.2, 0.4, 0.6<span style="color: #2d9574;">]</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
<span style="color: #715ab1;">B1</span> = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>0.1, 0.2, 0.3<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>


<span style="color: #715ab1;">A1</span> = np.dot<span style="color: #3a81c3;">(</span>X, W1<span style="color: #3a81c3;">)</span> + B1
<span style="color: #715ab1;">Z1</span> = sigmoid<span style="color: #3a81c3;">(</span>A1<span style="color: #3a81c3;">)</span>

<span style="color: #715ab1;">W2</span> = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span><span style="color: #2d9574;">[</span>0.1, 0.4<span style="color: #2d9574;">]</span>, <span style="color: #2d9574;">[</span>0.2, 0.5<span style="color: #2d9574;">]</span>, <span style="color: #2d9574;">[</span>0.3, 0.6<span style="color: #2d9574;">]</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
<span style="color: #715ab1;">B2</span> = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>0.1, 0.2<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>

<span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>Z1.shape<span style="color: #3a81c3;">)</span>
<span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>W2.shape<span style="color: #3a81c3;">)</span>
<span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>B2.shape<span style="color: #3a81c3;">)</span>

<span style="color: #715ab1;">A2</span> = np.dot<span style="color: #3a81c3;">(</span>Z1, W2<span style="color: #3a81c3;">)</span> + B2
<span style="color: #715ab1;">Z2</span> = sigmoid<span style="color: #3a81c3;">(</span>A2<span style="color: #3a81c3;">)</span>
<span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>A2<span style="color: #3a81c3;">)</span>
<span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>Z2<span style="color: #3a81c3;">)</span>


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">identity_function</span><span style="color: #3a81c3;">(</span>x<span style="color: #3a81c3;">)</span>:
    <span style="color: #3a81c3; font-weight: bold;">return</span> x

<span style="color: #715ab1;">W3</span> = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span><span style="color: #2d9574;">[</span>0.1, 0.3<span style="color: #2d9574;">]</span>, <span style="color: #2d9574;">[</span>0.2, 0.4<span style="color: #2d9574;">]</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
<span style="color: #715ab1;">B3</span> = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>0.1, 0.2<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>

<span style="color: #715ab1;">A3</span> = np.dot<span style="color: #3a81c3;">(</span>Z2, W3<span style="color: #3a81c3;">)</span> + B3
<span style="color: #715ab1;">Y</span> = identity_function<span style="color: #3a81c3;">(</span>A3<span style="color: #3a81c3;">)</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">(3,)</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">(3, 2)</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">(2,)</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[0.51615984 1.21402696]</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[0.62624937 0.7710107 ]</span>
</pre>
</div></li>
<li>这里Z2是输入</li>
<li>我们这里定义了identity_function()函数,并且作为输出层的激活函数.这个函数其实什么都没干,我们也只是
为了和之前的流程保持一致,所以加了这个函数.</li>
<li>输出层所用的激活函数,要根据求解问题的性质决定:
<ol class="org-ol">
<li>回归问题可以用恒等函数,因为回顾问题本来就是求一个浮点数</li>
<li>二元分类问题可以使用sigmoid函数</li>
<li>多元分类问题可以使用softmax函数</li>
</ol></li>
<li>identity_function()这个函数对应于图3-20中的 \(\sigma()\)</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org7d95554" class="outline-4">
<h4 id="org7d95554"><span class="section-number-4">3.4.3.</span> 代码现小结</h4>
<div class="outline-text-4" id="text-3-4-3">
<ul class="org-ul">
<li>我们可以把前面几个步骤重新整理一下
<ul class="org-ul">
<li><p>
完整的代码如下
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #3a81c3; font-weight: bold;">import</span> numpy <span style="color: #3a81c3; font-weight: bold;">as</span> np


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">sigmoid</span><span style="color: #3a81c3;">(</span>x<span style="color: #3a81c3;">)</span>:
    <span style="color: #3a81c3; font-weight: bold;">return</span> 1 / <span style="color: #3a81c3;">(</span>1 + np.exp<span style="color: #6c3163;">(</span>-x<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">identity_function</span><span style="color: #3a81c3;">(</span>x<span style="color: #3a81c3;">)</span>:
    <span style="color: #3a81c3; font-weight: bold;">return</span> x


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">init_network</span><span style="color: #3a81c3;">()</span>:
    <span style="color: #715ab1;">network</span> = <span style="color: #3a81c3;">{}</span>
    <span style="color: #715ab1;">network</span><span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"W1"</span><span style="color: #3a81c3;">]</span> = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span><span style="color: #2d9574;">[</span>0.1, 0.3, 0.5<span style="color: #2d9574;">]</span>, <span style="color: #2d9574;">[</span>0.2, 0.4, 0.6<span style="color: #2d9574;">]</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">network</span><span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"b1"</span><span style="color: #3a81c3;">]</span> = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>0.1, 0.2, 0.3<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">network</span><span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"W2"</span><span style="color: #3a81c3;">]</span> = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span><span style="color: #2d9574;">[</span>0.1, 0.4<span style="color: #2d9574;">]</span>, <span style="color: #2d9574;">[</span>0.2, 0.5<span style="color: #2d9574;">]</span>, <span style="color: #2d9574;">[</span>0.3, 0.6<span style="color: #2d9574;">]</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">network</span><span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"b2"</span><span style="color: #3a81c3;">]</span> = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>0.1, 0.2<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">network</span><span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"W3"</span><span style="color: #3a81c3;">]</span> = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span><span style="color: #2d9574;">[</span>0.1, 0.3<span style="color: #2d9574;">]</span>, <span style="color: #2d9574;">[</span>0.2, 0.4<span style="color: #2d9574;">]</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">network</span><span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"b3"</span><span style="color: #3a81c3;">]</span> = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>0.1, 0.2<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3; font-weight: bold;">return</span> network


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">forward</span><span style="color: #3a81c3;">(</span>network, x<span style="color: #3a81c3;">)</span>:
    <span style="color: #715ab1;">W1</span>, <span style="color: #715ab1;">W2</span>, <span style="color: #715ab1;">W3</span> = network<span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"W1"</span><span style="color: #3a81c3;">]</span>, network<span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"W2"</span><span style="color: #3a81c3;">]</span>, network<span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"W3"</span><span style="color: #3a81c3;">]</span>
    <span style="color: #715ab1;">b1</span>, <span style="color: #715ab1;">b2</span>, <span style="color: #715ab1;">b3</span> = network<span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"b1"</span><span style="color: #3a81c3;">]</span>, network<span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"b2"</span><span style="color: #3a81c3;">]</span>, network<span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"b3"</span><span style="color: #3a81c3;">]</span>

    <span style="color: #715ab1;">a1</span> = np.dot<span style="color: #3a81c3;">(</span>x, W1<span style="color: #3a81c3;">)</span> + b1
    <span style="color: #715ab1;">z1</span> = sigmoid<span style="color: #3a81c3;">(</span>a1<span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">a2</span> = np.dot<span style="color: #3a81c3;">(</span>z1, W2<span style="color: #3a81c3;">)</span> + b2
    <span style="color: #715ab1;">z2</span> = sigmoid<span style="color: #3a81c3;">(</span>a2<span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">a3</span> = np.dot<span style="color: #3a81c3;">(</span>z2, W3<span style="color: #3a81c3;">)</span> + b3
    <span style="color: #715ab1;">y</span> = identity_function<span style="color: #3a81c3;">(</span>a3<span style="color: #3a81c3;">)</span>

    <span style="color: #3a81c3; font-weight: bold;">return</span> y


<span style="color: #715ab1;">network</span> = init_network<span style="color: #3a81c3;">()</span>
<span style="color: #715ab1;">x</span> = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>1.0, 0.5<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
<span style="color: #715ab1;">y</span> = forward<span style="color: #3a81c3;">(</span>network, x<span style="color: #3a81c3;">)</span>
<span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>y<span style="color: #3a81c3;">)</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[0.31682708 0.69627909]</span>
</pre>
</div></li>
<li>我们这里引入了init_network()函数来初始化权重和偏置</li>
<li>这里的forward()函数则封装了将输入信号转换为输出信号的过程. forward的前项,指的是从输入到输出方向的
传递处理.后面在介绍"训练"阶段的时候,我们将介绍backward(后向:从输出到输入)的处理</li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org7537037" class="outline-3">
<h3 id="org7537037"><span class="section-number-3">3.5.</span> 输出层的设计</h3>
<div class="outline-text-3" id="text-3-5">
<ul class="org-ul">
<li>神经网络可以用在如下两种问题上:
<ul class="org-ul">
<li>回归问题(比如区分图形中的人是男性还是女性): 一般使用恒等函数</li>
<li>分类问题(根据一个人的图像预测这个人的体重): 一般使用softmax函数</li>
</ul></li>
</ul>
</div>
<div id="outline-container-org9cc28e5" class="outline-4">
<h4 id="org9cc28e5"><span class="section-number-4">3.5.1.</span> 恒等函数和softmax函数</h4>
<div class="outline-text-4" id="text-3-5-1">
<ul class="org-ul">
<li>恒等函数就非常直接了,在输出层使用恒等函数的时候,输入信号会原封不动地被输出
<ul class="org-ul">
<li><p>
如图
</p>

<div id="org5fa134a" class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/image/master/dlfs/3-21.png" alt="3-21.png" />
</p>
<p><span class="figure-number">Figure 31: </span>dlfs/3-21.png</p>
</div></li>
<li>上图的 \(\sigma()\) 就是恒等函数.我们可以看到恒等函数转换的时候 \(y_n\) 只跟 \(a_n\) 有关系(两者通过箭
头相连,表示转换的时候有关系)</li>
</ul></li>
<li>分类问题使用的softmax函数可以用下面的公式表示
<ul class="org-ul">
<li><p>
公式如下
</p>
\begin{equation}
 y_k = \frac{\exp(a_k)}{  \displaystyle \sum_{i=1}^{n} \exp(a_i) } \tag{3.10}
\end{equation}</li>
<li>\(\exp(x)\) 是表示 \(\mathrm{e}^x\) 的指数函数( \(\mathrm{e}\) 是纳皮尔常数2.7182&#x2026;)</li>
<li>上述公式表示假设输出层有n个神经元,计算第k个神经元的输出 \(y_k\)</li>
<li>softmax函数的分子是输入信号 \(a_k\) 的指数函数,分母是所有输入信号的指数函数的和</li>
<li><p>
用图表示如下
</p>

<div id="orgb4c8c62" class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/image/master/dlfs/3-22.png" alt="3-22.png" />
</p>
<p><span class="figure-number">Figure 32: </span>dlfs/3-22.png</p>
</div></li>
<li>这里箭头还是和图3-21一样表示计算时候有关联,那么我们可以看到:图3-22输出层每个神经元都受到所有输入信号的影响</li>
</ul></li>
<li>我们使用python来实现一遍softmax函数
<ul class="org-ul">
<li><p>
代码如下
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #3a81c3; font-weight: bold;">import</span> numpy <span style="color: #3a81c3; font-weight: bold;">as</span> np

<span style="color: #715ab1;">a</span> = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>0.3, 2.9, 4.0<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
<span style="color: #715ab1;">exp_a</span> = np.exp<span style="color: #3a81c3;">(</span>a<span style="color: #3a81c3;">)</span>
<span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"""|exp_a|=&gt;"""</span>, exp_a<span style="color: #3a81c3;">)</span>

<span style="color: #715ab1;">sum_exp_a</span> = np.<span style="color: #3a81c3;">sum</span><span style="color: #3a81c3;">(</span>exp_a<span style="color: #3a81c3;">)</span>
<span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"""|sum_exp_a|=&gt;"""</span>, sum_exp_a<span style="color: #3a81c3;">)</span>
<span style="color: #715ab1;">y</span> = exp_a / sum_exp_a
<span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"""|y|=&gt;"""</span>, y<span style="color: #3a81c3;">)</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">|exp_a|=&gt; [ 1.34985881 18.17414537 54.59815003]</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">|sum_exp_a|=&gt; 74.1221542101633</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">|y|=&gt; [0.01821127 0.24519181 0.73659691]</span>
</pre>
</div></li>
<li>我们可以看到,softmax的数组结果加起来为1</li>
<li><p>
考虑到后面还要使用这段代码，我们把函数实现总结如下
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #3a81c3; font-weight: bold;">import</span> numpy <span style="color: #3a81c3; font-weight: bold;">as</span> np


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">softmax</span><span style="color: #3a81c3;">(</span>a<span style="color: #3a81c3;">)</span>:
    <span style="color: #715ab1;">exp_a</span> = np.exp<span style="color: #3a81c3;">(</span>a<span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">sum_exp_a</span> = np.<span style="color: #3a81c3;">sum</span><span style="color: #3a81c3;">(</span>exp_a<span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">y</span> = exp_a / sum_exp_a
    <span style="color: #3a81c3; font-weight: bold;">return</span> y
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgf3af941" class="outline-4">
<h4 id="orgf3af941"><span class="section-number-4">3.5.2.</span> 实现softmax函数时的注意事项</h4>
<div class="outline-text-4" id="text-3-5-2">
<ul class="org-ul">
<li>上面的softmax函数的实现虽然正确的描述了公式3.10, 但是在计算的时候有一定的缺陷,因为函数的中间值可能
会变的非常大,比如:
<ul class="org-ul">
<li><p>
np.exp(10)就会超过2000
</p>
<div class="org-src-container">
<pre class="src src-python">&gt;&gt;&gt; np.exp<span style="color: #3a81c3;">(</span>10<span style="color: #3a81c3;">)</span>
22026.465794806718
</pre>
</div></li>
<li><p>
np.exp(100)会变成有40多个0 的超大值
</p>
<div class="org-src-container">
<pre class="src src-python">&gt;&gt;&gt; np.exp<span style="color: #3a81c3;">(</span>100<span style="color: #3a81c3;">)</span>
2.6881171418161356e+43
</pre>
</div></li>
<li><p>
np.exp(1000) 的结果会溢出
</p>
<div class="org-src-container">
<pre class="src src-python">&gt;&gt;&gt; np.exp<span style="color: #3a81c3;">(</span>1000<span style="color: #3a81c3;">)</span>
&lt;stdin&gt;:1: <span style="color: #ba2f59; font-weight: bold;">RuntimeWarning</span>: overflow encountered <span style="color: #3a81c3; font-weight: bold;">in</span> exp
inf
</pre>
</div></li>
</ul></li>
<li>为了让我们的计算过程中间值不要出现溢出(或者超大值,因为超大值之间的计算也可能出现问题),我们需要对公
式3.10进行改造
<ul class="org-ul">
<li><p>
新公式如下
</p>
\begin{align}
y_k    = \frac{\exp(a_k)}{\displaystyle \sum_{i=1}^{n} \exp(a_i)} &= \frac{\mathrm{C} \exp(a_k)}{\mathrm{C} \displaystyle \sum_{i=1}^{n} \exp(a_i)} \notag \\
     &  =  \frac{ \exp(a_k + \mathrm{log \;C})}{ \displaystyle \sum_{i=1}^{n} \exp(a_i + \mathrm{log \; C})} \notag \\
     &  =  \frac{ \exp(a_k + \mathrm{C'})}{ \displaystyle \sum_{i=1}^{n} \exp(a_i + \mathrm{C'})} \tag{3.11}
\end{align}</li>
<li>分子分母都乘以常数C,结果不变</li>
<li>把C移动到指数函数exp中,记作logC(也就是C')</li>
<li>公式3.11说明,在进行softmax函数计算的时候,加上或者减去一个常数不会改变结果,并且C'可以是任意值</li>
<li><p>
虽然C'可以是任意值,通常情况下,为了防止再出现溢出,我们会选择输入vector中最大的值来作为C'(这样np.exp
的参数最大的只可能是0),例子如下
</p>
<div class="org-src-container">
<pre class="src src-shell">&gt;&gt;&gt; a = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>1010, 1000, 990<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; np.exp<span style="color: #3a81c3;">(</span>a<span style="color: #3a81c3;">)</span> / np.sum<span style="color: #3a81c3;">(</span>np.exp<span style="color: #6c3163;">(</span>a<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
&lt;stdin&gt;:1: RuntimeWarning: invalid value encountered<span style="color: #3a81c3; font-weight: bold;"> in</span> divide
<span style="color: #6c3163; font-weight: bold;">array</span><span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>nan, nan, nan<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; c = np.max<span style="color: #3a81c3;">(</span>a<span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; c
1010
&gt;&gt;&gt; a - c
<span style="color: #6c3163; font-weight: bold;">array</span><span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>  0, -10, -20<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; np.exp<span style="color: #3a81c3;">(</span>a-c<span style="color: #3a81c3;">)</span> / np.sum<span style="color: #3a81c3;">(</span>np.exp<span style="color: #6c3163;">(</span>a-c<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
<span style="color: #6c3163; font-weight: bold;">array</span><span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>9.99954600e-01, 4.53978686e-05, 2.06106005e-09<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
</pre>
</div></li>
<li><p>
公式3.11对应的代码如下
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #3a81c3; font-weight: bold;">import</span> numpy <span style="color: #3a81c3; font-weight: bold;">as</span> np


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">softmax</span><span style="color: #3a81c3;">(</span>a<span style="color: #3a81c3;">)</span>:
    <span style="color: #715ab1;">c</span> = np.<span style="color: #3a81c3;">max</span><span style="color: #3a81c3;">(</span>a<span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">exp_a</span> = np.exp<span style="color: #3a81c3;">(</span>a - c<span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">sum_exp_a</span> = np.<span style="color: #3a81c3;">sum</span><span style="color: #3a81c3;">(</span>exp_a<span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">y</span> = exp_a / sum_exp_a
    <span style="color: #3a81c3; font-weight: bold;">return</span> y
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org4ba3a61" class="outline-4">
<h4 id="org4ba3a61"><span class="section-number-4">3.5.3.</span> softmax函数的特征</h4>
<div class="outline-text-4" id="text-3-5-3">
<ul class="org-ul">
<li>我们模拟一个输入[0.3, 2.9, 4.0], 看看softmax函数的输出有什么特点
<ul class="org-ul">
<li><p>
代码如下
</p>
<div class="org-src-container">
<pre class="src src-python">&gt;&gt;&gt; a = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>0.3, 2.9, 4.0<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; y = softmax<span style="color: #3a81c3;">(</span>a<span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>y<span style="color: #3a81c3;">)</span>
<span style="color: #3a81c3;">[</span>0.01821127 0.24519181 0.73659691<span style="color: #3a81c3;">]</span>
&gt;&gt;&gt; np.<span style="color: #3a81c3;">sum</span><span style="color: #3a81c3;">(</span>y<span style="color: #3a81c3;">)</span>
1.0
</pre>
</div></li>
<li>如上所述,softmax函数的输出是0.0到1.0之间的实数</li>
<li><p>
softmax函数的输出值总和是1."输出值总和为1"是softmax函数的重要特征,正因为有了这个特征,我们才可以
把softmax邯郸的输出解释为"概率",比如上面的例子就可以从概率的角度解释为
</p>
<pre class="example" id="org980184d">
有74%的概率是第2个类别,有25%的概率是第一个类别,有1%的概率是第0个类别
</pre></li>
<li>这里需要注意的是,即便使用了softmax函数,各个元素之间的大小关系也不会改变,因为指数函数( \(y = \exp(x)\) )
是单调递增函数. 比如上个例子中输入(也就是a)中最大的是第2个,输出(也就是y)中最大的也是第2个</li>
<li>一般而言,神经网络只把输出值最大的神经元所对应的类别作为识别结果,比如上面数组a就已经说明第2个元素
最大了,softmax计算过后选出来的还是第2个元素,那么再耗费计算资源去计算softmax就没有意义了.所以,我们
说:
<ol class="org-ol">
<li>在(模型已经创建好后)再进行分类,回归等"推理"阶段的时候,我们不计算softmax,因为没有意义</li>
<li>在(模型还在探索的)"学习"阶段,我们是要使用softmax函数的,具体信息我们后面会看到</li>
</ol></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org94b07f5" class="outline-4">
<h4 id="org94b07f5"><span class="section-number-4">3.5.4.</span> 输出层的神经元数量</h4>
<div class="outline-text-4" id="text-3-5-4">
<ul class="org-ul">
<li><p>
输出层神经元的数量要根据待解决的问题来定:
</p>
<pre class="example" id="orgd5fc18d">
对于分类问题,输出层的神经元数量一般设定为类别的数量
</pre></li>
<li>比如对于某个输入图像,预测图中数字是0-9中哪个数字的问题,我们将输出层神经元设定为10个
<ul class="org-ul">
<li><p>
如图
</p>

<div id="org597bca6" class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/image/master/dlfs/3-23.png" alt="3-23.png" />
</p>
<p><span class="figure-number">Figure 33: </span>dlfs/3-23.png</p>
</div></li>
<li>上图中神经元从上到下以此对应数字0-9</li>
<li>图中输出层神经元的值用不同灰度表示,颜色越深,输出值越大.上图中y2的颜色最深,表示这个神经元预测手写
输入的结果是y2对应的类别,也就是"2"</li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgc4d3cee" class="outline-3">
<h3 id="orgc4d3cee"><span class="section-number-3">3.6.</span> 手写数字识别</h3>
<div class="outline-text-3" id="text-3-6">
<ul class="org-ul">
<li><p>
我们本节来看一个神经网络的例子. 这个例子假设神经网络的"学习阶段"已经完成(也就是模型参数也存储下来了),
我们利用存储下来的模型参数来进行"推理阶段",推理一个模型没见过的新的输入.
</p>
<pre class="example" id="org57f6b42">
已知模型参数,对位置问题进行推理的过程,也被称为神经网络的前向传播(forward progagation)
</pre></li>
</ul>
</div>
<div id="outline-container-org66e4d9c" class="outline-4">
<h4 id="org66e4d9c"><span class="section-number-4">3.6.1.</span> MNIST数据集</h4>
<div class="outline-text-4" id="text-3-6-1">
<ul class="org-ul">
<li>MNIST数据集是由0到9的数字图像构成,其中:
<ul class="org-ul">
<li>训练图像有6万张</li>
<li>测试图像有1万张</li>
</ul></li>
<li>MNIST的图像数据是28像素*28像素的灰度图像,灰阶力度在0-255之间</li>
<li><p>
每个数据都相应的标记了"7","2", "1"等标签,如下图
</p>

<div id="org4d543dc" class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/image/master/dlfs/3-24.png" alt="3-24.png" />
</p>
<p><span class="figure-number">Figure 34: </span>dlfs/3-24.png</p>
</div></li>
<li>本书提供了一个脚本下载mnist数据
<ul class="org-ul">
<li><p>
例子如下
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #3a81c3; font-weight: bold;">try</span>:
    <span style="color: #3a81c3; font-weight: bold;">import</span> urllib.request
<span style="color: #3a81c3; font-weight: bold;">except</span> <span style="color: #ba2f59; font-weight: bold;">ImportError</span>:
    <span style="color: #3a81c3; font-weight: bold;">raise</span> <span style="color: #ba2f59; font-weight: bold;">ImportError</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"You should use Python 3.x"</span><span style="color: #3a81c3;">)</span>
<span style="color: #3a81c3; font-weight: bold;">import</span> os.path
<span style="color: #3a81c3; font-weight: bold;">import</span> gzip
<span style="color: #3a81c3; font-weight: bold;">import</span> pickle
<span style="color: #3a81c3; font-weight: bold;">import</span> os
<span style="color: #3a81c3; font-weight: bold;">import</span> numpy <span style="color: #3a81c3; font-weight: bold;">as</span> np


<span style="color: #715ab1;">url_base</span> = <span style="color: #2d9574;">"http://yann.lecun.com/exdb/mnist/"</span>
<span style="color: #715ab1;">key_file</span> = <span style="color: #3a81c3;">{</span>
    <span style="color: #2d9574;">"train_img"</span>: <span style="color: #2d9574;">"train-images-idx3-ubyte.gz"</span>,
    <span style="color: #2d9574;">"train_label"</span>: <span style="color: #2d9574;">"train-labels-idx1-ubyte.gz"</span>,
    <span style="color: #2d9574;">"test_img"</span>: <span style="color: #2d9574;">"t10k-images-idx3-ubyte.gz"</span>,
    <span style="color: #2d9574;">"test_label"</span>: <span style="color: #2d9574;">"t10k-labels-idx1-ubyte.gz"</span>,
<span style="color: #3a81c3;">}</span>

<span style="color: #715ab1;">dataset_dir</span> = os.path.dirname<span style="color: #3a81c3;">(</span>os.path.abspath<span style="color: #6c3163;">(</span>__file__<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
<span style="color: #715ab1;">save_file</span> = dataset_dir + <span style="color: #2d9574;">"/mnist.pkl"</span>

<span style="color: #715ab1;">train_num</span> = 60000
<span style="color: #715ab1;">test_num</span> = 10000
<span style="color: #715ab1;">img_dim</span> = <span style="color: #3a81c3;">(</span>1, 28, 28<span style="color: #3a81c3;">)</span>
<span style="color: #715ab1;">img_size</span> = 784


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">_download</span><span style="color: #3a81c3;">(</span>file_name<span style="color: #3a81c3;">)</span>:
    <span style="color: #715ab1;">file_path</span> = dataset_dir + <span style="color: #2d9574;">"/"</span> + file_name

    <span style="color: #3a81c3; font-weight: bold;">if</span> os.path.exists<span style="color: #3a81c3;">(</span>file_path<span style="color: #3a81c3;">)</span>:
        <span style="color: #3a81c3; font-weight: bold;">return</span>

    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Downloading "</span> + file_name + <span style="color: #2d9574;">" ... "</span><span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">headers</span> = <span style="color: #3a81c3;">{</span>
        <span style="color: #2d9574;">"User-Agent"</span>: <span style="color: #2d9574;">"Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:47.0) Gecko/20100101 Firefox/47.0"</span>
    <span style="color: #3a81c3;">}</span>
    <span style="color: #715ab1;">request</span> = urllib.request.Request<span style="color: #3a81c3;">(</span>url_base + file_name, headers=headers<span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">response</span> = urllib.request.urlopen<span style="color: #3a81c3;">(</span>request<span style="color: #3a81c3;">)</span>.read<span style="color: #3a81c3;">()</span>
    <span style="color: #3a81c3; font-weight: bold;">with</span> <span style="color: #3a81c3;">open</span><span style="color: #3a81c3;">(</span>file_path, mode=<span style="color: #2d9574;">"wb"</span><span style="color: #3a81c3;">)</span> <span style="color: #3a81c3; font-weight: bold;">as</span> f:
        f.write<span style="color: #3a81c3;">(</span>response<span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Done"</span><span style="color: #3a81c3;">)</span>


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">download_mnist</span><span style="color: #3a81c3;">()</span>:
    <span style="color: #3a81c3; font-weight: bold;">for</span> v <span style="color: #3a81c3; font-weight: bold;">in</span> key_file.values<span style="color: #3a81c3;">()</span>:
        _download<span style="color: #3a81c3;">(</span>v<span style="color: #3a81c3;">)</span>


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">_load_label</span><span style="color: #3a81c3;">(</span>file_name<span style="color: #3a81c3;">)</span>:
    <span style="color: #715ab1;">file_path</span> = dataset_dir + <span style="color: #2d9574;">"/"</span> + file_name

    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Converting "</span> + file_name + <span style="color: #2d9574;">" to NumPy Array ..."</span><span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3; font-weight: bold;">with</span> gzip.<span style="color: #3a81c3;">open</span><span style="color: #3a81c3;">(</span>file_path, <span style="color: #2d9574;">"rb"</span><span style="color: #3a81c3;">)</span> <span style="color: #3a81c3; font-weight: bold;">as</span> f:
        <span style="color: #715ab1;">labels</span> = np.frombuffer<span style="color: #3a81c3;">(</span>f.read<span style="color: #6c3163;">()</span>, np.uint8, offset=8<span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Done"</span><span style="color: #3a81c3;">)</span>

    <span style="color: #3a81c3; font-weight: bold;">return</span> labels


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">_load_img</span><span style="color: #3a81c3;">(</span>file_name<span style="color: #3a81c3;">)</span>:
    <span style="color: #715ab1;">file_path</span> = dataset_dir + <span style="color: #2d9574;">"/"</span> + file_name

    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Converting "</span> + file_name + <span style="color: #2d9574;">" to NumPy Array ..."</span><span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3; font-weight: bold;">with</span> gzip.<span style="color: #3a81c3;">open</span><span style="color: #3a81c3;">(</span>file_path, <span style="color: #2d9574;">"rb"</span><span style="color: #3a81c3;">)</span> <span style="color: #3a81c3; font-weight: bold;">as</span> f:
        <span style="color: #715ab1;">data</span> = np.frombuffer<span style="color: #3a81c3;">(</span>f.read<span style="color: #6c3163;">()</span>, np.uint8, offset=16<span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">data</span> = data.reshape<span style="color: #3a81c3;">(</span>-1, img_size<span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Done"</span><span style="color: #3a81c3;">)</span>

    <span style="color: #3a81c3; font-weight: bold;">return</span> data


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">_convert_numpy</span><span style="color: #3a81c3;">()</span>:
    <span style="color: #715ab1;">dataset</span> = <span style="color: #3a81c3;">{}</span>
    <span style="color: #715ab1;">dataset</span><span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"train_img"</span><span style="color: #3a81c3;">]</span> = _load_img<span style="color: #3a81c3;">(</span>key_file<span style="color: #6c3163;">[</span><span style="color: #2d9574;">"train_img"</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">dataset</span><span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"train_label"</span><span style="color: #3a81c3;">]</span> = _load_label<span style="color: #3a81c3;">(</span>key_file<span style="color: #6c3163;">[</span><span style="color: #2d9574;">"train_label"</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">dataset</span><span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"test_img"</span><span style="color: #3a81c3;">]</span> = _load_img<span style="color: #3a81c3;">(</span>key_file<span style="color: #6c3163;">[</span><span style="color: #2d9574;">"test_img"</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">dataset</span><span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"test_label"</span><span style="color: #3a81c3;">]</span> = _load_label<span style="color: #3a81c3;">(</span>key_file<span style="color: #6c3163;">[</span><span style="color: #2d9574;">"test_label"</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>

    <span style="color: #3a81c3; font-weight: bold;">return</span> dataset


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">init_mnist</span><span style="color: #3a81c3;">()</span>:
    download_mnist<span style="color: #3a81c3;">()</span>
    <span style="color: #715ab1;">dataset</span> = _convert_numpy<span style="color: #3a81c3;">()</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Creating pickle file ..."</span><span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3; font-weight: bold;">with</span> <span style="color: #3a81c3;">open</span><span style="color: #3a81c3;">(</span>save_file, <span style="color: #2d9574;">"wb"</span><span style="color: #3a81c3;">)</span> <span style="color: #3a81c3; font-weight: bold;">as</span> f:
        pickle.dump<span style="color: #3a81c3;">(</span>dataset, f, -1<span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Done!"</span><span style="color: #3a81c3;">)</span>


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">_change_one_hot_label</span><span style="color: #3a81c3;">(</span>X<span style="color: #3a81c3;">)</span>:
    <span style="color: #715ab1;">T</span> = np.zeros<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">(</span>X.size, 10<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3; font-weight: bold;">for</span> idx, row <span style="color: #3a81c3; font-weight: bold;">in</span> <span style="color: #3a81c3;">enumerate</span><span style="color: #3a81c3;">(</span>T<span style="color: #3a81c3;">)</span>:
        row<span style="color: #3a81c3;">[</span>X<span style="color: #6c3163;">[</span>idx<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">]</span> = 1

    <span style="color: #3a81c3; font-weight: bold;">return</span> T


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">load_mnist</span><span style="color: #3a81c3;">(</span>normalize=<span style="color: #4e3163;">True</span>, flatten=<span style="color: #4e3163;">True</span>, one_hot_label=<span style="color: #4e3163;">False</span><span style="color: #3a81c3;">)</span>:
    <span style="color: #3a81c3; font-weight: bold;">if</span> <span style="color: #3a81c3; font-weight: bold;">not</span> os.path.exists<span style="color: #3a81c3;">(</span>save_file<span style="color: #3a81c3;">)</span>:
        init_mnist<span style="color: #3a81c3;">()</span>

    <span style="color: #3a81c3; font-weight: bold;">with</span> <span style="color: #3a81c3;">open</span><span style="color: #3a81c3;">(</span>save_file, <span style="color: #2d9574;">"rb"</span><span style="color: #3a81c3;">)</span> <span style="color: #3a81c3; font-weight: bold;">as</span> f:
        <span style="color: #715ab1;">dataset</span> = pickle.load<span style="color: #3a81c3;">(</span>f<span style="color: #3a81c3;">)</span>

    <span style="color: #3a81c3; font-weight: bold;">if</span> normalize:
        <span style="color: #3a81c3; font-weight: bold;">for</span> key <span style="color: #3a81c3; font-weight: bold;">in</span> <span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"train_img"</span>, <span style="color: #2d9574;">"test_img"</span><span style="color: #3a81c3;">)</span>:
            <span style="color: #715ab1;">dataset</span><span style="color: #3a81c3;">[</span>key<span style="color: #3a81c3;">]</span> = dataset<span style="color: #3a81c3;">[</span>key<span style="color: #3a81c3;">]</span>.astype<span style="color: #3a81c3;">(</span>np.float32<span style="color: #3a81c3;">)</span>
            <span style="color: #715ab1;">dataset</span><span style="color: #3a81c3;">[</span>key<span style="color: #3a81c3;">]</span> /= 255.0

    <span style="color: #3a81c3; font-weight: bold;">if</span> one_hot_label:
        <span style="color: #715ab1;">dataset</span><span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"train_label"</span><span style="color: #3a81c3;">]</span> = _change_one_hot_label<span style="color: #3a81c3;">(</span>dataset<span style="color: #6c3163;">[</span><span style="color: #2d9574;">"train_label"</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
        <span style="color: #715ab1;">dataset</span><span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"test_label"</span><span style="color: #3a81c3;">]</span> = _change_one_hot_label<span style="color: #3a81c3;">(</span>dataset<span style="color: #6c3163;">[</span><span style="color: #2d9574;">"test_label"</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>

    <span style="color: #3a81c3; font-weight: bold;">if</span> <span style="color: #3a81c3; font-weight: bold;">not</span> flatten:
        <span style="color: #3a81c3; font-weight: bold;">for</span> key <span style="color: #3a81c3; font-weight: bold;">in</span> <span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"train_img"</span>, <span style="color: #2d9574;">"test_img"</span><span style="color: #3a81c3;">)</span>:
            <span style="color: #715ab1;">dataset</span><span style="color: #3a81c3;">[</span>key<span style="color: #3a81c3;">]</span> = dataset<span style="color: #3a81c3;">[</span>key<span style="color: #3a81c3;">]</span>.reshape<span style="color: #3a81c3;">(</span>-1, 1, 28, 28<span style="color: #3a81c3;">)</span>

    <span style="color: #3a81c3; font-weight: bold;">return</span> <span style="color: #3a81c3;">(</span>dataset<span style="color: #6c3163;">[</span><span style="color: #2d9574;">"train_img"</span><span style="color: #6c3163;">]</span>, dataset<span style="color: #6c3163;">[</span><span style="color: #2d9574;">"train_label"</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>, <span style="color: #3a81c3;">(</span>
        dataset<span style="color: #6c3163;">[</span><span style="color: #2d9574;">"test_img"</span><span style="color: #6c3163;">]</span>,
        dataset<span style="color: #6c3163;">[</span><span style="color: #2d9574;">"test_label"</span><span style="color: #6c3163;">]</span>,
    <span style="color: #3a81c3;">)</span>


<span style="color: #3a81c3; font-weight: bold;">if</span> <span style="color: #3a81c3;">__name__</span> == <span style="color: #2d9574;">"__main__"</span>:
    <span style="color: #3a81c3;">(</span>x_train, t_train<span style="color: #3a81c3;">)</span>, <span style="color: #3a81c3;">(</span><span style="color: #715ab1;">x_test</span>, <span style="color: #715ab1;">t_test</span><span style="color: #3a81c3;">)</span> = load_mnist<span style="color: #3a81c3;">(</span>flatten=<span style="color: #4e3163;">True</span>, normalize=<span style="color: #4e3163;">False</span><span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>x_train.shape<span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>t_train.shape<span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>x_test.shape<span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>t_test.shape<span style="color: #3a81c3;">)</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Downloading train-images-idx3-ubyte.gz ...</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Done</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Downloading train-labels-idx1-ubyte.gz ...</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Done</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Downloading t10k-images-idx3-ubyte.gz ...</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Done</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Downloading t10k-labels-idx1-ubyte.gz ...</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Done</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Converting train-images-idx3-ubyte.gz to NumPy Array ...</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Done</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Converting train-labels-idx1-ubyte.gz to NumPy Array ...</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Done</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Converting t10k-images-idx3-ubyte.gz to NumPy Array ...</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Done</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Converting t10k-labels-idx1-ubyte.gz to NumPy Array ...</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Done</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Creating pickle file ...</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Done!</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">(60000, 784)</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">(60000,)</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">(10000, 784)</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">(10000,)</span>
</pre>
</div></li>
<li>我们的load_mnist有三个参数:
<ol class="org-ol">
<li>normalize=True, 默认参数要正则化，也就是说图像像素数组（无论是一维还是二维）不再是0-255,而是0.0-1.0, 我们选择不要正则化</li>
<li>flattern=True, 默认图像数组是打扁的，也就是一维数组成员是784个，成员数据为0-255或者是0.0-1.0</li>
<li>one_hot_label=False，默认标签是不要one-hot的，而是7,2这种数字</li>
</ol></li>
<li>由于我们选择了flatten为true，所以我们的结果是一个打扁了的图像文件总像素是784</li>
<li><p>
这个例子第一次会下载数据到本地，也就是如下几个压缩文件
</p>
<pre class="example" id="org24dd0c2">
t10k-images-idx3-ubyte.gz
t10k-labels-idx1-ubyte.gz
train-images-idx3-ubyte.gz
train-labels-idx1-ubyte.gz
</pre></li>
<li><p>
然后，程序还会把这些压缩文件存储到pickle文件（这是python默认的二进制导出文件）
</p>
<pre class="example" id="org8e88397">
mnist.pkl
</pre></li>
</ul></li>
<li>我们下面为了体验一下数据，选择训练集的第一个数据，打印出来
<ul class="org-ul">
<li><p>
代码如下
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #3a81c3; font-weight: bold;">try</span>:
    <span style="color: #3a81c3; font-weight: bold;">import</span> urllib.request
<span style="color: #3a81c3; font-weight: bold;">except</span> <span style="color: #ba2f59; font-weight: bold;">ImportError</span>:
    <span style="color: #3a81c3; font-weight: bold;">raise</span> <span style="color: #ba2f59; font-weight: bold;">ImportError</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"You should use Python 3.x"</span><span style="color: #3a81c3;">)</span>
<span style="color: #3a81c3; font-weight: bold;">import</span> os.path
<span style="color: #3a81c3; font-weight: bold;">import</span> gzip
<span style="color: #3a81c3; font-weight: bold;">import</span> pickle
<span style="color: #3a81c3; font-weight: bold;">import</span> os
<span style="color: #3a81c3; font-weight: bold;">import</span> numpy <span style="color: #3a81c3; font-weight: bold;">as</span> np


<span style="color: #715ab1;">url_base</span> = <span style="color: #2d9574;">"http://yann.lecun.com/exdb/mnist/"</span>
<span style="color: #715ab1;">key_file</span> = <span style="color: #3a81c3;">{</span>
    <span style="color: #2d9574;">"train_img"</span>: <span style="color: #2d9574;">"train-images-idx3-ubyte.gz"</span>,
    <span style="color: #2d9574;">"train_label"</span>: <span style="color: #2d9574;">"train-labels-idx1-ubyte.gz"</span>,
    <span style="color: #2d9574;">"test_img"</span>: <span style="color: #2d9574;">"t10k-images-idx3-ubyte.gz"</span>,
    <span style="color: #2d9574;">"test_label"</span>: <span style="color: #2d9574;">"t10k-labels-idx1-ubyte.gz"</span>,
<span style="color: #3a81c3;">}</span>

<span style="color: #715ab1;">dataset_dir</span> = os.path.dirname<span style="color: #3a81c3;">(</span>os.path.abspath<span style="color: #6c3163;">(</span>__file__<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
<span style="color: #715ab1;">save_file</span> = dataset_dir + <span style="color: #2d9574;">"/mnist.pkl"</span>

<span style="color: #715ab1;">train_num</span> = 60000
<span style="color: #715ab1;">test_num</span> = 10000
<span style="color: #715ab1;">img_dim</span> = <span style="color: #3a81c3;">(</span>1, 28, 28<span style="color: #3a81c3;">)</span>
<span style="color: #715ab1;">img_size</span> = 784


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">_download</span><span style="color: #3a81c3;">(</span>file_name<span style="color: #3a81c3;">)</span>:
    <span style="color: #715ab1;">file_path</span> = dataset_dir + <span style="color: #2d9574;">"/"</span> + file_name

    <span style="color: #3a81c3; font-weight: bold;">if</span> os.path.exists<span style="color: #3a81c3;">(</span>file_path<span style="color: #3a81c3;">)</span>:
        <span style="color: #3a81c3; font-weight: bold;">return</span>

    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Downloading "</span> + file_name + <span style="color: #2d9574;">" ... "</span><span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">headers</span> = <span style="color: #3a81c3;">{</span>
        <span style="color: #2d9574;">"User-Agent"</span>: <span style="color: #2d9574;">"Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:47.0) Gecko/20100101 Firefox/47.0"</span>
    <span style="color: #3a81c3;">}</span>
    <span style="color: #715ab1;">request</span> = urllib.request.Request<span style="color: #3a81c3;">(</span>url_base + file_name, headers=headers<span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">response</span> = urllib.request.urlopen<span style="color: #3a81c3;">(</span>request<span style="color: #3a81c3;">)</span>.read<span style="color: #3a81c3;">()</span>
    <span style="color: #3a81c3; font-weight: bold;">with</span> <span style="color: #3a81c3;">open</span><span style="color: #3a81c3;">(</span>file_path, mode=<span style="color: #2d9574;">"wb"</span><span style="color: #3a81c3;">)</span> <span style="color: #3a81c3; font-weight: bold;">as</span> f:
        f.write<span style="color: #3a81c3;">(</span>response<span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Done"</span><span style="color: #3a81c3;">)</span>


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">download_mnist</span><span style="color: #3a81c3;">()</span>:
    <span style="color: #3a81c3; font-weight: bold;">for</span> v <span style="color: #3a81c3; font-weight: bold;">in</span> key_file.values<span style="color: #3a81c3;">()</span>:
        _download<span style="color: #3a81c3;">(</span>v<span style="color: #3a81c3;">)</span>


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">_load_label</span><span style="color: #3a81c3;">(</span>file_name<span style="color: #3a81c3;">)</span>:
    <span style="color: #715ab1;">file_path</span> = dataset_dir + <span style="color: #2d9574;">"/"</span> + file_name

    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Converting "</span> + file_name + <span style="color: #2d9574;">" to NumPy Array ..."</span><span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3; font-weight: bold;">with</span> gzip.<span style="color: #3a81c3;">open</span><span style="color: #3a81c3;">(</span>file_path, <span style="color: #2d9574;">"rb"</span><span style="color: #3a81c3;">)</span> <span style="color: #3a81c3; font-weight: bold;">as</span> f:
        <span style="color: #715ab1;">labels</span> = np.frombuffer<span style="color: #3a81c3;">(</span>f.read<span style="color: #6c3163;">()</span>, np.uint8, offset=8<span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Done"</span><span style="color: #3a81c3;">)</span>

    <span style="color: #3a81c3; font-weight: bold;">return</span> labels


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">_load_img</span><span style="color: #3a81c3;">(</span>file_name<span style="color: #3a81c3;">)</span>:
    <span style="color: #715ab1;">file_path</span> = dataset_dir + <span style="color: #2d9574;">"/"</span> + file_name

    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Converting "</span> + file_name + <span style="color: #2d9574;">" to NumPy Array ..."</span><span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3; font-weight: bold;">with</span> gzip.<span style="color: #3a81c3;">open</span><span style="color: #3a81c3;">(</span>file_path, <span style="color: #2d9574;">"rb"</span><span style="color: #3a81c3;">)</span> <span style="color: #3a81c3; font-weight: bold;">as</span> f:
        <span style="color: #715ab1;">data</span> = np.frombuffer<span style="color: #3a81c3;">(</span>f.read<span style="color: #6c3163;">()</span>, np.uint8, offset=16<span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">data</span> = data.reshape<span style="color: #3a81c3;">(</span>-1, img_size<span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Done"</span><span style="color: #3a81c3;">)</span>

    <span style="color: #3a81c3; font-weight: bold;">return</span> data


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">_convert_numpy</span><span style="color: #3a81c3;">()</span>:
    <span style="color: #715ab1;">dataset</span> = <span style="color: #3a81c3;">{}</span>
    <span style="color: #715ab1;">dataset</span><span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"train_img"</span><span style="color: #3a81c3;">]</span> = _load_img<span style="color: #3a81c3;">(</span>key_file<span style="color: #6c3163;">[</span><span style="color: #2d9574;">"train_img"</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">dataset</span><span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"train_label"</span><span style="color: #3a81c3;">]</span> = _load_label<span style="color: #3a81c3;">(</span>key_file<span style="color: #6c3163;">[</span><span style="color: #2d9574;">"train_label"</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">dataset</span><span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"test_img"</span><span style="color: #3a81c3;">]</span> = _load_img<span style="color: #3a81c3;">(</span>key_file<span style="color: #6c3163;">[</span><span style="color: #2d9574;">"test_img"</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">dataset</span><span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"test_label"</span><span style="color: #3a81c3;">]</span> = _load_label<span style="color: #3a81c3;">(</span>key_file<span style="color: #6c3163;">[</span><span style="color: #2d9574;">"test_label"</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>

    <span style="color: #3a81c3; font-weight: bold;">return</span> dataset


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">init_mnist</span><span style="color: #3a81c3;">()</span>:
    download_mnist<span style="color: #3a81c3;">()</span>
    <span style="color: #715ab1;">dataset</span> = _convert_numpy<span style="color: #3a81c3;">()</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Creating pickle file ..."</span><span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3; font-weight: bold;">with</span> <span style="color: #3a81c3;">open</span><span style="color: #3a81c3;">(</span>save_file, <span style="color: #2d9574;">"wb"</span><span style="color: #3a81c3;">)</span> <span style="color: #3a81c3; font-weight: bold;">as</span> f:
        pickle.dump<span style="color: #3a81c3;">(</span>dataset, f, -1<span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Done!"</span><span style="color: #3a81c3;">)</span>


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">_change_one_hot_label</span><span style="color: #3a81c3;">(</span>X<span style="color: #3a81c3;">)</span>:
    <span style="color: #715ab1;">T</span> = np.zeros<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">(</span>X.size, 10<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3; font-weight: bold;">for</span> idx, row <span style="color: #3a81c3; font-weight: bold;">in</span> <span style="color: #3a81c3;">enumerate</span><span style="color: #3a81c3;">(</span>T<span style="color: #3a81c3;">)</span>:
        row<span style="color: #3a81c3;">[</span>X<span style="color: #6c3163;">[</span>idx<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">]</span> = 1

    <span style="color: #3a81c3; font-weight: bold;">return</span> T


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">load_mnist</span><span style="color: #3a81c3;">(</span>normalize=<span style="color: #4e3163;">True</span>, flatten=<span style="color: #4e3163;">True</span>, one_hot_label=<span style="color: #4e3163;">False</span><span style="color: #3a81c3;">)</span>:
    <span style="color: #3a81c3; font-weight: bold;">if</span> <span style="color: #3a81c3; font-weight: bold;">not</span> os.path.exists<span style="color: #3a81c3;">(</span>save_file<span style="color: #3a81c3;">)</span>:
        init_mnist<span style="color: #3a81c3;">()</span>

    <span style="color: #3a81c3; font-weight: bold;">with</span> <span style="color: #3a81c3;">open</span><span style="color: #3a81c3;">(</span>save_file, <span style="color: #2d9574;">"rb"</span><span style="color: #3a81c3;">)</span> <span style="color: #3a81c3; font-weight: bold;">as</span> f:
        <span style="color: #715ab1;">dataset</span> = pickle.load<span style="color: #3a81c3;">(</span>f<span style="color: #3a81c3;">)</span>

    <span style="color: #3a81c3; font-weight: bold;">if</span> normalize:
        <span style="color: #3a81c3; font-weight: bold;">for</span> key <span style="color: #3a81c3; font-weight: bold;">in</span> <span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"train_img"</span>, <span style="color: #2d9574;">"test_img"</span><span style="color: #3a81c3;">)</span>:
            <span style="color: #715ab1;">dataset</span><span style="color: #3a81c3;">[</span>key<span style="color: #3a81c3;">]</span> = dataset<span style="color: #3a81c3;">[</span>key<span style="color: #3a81c3;">]</span>.astype<span style="color: #3a81c3;">(</span>np.float32<span style="color: #3a81c3;">)</span>
            <span style="color: #715ab1;">dataset</span><span style="color: #3a81c3;">[</span>key<span style="color: #3a81c3;">]</span> /= 255.0

    <span style="color: #3a81c3; font-weight: bold;">if</span> one_hot_label:
        <span style="color: #715ab1;">dataset</span><span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"train_label"</span><span style="color: #3a81c3;">]</span> = _change_one_hot_label<span style="color: #3a81c3;">(</span>dataset<span style="color: #6c3163;">[</span><span style="color: #2d9574;">"train_label"</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
        <span style="color: #715ab1;">dataset</span><span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"test_label"</span><span style="color: #3a81c3;">]</span> = _change_one_hot_label<span style="color: #3a81c3;">(</span>dataset<span style="color: #6c3163;">[</span><span style="color: #2d9574;">"test_label"</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>

    <span style="color: #3a81c3; font-weight: bold;">if</span> <span style="color: #3a81c3; font-weight: bold;">not</span> flatten:
        <span style="color: #3a81c3; font-weight: bold;">for</span> key <span style="color: #3a81c3; font-weight: bold;">in</span> <span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"train_img"</span>, <span style="color: #2d9574;">"test_img"</span><span style="color: #3a81c3;">)</span>:
            <span style="color: #715ab1;">dataset</span><span style="color: #3a81c3;">[</span>key<span style="color: #3a81c3;">]</span> = dataset<span style="color: #3a81c3;">[</span>key<span style="color: #3a81c3;">]</span>.reshape<span style="color: #3a81c3;">(</span>-1, 1, 28, 28<span style="color: #3a81c3;">)</span>

    <span style="color: #3a81c3; font-weight: bold;">return</span> <span style="color: #3a81c3;">(</span>dataset<span style="color: #6c3163;">[</span><span style="color: #2d9574;">"train_img"</span><span style="color: #6c3163;">]</span>, dataset<span style="color: #6c3163;">[</span><span style="color: #2d9574;">"train_label"</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>, <span style="color: #3a81c3;">(</span>
        dataset<span style="color: #6c3163;">[</span><span style="color: #2d9574;">"test_img"</span><span style="color: #6c3163;">]</span>,
        dataset<span style="color: #6c3163;">[</span><span style="color: #2d9574;">"test_label"</span><span style="color: #6c3163;">]</span>,
    <span style="color: #3a81c3;">)</span>


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">img_show</span><span style="color: #3a81c3;">(</span>img<span style="color: #3a81c3;">)</span>:
    <span style="color: #3a81c3; font-weight: bold;">from</span> PIL <span style="color: #3a81c3; font-weight: bold;">import</span> Image

    <span style="color: #715ab1;">pil_img</span> = Image.fromarray<span style="color: #3a81c3;">(</span>np.uint8<span style="color: #6c3163;">(</span>img<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
    pil_img.show<span style="color: #3a81c3;">()</span>


<span style="color: #3a81c3; font-weight: bold;">if</span> <span style="color: #3a81c3;">__name__</span> == <span style="color: #2d9574;">"__main__"</span>:
    <span style="color: #3a81c3;">(</span>x_train, t_train<span style="color: #3a81c3;">)</span>, <span style="color: #3a81c3;">(</span><span style="color: #715ab1;">x_test</span>, <span style="color: #715ab1;">t_test</span><span style="color: #3a81c3;">)</span> = load_mnist<span style="color: #3a81c3;">(</span>flatten=<span style="color: #4e3163;">True</span>, normalize=<span style="color: #4e3163;">False</span><span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">img</span> = x_train<span style="color: #3a81c3;">[</span>0<span style="color: #3a81c3;">]</span>
    <span style="color: #715ab1;">label</span> = t_train<span style="color: #3a81c3;">[</span>0<span style="color: #3a81c3;">]</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>label<span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>img.shape<span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">img</span> = img.reshape<span style="color: #3a81c3;">(</span>28, 28<span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>img.shape<span style="color: #3a81c3;">)</span>
    img_show<span style="color: #3a81c3;">(</span>img<span style="color: #3a81c3;">)</span>


<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;"># &lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">5</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">(784,)</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">(28, 28)</span>
</pre>
</div></li>
<li>我们从训练集的label可以看到，这个图的正确结果是一个5</li>
<li>我们想打印这个数据，但是因为我们flattern过，所以我们要reshape之后，再打印，我们在命令行运行会看到
一个图像5</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org5fbbef6" class="outline-4">
<h4 id="org5fbbef6"><span class="section-number-4">3.6.2.</span> 神经网络的推理处理</h4>
<div class="outline-text-4" id="text-3-6-2">
<ul class="org-ul">
<li>我们下面对这个MNIST数据集进行推理处理:
<ul class="org-ul">
<li>首先还是要注意,推理处理是在已经学习到"参数"的情况下进行的,我们的代码使用了之前已经学习好的参数,
并且把他们存储在了sample_weight.pkl</li>
<li>识别一个MNIST图像,就要把图像分解成像素.我们这里把输入的像素打平成一维数组,长度是784,那么我们的神
经网络的输入层就是有784个神经元</li>
<li>而我们识别的目的是0-9这个十个数字,所以我们的输出层就是有10个神经元</li>
<li>因为我们使用了已有的"参数"(存储在sample_weight.pkl),这个"参数"为整个神经网络设计了两个隐藏层:
<ol class="org-ol">
<li>第一个隐藏层有50个神经元</li>
<li>第二个隐藏层有100个单元</li>
</ol></li>
<li>设计几个隐藏层,每层有多少个神经元是一个玄学,我们称之为"超参"</li>
<li><p>
整个过程的全部代码如下
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #3a81c3; font-weight: bold;">import</span> urllib.request
<span style="color: #3a81c3; font-weight: bold;">import</span> gzip
<span style="color: #3a81c3; font-weight: bold;">import</span> numpy <span style="color: #3a81c3; font-weight: bold;">as</span> np
<span style="color: #3a81c3; font-weight: bold;">import</span> os
<span style="color: #3a81c3; font-weight: bold;">import</span> pickle

<span style="color: #715ab1;">url_base</span> = <span style="color: #2d9574;">"http://yann.lecun.com/exdb/mnist/"</span>
<span style="color: #715ab1;">key_file</span> = <span style="color: #3a81c3;">{</span>
    <span style="color: #2d9574;">"train_img"</span>: <span style="color: #2d9574;">"train-images-idx3-ubyte.gz"</span>,
    <span style="color: #2d9574;">"train_label"</span>: <span style="color: #2d9574;">"train-labels-idx1-ubyte.gz"</span>,
    <span style="color: #2d9574;">"test_img"</span>: <span style="color: #2d9574;">"t10k-images-idx3-ubyte.gz"</span>,
    <span style="color: #2d9574;">"test_label"</span>: <span style="color: #2d9574;">"t10k-labels-idx1-ubyte.gz"</span>,
<span style="color: #3a81c3;">}</span>

<span style="color: #715ab1;">dataset_dir</span> = os.path.dirname<span style="color: #3a81c3;">(</span>os.path.abspath<span style="color: #6c3163;">(</span>__file__<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
<span style="color: #715ab1;">save_file</span> = dataset_dir + <span style="color: #2d9574;">"/mnist.pkl"</span>

<span style="color: #715ab1;">train_num</span> = 60000
<span style="color: #715ab1;">test_num</span> = 10000
<span style="color: #715ab1;">img_dim</span> = <span style="color: #3a81c3;">(</span>1, 28, 28<span style="color: #3a81c3;">)</span>
<span style="color: #715ab1;">img_size</span> = 784


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">_download</span><span style="color: #3a81c3;">(</span>file_name<span style="color: #3a81c3;">)</span>:
    <span style="color: #715ab1;">file_path</span> = dataset_dir + <span style="color: #2d9574;">"/"</span> + file_name

    <span style="color: #3a81c3; font-weight: bold;">if</span> os.path.exists<span style="color: #3a81c3;">(</span>file_path<span style="color: #3a81c3;">)</span>:
        <span style="color: #3a81c3; font-weight: bold;">return</span>

    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Downloading "</span> + file_name + <span style="color: #2d9574;">" ... "</span><span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">headers</span> = <span style="color: #3a81c3;">{</span>
        <span style="color: #2d9574;">"User-Agent"</span>: <span style="color: #2d9574;">"Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:47.0) Gecko/20100101 Firefox/47.0"</span>
    <span style="color: #3a81c3;">}</span>
    <span style="color: #715ab1;">request</span> = urllib.request.Request<span style="color: #3a81c3;">(</span>url_base + file_name, headers=headers<span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">response</span> = urllib.request.urlopen<span style="color: #3a81c3;">(</span>request<span style="color: #3a81c3;">)</span>.read<span style="color: #3a81c3;">()</span>
    <span style="color: #3a81c3; font-weight: bold;">with</span> <span style="color: #3a81c3;">open</span><span style="color: #3a81c3;">(</span>file_path, mode=<span style="color: #2d9574;">"wb"</span><span style="color: #3a81c3;">)</span> <span style="color: #3a81c3; font-weight: bold;">as</span> f:
        f.write<span style="color: #3a81c3;">(</span>response<span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Done"</span><span style="color: #3a81c3;">)</span>


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">download_mnist</span><span style="color: #3a81c3;">()</span>:
    <span style="color: #3a81c3; font-weight: bold;">for</span> v <span style="color: #3a81c3; font-weight: bold;">in</span> key_file.values<span style="color: #3a81c3;">()</span>:
        _download<span style="color: #3a81c3;">(</span>v<span style="color: #3a81c3;">)</span>


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">_load_label</span><span style="color: #3a81c3;">(</span>file_name<span style="color: #3a81c3;">)</span>:
    <span style="color: #715ab1;">file_path</span> = dataset_dir + <span style="color: #2d9574;">"/"</span> + file_name

    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Converting "</span> + file_name + <span style="color: #2d9574;">" to NumPy Array ..."</span><span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3; font-weight: bold;">with</span> gzip.<span style="color: #3a81c3;">open</span><span style="color: #3a81c3;">(</span>file_path, <span style="color: #2d9574;">"rb"</span><span style="color: #3a81c3;">)</span> <span style="color: #3a81c3; font-weight: bold;">as</span> f:
        <span style="color: #715ab1;">labels</span> = np.frombuffer<span style="color: #3a81c3;">(</span>f.read<span style="color: #6c3163;">()</span>, np.uint8, offset=8<span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Done"</span><span style="color: #3a81c3;">)</span>

    <span style="color: #3a81c3; font-weight: bold;">return</span> labels


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">_load_img</span><span style="color: #3a81c3;">(</span>file_name<span style="color: #3a81c3;">)</span>:
    <span style="color: #715ab1;">file_path</span> = dataset_dir + <span style="color: #2d9574;">"/"</span> + file_name

    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Converting "</span> + file_name + <span style="color: #2d9574;">" to NumPy Array ..."</span><span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3; font-weight: bold;">with</span> gzip.<span style="color: #3a81c3;">open</span><span style="color: #3a81c3;">(</span>file_path, <span style="color: #2d9574;">"rb"</span><span style="color: #3a81c3;">)</span> <span style="color: #3a81c3; font-weight: bold;">as</span> f:
        <span style="color: #715ab1;">data</span> = np.frombuffer<span style="color: #3a81c3;">(</span>f.read<span style="color: #6c3163;">()</span>, np.uint8, offset=16<span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">data</span> = data.reshape<span style="color: #3a81c3;">(</span>-1, img_size<span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Done"</span><span style="color: #3a81c3;">)</span>

    <span style="color: #3a81c3; font-weight: bold;">return</span> data


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">_convert_numpy</span><span style="color: #3a81c3;">()</span>:
    <span style="color: #715ab1;">dataset</span> = <span style="color: #3a81c3;">{}</span>
    <span style="color: #715ab1;">dataset</span><span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"train_img"</span><span style="color: #3a81c3;">]</span> = _load_img<span style="color: #3a81c3;">(</span>key_file<span style="color: #6c3163;">[</span><span style="color: #2d9574;">"train_img"</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">dataset</span><span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"train_label"</span><span style="color: #3a81c3;">]</span> = _load_label<span style="color: #3a81c3;">(</span>key_file<span style="color: #6c3163;">[</span><span style="color: #2d9574;">"train_label"</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">dataset</span><span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"test_img"</span><span style="color: #3a81c3;">]</span> = _load_img<span style="color: #3a81c3;">(</span>key_file<span style="color: #6c3163;">[</span><span style="color: #2d9574;">"test_img"</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">dataset</span><span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"test_label"</span><span style="color: #3a81c3;">]</span> = _load_label<span style="color: #3a81c3;">(</span>key_file<span style="color: #6c3163;">[</span><span style="color: #2d9574;">"test_label"</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>

    <span style="color: #3a81c3; font-weight: bold;">return</span> dataset


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">init_mnist</span><span style="color: #3a81c3;">()</span>:
    download_mnist<span style="color: #3a81c3;">()</span>
    <span style="color: #715ab1;">dataset</span> = _convert_numpy<span style="color: #3a81c3;">()</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Creating pickle file ..."</span><span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3; font-weight: bold;">with</span> <span style="color: #3a81c3;">open</span><span style="color: #3a81c3;">(</span>save_file, <span style="color: #2d9574;">"wb"</span><span style="color: #3a81c3;">)</span> <span style="color: #3a81c3; font-weight: bold;">as</span> f:
        pickle.dump<span style="color: #3a81c3;">(</span>dataset, f, -1<span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Done!"</span><span style="color: #3a81c3;">)</span>


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">_change_one_hot_label</span><span style="color: #3a81c3;">(</span>X<span style="color: #3a81c3;">)</span>:
    <span style="color: #715ab1;">T</span> = np.zeros<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">(</span>X.size, 10<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3; font-weight: bold;">for</span> idx, row <span style="color: #3a81c3; font-weight: bold;">in</span> <span style="color: #3a81c3;">enumerate</span><span style="color: #3a81c3;">(</span>T<span style="color: #3a81c3;">)</span>:
        row<span style="color: #3a81c3;">[</span>X<span style="color: #6c3163;">[</span>idx<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">]</span> = 1

    <span style="color: #3a81c3; font-weight: bold;">return</span> T


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">load_mnist</span><span style="color: #3a81c3;">(</span>normalize=<span style="color: #4e3163;">True</span>, flatten=<span style="color: #4e3163;">True</span>, one_hot_label=<span style="color: #4e3163;">False</span><span style="color: #3a81c3;">)</span>:
    <span style="color: #3a81c3; font-weight: bold;">if</span> <span style="color: #3a81c3; font-weight: bold;">not</span> os.path.exists<span style="color: #3a81c3;">(</span>save_file<span style="color: #3a81c3;">)</span>:
        init_mnist<span style="color: #3a81c3;">()</span>

    <span style="color: #3a81c3; font-weight: bold;">with</span> <span style="color: #3a81c3;">open</span><span style="color: #3a81c3;">(</span>save_file, <span style="color: #2d9574;">"rb"</span><span style="color: #3a81c3;">)</span> <span style="color: #3a81c3; font-weight: bold;">as</span> f:
        <span style="color: #715ab1;">dataset</span> = pickle.load<span style="color: #3a81c3;">(</span>f<span style="color: #3a81c3;">)</span>

    <span style="color: #3a81c3; font-weight: bold;">if</span> normalize:
        <span style="color: #3a81c3; font-weight: bold;">for</span> key <span style="color: #3a81c3; font-weight: bold;">in</span> <span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"train_img"</span>, <span style="color: #2d9574;">"test_img"</span><span style="color: #3a81c3;">)</span>:
            <span style="color: #715ab1;">dataset</span><span style="color: #3a81c3;">[</span>key<span style="color: #3a81c3;">]</span> = dataset<span style="color: #3a81c3;">[</span>key<span style="color: #3a81c3;">]</span>.astype<span style="color: #3a81c3;">(</span>np.float32<span style="color: #3a81c3;">)</span>
            <span style="color: #715ab1;">dataset</span><span style="color: #3a81c3;">[</span>key<span style="color: #3a81c3;">]</span> /= 255.0

    <span style="color: #3a81c3; font-weight: bold;">if</span> one_hot_label:
        <span style="color: #715ab1;">dataset</span><span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"train_label"</span><span style="color: #3a81c3;">]</span> = _change_one_hot_label<span style="color: #3a81c3;">(</span>dataset<span style="color: #6c3163;">[</span><span style="color: #2d9574;">"train_label"</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
        <span style="color: #715ab1;">dataset</span><span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"test_label"</span><span style="color: #3a81c3;">]</span> = _change_one_hot_label<span style="color: #3a81c3;">(</span>dataset<span style="color: #6c3163;">[</span><span style="color: #2d9574;">"test_label"</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>

    <span style="color: #3a81c3; font-weight: bold;">if</span> <span style="color: #3a81c3; font-weight: bold;">not</span> flatten:
        <span style="color: #3a81c3; font-weight: bold;">for</span> key <span style="color: #3a81c3; font-weight: bold;">in</span> <span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"train_img"</span>, <span style="color: #2d9574;">"test_img"</span><span style="color: #3a81c3;">)</span>:
            <span style="color: #715ab1;">dataset</span><span style="color: #3a81c3;">[</span>key<span style="color: #3a81c3;">]</span> = dataset<span style="color: #3a81c3;">[</span>key<span style="color: #3a81c3;">]</span>.reshape<span style="color: #3a81c3;">(</span>-1, 1, 28, 28<span style="color: #3a81c3;">)</span>

    <span style="color: #3a81c3; font-weight: bold;">return</span> <span style="color: #3a81c3;">(</span>dataset<span style="color: #6c3163;">[</span><span style="color: #2d9574;">"train_img"</span><span style="color: #6c3163;">]</span>, dataset<span style="color: #6c3163;">[</span><span style="color: #2d9574;">"train_label"</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>, <span style="color: #3a81c3;">(</span>
        dataset<span style="color: #6c3163;">[</span><span style="color: #2d9574;">"test_img"</span><span style="color: #6c3163;">]</span>,
        dataset<span style="color: #6c3163;">[</span><span style="color: #2d9574;">"test_label"</span><span style="color: #6c3163;">]</span>,
    <span style="color: #3a81c3;">)</span>


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">sigmoid</span><span style="color: #3a81c3;">(</span>x<span style="color: #3a81c3;">)</span>:
    <span style="color: #3a81c3; font-weight: bold;">return</span> 1 / <span style="color: #3a81c3;">(</span>1 + np.exp<span style="color: #6c3163;">(</span>-x<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">softmax</span><span style="color: #3a81c3;">(</span>x<span style="color: #3a81c3;">)</span>:
    <span style="color: #715ab1;">x</span> = x - np.<span style="color: #3a81c3;">max</span><span style="color: #3a81c3;">(</span>x, axis=-1, keepdims=<span style="color: #4e3163;">True</span><span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3; font-weight: bold;">return</span> np.exp<span style="color: #3a81c3;">(</span>x<span style="color: #3a81c3;">)</span> / np.<span style="color: #3a81c3;">sum</span><span style="color: #3a81c3;">(</span>np.exp<span style="color: #6c3163;">(</span>x<span style="color: #6c3163;">)</span>, axis=-1, keepdims=<span style="color: #4e3163;">True</span><span style="color: #3a81c3;">)</span>


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">get_data</span><span style="color: #3a81c3;">()</span>:
    <span style="color: #3a81c3;">(</span>x_train, t_train<span style="color: #3a81c3;">)</span>, <span style="color: #3a81c3;">(</span><span style="color: #715ab1;">x_test</span>, <span style="color: #715ab1;">t_test</span><span style="color: #3a81c3;">)</span> = load_mnist<span style="color: #3a81c3;">(</span>
        normalize=<span style="color: #4e3163;">True</span>, flatten=<span style="color: #4e3163;">True</span>, one_hot_label=<span style="color: #4e3163;">False</span>
    <span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3; font-weight: bold;">return</span> x_test, t_test


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">init_network</span><span style="color: #3a81c3;">()</span>:
    <span style="color: #3a81c3; font-weight: bold;">with</span> <span style="color: #3a81c3;">open</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"sample_weight.pkl"</span>, <span style="color: #2d9574;">"rb"</span><span style="color: #3a81c3;">)</span> <span style="color: #3a81c3; font-weight: bold;">as</span> f:
        <span style="color: #715ab1;">network</span> = pickle.load<span style="color: #3a81c3;">(</span>f<span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3; font-weight: bold;">return</span> network


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">predict</span><span style="color: #3a81c3;">(</span>network, x<span style="color: #3a81c3;">)</span>:
    <span style="color: #715ab1;">W1</span>, <span style="color: #715ab1;">W2</span>, <span style="color: #715ab1;">W3</span> = network<span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"W1"</span><span style="color: #3a81c3;">]</span>, network<span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"W2"</span><span style="color: #3a81c3;">]</span>, network<span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"W3"</span><span style="color: #3a81c3;">]</span>
    <span style="color: #715ab1;">b1</span>, <span style="color: #715ab1;">b2</span>, <span style="color: #715ab1;">b3</span> = network<span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"b1"</span><span style="color: #3a81c3;">]</span>, network<span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"b2"</span><span style="color: #3a81c3;">]</span>, network<span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"b3"</span><span style="color: #3a81c3;">]</span>

    <span style="color: #715ab1;">a1</span> = np.dot<span style="color: #3a81c3;">(</span>x, W1<span style="color: #3a81c3;">)</span> + b1
    <span style="color: #715ab1;">z1</span> = sigmoid<span style="color: #3a81c3;">(</span>a1<span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">a2</span> = np.dot<span style="color: #3a81c3;">(</span>z1, W2<span style="color: #3a81c3;">)</span> + b2
    <span style="color: #715ab1;">z2</span> = sigmoid<span style="color: #3a81c3;">(</span>a2<span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">a3</span> = np.dot<span style="color: #3a81c3;">(</span>z2, W3<span style="color: #3a81c3;">)</span> + b3
    <span style="color: #715ab1;">y</span> = softmax<span style="color: #3a81c3;">(</span>a3<span style="color: #3a81c3;">)</span>

    <span style="color: #3a81c3; font-weight: bold;">return</span> y


<span style="color: #3a81c3; font-weight: bold;">if</span> <span style="color: #3a81c3;">__name__</span> == <span style="color: #2d9574;">"__main__"</span>:
    <span style="color: #715ab1;">x</span>, <span style="color: #715ab1;">t</span> = get_data<span style="color: #3a81c3;">()</span>
    <span style="color: #715ab1;">network</span> = init_network<span style="color: #3a81c3;">()</span>
    <span style="color: #715ab1;">accuracy_cnt</span> = 0
    <span style="color: #3a81c3; font-weight: bold;">for</span> i <span style="color: #3a81c3; font-weight: bold;">in</span> <span style="color: #3a81c3;">range</span><span style="color: #3a81c3;">(</span><span style="color: #3a81c3;">len</span><span style="color: #6c3163;">(</span>x<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>:
        <span style="color: #715ab1;">y</span> = predict<span style="color: #3a81c3;">(</span>network, x<span style="color: #6c3163;">[</span>i<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
        <span style="color: #715ab1;">p</span> = np.argmax<span style="color: #3a81c3;">(</span>y<span style="color: #3a81c3;">)</span>
        <span style="color: #3a81c3; font-weight: bold;">if</span> p == t<span style="color: #3a81c3;">[</span>i<span style="color: #3a81c3;">]</span>:
            <span style="color: #715ab1;">accuracy_cnt</span> += 1

    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Accuracy:"</span> + <span style="color: #3a81c3;">str</span><span style="color: #6c3163;">(</span><span style="color: #3a81c3;">float</span><span style="color: #2d9574;">(</span>accuracy_cnt<span style="color: #2d9574;">)</span> / <span style="color: #3a81c3;">len</span><span style="color: #2d9574;">(</span>x<span style="color: #2d9574;">)</span><span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Accuracy:0.9352</span>
</pre>
</div></li>
<li><p>
"推理"一个图像属于哪个数字的代码如下(输入是一个长度为784的数组,输出是一个长度为10的数组,表明图像是0-9的概率)
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">get_data</span><span style="color: #3a81c3;">()</span>:
    <span style="color: #3a81c3;">(</span>x_train, t_train<span style="color: #3a81c3;">)</span>, <span style="color: #3a81c3;">(</span><span style="color: #715ab1;">x_test</span>, <span style="color: #715ab1;">t_test</span><span style="color: #3a81c3;">)</span> = load_mnist<span style="color: #3a81c3;">(</span>
        normalize=<span style="color: #4e3163;">True</span>, flatten=<span style="color: #4e3163;">True</span>, one_hot_label=<span style="color: #4e3163;">False</span>
    <span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3; font-weight: bold;">return</span> x_test, t_test


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">init_network</span><span style="color: #3a81c3;">()</span>:
    <span style="color: #3a81c3; font-weight: bold;">with</span> <span style="color: #3a81c3;">open</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"sample_weight.pkl"</span>, <span style="color: #2d9574;">"rb"</span><span style="color: #3a81c3;">)</span> <span style="color: #3a81c3; font-weight: bold;">as</span> f:
        <span style="color: #715ab1;">network</span> = pickle.load<span style="color: #3a81c3;">(</span>f<span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3; font-weight: bold;">return</span> network


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">predict</span><span style="color: #3a81c3;">(</span>network, x<span style="color: #3a81c3;">)</span>:
    <span style="color: #715ab1;">W1</span>, <span style="color: #715ab1;">W2</span>, <span style="color: #715ab1;">W3</span> = network<span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"W1"</span><span style="color: #3a81c3;">]</span>, network<span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"W2"</span><span style="color: #3a81c3;">]</span>, network<span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"W3"</span><span style="color: #3a81c3;">]</span>
    <span style="color: #715ab1;">b1</span>, <span style="color: #715ab1;">b2</span>, <span style="color: #715ab1;">b3</span> = network<span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"b1"</span><span style="color: #3a81c3;">]</span>, network<span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"b2"</span><span style="color: #3a81c3;">]</span>, network<span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"b3"</span><span style="color: #3a81c3;">]</span>

    <span style="color: #715ab1;">a1</span> = np.dot<span style="color: #3a81c3;">(</span>x, W1<span style="color: #3a81c3;">)</span> + b1
    <span style="color: #715ab1;">z1</span> = sigmoid<span style="color: #3a81c3;">(</span>a1<span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">a2</span> = np.dot<span style="color: #3a81c3;">(</span>z1, W2<span style="color: #3a81c3;">)</span> + b2
    <span style="color: #715ab1;">z2</span> = sigmoid<span style="color: #3a81c3;">(</span>a2<span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">a3</span> = np.dot<span style="color: #3a81c3;">(</span>z2, W3<span style="color: #3a81c3;">)</span> + b3
    <span style="color: #715ab1;">y</span> = softmax<span style="color: #3a81c3;">(</span>a3<span style="color: #3a81c3;">)</span>

    <span style="color: #3a81c3; font-weight: bold;">return</span> y
</pre>
</div></li>
<li><p>
"参数"并不是我们训练的,我们只是用这个"参数"来进行"推理",判定这个"参数"好不好的标志,就是看看这个
参数判断100个(没见过的)图像能判断对几个.首先获取"没见过的图像"
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">get_data</span><span style="color: #3a81c3;">()</span>:
    <span style="color: #3a81c3;">(</span>x_train, t_train<span style="color: #3a81c3;">)</span>, <span style="color: #3a81c3;">(</span><span style="color: #715ab1;">x_test</span>, <span style="color: #715ab1;">t_test</span><span style="color: #3a81c3;">)</span> = load_mnist<span style="color: #3a81c3;">(</span>
        normalize=<span style="color: #4e3163;">True</span>, flatten=<span style="color: #4e3163;">True</span>, one_hot_label=<span style="color: #4e3163;">False</span>
    <span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3; font-weight: bold;">return</span> x_test, t_test
</pre>
</div></li>
<li><p>
然后我们在main函数里面就是判定"参数"能够在"没见过"的图像里面,正确的认识几个:通过 np.argmax(y) 获
取到概率最大的数字,并且和标签t[i]进行比较,相等算"推理"成功一个
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #3a81c3; font-weight: bold;">if</span> <span style="color: #3a81c3;">__name__</span> == <span style="color: #2d9574;">"__main__"</span>:
    <span style="color: #715ab1;">x</span>, <span style="color: #715ab1;">t</span> = get_data<span style="color: #3a81c3;">()</span>
    <span style="color: #715ab1;">network</span> = init_network<span style="color: #3a81c3;">()</span>
    <span style="color: #715ab1;">accuracy_cnt</span> = 0
    <span style="color: #3a81c3; font-weight: bold;">for</span> i <span style="color: #3a81c3; font-weight: bold;">in</span> <span style="color: #3a81c3;">range</span><span style="color: #3a81c3;">(</span><span style="color: #3a81c3;">len</span><span style="color: #6c3163;">(</span>x<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>:
        <span style="color: #715ab1;">y</span> = predict<span style="color: #3a81c3;">(</span>network, x<span style="color: #6c3163;">[</span>i<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
        <span style="color: #715ab1;">p</span> = np.argmax<span style="color: #3a81c3;">(</span>y<span style="color: #3a81c3;">)</span>
        <span style="color: #3a81c3; font-weight: bold;">if</span> p == t<span style="color: #3a81c3;">[</span>i<span style="color: #3a81c3;">]</span>:
            <span style="color: #715ab1;">accuracy_cnt</span> += 1

    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Accuracy:"</span> + <span style="color: #3a81c3;">str</span><span style="color: #6c3163;">(</span><span style="color: #3a81c3;">float</span><span style="color: #2d9574;">(</span>accuracy_cnt<span style="color: #2d9574;">)</span> / <span style="color: #3a81c3;">len</span><span style="color: #2d9574;">(</span>x<span style="color: #2d9574;">)</span><span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Accuracy:0.9352</span>
</pre>
</div></li>
<li><p>
还有一点,我们在load_mnist的时候把normalize设置成了True,这就意味着数组的784个成员,每个都是0-1.0,
像这样吧数据限定到某个范围内的处理称之为正规化(normalization),正规化能够提高深度学习模型的性能
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #3a81c3;">(</span>x_train, t_train<span style="color: #3a81c3;">)</span>, <span style="color: #3a81c3;">(</span><span style="color: #715ab1;">x_test</span>, <span style="color: #715ab1;">t_test</span><span style="color: #3a81c3;">)</span> = load_mnist<span style="color: #3a81c3;">(</span>
    normalize=<span style="color: #4e3163;">True</span>, flatten=<span style="color: #4e3163;">True</span>, one_hot_label=<span style="color: #4e3163;">False</span>
<span style="color: #3a81c3;">)</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org69f1270" class="outline-4">
<h4 id="org69f1270"><span class="section-number-4">3.6.3.</span> 批处理</h4>
<div class="outline-text-4" id="text-3-6-3">
<ul class="org-ul">
<li>上述是一次性处理一个image的情况,最终的输出是一个一维数组,长度是10,分别代表image为0-9的概率
<ul class="org-ul">
<li><p>
一次性处理一个image的参数列表如下
</p>

<div id="org7816b26" class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/image/master/dlfs/3-26.png" alt="3-26.png" />
</p>
<p><span class="figure-number">Figure 35: </span>dlfs/3-26.png</p>
</div></li>
<li>我们可以看到,我们的输入参数可以理解为1*784,输出是1*10</li>
<li><p>
那么如果我们每次传入100张图片呢?其实就是输入变成了100*784,我们的"参数"完全不用更改,最后的结果也
变了,变成了100*10,如下图
</p>

<div id="org0e4e124" class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/image/master/dlfs/3-27.png" alt="3-27.png" />
</p>
<p><span class="figure-number">Figure 36: </span>dlfs/3-27.png</p>
</div></li>
<li>输入变成一百个,输出也相应变成100个,这得益于矩阵的特性.这种打包式的输入称之为批(batch)</li>
</ul></li>
<li>批处理只会更改部分代码
<ul class="org-ul">
<li><p>
总体代码如下
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #3a81c3; font-weight: bold;">import</span> urllib.request
<span style="color: #3a81c3; font-weight: bold;">import</span> gzip
<span style="color: #3a81c3; font-weight: bold;">import</span> numpy <span style="color: #3a81c3; font-weight: bold;">as</span> np
<span style="color: #3a81c3; font-weight: bold;">import</span> os
<span style="color: #3a81c3; font-weight: bold;">import</span> pickle

<span style="color: #715ab1;">url_base</span> = <span style="color: #2d9574;">"http://yann.lecun.com/exdb/mnist/"</span>
<span style="color: #715ab1;">key_file</span> = <span style="color: #3a81c3;">{</span>
    <span style="color: #2d9574;">"train_img"</span>: <span style="color: #2d9574;">"train-images-idx3-ubyte.gz"</span>,
    <span style="color: #2d9574;">"train_label"</span>: <span style="color: #2d9574;">"train-labels-idx1-ubyte.gz"</span>,
    <span style="color: #2d9574;">"test_img"</span>: <span style="color: #2d9574;">"t10k-images-idx3-ubyte.gz"</span>,
    <span style="color: #2d9574;">"test_label"</span>: <span style="color: #2d9574;">"t10k-labels-idx1-ubyte.gz"</span>,
<span style="color: #3a81c3;">}</span>

<span style="color: #715ab1;">dataset_dir</span> = os.path.dirname<span style="color: #3a81c3;">(</span>os.path.abspath<span style="color: #6c3163;">(</span>__file__<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
<span style="color: #715ab1;">save_file</span> = dataset_dir + <span style="color: #2d9574;">"/mnist.pkl"</span>

<span style="color: #715ab1;">train_num</span> = 60000
<span style="color: #715ab1;">test_num</span> = 10000
<span style="color: #715ab1;">img_dim</span> = <span style="color: #3a81c3;">(</span>1, 28, 28<span style="color: #3a81c3;">)</span>
<span style="color: #715ab1;">img_size</span> = 784


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">_download</span><span style="color: #3a81c3;">(</span>file_name<span style="color: #3a81c3;">)</span>:
    <span style="color: #715ab1;">file_path</span> = dataset_dir + <span style="color: #2d9574;">"/"</span> + file_name

    <span style="color: #3a81c3; font-weight: bold;">if</span> os.path.exists<span style="color: #3a81c3;">(</span>file_path<span style="color: #3a81c3;">)</span>:
        <span style="color: #3a81c3; font-weight: bold;">return</span>

    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Downloading "</span> + file_name + <span style="color: #2d9574;">" ... "</span><span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">headers</span> = <span style="color: #3a81c3;">{</span>
        <span style="color: #2d9574;">"User-Agent"</span>: <span style="color: #2d9574;">"Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:47.0) Gecko/20100101 Firefox/47.0"</span>
    <span style="color: #3a81c3;">}</span>
    <span style="color: #715ab1;">request</span> = urllib.request.Request<span style="color: #3a81c3;">(</span>url_base + file_name, headers=headers<span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">response</span> = urllib.request.urlopen<span style="color: #3a81c3;">(</span>request<span style="color: #3a81c3;">)</span>.read<span style="color: #3a81c3;">()</span>
    <span style="color: #3a81c3; font-weight: bold;">with</span> <span style="color: #3a81c3;">open</span><span style="color: #3a81c3;">(</span>file_path, mode=<span style="color: #2d9574;">"wb"</span><span style="color: #3a81c3;">)</span> <span style="color: #3a81c3; font-weight: bold;">as</span> f:
        f.write<span style="color: #3a81c3;">(</span>response<span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Done"</span><span style="color: #3a81c3;">)</span>


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">download_mnist</span><span style="color: #3a81c3;">()</span>:
    <span style="color: #3a81c3; font-weight: bold;">for</span> v <span style="color: #3a81c3; font-weight: bold;">in</span> key_file.values<span style="color: #3a81c3;">()</span>:
        _download<span style="color: #3a81c3;">(</span>v<span style="color: #3a81c3;">)</span>


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">_load_label</span><span style="color: #3a81c3;">(</span>file_name<span style="color: #3a81c3;">)</span>:
    <span style="color: #715ab1;">file_path</span> = dataset_dir + <span style="color: #2d9574;">"/"</span> + file_name

    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Converting "</span> + file_name + <span style="color: #2d9574;">" to NumPy Array ..."</span><span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3; font-weight: bold;">with</span> gzip.<span style="color: #3a81c3;">open</span><span style="color: #3a81c3;">(</span>file_path, <span style="color: #2d9574;">"rb"</span><span style="color: #3a81c3;">)</span> <span style="color: #3a81c3; font-weight: bold;">as</span> f:
        <span style="color: #715ab1;">labels</span> = np.frombuffer<span style="color: #3a81c3;">(</span>f.read<span style="color: #6c3163;">()</span>, np.uint8, offset=8<span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Done"</span><span style="color: #3a81c3;">)</span>

    <span style="color: #3a81c3; font-weight: bold;">return</span> labels


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">_load_img</span><span style="color: #3a81c3;">(</span>file_name<span style="color: #3a81c3;">)</span>:
    <span style="color: #715ab1;">file_path</span> = dataset_dir + <span style="color: #2d9574;">"/"</span> + file_name

    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Converting "</span> + file_name + <span style="color: #2d9574;">" to NumPy Array ..."</span><span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3; font-weight: bold;">with</span> gzip.<span style="color: #3a81c3;">open</span><span style="color: #3a81c3;">(</span>file_path, <span style="color: #2d9574;">"rb"</span><span style="color: #3a81c3;">)</span> <span style="color: #3a81c3; font-weight: bold;">as</span> f:
        <span style="color: #715ab1;">data</span> = np.frombuffer<span style="color: #3a81c3;">(</span>f.read<span style="color: #6c3163;">()</span>, np.uint8, offset=16<span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">data</span> = data.reshape<span style="color: #3a81c3;">(</span>-1, img_size<span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Done"</span><span style="color: #3a81c3;">)</span>

    <span style="color: #3a81c3; font-weight: bold;">return</span> data


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">_convert_numpy</span><span style="color: #3a81c3;">()</span>:
    <span style="color: #715ab1;">dataset</span> = <span style="color: #3a81c3;">{}</span>
    <span style="color: #715ab1;">dataset</span><span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"train_img"</span><span style="color: #3a81c3;">]</span> = _load_img<span style="color: #3a81c3;">(</span>key_file<span style="color: #6c3163;">[</span><span style="color: #2d9574;">"train_img"</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">dataset</span><span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"train_label"</span><span style="color: #3a81c3;">]</span> = _load_label<span style="color: #3a81c3;">(</span>key_file<span style="color: #6c3163;">[</span><span style="color: #2d9574;">"train_label"</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">dataset</span><span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"test_img"</span><span style="color: #3a81c3;">]</span> = _load_img<span style="color: #3a81c3;">(</span>key_file<span style="color: #6c3163;">[</span><span style="color: #2d9574;">"test_img"</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">dataset</span><span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"test_label"</span><span style="color: #3a81c3;">]</span> = _load_label<span style="color: #3a81c3;">(</span>key_file<span style="color: #6c3163;">[</span><span style="color: #2d9574;">"test_label"</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>

    <span style="color: #3a81c3; font-weight: bold;">return</span> dataset


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">init_mnist</span><span style="color: #3a81c3;">()</span>:
    download_mnist<span style="color: #3a81c3;">()</span>
    <span style="color: #715ab1;">dataset</span> = _convert_numpy<span style="color: #3a81c3;">()</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Creating pickle file ..."</span><span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3; font-weight: bold;">with</span> <span style="color: #3a81c3;">open</span><span style="color: #3a81c3;">(</span>save_file, <span style="color: #2d9574;">"wb"</span><span style="color: #3a81c3;">)</span> <span style="color: #3a81c3; font-weight: bold;">as</span> f:
        pickle.dump<span style="color: #3a81c3;">(</span>dataset, f, -1<span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Done!"</span><span style="color: #3a81c3;">)</span>


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">_change_one_hot_label</span><span style="color: #3a81c3;">(</span>X<span style="color: #3a81c3;">)</span>:
    <span style="color: #715ab1;">T</span> = np.zeros<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">(</span>X.size, 10<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3; font-weight: bold;">for</span> idx, row <span style="color: #3a81c3; font-weight: bold;">in</span> <span style="color: #3a81c3;">enumerate</span><span style="color: #3a81c3;">(</span>T<span style="color: #3a81c3;">)</span>:
        row<span style="color: #3a81c3;">[</span>X<span style="color: #6c3163;">[</span>idx<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">]</span> = 1

    <span style="color: #3a81c3; font-weight: bold;">return</span> T


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">load_mnist</span><span style="color: #3a81c3;">(</span>normalize=<span style="color: #4e3163;">True</span>, flatten=<span style="color: #4e3163;">True</span>, one_hot_label=<span style="color: #4e3163;">False</span><span style="color: #3a81c3;">)</span>:
    <span style="color: #3a81c3; font-weight: bold;">if</span> <span style="color: #3a81c3; font-weight: bold;">not</span> os.path.exists<span style="color: #3a81c3;">(</span>save_file<span style="color: #3a81c3;">)</span>:
        init_mnist<span style="color: #3a81c3;">()</span>

    <span style="color: #3a81c3; font-weight: bold;">with</span> <span style="color: #3a81c3;">open</span><span style="color: #3a81c3;">(</span>save_file, <span style="color: #2d9574;">"rb"</span><span style="color: #3a81c3;">)</span> <span style="color: #3a81c3; font-weight: bold;">as</span> f:
        <span style="color: #715ab1;">dataset</span> = pickle.load<span style="color: #3a81c3;">(</span>f<span style="color: #3a81c3;">)</span>

    <span style="color: #3a81c3; font-weight: bold;">if</span> normalize:
        <span style="color: #3a81c3; font-weight: bold;">for</span> key <span style="color: #3a81c3; font-weight: bold;">in</span> <span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"train_img"</span>, <span style="color: #2d9574;">"test_img"</span><span style="color: #3a81c3;">)</span>:
            <span style="color: #715ab1;">dataset</span><span style="color: #3a81c3;">[</span>key<span style="color: #3a81c3;">]</span> = dataset<span style="color: #3a81c3;">[</span>key<span style="color: #3a81c3;">]</span>.astype<span style="color: #3a81c3;">(</span>np.float32<span style="color: #3a81c3;">)</span>
            <span style="color: #715ab1;">dataset</span><span style="color: #3a81c3;">[</span>key<span style="color: #3a81c3;">]</span> /= 255.0

    <span style="color: #3a81c3; font-weight: bold;">if</span> one_hot_label:
        <span style="color: #715ab1;">dataset</span><span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"train_label"</span><span style="color: #3a81c3;">]</span> = _change_one_hot_label<span style="color: #3a81c3;">(</span>dataset<span style="color: #6c3163;">[</span><span style="color: #2d9574;">"train_label"</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
        <span style="color: #715ab1;">dataset</span><span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"test_label"</span><span style="color: #3a81c3;">]</span> = _change_one_hot_label<span style="color: #3a81c3;">(</span>dataset<span style="color: #6c3163;">[</span><span style="color: #2d9574;">"test_label"</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>

    <span style="color: #3a81c3; font-weight: bold;">if</span> <span style="color: #3a81c3; font-weight: bold;">not</span> flatten:
        <span style="color: #3a81c3; font-weight: bold;">for</span> key <span style="color: #3a81c3; font-weight: bold;">in</span> <span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"train_img"</span>, <span style="color: #2d9574;">"test_img"</span><span style="color: #3a81c3;">)</span>:
            <span style="color: #715ab1;">dataset</span><span style="color: #3a81c3;">[</span>key<span style="color: #3a81c3;">]</span> = dataset<span style="color: #3a81c3;">[</span>key<span style="color: #3a81c3;">]</span>.reshape<span style="color: #3a81c3;">(</span>-1, 1, 28, 28<span style="color: #3a81c3;">)</span>

    <span style="color: #3a81c3; font-weight: bold;">return</span> <span style="color: #3a81c3;">(</span>dataset<span style="color: #6c3163;">[</span><span style="color: #2d9574;">"train_img"</span><span style="color: #6c3163;">]</span>, dataset<span style="color: #6c3163;">[</span><span style="color: #2d9574;">"train_label"</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>, <span style="color: #3a81c3;">(</span>
        dataset<span style="color: #6c3163;">[</span><span style="color: #2d9574;">"test_img"</span><span style="color: #6c3163;">]</span>,
        dataset<span style="color: #6c3163;">[</span><span style="color: #2d9574;">"test_label"</span><span style="color: #6c3163;">]</span>,
    <span style="color: #3a81c3;">)</span>


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">sigmoid</span><span style="color: #3a81c3;">(</span>x<span style="color: #3a81c3;">)</span>:
    <span style="color: #3a81c3; font-weight: bold;">return</span> 1 / <span style="color: #3a81c3;">(</span>1 + np.exp<span style="color: #6c3163;">(</span>-x<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">softmax</span><span style="color: #3a81c3;">(</span>x<span style="color: #3a81c3;">)</span>:
    <span style="color: #715ab1;">x</span> = x - np.<span style="color: #3a81c3;">max</span><span style="color: #3a81c3;">(</span>x, axis=-1, keepdims=<span style="color: #4e3163;">True</span><span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3; font-weight: bold;">return</span> np.exp<span style="color: #3a81c3;">(</span>x<span style="color: #3a81c3;">)</span> / np.<span style="color: #3a81c3;">sum</span><span style="color: #3a81c3;">(</span>np.exp<span style="color: #6c3163;">(</span>x<span style="color: #6c3163;">)</span>, axis=-1, keepdims=<span style="color: #4e3163;">True</span><span style="color: #3a81c3;">)</span>


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">get_data</span><span style="color: #3a81c3;">()</span>:
    <span style="color: #3a81c3;">(</span>x_train, t_train<span style="color: #3a81c3;">)</span>, <span style="color: #3a81c3;">(</span><span style="color: #715ab1;">x_test</span>, <span style="color: #715ab1;">t_test</span><span style="color: #3a81c3;">)</span> = load_mnist<span style="color: #3a81c3;">(</span>
        normalize=<span style="color: #4e3163;">True</span>, flatten=<span style="color: #4e3163;">True</span>, one_hot_label=<span style="color: #4e3163;">False</span>
    <span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3; font-weight: bold;">return</span> x_test, t_test


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">init_network</span><span style="color: #3a81c3;">()</span>:
    <span style="color: #3a81c3; font-weight: bold;">with</span> <span style="color: #3a81c3;">open</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"sample_weight.pkl"</span>, <span style="color: #2d9574;">"rb"</span><span style="color: #3a81c3;">)</span> <span style="color: #3a81c3; font-weight: bold;">as</span> f:
        <span style="color: #715ab1;">network</span> = pickle.load<span style="color: #3a81c3;">(</span>f<span style="color: #3a81c3;">)</span>
    <span style="color: #3a81c3; font-weight: bold;">return</span> network


<span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">predict</span><span style="color: #3a81c3;">(</span>network, x<span style="color: #3a81c3;">)</span>:
    <span style="color: #715ab1;">W1</span>, <span style="color: #715ab1;">W2</span>, <span style="color: #715ab1;">W3</span> = network<span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"W1"</span><span style="color: #3a81c3;">]</span>, network<span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"W2"</span><span style="color: #3a81c3;">]</span>, network<span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"W3"</span><span style="color: #3a81c3;">]</span>
    <span style="color: #715ab1;">b1</span>, <span style="color: #715ab1;">b2</span>, <span style="color: #715ab1;">b3</span> = network<span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"b1"</span><span style="color: #3a81c3;">]</span>, network<span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"b2"</span><span style="color: #3a81c3;">]</span>, network<span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"b3"</span><span style="color: #3a81c3;">]</span>

    <span style="color: #715ab1;">a1</span> = np.dot<span style="color: #3a81c3;">(</span>x, W1<span style="color: #3a81c3;">)</span> + b1
    <span style="color: #715ab1;">z1</span> = sigmoid<span style="color: #3a81c3;">(</span>a1<span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">a2</span> = np.dot<span style="color: #3a81c3;">(</span>z1, W2<span style="color: #3a81c3;">)</span> + b2
    <span style="color: #715ab1;">z2</span> = sigmoid<span style="color: #3a81c3;">(</span>a2<span style="color: #3a81c3;">)</span>
    <span style="color: #715ab1;">a3</span> = np.dot<span style="color: #3a81c3;">(</span>z2, W3<span style="color: #3a81c3;">)</span> + b3
    <span style="color: #715ab1;">y</span> = softmax<span style="color: #3a81c3;">(</span>a3<span style="color: #3a81c3;">)</span>

    <span style="color: #3a81c3; font-weight: bold;">return</span> y


<span style="color: #3a81c3; font-weight: bold;">if</span> <span style="color: #3a81c3;">__name__</span> == <span style="color: #2d9574;">"__main__"</span>:
    <span style="color: #715ab1;">x</span>, <span style="color: #715ab1;">t</span> = get_data<span style="color: #3a81c3;">()</span>
    <span style="color: #715ab1;">network</span> = init_network<span style="color: #3a81c3;">()</span>

    <span style="color: #715ab1;">batch_size</span> = 100
    <span style="color: #715ab1;">accuracy_cnt</span> = 0

    <span style="color: #3a81c3; font-weight: bold;">for</span> i <span style="color: #3a81c3; font-weight: bold;">in</span> <span style="color: #3a81c3;">range</span><span style="color: #3a81c3;">(</span>0, <span style="color: #3a81c3;">len</span><span style="color: #6c3163;">(</span>x<span style="color: #6c3163;">)</span>, batch_size<span style="color: #3a81c3;">)</span>:
        <span style="color: #715ab1;">x_batch</span> = x<span style="color: #3a81c3;">[</span>i : i + batch_size<span style="color: #3a81c3;">]</span>
        <span style="color: #715ab1;">y_batch</span> = predict<span style="color: #3a81c3;">(</span>network, x_batch<span style="color: #3a81c3;">)</span>
        <span style="color: #715ab1;">p</span> = np.argmax<span style="color: #3a81c3;">(</span>y_batch, axis=1<span style="color: #3a81c3;">)</span>
        <span style="color: #715ab1;">accuracy_cnt</span> += np.<span style="color: #3a81c3;">sum</span><span style="color: #3a81c3;">(</span>p == t<span style="color: #6c3163;">[</span>i : i + batch_size<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>

    <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Accuracy:"</span> + <span style="color: #3a81c3;">str</span><span style="color: #6c3163;">(</span><span style="color: #3a81c3;">float</span><span style="color: #2d9574;">(</span>accuracy_cnt<span style="color: #2d9574;">)</span> / <span style="color: #3a81c3;">len</span><span style="color: #2d9574;">(</span>x<span style="color: #2d9574;">)</span><span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">#  </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Accuracy:0.9352</span>

</pre>
</div></li>
<li><p>
和之前代码不一样的地方如下
</p>
<div class="org-src-container">
<pre class="src src-diff"> if __name__ == "__main__":
     x, t = get_data()
     network = init_network()
<span style="color: #67b11d;">+</span>
<span style="color: #67b11d;">+</span><span style="color: #67b11d;">    batch_size = 100</span>
     accuracy_cnt = 0
<span style="color: #f2241f;">-</span><span style="color: #f2241f;">    for i in range(len(x)):</span>
<span style="color: #f2241f;">-</span><span style="color: #f2241f;">        y = predict(network, x[i])</span>
<span style="color: #f2241f;">-</span><span style="color: #f2241f;">        p = np.argmax(y)</span>
<span style="color: #f2241f;">-</span><span style="color: #f2241f;">        if p == t[i]:</span>
<span style="color: #f2241f;">-</span><span style="color: #f2241f;">            accuracy_cnt += 1</span>
<span style="color: #67b11d;">+</span>
<span style="color: #67b11d;">+</span><span style="color: #67b11d;">    for i in range(0, len(x), batch_size):</span>
<span style="color: #67b11d;">+</span><span style="color: #67b11d;">        x_batch = x[i : i + batch_size]</span>
<span style="color: #67b11d;">+</span><span style="color: #67b11d;">        y_batch = predict(network, x_batch)</span>
<span style="color: #67b11d;">+</span><span style="color: #67b11d;">        p = np.argmax(y_batch, axis=1)</span>
<span style="color: #67b11d;">+</span><span style="color: #67b11d;">        accuracy_cnt += np.sum(p == t[i : i + batch_size])</span>

     print("Accuracy:" + str(float(accuracy_cnt) / len(x)))
</pre>
</div></li>
<li><p>
其中的range()函数加了第三个参数是step,这样每次循环的开始位置会不一样
</p>
<div class="org-src-container">
<pre class="src src-shell"> &gt;&gt;&gt; list<span style="color: #3a81c3;">(</span>range<span style="color: #6c3163;">(</span>0, 10<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
<span style="color: #3a81c3;">[</span>0, 1, 2, 3, 4, 5, 6, 7, 8, 9<span style="color: #3a81c3;">]</span>
&gt;&gt;&gt; list<span style="color: #3a81c3;">(</span>range<span style="color: #6c3163;">(</span>0, 10, 3<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
<span style="color: #3a81c3;">[</span>0, 3, 6, 9<span style="color: #3a81c3;">]</span>
</pre>
</div></li>
<li><p>
agrmax()这里也多了一个参数axis=1,也就是要沿着第1维的方向找到最大index(也就是每个子数组的最大index)
</p>
<div class="org-src-container">
<pre class="src src-python">&gt;&gt;&gt; <span style="color: #3a81c3; font-weight: bold;">import</span> numpy <span style="color: #3a81c3; font-weight: bold;">as</span> np
&gt;&gt;&gt; x = np.array<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span><span style="color: #2d9574;">[</span>0.1, 0.8, 0.1<span style="color: #2d9574;">]</span>, <span style="color: #2d9574;">[</span>0.3, 0.1, 0.6<span style="color: #2d9574;">]</span>, <span style="color: #2d9574;">[</span>0.2, 0.5, 0.3<span style="color: #2d9574;">]</span>, <span style="color: #2d9574;">[</span>0.8, 0.1, 0.1<span style="color: #2d9574;">]</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; y = np.argmax<span style="color: #3a81c3;">(</span>x, axis=1<span style="color: #3a81c3;">)</span>
&gt;&gt;&gt; <span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span>y<span style="color: #3a81c3;">)</span>
<span style="color: #3a81c3;">[</span>1 2 1 0<span style="color: #3a81c3;">]</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-orgaf56dc6" class="outline-2">
<h2 id="orgaf56dc6"><span class="section-number-2">4.</span> 神经网络的学习</h2>
<div class="outline-text-2" id="text-4">
</div>
<div id="outline-container-orgf9e21ce" class="outline-3">
<h3 id="orgf9e21ce"><span class="section-number-3">4.1.</span> 从数据中学习</h3>
<div class="outline-text-3" id="text-4-1">
<ul class="org-ul">
<li>神经网络的特征就是可以从数据中学习.所谓"从数据中学习",是指可以由数据自动决定"参数"</li>
<li>如果由人来决定"参数"的话,是典型的statistical learning(也叫机器学习),而神经网络是让数据自己来决定参
数.比机器学习更"深",所以叫"深度学习"</li>
</ul>
</div>
<div id="outline-container-orge0c7502" class="outline-4">
<h4 id="orge0c7502"><span class="section-number-4">4.1.1.</span> 数据驱动</h4>
<div class="outline-text-4" id="text-4-1-1">
<ul class="org-ul">
<li>我们要解决的问题是识别图片:
<ul class="org-ul">
<li>对于人来说,我们可以简单的识别出5,但是却很难明确说出是基于何种规律而识别出了5</li>
<li>利用数据来解决这个问题的话,就会有两个思路:
<ol class="org-ol">
<li>机器学习</li>
<li>深度学习</li>
</ol></li>
</ul></li>
<li>机器学习和深度学习都是使用数据来让计算机判断图片,但是两者却有着很大的差别:
<ul class="org-ul">
<li><p>
如图
</p>

<div id="org182e64d" class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/image/master/dlfs/4-2.png" alt="4-2.png" />
</p>
<p><span class="figure-number">Figure 37: </span>dlfs/4-2.png</p>
</div></li>
<li>白色部分是需要人参与的, 灰色的部分是计算机自动可以完成的</li>
<li>我们可以看到机器学习方法是介于"纯人工"和"纯自动化"之间的一种方法:虽然SVM,KNN等分类器可以自动学得
参数,但是这些分类器的"向量"确是需要通过经验来选取特点的方法(SIFT,HOG等)把image转换后获得</li>
<li>深度学习则是完全"自动化的",连重要的特征量也是有机器来学习的</li>
<li>神经网络的优点是对所有的问题都可以使用同样的流程来解决,比如不管要求求解的问题是识别5,还是识别狗,
神经网络都是通过不断地学习所提供的数据,尝试发现待求解问题的模式.换句话说,神经网络可以将数据直接
作为原始数据,进行"端对端"的学习,而与待处理的问题无关</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org53414a2" class="outline-4">
<h4 id="org53414a2"><span class="section-number-4">4.1.2.</span> 训练数据和测试数据</h4>
<div class="outline-text-4" id="text-4-1-2">
<ul class="org-ul">
<li>机器学习中,一般将数据分为如下两个部分:
<ul class="org-ul">
<li>训练数据:首先使用训练数据进行学习,寻找最优的"参数"</li>
<li>测试数据:然后使用测试数据评价"参数"的实际能力</li>
</ul></li>
<li>为什么要将数据分成训练数据和测试数据:
<ul class="org-ul">
<li>因为我们追求的是模型的泛化能力,只有划分中训练数据和测试数据,才能正确评价模型的泛化能力</li>
<li>所谓"泛化能力",是指处理未被观察过的数据(也就是训练时候没有见过的数据)的能力</li>
<li>训练数据页可以称之为监督数据(所谓监督,是在训练模型的时候才需要监督)</li>
<li>对某个数据集过度拟合的状态称之为过拟合(overfitting),避免过拟合也是机器学习的一个重要课题</li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgdff7024" class="outline-3">
<h3 id="orgdff7024"><span class="section-number-3">4.2.</span> 损失函数</h3>
<div class="outline-text-3" id="text-4-2">
<ul class="org-ul">
<li>如果有人问你现在有多幸福
<ul class="org-ul">
<li>一般人可能回答"还可以吧", "很幸福"等笼统的回答</li>
<li>如果有人用数值来评判自己的幸福程度(比如"我现在的幸福指数是10.23"),那么可能会把人吓一跳,因为他用
数值来评价自己的幸福程度</li>
<li><p>
其实神经网络就是在做同样的事情:
</p>
<pre class="example" id="org6fb881a">
通过某个指标来表示当前的状态,然后,以这个指标为基准,寻找最优权重参数
</pre></li>
<li>神经网络的"某个指标",其实是一个损失函数(loss function), 通常使用如下两种函数:
<ol class="org-ol">
<li>均方误差</li>
<li>交叉熵误差</li>
</ol></li>
</ul></li>
<li>损失函数是表示神经网络性能的"恶劣程度"的指标,也就是说当前的神经网络对监督数据在多大程度上不拟合,在
多大程度上不一致(注意是监督数据,我们关于训练,所有的数据都是监督数据,没有测试数据什么事)</li>
<li>以"性能的恶劣程度"为指标可能让人感觉不自然,但是我们如果给损失函数乘以一个-1,那么就可以解释为"性能
的优秀程度",也就是"性能有多好"</li>
<li>损失函数可以使用任意函数,但一般使用均方误差和交叉熵误差等函数</li>
</ul>
</div>
<div id="outline-container-org374012f" class="outline-4">
<h4 id="org374012f"><span class="section-number-4">4.2.1.</span> 均方误差</h4>
<div class="outline-text-4" id="text-4-2-1">
<ul class="org-ul">
<li>损失函数中最有名的就是均方误差(mean sauared error)
<ul class="org-ul">
<li><p>
其公式如下
</p>
\begin{equation}
E = \frac{1}{2} \sum_{k} \left( y_{k} - t_{k} \right)^{2}
\end{equation}</li>
<li>\(y_k\) 表示神经网络的输出</li>
<li>\(t_k\) 表示监督数据</li>
<li>\(k\) 表示数据的维度</li>
</ul></li>
<li>比如,上一章最后的手写识别项目中:
<ul class="org-ul">
<li><p>
\(y_k\) 如下: 表示当前图像为0的概率是0.1, 为1的概率是0.05, 为2的概率是0.6,等等
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #715ab1;">y</span> = <span style="color: #3a81c3;">[</span>0.1, 0.05, 0.6, 0.0, 0.05, 0.1, 0.0, 0.1, 0.0, 0.0<span style="color: #3a81c3;">]</span>
</pre>
</div></li>
<li><p>
\(t_k\) 如下: 表示正确的结果应该是2(只有第2位是1, 这种将正确标签表示为1,其他为0的方法称之为one-hot表示)
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #715ab1;">t</span> = <span style="color: #3a81c3;">[</span>0, 0, 1, 0, 0, 0, 0, 0, 0, 0<span style="color: #3a81c3;">]</span>
</pre>
</div></li>
<li>\(k\) 就是10</li>
</ul></li>
<li>我们使用numpy能够非常容易的计算均方差
<ul class="org-ul">
<li><p>
代码如下
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #3a81c3; font-weight: bold;">def</span> <span style="color: #6c3163; font-weight: bold;">mean_squared_error</span><span style="color: #3a81c3;">(</span>y, t<span style="color: #3a81c3;">)</span>:
    <span style="color: #3a81c3; font-weight: bold;">return</span> 0.5 * np.<span style="color: #3a81c3;">sum</span><span style="color: #3a81c3;">(</span><span style="color: #6c3163;">(</span>y - t<span style="color: #6c3163;">)</span> ** 2<span style="color: #3a81c3;">)</span>
</pre>
</div></li>
<li><p>
我们的标签是不变的
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #715ab1;">t</span> = <span style="color: #3a81c3;">[</span>0, 0, 1, 0, 0, 0, 0, 0, 0, 0<span style="color: #3a81c3;">]</span>
</pre>
</div></li>
<li><p>
一个和标签比较吻合的结果("2"的概率最高的情况),得到的均方差值较小
</p>
<div class="org-src-container">
<pre class="src src-shell">&gt;&gt;&gt; y = <span style="color: #3a81c3;">[</span>0.1, 0.05, 0.6, 0.0, 0.05, 0.1, 0.0, 0.1, 0.0, 0.0<span style="color: #3a81c3;">]</span>
&gt;&gt;&gt; mean_squared_error<span style="color: #3a81c3;">(</span>np.array<span style="color: #6c3163;">(</span>y<span style="color: #6c3163;">)</span>, np.array<span style="color: #6c3163;">(</span>t<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
0.09750000000000003
</pre>
</div></li>
<li><p>
一个和标签不太吻合的结果("7"的概率最高的情况),得到的均方差值较大
</p>
<div class="org-src-container">
<pre class="src src-shell">&gt;&gt;&gt; y2 = <span style="color: #3a81c3;">[</span>0.1, 0.05, 0.1, 0.0, 0.05, 0.1, 0.0, 0.6, 0.0, 0.0<span style="color: #3a81c3;">]</span>
&gt;&gt;&gt; mean_squared_error<span style="color: #3a81c3;">(</span>np.array<span style="color: #6c3163;">(</span>y2<span style="color: #6c3163;">)</span>, np.array<span style="color: #6c3163;">(</span>t<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
0.5975
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org7a7f03a" class="outline-4">
<h4 id="org7a7f03a"><span class="section-number-4">4.2.2.</span> 交叉熵误差</h4>
</div>
<div id="outline-container-orge4c0747" class="outline-4">
<h4 id="orge4c0747"><span class="section-number-4">4.2.3.</span> mini-batch学习</h4>
</div>
<div id="outline-container-orgd546388" class="outline-4">
<h4 id="orgd546388"><span class="section-number-4">4.2.4.</span> mini-batch版交叉熵误差的实现</h4>
</div>
<div id="outline-container-org869cc14" class="outline-4">
<h4 id="org869cc14"><span class="section-number-4">4.2.5.</span> 为何要设定损失函数</h4>
</div>
</div>
<div id="outline-container-orge2b3b2e" class="outline-3">
<h3 id="orge2b3b2e"><span class="section-number-3">4.3.</span> 数值微分</h3>
<div class="outline-text-3" id="text-4-3">
</div>
<div id="outline-container-org6dafa6c" class="outline-4">
<h4 id="org6dafa6c"><span class="section-number-4">4.3.1.</span> 导数</h4>
</div>
<div id="outline-container-orgc9662e0" class="outline-4">
<h4 id="orgc9662e0"><span class="section-number-4">4.3.2.</span> 数值微分的例子</h4>
</div>
<div id="outline-container-orgb4358f8" class="outline-4">
<h4 id="orgb4358f8"><span class="section-number-4">4.3.3.</span> 偏导数</h4>
</div>
</div>
<div id="outline-container-orged7fe70" class="outline-3">
<h3 id="orged7fe70"><span class="section-number-3">4.4.</span> 梯度</h3>
<div class="outline-text-3" id="text-4-4">
</div>
<div id="outline-container-org485e77c" class="outline-4">
<h4 id="org485e77c"><span class="section-number-4">4.4.1.</span> 梯度法</h4>
</div>
<div id="outline-container-orge128751" class="outline-4">
<h4 id="orge128751"><span class="section-number-4">4.4.2.</span> 神经网络的梯度</h4>
</div>
</div>
<div id="outline-container-org2264024" class="outline-3">
<h3 id="org2264024"><span class="section-number-3">4.5.</span> 学习算法的实现</h3>
<div class="outline-text-3" id="text-4-5">
</div>
<div id="outline-container-orge6dd2b1" class="outline-4">
<h4 id="orge6dd2b1"><span class="section-number-4">4.5.1.</span> 2层神经网络的类</h4>
</div>
<div id="outline-container-org87b0655" class="outline-4">
<h4 id="org87b0655"><span class="section-number-4">4.5.2.</span> mini-batch的实现</h4>
</div>
<div id="outline-container-orgb193f2e" class="outline-4">
<h4 id="orgb193f2e"><span class="section-number-4">4.5.3.</span> 基于测试数据的评价</h4>
</div>
</div>
</div>
<div id="outline-container-org239d768" class="outline-2">
<h2 id="org239d768"><span class="section-number-2">5.</span> 误差反向传播法</h2>
</div>
<div id="outline-container-org3e3d374" class="outline-2">
<h2 id="org3e3d374"><span class="section-number-2">6.</span> 与学习相关的技巧</h2>
</div>
<div id="outline-container-orga5b6f60" class="outline-2">
<h2 id="orga5b6f60"><span class="section-number-2">7.</span> 卷积神经网络</h2>
</div>
<div id="outline-container-org2377641" class="outline-2">
<h2 id="org2377641"><span class="section-number-2">8.</span> 深度学习</h2>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: harrifeng@outlook.com</p>
<p class="date">Created: 2024-08-06 Tue 16:50</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>