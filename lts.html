<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2025-04-09 Wed 10:58 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>lts</title>
<meta name="author" content="harrifeng@outlook.com" />
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="src/readtheorg_theme/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="src/readtheorg_theme/css/readtheorg.css"/>
<script type="text/javascript" src="src/lib/js/jquery.min.js"></script>
<script type="text/javascript" src="src/lib/js/bootstrap.min.js"></script>
<script type="text/javascript" src="src/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="src/readtheorg_theme/js/readtheorg.js"></script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">lts</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orgc1e69b2">1. Chapter 1: From JavaScript to TypeScript</a>
<ul>
<li><a href="#org3504368">1.1. History of JavaScript</a></li>
<li><a href="#org31e112b">1.2. Vanilla JavaScript's Pitfalls</a>
<ul>
<li><a href="#org2f32669">1.2.1. Costly Freedom</a></li>
<li><a href="#org428e076">1.2.2. Losse Documentation</a></li>
<li><a href="#org575a7e1">1.2.3. Weaker Developer Tooling</a></li>
</ul>
</li>
<li><a href="#orgff79137">1.3. Typescript!</a></li>
<li><a href="#org31d231c">1.4. Getting Started in the TypeScript Playground</a>
<ul>
<li><a href="#org40e69ca">1.4.1. TypeScript in Action</a></li>
<li><a href="#org8d87d86">1.4.2. Freedom Through Restriction</a></li>
<li><a href="#org9210343">1.4.3. Precise Documentation</a></li>
<li><a href="#org5a68cf8">1.4.4. Stronger Developer Tooling</a></li>
<li><a href="#org1d39585">1.4.5. Compiling Syntax</a></li>
</ul>
</li>
<li><a href="#orgc37e48d">1.5. Getting Started Locally</a>
<ul>
<li><a href="#org6a70ae6">1.5.1. Running Locally</a></li>
<li><a href="#orge949f8d">1.5.2. Editor Features</a></li>
</ul>
</li>
<li><a href="#orgef65c8b">1.6. What TypeScript is Not</a>
<ul>
<li><a href="#org7283cbf">1.6.1. A Remedy for Bad Code</a></li>
<li><a href="#org79a63f1">1.6.2. Extensions to JavaScript(Mostly)</a></li>
<li><a href="#orge33ff62">1.6.3. SLower Than JavaScript</a></li>
<li><a href="#orgefc65dc">1.6.4. Finished Evolving</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgbadc9a7">2. Chapter 2: The Type System</a>
<ul>
<li><a href="#org20f402b">2.1. What's in a Type?</a>
<ul>
<li><a href="#org6913aba">2.1.1. Type Systems</a></li>
<li><a href="#orge2636f0">2.1.2. Kinds of Errors</a></li>
</ul>
</li>
<li><a href="#orgd196db3">2.2. Assignability</a>
<ul>
<li><a href="#org6923e87">2.2.1. Understanding Assignability Errors</a></li>
</ul>
</li>
<li><a href="#orge4899f6">2.3. Type Annotations</a>
<ul>
<li><a href="#org09859ce">2.3.1. Unnecessary Type Annotaions</a></li>
</ul>
</li>
<li><a href="#orgf7cf873">2.4. Type Shapes</a>
<ul>
<li><a href="#orgdeb2b77">2.4.1. Modules</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org8d24677">3. Chapter 3: Unions and Literals</a>
<ul>
<li><a href="#org4e86527">3.1. Union Types</a>
<ul>
<li><a href="#org909baeb">3.1.1. Declaring Union Types</a></li>
<li><a href="#orgc77ee93">3.1.2. Union Preperties</a></li>
</ul>
</li>
<li><a href="#org56df9d3">3.2. Narrowing</a>
<ul>
<li><a href="#org76542d9">3.2.1. Assignment Narrowing</a></li>
<li><a href="#orgbdfe0a2">3.2.2. Conditional Checks</a></li>
<li><a href="#org5a3a2f6">3.2.3. Typeof Checks</a></li>
</ul>
</li>
<li><a href="#org7a63646">3.3. Literal Types</a>
<ul>
<li><a href="#org0031daa">3.3.1. Literal Assignability</a></li>
</ul>
</li>
<li><a href="#orge45557d">3.4. Strict Null Checking</a>
<ul>
<li><a href="#org910473f">3.4.1. The Billion-Dollar Mistake</a></li>
<li><a href="#orgb630060">3.4.2. Truthiness Narrowing</a></li>
<li><a href="#orgcf0df6f">3.4.3. Variables Without Initial Values</a></li>
</ul>
</li>
<li><a href="#org10d5742">3.5. Type Aliases</a>
<ul>
<li><a href="#org97b52ba">3.5.1. Type Aliases Are Not JavaScript</a></li>
<li><a href="#org960f91f">3.5.2. Combining Type Aliases</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org2469b01">4. Chapter 4: Objects</a>
<ul>
<li><a href="#org2b88c60">4.1. Object Types</a>
<ul>
<li><a href="#org9b5db41">4.1.1. Declaring Object Types</a></li>
<li><a href="#org5c12dc2">4.1.2. Aliased Object Types</a></li>
</ul>
</li>
<li><a href="#org0b03970">4.2. Structural Typing</a>
<ul>
<li><a href="#orgf572074">4.2.1. Usage Checking</a></li>
<li><a href="#orgc66b4c8">4.2.2. Excess Property Checking</a></li>
<li><a href="#orgde5b609">4.2.3. Nested Object Types</a></li>
<li><a href="#org6f6b03c">4.2.4. Optional Properties</a></li>
</ul>
</li>
<li><a href="#org7e65dec">4.3. Unions of Object Types</a>
<ul>
<li><a href="#org0b5bdea">4.3.1. Inferred Object-Type Unions</a></li>
<li><a href="#org9bcf094">4.3.2. Explicit Object-Type Unions</a></li>
<li><a href="#orge9f62e5">4.3.3. Narrowing Object Types</a></li>
<li><a href="#org122c5a1">4.3.4. Discriminated Unions</a></li>
</ul>
</li>
<li><a href="#orgecd9590">4.4. Intersection Types</a>
<ul>
<li><a href="#org803b64e">4.4.1. Dangers of Intersection Types</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orge5ee814">5. Chapter 5: Functions</a>
<ul>
<li><a href="#orgb6edbe7">5.1. Function Parameters</a>
<ul>
<li><a href="#orgae2989c">5.1.1. Required Parameters</a></li>
<li><a href="#org3ac7c14">5.1.2. Optional Parameters</a></li>
<li><a href="#orgbedd770">5.1.3. Default Parameters</a></li>
<li><a href="#org990e500">5.1.4. Rest Parameters</a></li>
</ul>
</li>
<li><a href="#org63cd35a">5.2. Return Types</a>
<ul>
<li><a href="#orgd9c8fc2">5.2.1. Explicit Return Types</a></li>
</ul>
</li>
<li><a href="#org2691324">5.3. Function Types</a>
<ul>
<li><a href="#org1609c45">5.3.1. Function Type Parentheses</a></li>
<li><a href="#org4ebe69d">5.3.2. Parameter Type Inferences</a></li>
<li><a href="#org6380d26">5.3.3. Function Type Aliases</a></li>
</ul>
</li>
<li><a href="#org3b9843e">5.4. More Return Types</a>
<ul>
<li><a href="#org70a1ea7">5.4.1. Void Returns</a></li>
<li><a href="#org0c1bb5c">5.4.2. Never Returns</a></li>
</ul>
</li>
<li><a href="#org625bb68">5.5. Function Overloads</a>
<ul>
<li><a href="#org7955f7a">5.5.1. Call-Signature Compatibility</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org62d5f59">6. Chapter 6: Arrays</a>
<ul>
<li><a href="#org5175a3b">6.1. Array Types</a>
<ul>
<li><a href="#org345dc07">6.1.1. Array and Function Types</a></li>
<li><a href="#org7e8b2d8">6.1.2. Union Type Arrays</a></li>
<li><a href="#orge0fb922">6.1.3. Evolving Any Arrays</a></li>
<li><a href="#org859b6f2">6.1.4. Multidimensional Arrays</a></li>
</ul>
</li>
<li><a href="#org70ecabb">6.2. Array Members</a>
<ul>
<li><a href="#org20e8f4e">6.2.1. Caveat: Unsound Members</a></li>
</ul>
</li>
<li><a href="#orgca91e84">6.3. Spreads and Rests</a>
<ul>
<li><a href="#org9dd825e">6.3.1. Spreads</a></li>
<li><a href="#org9a177ce">6.3.2. Spreading Rest Parameters</a></li>
</ul>
</li>
<li><a href="#orgdf92192">6.4. Tuples</a>
<ul>
<li><a href="#orgc04397f">6.4.1. Tuple Assignability</a></li>
<li><a href="#orgcc8fde7">6.4.2. Tuple Inferences</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org2e38161">7. Chapter 7: Interfaces</a>
<ul>
<li><a href="#org880f7bc">7.1. Type Aliases Versus Intrfaces</a></li>
<li><a href="#org6e3a45c">7.2. Type of Proprties</a>
<ul>
<li><a href="#orgebb724e">7.2.1. Optional Properties</a></li>
<li><a href="#org86a9d21">7.2.2. Read-Only Properties</a></li>
<li><a href="#org0c0ba01">7.2.3. Functions and Methods</a></li>
<li><a href="#org7b83c22">7.2.4. Call Signatures</a></li>
<li><a href="#orgdc6c168">7.2.5. Index Signatures</a></li>
<li><a href="#orgd8c582a">7.2.6. Nested Interfaces</a></li>
</ul>
</li>
<li><a href="#org9fd7c67">7.3. Interface Extensions</a>
<ul>
<li><a href="#orge8c47dc">7.3.1. Overridden Properties</a></li>
<li><a href="#orgde0da25">7.3.2. Extending Multiple Interfaces</a></li>
</ul>
</li>
<li><a href="#org031f886">7.4. Interface Merging</a>
<ul>
<li><a href="#org5878b1c">7.4.1. Member Naming Conflicts</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org28ae132">8. Chapter 8: Classes</a>
<ul>
<li><a href="#org0f4e88c">8.1. Class Methods</a></li>
<li><a href="#orgece86a0">8.2. Class Properties</a>
<ul>
<li><a href="#orgfe2b5dd">8.2.1. Function Properties</a></li>
<li><a href="#orgd932fab">8.2.2. Initialization Checking</a></li>
<li><a href="#org77f0d7e">8.2.3. Optional Properties</a></li>
<li><a href="#org14d67d0">8.2.4. Read-Only Properties</a></li>
</ul>
</li>
<li><a href="#org7a76cd2">8.3. Classes as Types</a></li>
<li><a href="#orgd01d732">8.4. Classes and Interfaces</a>
<ul>
<li><a href="#org6fa546c">8.4.1. Implementing Multiple Interfaces</a></li>
</ul>
</li>
<li><a href="#orgae0c272">8.5. Extending a Class</a>
<ul>
<li><a href="#orgb7031a4">8.5.1. Extension Assignability</a></li>
<li><a href="#orgea42979">8.5.2. Overriddeng Constructors</a></li>
<li><a href="#orgf4e924a">8.5.3. Overridden Methods</a></li>
<li><a href="#orgeaa3509">8.5.4. Overridden Properties</a></li>
</ul>
</li>
<li><a href="#org1e60c6d">8.6. Abstract Classes</a></li>
<li><a href="#orgd5c8376">8.7. Member Visibility</a>
<ul>
<li><a href="#org0c0f13f">8.7.1. Static Field Modifiers</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org14038df">9. Chapter 9: Type Modifiers</a>
<ul>
<li><a href="#orgcda06a8">9.1. Top Types</a>
<ul>
<li><a href="#org8b40967">9.1.1. any, Again</a></li>
<li><a href="#orga73426c">9.1.2. unknown</a></li>
</ul>
</li>
<li><a href="#org8ed881b">9.2. Type Prddicates</a></li>
<li><a href="#org7284896">9.3. Type Operators</a>
<ul>
<li><a href="#org466c593">9.3.1. keyof</a></li>
<li><a href="#org14f2d32">9.3.2. typeof</a></li>
</ul>
</li>
<li><a href="#org0686fb0">9.4. Type Assertions</a>
<ul>
<li><a href="#orgc957515">9.4.1. Asserting Caught Error Types</a></li>
<li><a href="#org65d1d1b">9.4.2. Non-Null Assertions</a></li>
<li><a href="#org6171523">9.4.3. Type Assertin Caveats</a></li>
</ul>
</li>
<li><a href="#org7cc0916">9.5. Const Assertions</a>
<ul>
<li><a href="#orgf6c0b4a">9.5.1. Literals to Primitives</a></li>
<li><a href="#orgbef7bc9">9.5.2. Read-Only Objects</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgb16f4d5">10. Chapter 10: Generics</a>
<ul>
<li><a href="#org0012ebc">10.1. Generic Functions</a>
<ul>
<li><a href="#orgc8c2db4">10.1.1. Explicit Generic Call Types</a></li>
<li><a href="#orgd86c56b">10.1.2. Multiple Function Type Parameters</a></li>
</ul>
</li>
<li><a href="#org32864cd">10.2. Generic Interface</a>
<ul>
<li><a href="#org6e2318d">10.2.1. Inferred Generic Interface Types</a></li>
</ul>
</li>
<li><a href="#orgc28bfec">10.3. Generic Classes</a>
<ul>
<li><a href="#orgee5c18e">10.3.1. Explicit Generic Class Types</a></li>
<li><a href="#org0e0ccad">10.3.2. Extending Generic Classes</a></li>
<li><a href="#orgae22724">10.3.3. Implementing Generic Interfaces</a></li>
<li><a href="#org66e77a5">10.3.4. Method Generics</a></li>
<li><a href="#orgdc3c94c">10.3.5. Static Class Generics</a></li>
</ul>
</li>
<li><a href="#org7b181dd">10.4. Generic Type Aliases</a>
<ul>
<li><a href="#orgb0bb822">10.4.1. Generic Discriminated Unions</a></li>
</ul>
</li>
<li><a href="#org2be1da1">10.5. Generic Modifiers</a>
<ul>
<li><a href="#org40501d2">10.5.1. Generic Defaults</a></li>
</ul>
</li>
<li><a href="#org691645f">10.6. Constrained Generic Types</a>
<ul>
<li><a href="#orga5ed573">10.6.1. keyof and Constrained Type Parameters</a></li>
</ul>
</li>
<li><a href="#orgd0b3afd">10.7. Promises</a>
<ul>
<li><a href="#org914930f">10.7.1. Creating Promises</a></li>
<li><a href="#org61dc62d">10.7.2. Async Functions</a></li>
</ul>
</li>
<li><a href="#orga46781d">10.8. Using Generics Right</a>
<ul>
<li><a href="#org1987bb1">10.8.1. The Golden Rule of Generics</a></li>
<li><a href="#org19a8afa">10.8.2. Generic Naming Conventions</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-orgc1e69b2" class="outline-2">
<h2 id="orgc1e69b2"><span class="section-number-2">1.</span> Chapter 1: From JavaScript to TypeScript</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org3504368" class="outline-3">
<h3 id="org3504368"><span class="section-number-3">1.1.</span> History of JavaScript</h3>
<div class="outline-text-3" id="text-1-1">
<ul class="org-ul">
<li>javascript是Brendan Eich在1995年用十天时间发明的语言,由于时间仓促,javascript有很多奇怪的地方</li>
<li>从2015年开始,javascript的规范化组织ECMAScript(因为javascript是火狐浏览器的商标),就每年发布新版本,并
且保证向前兼容</li>
</ul>
</div>
</div>
<div id="outline-container-org31e112b" class="outline-3">
<h3 id="org31e112b"><span class="section-number-3">1.2.</span> Vanilla JavaScript's Pitfalls</h3>
<div class="outline-text-3" id="text-1-2">
<ul class="org-ul">
<li>开发者把没有使用任何框架的javascript叫做vanilla(因为香草味是最常见的味道)</li>
<li>实际上很少有项目使用vanilla javascript,因为原生javascript的陷阱实在是太多了,这也是为什么Typescript会诞生的原因</li>
</ul>
</div>
<div id="outline-container-org2f32669" class="outline-4">
<h4 id="org2f32669"><span class="section-number-4">1.2.1.</span> Costly Freedom</h4>
<div class="outline-text-4" id="text-1-2-1">
<ul class="org-ul">
<li>javascript太过于自由了,导致有很多的问题.
<ul class="org-ul">
<li><p>
比如下面的代码:
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #531ab6;">function</span> <span style="color: #721045;">paintPainting</span><span style="color: #000000;">(</span><span style="color: #005e8b;">painter</span>, <span style="color: #005e8b;">painting</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> painter
    .prepare<span style="color: #dd22dd;">()</span>
    .paint<span style="color: #dd22dd;">(</span>painting, painter.ownMaterials<span style="color: #dd22dd;">)</span>
    .finish<span style="color: #dd22dd;">()</span>;
<span style="color: #000000;">}</span>
</pre>
</div></li>
<li>由于不经过编译器确认,那么一旦paint()函数改名字了,那么代码毫无感觉,直到代码运行到这个地方</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org428e076" class="outline-4">
<h4 id="org428e076"><span class="section-number-4">1.2.2.</span> Losse Documentation</h4>
<div class="outline-text-4" id="text-1-2-2">
<ul class="org-ul">
<li>由于是动态语言,所以维持js代码的文档是非常困难的,因为:
<ul class="org-ul">
<li>很有可能JSDoc是错误的,因为它和代码是分离的</li>
<li>即便我们JSDoc是正确的,但是随着代码的重构,我们要经常性的去更改那些now-invalid JSDoc,这个是非常困难
也复杂的</li>
<li>描述复杂的对象会非常的复杂</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org575a7e1" class="outline-4">
<h4 id="org575a7e1"><span class="section-number-4">1.2.3.</span> Weaker Developer Tooling</h4>
<div class="outline-text-4" id="text-1-2-3">
<ul class="org-ul">
<li>Js作为动态语言,天然的没有太多开发者支持工具,比如重命名成员和跳转到定义等</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgff79137" class="outline-3">
<h3 id="orgff79137"><span class="section-number-3">1.3.</span> Typescript!</h3>
<div class="outline-text-3" id="text-1-3">
<ul class="org-ul">
<li>Typescript由C#,Pascal语言的作者 Anders Hejlsberg在2010年发明,并在2012年开源</li>
<li>我们可以把Typescript看成是如下四个东西:
<ul class="org-ul">
<li>programming language: 一个包含所有Js的syntax的语言,外加新的TypeScript-specific syntax用来定义和使用type</li>
<li>Type checker: 还可以把ts看成是一个程序,用来检查输入的js和ts代码是否正确</li>
<li>Compiler: 还可以把ts卡成是一个编译器,用来把ts代码编译成js代码</li>
<li>Language service: 还可以把ts看成是一个服务,提供给编辑器(比如vs code)来帮助开发者开发代码</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org31d231c" class="outline-3">
<h3 id="org31d231c"><span class="section-number-3">1.4.</span> Getting Started in the TypeScript Playground</h3>
<div class="outline-text-3" id="text-1-4">
<ul class="org-ul">
<li>TypeScript主页包含了一个在线的编辑器,叫TypeScript Playground,地址如下 <a href="https://www.typescriptlang.org/play">https://www.typescriptlang.org/play</a></li>
</ul>
</div>
<div id="outline-container-org40e69ca" class="outline-4">
<h4 id="org40e69ca"><span class="section-number-4">1.4.1.</span> TypeScript in Action</h4>
<div class="outline-text-4" id="text-1-4-1">
<ul class="org-ul">
<li><p>
我们先来看看一个代码片段
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">firstName</span> = <span style="color: #3548cf;">"Georgia"</span>;
<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">nameLangth</span> = firstName.length<span style="color: #000000;">()</span>;
</pre>
</div></li>
<li>这段如果是js代码的话,在运行时会爆出问题,因为字符串没有length()函数</li>
<li><p>
我们把这段代码贴到Typescript Playground,我们会发现,ts作为language service会帮我们分析到
</p>
<pre class="example" id="org175d206">
This expression is not callable.
  Type 'Number' has no call signatures. ts(2349)
</pre></li>
<li>在代码书写阶段就得到警告,好过运行的时候整个程序崩溃</li>
</ul>
</div>
</div>
<div id="outline-container-org8d87d86" class="outline-4">
<h4 id="org8d87d86"><span class="section-number-4">1.4.2.</span> Freedom Through Restriction</h4>
<div class="outline-text-4" id="text-1-4-2">
<ul class="org-ul">
<li>ts允许我们选定参数和变量能够使用的类型</li>
<li>ts还允许我们在函数的定义改变的时候,做出告警</li>
</ul>
</div>
</div>
<div id="outline-container-org9210343" class="outline-4">
<h4 id="org9210343"><span class="section-number-4">1.4.3.</span> Precise Documentation</h4>
<div class="outline-text-4" id="text-1-4-3">
<ul class="org-ul">
<li><p>
我们来看看ts版本的paintPainting,即便我们还没引入ts的内容,但是你也可以看出这就是代码本身就是documentation的范本
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">Painter</span> <span style="color: #000000;">{</span>
  <span style="color: #721045;">finish</span><span style="color: #dd22dd;">()</span>: <span style="color: #531ab6;">boolean</span>;
  ownMaterials: <span style="color: #005f5f;">Material</span><span style="color: #dd22dd;">[]</span>;
  <span style="color: #721045;">paint</span><span style="color: #dd22dd;">(</span><span style="color: #005e8b;">painting</span>: <span style="color: #531ab6;">string</span>, <span style="color: #005e8b;">materials</span>: <span style="color: #005f5f;">Material</span><span style="color: #008899;">[]</span><span style="color: #dd22dd;">)</span>: <span style="color: #531ab6;">boolean</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">function</span> <span style="color: #721045;">paintPainting</span><span style="color: #000000;">(</span><span style="color: #005e8b;">painter</span>: <span style="color: #005f5f;">Painter</span>, <span style="color: #005e8b;">painting</span>: <span style="color: #531ab6;">string</span><span style="color: #000000;">)</span>: <span style="color: #531ab6;">boolean</span><span style="color: #000000;">{</span><span style="color: #7f0000;">/* </span><span style="color: #7f0000;">... */</span><span style="color: #000000;">}</span>
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-org5a68cf8" class="outline-4">
<h4 id="org5a68cf8"><span class="section-number-4">1.4.4.</span> Stronger Developer Tooling</h4>
<div class="outline-text-4" id="text-1-4-4">
<ul class="org-ul">
<li>Typescript 自己就能为vs code 提供自动补全等功能</li>
</ul>
</div>
</div>
<div id="outline-container-org1d39585" class="outline-4">
<h4 id="org1d39585"><span class="section-number-4">1.4.5.</span> Compiling Syntax</h4>
<div class="outline-text-4" id="text-1-4-5">
<ul class="org-ul">
<li>Typescript不仅能把ts编译成js,还能把新版本的js编译成老版本的js</li>
<li>我们可以在Typescript playground页面的右侧看到编译好的js代码</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgc37e48d" class="outline-3">
<h3 id="orgc37e48d"><span class="section-number-3">1.5.</span> Getting Started Locally</h3>
<div class="outline-text-3" id="text-1-5">
<ul class="org-ul">
<li><p>
typescript是作为nodejs的一个module被安装的,如果要本地使用,记得全局安装
</p>
<div class="org-src-container">
<pre class="src src-shell">npm i -g typescript
</pre>
</div></li>
<li><p>
一旦全局安装typescript module成功之后,会有一个tsc的命令放在path
</p>
<div class="org-src-container">
<pre class="src src-shell">$ tsc --version
Version 5.0.4
</pre>
</div></li>
</ul>
</div>
<div id="outline-container-org6a70ae6" class="outline-4">
<h4 id="org6a70ae6"><span class="section-number-4">1.5.1.</span> Running Locally</h4>
<div class="outline-text-4" id="text-1-5-1">
<ul class="org-ul">
<li><p>
在一个空白的文件夹下面运行如下命令,就能在root目录创建一个新的tsconfig.json配置文件
</p>
<div class="org-src-container">
<pre class="src src-shell">$ tsc --init

Created a new tsconfig.json with:
                                                                                                              TS
  target: es2016
  module: commonjs
  strict: true
  esModuleInterop: true
  skipLibCheck: true
  forceConsistentCasingInFileNames: true


You can learn more at https://aka.ms/tsconfig
$ ls -al .
total 24
drwxr-xr-x   3 fenghaoran  staff     96 May  8 17:58 .
drwxr-xr-x  23 fenghaoran  staff    736 May  8 17:58 ..
-rw-r--r--   1 fenghaoran  staff  12288 May  8 17:58 tsconfig.json
</pre>
</div></li>
<li><p>
我们在这个文件夹里面创建一个文件index.ts并且添加如下文本
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #005f5f;">console</span>.<span style="color: #721045;">blub</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Nothing is worth more than laughter."</span><span style="color: #000000;">)</span>;
</pre>
</div></li>
<li><p>
我们如果使用tsc编译的话,会出现如下错误
</p>
<div class="org-src-container">
<pre class="src src-shell">$ tsc index.ts
index.ts:1:9 - error TS2339: Property <span style="color: #3548cf;">'blub'</span> does not exist on type <span style="color: #3548cf;">'Console'</span>.

1 console.blub<span style="color: #000000;">(</span><span style="color: #3548cf;">"Nothing is worth more than laughter."</span><span style="color: #000000;">)</span>;
          ~~~~


Found 1 error<span style="color: #531ab6;"> in</span> index.ts:1
</pre>
</div></li>
<li><p>
虽然你的写法tsc认为有问题,但是它还是给你创建了一个新的index.js文件
</p>
<div class="org-src-container">
<pre class="src src-shell">$ cat index.js
<span style="color: #721045;">console.blub</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Nothing is worth more than laughter."</span><span style="color: #000000;">)</span>;
</pre>
</div></li>
<li>从这里看tsc的编译和我们之前理解的gcc等还是有差别的.</li>
<li><p>
我们更改错误之后,编译就不会有问题了,而且会产生新的正确的js代码
</p>
<div class="org-src-container">
<pre class="src src-shell">$ cat index.ts
<span style="color: #721045;">console.log</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Nothing is worth more than laughter."</span><span style="color: #000000;">)</span>;
$ tsc index.ts
$ cat index.js
<span style="color: #721045;">console.log</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Nothing is worth more than laughter."</span><span style="color: #000000;">)</span>;
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-orge949f8d" class="outline-4">
<h4 id="orge949f8d"><span class="section-number-4">1.5.2.</span> Editor Features</h4>
<div class="outline-text-4" id="text-1-5-2">
<ul class="org-ul">
<li>tsconfig.json配置文件的巨大作用,在于让vs code(或者其他编辑器,IDE)能够识别出ts project root folder</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgef65c8b" class="outline-3">
<h3 id="orgef65c8b"><span class="section-number-3">1.6.</span> What TypeScript is Not</h3>
<div class="outline-text-3" id="text-1-6">
<ul class="org-ul">
<li>每个工具都有其优点,也有其局限性. ts的局限性总计起来就是</li>
</ul>
</div>
<div id="outline-container-org7283cbf" class="outline-4">
<h4 id="org7283cbf"><span class="section-number-4">1.6.1.</span> A Remedy for Bad Code</h4>
<div class="outline-text-4" id="text-1-6-1">
<ul class="org-ul">
<li>ts只会enforce type safety,它不会强制你使用任何的structure(比如class等)</li>
</ul>
</div>
</div>
<div id="outline-container-org79a63f1" class="outline-4">
<h4 id="org79a63f1"><span class="section-number-4">1.6.2.</span> Extensions to JavaScript(Mostly)</h4>
<div class="outline-text-4" id="text-1-6-2">
<ul class="org-ul">
<li>ts的设计目标说,it should:
<ul class="org-ul">
<li>遵守当前的,以及未来的ECMAScript proposal</li>
<li>能够适配所有js的runtime(比如老版本的IE11)</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orge33ff62" class="outline-4">
<h4 id="orge33ff62"><span class="section-number-4">1.6.3.</span> SLower Than JavaScript</h4>
<div class="outline-text-4" id="text-1-6-3">
<ul class="org-ul">
<li>关于ts比js慢的观点,是不准确,而且有诱导性的,因为ts慢是因为它首先要转成js,而且编译的时候有类型检查</li>
</ul>
</div>
</div>
<div id="outline-container-orgefc65dc" class="outline-4">
<h4 id="orgefc65dc"><span class="section-number-4">1.6.4.</span> Finished Evolving</h4>
<div class="outline-text-4" id="text-1-6-4">
<ul class="org-ul">
<li>随着web的继续发展,ts也会不断演进</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-orgbadc9a7" class="outline-2">
<h2 id="orgbadc9a7"><span class="section-number-2">2.</span> Chapter 2: The Type System</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-org20f402b" class="outline-3">
<h3 id="org20f402b"><span class="section-number-3">2.1.</span> What's in a Type?</h3>
<div class="outline-text-3" id="text-2-1">
<ul class="org-ul">
<li>所谓的shape,是指有哪些property和method在一个value上,也可以理解为内置的typeof操作符对这个value的解释</li>
<li><p>
比如下面的js代码,如果给ts来理解,它肯定能知道singer是一个string type的变量
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">singer</span> = <span style="color: #3548cf;">"Aretha"</span>
</pre>
</div></li>
<li>js中有如下七中原生类型,ts也同样视他们为原生类型:
<ul class="org-ul">
<li>null</li>
<li>undefined</li>
<li>boolean</li>
<li>string</li>
<li>number</li>
<li>bigint</li>
<li>symbol</li>
</ul></li>
</ul>
</div>
<div id="outline-container-org6913aba" class="outline-4">
<h4 id="org6913aba"><span class="section-number-4">2.1.1.</span> Type Systems</h4>
<div class="outline-text-4" id="text-2-1-1">
<ul class="org-ul">
<li>TypeScript的type system总体上是安装如下流程工作的:
<ul class="org-ul">
<li>读取你的代码,理解代码中所有的type,和所有的value</li>
<li>对每个value,试着从其初始化的地方理解其可能有的类型</li>
<li>对每个value,看看在后续代码里面其使用的方式(有没有超过其类型所限)</li>
<li>如果value采用了不符合其类型的操作,反馈给用户</li>
</ul></li>
<li>我们以一个例子来介绍下上面的几步都是什么意思:
<ul class="org-ul">
<li><p>
代码如下
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">firstName</span> = <span style="color: #3548cf;">"Whiteney"</span>;
firstName.length<span style="color: #000000;">()</span>;
<span style="color: #7f0000;">//        </span><span style="color: #7f0000;">~~~~~~</span>
<span style="color: #7f0000;">//  </span><span style="color: #7f0000;">This expression is not callable.</span>
<span style="color: #7f0000;">//    </span><span style="color: #7f0000;">Type 'Number' has no call signatures</span>
</pre>
</div></li>
<li>ts能够得到上面的报警,是依次通过如下步骤获得的:
<ol class="org-ol">
<li>读取代码,并且理解了代码里面有个变量叫做firstName</li>
<li>总结出来firstName是string类型的,因为它的初始化值为"Whitney"</li>
<li>发现代码会去让firstName去调用.length这个method</li>
<li>终于得到机会进行警告: .length是一个member,而不是一个函数</li>
</ol></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orge2636f0" class="outline-4">
<h4 id="orge2636f0"><span class="section-number-4">2.1.2.</span> Kinds of Errors</h4>
<div class="outline-text-4" id="text-2-1-2">
<ul class="org-ul">
<li>在ts里面一般会遇到两种错误:
<ul class="org-ul">
<li>syntax error: 可以认为是严重错误,导致ts无法转换成js代码(虽然也会产生js代码,但是肯定是错误的,无法运行的)</li>
<li><p>
type error: 可以认为是普通告警,syntax error不存在的情况下(所以ts成功转换成了js代码),但是ts 编译器
认为你的代码可能出错.注意type error是说,从type类型的角度上讲,你是错误的.但是从动态语言的角度讲,
不一定是错误的.比如下面的代码,一个变量开始是字符类型,后来被赋值了true,在ts看来就是type error,但是js
看来,这是再正常不过的代码
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">lastName</span> = <span style="color: #3548cf;">"King"</span>;
lastName = <span style="color: #0000b0;">true</span>;
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgd196db3" class="outline-3">
<h3 id="orgd196db3"><span class="section-number-3">2.2.</span> Assignability</h3>
<div class="outline-text-3" id="text-2-2">
<ul class="org-ul">
<li><p>
ts会读取变量的初始化值来判断其类型,如果后面赋值的时候类型一样还好,如果类型不一样,那么报警是跑不了
的了,而且报的就是Type error
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">lastName</span> = <span style="color: #3548cf;">"King"</span>;
lastName = <span style="color: #0000b0;">true</span>;
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Error: Type 'boolean' is not assignable to type 'string'.</span>
</pre>
</div></li>
</ul>
</div>
<div id="outline-container-org6923e87" class="outline-4">
<h4 id="org6923e87"><span class="section-number-4">2.2.1.</span> Understanding Assignability Errors</h4>
<div class="outline-text-4" id="text-2-2-1">
<ul class="org-ul">
<li>我们要试着理解Type Error报警:
<ul class="org-ul">
<li>比如 Type 'A' is not assignable to type 'B'</li>
<li>意思就是类型A无法赋值给类型B, 类型B是接受者(变量), 类型A是赋值者(新的类型)</li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orge4899f6" class="outline-3">
<h3 id="orge4899f6"><span class="section-number-3">2.3.</span> Type Annotations</h3>
<div class="outline-text-3" id="text-2-3">
<ul class="org-ul">
<li>如果一个变量没有设置初始化的值,那么ts显然不能assume它的类型,这种情况下,ts认为这个变量的类型是any</li>
<li>any类型很奇怪:
<ul class="org-ul">
<li><p>
一个any类型的变量可以先后被赋值任何类型的数值.如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">rocker</span>;                     <span style="color: #7f0000;">// </span><span style="color: #7f0000;">Type: any</span>
rocker.<span style="color: #721045;">toUpperCase</span><span style="color: #000000;">()</span>;

rocker = 19.58;
rocker.<span style="color: #721045;">toPrecision</span><span style="color: #000000;">(</span>1<span style="color: #000000;">)</span>;
</pre>
</div></li>
<li><p>
但是每次赋值相当于让当前变量处于某个类型,不过不能调用其他类型的method,如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">rocker</span>;                     <span style="color: #7f0000;">// </span><span style="color: #7f0000;">Type: any</span>
rocker.<span style="color: #721045;">toUpperCase</span><span style="color: #000000;">()</span>;

rocker = 19.58;
rocker.<span style="color: #721045;">toPrecision</span><span style="color: #000000;">(</span>1<span style="color: #000000;">)</span>;

rocker.<span style="color: #721045;">toUpperCase</span><span style="color: #000000;">()</span>;           <span style="color: #7f0000;">// </span><span style="color: #7f0000;">error    2339   Property 'toUpperCase' does not exist on type 'number'. (typescript-</span><span style="color: #005e8b;">tide</span><span style="color: #7f0000;">)</span>

</pre>
</div></li>
</ul></li>
<li>使用any类型是不推荐的,因为它本质上是一种妥协,一旦设置了any, ts的很多类型检查就不再起作用了</li>
<li>如果没有初始化值,但是还想要设置类型怎么办? ts给出的解决方案是type annotation:
<ul class="org-ul">
<li><p>
type annotation的代码如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">rocker</span>: <span style="color: #531ab6;">string</span>;
rocker = <span style="color: #3548cf;">"Joan Jett"</span>;
</pre>
</div></li>
<li><p>
type annotation是ts的特有syntax, js无法理解. tsc会把上面的ts代码编译成如下的js代码
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #531ab6;">var</span> <span style="color: #005e8b;">rocker</span>;
rocker = <span style="color: #3548cf;">"Joan Jett"</span>;
</pre>
</div></li>
</ul></li>
</ul>
</div>
<div id="outline-container-org09859ce" class="outline-4">
<h4 id="org09859ce"><span class="section-number-4">2.3.1.</span> Unnecessary Type Annotaions</h4>
<div class="outline-text-4" id="text-2-3-1">
<ul class="org-ul">
<li>只有在没有初始化值的情况下才需要type annotation,否则:
<ul class="org-ul">
<li>如果类型和初始化值一样,那么type annotation是多此一举</li>
<li>如果类型和初始化值不一样,那么还会报错</li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgf7cf873" class="outline-3">
<h3 id="orgf7cf873"><span class="section-number-3">2.4.</span> Type Shapes</h3>
<div class="outline-text-3" id="text-2-4">
<ul class="org-ul">
<li>typescript不仅仅能检查赋值的时候类型是否匹配,还会理解object的shape</li>
<li>所谓object的shape,就是object能够拥有哪些:
<ul class="org-ul">
<li>property</li>
<li>method</li>
</ul></li>
</ul>
</div>
<div id="outline-container-orgdeb2b77" class="outline-4">
<h4 id="orgdeb2b77"><span class="section-number-4">2.4.1.</span> Modules</h4>
<div class="outline-text-4" id="text-2-4-1">
<ul class="org-ul">
<li>js自己是没有包版本管理系统的,直到2015年ECMAScript添加了ECMAScript modules(ESM),标准化了如下两个命令:
<ul class="org-ul">
<li><p>
import: 用来从其他文件读取value
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #531ab6;">import</span> <span style="color: #000000;">{</span> value <span style="color: #000000;">}</span> from <span style="color: #3548cf;">"./values"</span>;
</pre>
</div></li>
<li><p>
export: 用来把value导出到其他文件
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #531ab6;">export</span> <span style="color: #531ab6;">const</span> <span style="color: #005e8b;">doubled</span> = value * 2;
</pre>
</div></li>
</ul></li>
<li>本书为了和ECAMScript规范相一致,会严格区分如下两个概念:
<ul class="org-ul">
<li>Module: 包含export或者import的文件</li>
<li>Script: 不是module的文件,都是script</li>
</ul></li>
<li>ts自然是能和Module以及Script都处理好关系的,这是最低要求</li>
<li>moduleA里面如果定义了一个变量, 并不会和moduleB里面定义的其他同名变量相conflict(例外情况是你非要从
moduleB里面import那肯定不行,比如下面的例子),这也是module的魅力
<ul class="org-ul">
<li><p>
两个module里面相同名字,没问题
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #7f0000;">// </span><span style="color: #7f0000;">a.ts</span>
<span style="color: #531ab6;">export</span> <span style="color: #531ab6;">const</span> <span style="color: #005e8b;">shared</span> = <span style="color: #3548cf;">"Cher"</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">b.ts</span>
<span style="color: #531ab6;">export</span> <span style="color: #531ab6;">const</span> <span style="color: #005e8b;">shared</span> = <span style="color: #3548cf;">"Cher"</span>;
</pre>
</div></li>
<li><p>
两个module里面相同名字,但是你要从另外一个module import,那么就会declaration conflicts啦
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #7f0000;">// </span><span style="color: #7f0000;">a.ts</span>
<span style="color: #531ab6;">export</span> <span style="color: #531ab6;">const</span> <span style="color: #005e8b;">shared</span> = <span style="color: #3548cf;">"Cher"</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">c.ts</span>
<span style="color: #531ab6;">import</span> <span style="color: #000000;">{</span> shared <span style="color: #000000;">}</span> <span style="color: #531ab6;">from</span> <span style="color: #3548cf;">"./a"</span>;
<span style="color: #7f0000;">//       </span><span style="color: #7f0000;">~~~~~~</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Error: Import declaration conflicts with local declaration of 'shared'.</span>

<span style="color: #531ab6;">export</span> <span style="color: #531ab6;">const</span> <span style="color: #005e8b;">shared</span> = <span style="color: #3548cf;">"Cher"</span>;
<span style="color: #7f0000;">//           </span><span style="color: #7f0000;">~~~~~~</span>
<span style="color: #7f0000;">//  </span><span style="color: #7f0000;">Error: Individual declarations in merged declaration</span>
<span style="color: #7f0000;">//  </span><span style="color: #7f0000;">'shared' must b all exported or all local</span>
</pre>
</div></li>
</ul></li>
<li>在script里面,可以就不一样了,scriptA里面定义了一个变量,那么ts就认为他是全局的,同一个project下面的另
外一个scriptB文件就完全不能再定义同一个名字的变量了.
<ul class="org-ul">
<li><p>
例子如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #7f0000;">// </span><span style="color: #7f0000;">a.ts</span>
<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">shared</span> = <span style="color: #3548cf;">"Cher"</span>;
<span style="color: #7f0000;">//    </span><span style="color: #7f0000;">~~~~~~</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Cannot redeclare block-scoped variable 'shared'.</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">b.ts</span>
<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">shared</span> = <span style="color: #3548cf;">"Cher"</span>;
<span style="color: #7f0000;">//    </span><span style="color: #7f0000;">~~~~~~</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Cannot redeclare block-scoped variable 'shared'.</span>
</pre>
</div></li>
<li>上面的俩个文件虽然是.ts文件,但是由于没有import也没有export,那么就认为是普通script(不是module),于
是两个文件里面连同名变量都不能有</li>
<li>以后一旦看到"Cannot redeclare &#x2026;",那么看看是不是你的文件可能是script,避免这个错误的办法可以是转
换script成module</li>
<li><p>
如果实在不需要export和import,还想让你的script成为module,那么可以使用一个export {}.如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #7f0000;">// </span><span style="color: #7f0000;">a.ts and b.ts</span>
<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">shared</span> = <span style="color: #3548cf;">"Cher"</span>           <span style="color: #7f0000;">// </span><span style="color: #7f0000;">ok</span>
<span style="color: #531ab6;">export</span> <span style="color: #000000;">{}</span>;
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org8d24677" class="outline-2">
<h2 id="org8d24677"><span class="section-number-2">3.</span> Chapter 3: Unions and Literals</h2>
<div class="outline-text-2" id="text-3">
<ul class="org-ul">
<li>本章主要介绍如下两个特性:
<ul class="org-ul">
<li>Unions: 可以让一个value承载两种或者多种类型</li>
<li>Narrowing: 可以让一个value承载除了某几种类型以外的类型</li>
</ul></li>
</ul>
</div>
<div id="outline-container-org4e86527" class="outline-3">
<h3 id="org4e86527"><span class="section-number-3">3.1.</span> Union Types</h3>
<div class="outline-text-3" id="text-3-1">
<ul class="org-ul">
<li>有种情况,某个类型可能是多种类型
<ul class="org-ul">
<li><p>
代码如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">mathematician</span> = Math.<span style="color: #721045;">random</span><span style="color: #000000;">()</span> &gt; 0.5
  ? <span style="color: #0000b0;">undefined</span>
  : <span style="color: #3548cf;">"Mark Goldberg"</span>;
</pre>
</div></li>
<li>mathematician是一个either undefined or string的变量.这种"either or"类型在ts
里面就叫做union</li>
<li><p>
Typescript的编译器会分析出来,并且给出mathematician的类型判断如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">mathematician</span>: <span style="color: #531ab6;">string</span> | <span style="color: #0000b0;">undefined</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
<div id="outline-container-org909baeb" class="outline-4">
<h4 id="org909baeb"><span class="section-number-4">3.1.1.</span> Declaring Union Types</h4>
<div class="outline-text-4" id="text-3-1-1">
<ul class="org-ul">
<li><p>
union type的定义例子如下: 虽然thinker已经有了初始化值null,但是因为它有可能后面变成string,所以还是
给它一个string的定义
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">thinker</span>: <span style="color: #531ab6;">string</span> | <span style="color: #0000b0;">null</span> = <span style="color: #0000b0;">null</span>;

<span style="color: #531ab6;">if</span> <span style="color: #000000;">(</span>Math.<span style="color: #721045;">random</span><span style="color: #dd22dd;">()</span> &gt; 0.5<span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  thinker = <span style="color: #3548cf;">"Susanne Langer"</span>;   <span style="color: #7f0000;">// </span><span style="color: #7f0000;">ok</span>
<span style="color: #000000;">}</span>
</pre>
</div></li>
<li>union里面的多个类型的先后顺序是不重要的</li>
</ul>
</div>
</div>
<div id="outline-container-orgc77ee93" class="outline-4">
<h4 id="orgc77ee93"><span class="section-number-4">3.1.2.</span> Union Preperties</h4>
<div class="outline-text-4" id="text-3-1-2">
<ul class="org-ul">
<li><p>
如果一个类型是union的,那么ts只允许你访问union内部所有类型都有的member property. 访问只有部分类型有
的member property是会报type-checking error的,例子如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">physicist</span> = Math.<span style="color: #721045;">random</span><span style="color: #000000;">()</span> &gt; 0.5
  ? <span style="color: #3548cf;">"Marie Curie"</span>
  : 84;

physicist.<span style="color: #721045;">toString</span><span style="color: #000000;">()</span>;


<span style="color: #7f0000;">////////////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">error TS2339: Property 'toUpperCase' does not exist on type 'string | number'. //</span>
<span style="color: #7f0000;">////////////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">physicist.</span><span style="color: #721045;">toUpperCase</span><span style="color: #7f0000;">();</span>


<span style="color: #7f0000;">////////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">error TS2339: Property 'toFixed' does not exist on type 'string | number'. //</span>
<span style="color: #7f0000;">////////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">physicist.</span><span style="color: #721045;">toFixed</span><span style="color: #7f0000;">();</span>
</pre>
</div></li>
<li>为了能够使用只有某一种类型上才有的property, 代码需要告诉ts,在某处的code是one of those more specific
type:这个过程叫做narrowing</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org56df9d3" class="outline-3">
<h3 id="org56df9d3"><span class="section-number-3">3.2.</span> Narrowing</h3>
<div class="outline-text-3" id="text-3-2">
<ul class="org-ul">
<li>narrowing的方法有两种:
<ul class="org-ul">
<li>一种通过assignment</li>
<li>另外一种通过check</li>
</ul></li>
</ul>
</div>
<div id="outline-container-org76542d9" class="outline-4">
<h4 id="org76542d9"><span class="section-number-4">3.2.1.</span> Assignment Narrowing</h4>
<div class="outline-text-4" id="text-3-2-1">
<ul class="org-ul">
<li>assignment narrowing又有两种情况:
<ul class="org-ul">
<li><p>
初始化为其中一个类型
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">physicist</span>: <span style="color: #531ab6;">number</span> | <span style="color: #531ab6;">string</span> = 83;

physicist.<span style="color: #721045;">toString</span><span style="color: #000000;">()</span>;

<span style="color: #7f0000;">////////////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">error TS2339: Property 'toUpperCase' does not exist on type 'string | number'. //</span>
<span style="color: #7f0000;">////////////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">physicist.</span><span style="color: #721045;">toUpperCase</span><span style="color: #7f0000;">();</span>

physicist.<span style="color: #721045;">toFixed</span><span style="color: #000000;">()</span>;
</pre>
</div></li>
<li><p>
赋值为其中一个类型
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">physicist</span> = Math.<span style="color: #721045;">random</span><span style="color: #000000;">()</span> &gt; 0.5 ? <span style="color: #3548cf;">"Marie Curie"</span> : 84;

physicist.<span style="color: #721045;">toString</span><span style="color: #000000;">()</span>;

physicist = <span style="color: #3548cf;">"Hedy Lamarr"</span>;
physicist.<span style="color: #721045;">toUpperCase</span><span style="color: #000000;">()</span>;

<span style="color: #7f0000;">////////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">error TS2339: Property 'toFixed' does not exist on type 'string | number'. //</span>
<span style="color: #7f0000;">////////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">physicist.</span><span style="color: #721045;">toFixed</span><span style="color: #7f0000;">();</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgbdfe0a2" class="outline-4">
<h4 id="orgbdfe0a2"><span class="section-number-4">3.2.2.</span> Conditional Checks</h4>
<div class="outline-text-4" id="text-3-2-2">
<ul class="org-ul">
<li><p>
ts非常聪明,能够判定if statement里面的变量当前是什么类型.下面的例子中在if里面scientist是字符串类型,
但是出了循环scientist就不再单单是字符串类型了
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">scientist</span> = Math.<span style="color: #721045;">random</span><span style="color: #000000;">()</span> &gt; 0.5 ? <span style="color: #3548cf;">"Rosalind Franklin"</span> : 51;

<span style="color: #531ab6;">if</span> <span style="color: #000000;">(</span>scientist === <span style="color: #3548cf;">"Rosalind Franklin"</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">Type of scientist: string</span>
  scientist.<span style="color: #721045;">toUpperCase</span><span style="color: #dd22dd;">()</span>; <span style="color: #7f0000;">// </span><span style="color: #005e8b;">ok</span>
<span style="color: #000000;">}</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">error TS2339: Property 'toUpperCase' does not exist on type 'string | number'.</span>
<span style="color: #7f0000;">//////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">scientist.</span><span style="color: #721045;">toUpperCase</span><span style="color: #7f0000;">(); //</span>
<span style="color: #7f0000;">//////////////////////////////</span>
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-org5a3a2f6" class="outline-4">
<h4 id="org5a3a2f6"><span class="section-number-4">3.2.3.</span> Typeof Checks</h4>
<div class="outline-text-4" id="text-3-2-3">
<ul class="org-ul">
<li>除了用直接的等于(<code>=</code>)判断,typescript还支持typeof的结果</li>
<li><p>
typeof首先可以判断true的情况
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">researcher</span> = Math.<span style="color: #721045;">random</span><span style="color: #000000;">()</span> &gt; 0.5 ? <span style="color: #3548cf;">"Rosalind Franklin"</span> : 51;

<span style="color: #531ab6;">if</span> <span style="color: #000000;">(</span><span style="color: #531ab6;">typeof</span> researcher === <span style="color: #3548cf;">"string"</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  researcher.<span style="color: #721045;">toUpperCase</span><span style="color: #dd22dd;">()</span>; <span style="color: #7f0000;">// </span><span style="color: #005e8b;">ok</span>
<span style="color: #000000;">}</span>
</pre>
</div></li>
<li><p>
typeof也可以判断false的情况
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">researcher</span> = Math.<span style="color: #721045;">random</span><span style="color: #000000;">()</span> &gt; 0.5 ? <span style="color: #3548cf;">"Rosalind Franklin"</span> : 51;

<span style="color: #531ab6;">if</span> <span style="color: #000000;">(</span>!<span style="color: #dd22dd;">(</span><span style="color: #531ab6;">typeof</span> researcher === <span style="color: #3548cf;">"string"</span><span style="color: #dd22dd;">)</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  researcher.<span style="color: #721045;">toFixed</span><span style="color: #dd22dd;">()</span>; <span style="color: #7f0000;">// </span><span style="color: #005e8b;">ok</span>
<span style="color: #000000;">}</span> <span style="color: #531ab6;">else</span> <span style="color: #000000;">{</span>
  researcher.<span style="color: #721045;">toUpperCase</span><span style="color: #dd22dd;">()</span>; <span style="color: #7f0000;">// </span><span style="color: #005e8b;">ok</span>
<span style="color: #000000;">}</span>
</pre>
</div></li>
<li><p>
我们还可以把typeof写成三元表达式的情况
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">researcher</span> = Math.<span style="color: #721045;">random</span><span style="color: #000000;">()</span> &gt; 0.5 ? <span style="color: #3548cf;">"Rosalind Franklin"</span> : 51;

<span style="color: #531ab6;">typeof</span> researcher === <span style="color: #3548cf;">"string"</span>
  ? researcher.<span style="color: #721045;">toUpperCase</span><span style="color: #000000;">()</span> <span style="color: #7f0000;">// </span><span style="color: #005e8b;">ok</span>
  : researcher.<span style="color: #721045;">toFixed</span><span style="color: #000000;">()</span>; <span style="color: #7f0000;">// </span><span style="color: #005e8b;">ok</span>
</pre>
</div></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org7a63646" class="outline-3">
<h3 id="org7a63646"><span class="section-number-3">3.3.</span> Literal Types</h3>
<div class="outline-text-3" id="text-3-3">
<ul class="org-ul">
<li>先来看个例子
<ul class="org-ul">
<li><p>
例子如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">philosopher</span> = <span style="color: #3548cf;">"Hypatia"</span>;
</pre>
</div></li>
<li>这个例子中的philosopher是一个string类型,这也是我们之前学到的内容</li>
<li>我们这里要学到的是,philosopher不仅仅是string类型,它还是一个更具体的类型,叫做"specific Hypatia"类型</li>
<li><p>
这种"更具体的类型",就是literal type,具体点说就是
</p>
<pre class="example" id="org375b7d9">
The type of a value that is known to be a specific value of a primitive,
rather than any of those primitive's value at all
</pre></li>
</ul></li>
<li>我们来看看"string类型"和"Hypatia类型"的区别:
<ul class="org-ul">
<li>primitive type string代表了所有可能的字符串</li>
<li>literal type Hypatia只能代表一种字符串</li>
</ul></li>
<li><p>
如果你创建了变量,并且给它设置为const,那么ts就直接给这个变量设置为literal type,比如下面的例子中,
mathematician的类型就是 "Mark Goldberg"
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">mathematician</span> = <span style="color: #3548cf;">"Mark Goldberg"</span>;
</pre>
</div></li>
<li><p>
你可以把每个primitive type都看成是所有可能的literal value的union
</p>
<pre class="example" id="org4ab76ed">
You can think of each primitive type as a union of every possible matching literal value
</pre></li>
<li><p>
union type annotation可以混合literal和primitive,比如下面的例子
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">lifespan</span>: <span style="color: #531ab6;">number</span> | <span style="color: #3548cf;">"ongoing"</span> | <span style="color: #3548cf;">"uncertain"</span>;

lifespan = 89;                   <span style="color: #7f0000;">// </span><span style="color: #7f0000;">ok</span>
lifespan = <span style="color: #3548cf;">"ongoing"</span>;            <span style="color: #7f0000;">// </span><span style="color: #7f0000;">ok</span>

<span style="color: #7f0000;">/////////////////////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">error TS2322: Type 'true' is not assignable to type 'number | "ongoing" | "uncertain"'. //</span>
<span style="color: #7f0000;">/////////////////////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">//</span><span style="color: #7f0000;">lifespan = true;</span>
</pre>
</div></li>
</ul>
</div>
<div id="outline-container-org0031daa" class="outline-4">
<h4 id="org0031daa"><span class="section-number-4">3.3.1.</span> Literal Assignability</h4>
<div class="outline-text-4" id="text-3-3-1">
<ul class="org-ul">
<li>literal type可不是简单说说一下,它真的是一个类型:
<ul class="org-ul">
<li>我们知道,不通的primitive 类型相互之间不能赋值:比如number和string不能相互赋值</li>
<li>不同的literal type之间也不能相互赋值(虽然他们属于同一种primitive type)</li>
</ul></li>
<li>我们可以从下面的例子证明这一点:
<ul class="org-ul">
<li><p>
例子如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">specificallyAda</span>: <span style="color: #3548cf;">"Ada"</span>;
specificallyAda = <span style="color: #3548cf;">"Ada"</span>;         <span style="color: #7f0000;">// </span><span style="color: #7f0000;">ok</span>

<span style="color: #7f0000;">/////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">error TS2322: Type '"Byron"' is not assignable to type '"Ada"'. //</span>
<span style="color: #7f0000;">/////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">specificallyAda = "Byron";</span>

<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">someStirng</span> = <span style="color: #3548cf;">""</span>;            <span style="color: #7f0000;">// </span><span style="color: #7f0000;">Type: string</span>

<span style="color: #7f0000;">////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">error TS2322: Type 'string' is not assignable to type '"Ada"'. //</span>
<span style="color: #7f0000;">////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">specificallyAda = someStirng</span>
</pre>
</div></li>
<li><p>
注意,创建一个literal type除了使用const,还可以把literal 类型像其他类型一样写在':'后面,但是注意,虽
然specificallyAda的值只能是"Ada"(因为他是"Ada"类型的),但是初始化之后没有赋值,还是不能访问的,否则
会报错.例子如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">specificallyAda</span>: <span style="color: #3548cf;">"Ada"</span>;

<span style="color: #7f0000;">/////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">error TS2454: Variable 'specificallyAda' is used before being assigned. //</span>
<span style="color: #7f0000;">/////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">console.</span><span style="color: #721045;">log</span><span style="color: #7f0000;">(specificallyAda)</span>

specificallyAda = <span style="color: #3548cf;">"Ada"</span>;         <span style="color: #7f0000;">// </span><span style="color: #7f0000;">ok</span>
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>specificallyAda<span style="color: #000000;">)</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Ada</span>
</pre>
</div></li>
</ul></li>
<li>literal type相互之间不可用赋值,但是literal type却可以"向上"赋值给自己所在的primitive type,这也是
literal type作为比primitive低一个级别类型的特点."向上"赋值随时可见,只是我们没有想到.比如下面这两个
都是向上赋值:
<ul class="org-ul">
<li><p>
比较"严谨"的向上赋值
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">smile</span> : <span style="color: #3548cf;">":)"</span>;
smile = <span style="color: #3548cf;">":)"</span>;
<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">something</span> = <span style="color: #3548cf;">""</span>;

something = smile
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>something<span style="color: #000000;">)</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">:)</span>
</pre>
</div></li>
<li><p>
比较"常见"的向上赋值,其实是上面"严谨"版本的简化版
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">someString</span> = <span style="color: #3548cf;">":)"</span>;
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orge45557d" class="outline-3">
<h3 id="orge45557d"><span class="section-number-3">3.4.</span> Strict Null Checking</h3>
<div class="outline-text-3" id="text-3-4">
<ul class="org-ul">
<li>narrowed union在加上literal能够让ts非常从容的处理strict null checking</li>
</ul>
</div>
<div id="outline-container-org910473f" class="outline-4">
<h4 id="org910473f"><span class="section-number-4">3.4.1.</span> The Billion-Dollar Mistake</h4>
<div class="outline-text-4" id="text-3-4-1">
<ul class="org-ul">
<li>所谓的billion-dollar mistake是指, null value的发明者认为这不是一个好的发明,把null value引入编程语言
导致了几十亿美元的损失.</li>
<li>ts的编译器包含了很多option,允许我们配置编译器,最著名的一个选项就是strictNullChecks:
<ul class="org-ul">
<li><p>
如果enable,那么null(undefined)不能赋值给其他类型变量,默认的配置就是这样的
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">someString</span> = <span style="color: #3548cf;">"abc"</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>someString<span style="color: #000000;">)</span>

<span style="color: #7f0000;">///////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">error TS2322: Type 'null' is not assignable to type 'string'. //</span>
<span style="color: #7f0000;">///////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">someString = null;</span>
</pre>
</div></li>
<li><p>
如果disable,那么显然就是null(undefined)可以赋值给其他变量.其实质上的原理,就是给每个类型添加如下
代码
</p>
<div class="org-src-container">
<pre class="src src-typescript">| <span style="color: #0000b0;">null</span> | <span style="color: #0000b0;">undefined</span>
</pre>
</div></li>
</ul></li>
<li>ts的最佳实践就是开启strictNullCheck,否则无法规避某些null和undefined对代码的破坏</li>
</ul>
</div>
</div>
<div id="outline-container-orgb630060" class="outline-4">
<h4 id="orgb630060"><span class="section-number-4">3.4.2.</span> Truthiness Narrowing</h4>
<div class="outline-text-4" id="text-3-4-2">
<ul class="org-ul">
<li>在js里面,判断一个变量是否为true原理如下:变量只要不是如下值,那么它们就是true:
<ul class="org-ul">
<li>false</li>
<li>0</li>
<li>-0</li>
<li>0n</li>
<li>""</li>
<li>null</li>
<li>undefined</li>
<li>NaN</li>
</ul></li>
<li>基于js的这些设置,那么ts可以在某些if为true的case里面,narrowing类型成功(到一种)
<ul class="org-ul">
<li><p>
例子如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">geneticist</span> = Math.<span style="color: #721045;">random</span><span style="color: #000000;">()</span> &gt; 0.5
  ? <span style="color: #3548cf;">"Barbara McClintock"</span>
  : <span style="color: #0000b0;">undefined</span>;

<span style="color: #531ab6;">if</span> <span style="color: #000000;">(</span>geneticist<span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  geneticist.<span style="color: #721045;">toUpperCase</span><span style="color: #dd22dd;">()</span>;      <span style="color: #7f0000;">// </span><span style="color: #005e8b;">ok</span><span style="color: #7f0000;">: </span><span style="color: #005e8b;">string</span>
<span style="color: #000000;">}</span>

<span style="color: #7f0000;">//////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">error TS18048: 'geneticist' is possibly 'undefined'. //</span>
<span style="color: #7f0000;">//////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">geneticist.</span><span style="color: #721045;">toUpperCase</span><span style="color: #7f0000;">();</span>
</pre>
</div></li>
<li>上面例子中,由于undefined是不可能为true的,那么if 里面是必然是string类型的</li>
<li>在if之外,就不能narrowing了,强制调用toUpperCase()会失败</li>
</ul></li>
<li>注意,这种narrowing只能在true case里面起作用,无法在false case里面起作用,因为空字符串("")和undefined
都被认为是false</li>
</ul>
</div>
</div>
<div id="outline-container-orgcf0df6f" class="outline-4">
<h4 id="orgcf0df6f"><span class="section-number-4">3.4.3.</span> Variables Without Initial Values</h4>
<div class="outline-text-4" id="text-3-4-3">
<ul class="org-ul">
<li>在js里面,如果一个变量声明之后,没有给初始化值,那么这个变量就会初始化成undefined</li>
<li>在ts中如果试图使用一个值为undefined的变量(声明之后没有赋值的变量),ts会报一个特定的错误,
<ul class="org-ul">
<li><p>
代码如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">mathematician</span>: <span style="color: #531ab6;">string</span>;
<span style="color: #7f0000;">///////////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">error TS2454: Variable 'mathematician' is used before being assigned. //</span>
<span style="color: #7f0000;">///////////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">mathematician?.length;</span>

mathematician = <span style="color: #3548cf;">"Mark Goldberg"</span>;
mathematician.length;
</pre>
</div></li>
<li><p>
上面例子中出现了 `?`, 这是ts里面特有的安全链式调用,详细解释如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#36825;&#37324; Error&#23545;&#35937;&#23450;&#20041;&#30340;stack&#26159;&#21487;&#36873;&#21442;&#25968;&#65292;&#22914;&#26524;&#36825;&#26679;&#20889;&#30340;&#35805;&#32534;&#35793;&#22120;&#20250;&#25552;&#31034;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#20986;&#38169; TS2532: Object is possibly 'undefined'.</span>
<span style="color: #531ab6;">return</span> <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Error</span><span style="color: #000000;">()</span>.stack.<span style="color: #721045;">split</span><span style="color: #000000;">(</span><span style="color: #3548cf;">'\n'</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#25105;&#20204;&#21487;&#20197;&#28155;&#21152;?&#25805;&#20316;&#31526;&#65292;&#24403;stack&#23646;&#24615;&#23384;&#22312;&#26102;&#65292;&#35843;&#29992; stack.split&#12290;&#33509;stack&#19981;&#23384;&#22312;&#65292;&#21017;&#36820;&#22238;&#31354;</span>
<span style="color: #531ab6;">return</span> <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Error</span><span style="color: #000000;">()</span>.stack?.<span style="color: #721045;">split</span><span style="color: #000000;">(</span><span style="color: #3548cf;">'\n'</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#20197;&#19978;&#20195;&#30721;&#31561;&#21516;&#20197;&#19979;&#20195;&#30721;</span>
<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">err</span> = <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Error</span><span style="color: #000000;">()</span>;
<span style="color: #531ab6;">return</span> err.stack &amp;&amp; err.stack.<span style="color: #721045;">split</span><span style="color: #000000;">(</span><span style="color: #3548cf;">'\n'</span><span style="color: #000000;">)</span>;
</pre>
</div></li>
<li><p>
注意,如果类型里面union了undefined,那么上面的错误不会发生
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">mathematician</span>: <span style="color: #531ab6;">string</span> | <span style="color: #0000b0;">undefined</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>mathematician?.length<span style="color: #000000;">)</span>;

mathematician = <span style="color: #3548cf;">"Mark Goldberg"</span>;
mathematician.length;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">undefined</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org10d5742" class="outline-3">
<h3 id="org10d5742"><span class="section-number-3">3.5.</span> Type Aliases</h3>
<div class="outline-text-3" id="text-3-5">
<ul class="org-ul">
<li><p>
绝大多数情况下,union只有两三个成员,但是也有出现很多成员的情况,如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">rawDataFirst</span>: <span style="color: #531ab6;">boolean</span> | <span style="color: #531ab6;">number</span> | <span style="color: #531ab6;">string</span> | <span style="color: #0000b0;">null</span> | <span style="color: #0000b0;">undefined</span>
<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">rawDataSecond</span>: <span style="color: #531ab6;">boolean</span> | <span style="color: #531ab6;">number</span> | <span style="color: #531ab6;">string</span> | <span style="color: #0000b0;">null</span> | <span style="color: #0000b0;">undefined</span>
<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">rawDataThird</span>: <span style="color: #531ab6;">boolean</span> | <span style="color: #531ab6;">number</span> | <span style="color: #531ab6;">string</span> | <span style="color: #0000b0;">null</span> | <span style="color: #0000b0;">undefined</span>
</pre>
</div></li>
<li><p>
上述例子中的 `boolean | number | string | null | undefined` 被使用了多次,为了保证DRY原则,ts又设计了
重用type列表的type alias,上面的例子就可以改写成如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">type</span> <span style="color: #005f5f;">RawData</span> = <span style="color: #531ab6;">boolean</span> | <span style="color: #531ab6;">number</span> | <span style="color: #531ab6;">string</span> | <span style="color: #0000b0;">null</span> | <span style="color: #0000b0;">undefined</span>

<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">rawDataFirst</span>: <span style="color: #005f5f;">RawData</span>
<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">rawDataSecond</span>: <span style="color: #005f5f;">RawData</span>
<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">rawDataThird</span>: <span style="color: #005f5f;">RawData</span>
</pre>
</div></li>
</ul>
</div>
<div id="outline-container-org97b52ba" class="outline-4">
<h4 id="org97b52ba"><span class="section-number-4">3.5.1.</span> Type Aliases Are Not JavaScript</h4>
<div class="outline-text-4" id="text-3-5-1">
<ul class="org-ul">
<li>type alias不会编译成javascript,它只存在于typescript里面</li>
<li><p>
既然不会被编译成js,那么你在运行时想access这个变量就是违法的,ts会报警
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">type</span> <span style="color: #005f5f;">SomeType</span> = <span style="color: #531ab6;">string</span> | <span style="color: #0000b0;">undefined</span>;

<span style="color: #7f0000;">////////////////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">error TS2693: 'SomeType' only refers to a type, but is being used as a value here. //</span>
<span style="color: #7f0000;">////////////////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">console.</span><span style="color: #721045;">log</span><span style="color: #7f0000;">(SomeType)</span>
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-org960f91f" class="outline-4">
<h4 id="org960f91f"><span class="section-number-4">3.5.2.</span> Combining Type Aliases</h4>
<div class="outline-text-4" id="text-3-5-2">
<ul class="org-ul">
<li><p>
type alias还可以互相引用
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">type</span> <span style="color: #005f5f;">Id</span> = <span style="color: #531ab6;">number</span> | <span style="color: #531ab6;">string</span>

<span style="color: #531ab6;">type</span> <span style="color: #005f5f;">IdMaybe</span> = Id | <span style="color: #0000b0;">undefined</span> | <span style="color: #0000b0;">null</span>; <span style="color: #7f0000;">// </span><span style="color: #7f0000;">Equivalent to: number | string | undefind | null</span>
</pre>
</div></li>
<li><p>
互相引用的时候,不必要又顺序,ts编译器会全局考虑,所以使用未定义的type alias也是允许的
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">type</span> <span style="color: #005f5f;">IdMaybe</span> = Id | <span style="color: #0000b0;">undefined</span> | <span style="color: #0000b0;">null</span>; <span style="color: #7f0000;">// </span><span style="color: #7f0000;">Equivalent to: number | string | undefind | null</span>
<span style="color: #531ab6;">type</span> <span style="color: #005f5f;">Id</span> = <span style="color: #531ab6;">number</span> | <span style="color: #531ab6;">string</span>
</pre>
</div></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org2469b01" class="outline-2">
<h2 id="org2469b01"><span class="section-number-2">4.</span> Chapter 4: Objects</h2>
<div class="outline-text-2" id="text-4">
</div>
<div id="outline-container-org2b88c60" class="outline-3">
<h3 id="org2b88c60"><span class="section-number-3">4.1.</span> Object Types</h3>
<div class="outline-text-3" id="text-4-1">
<ul class="org-ul">
<li>在ts/js里面,有种创建object的方法叫做object literal
<ul class="org-ul">
<li><p>
样子如下
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">person</span> = <span style="color: #000000;">{</span>
  name: <span style="color: #3548cf;">"adam"</span>,
  age: 23,
<span style="color: #000000;">}</span>;
console.log<span style="color: #000000;">(</span>person<span style="color: #000000;">)</span>
console.log<span style="color: #000000;">(</span><span style="color: #531ab6;">typeof</span><span style="color: #dd22dd;">(</span>person<span style="color: #dd22dd;">)</span><span style="color: #000000;">)</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">{ name: 'adam', age: 23 }</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">object</span>
</pre>
</div></li>
<li>在js的语境中person的类型就是object</li>
</ul></li>
<li>ts中当然也承认这种用法,并且ts还做了js没有做的事情,给新的object person一个更加具体的类型
<ul class="org-ul">
<li>类型名字叫'{name: string; age: number;}'</li>
<li><p>
这个类型我们可以通过typescript playground可以看到,也可以通过如下的"错误"代码看到
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">person</span> = <span style="color: #000000;">{</span>
  name: <span style="color: #3548cf;">"adam"</span>,
  age: 23,
<span style="color: #000000;">}</span>;

<span style="color: #7f0000;">/////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Property 'foo' does not exist on type '{ name: string; age: number; }'. //</span>
<span style="color: #7f0000;">/////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">person.</span><span style="color: #721045;">foo</span><span style="color: #7f0000;">()</span>
</pre>
</div></li>
</ul></li>
<li>在js和ts中,我们都可以使用如下两种方式访问object value的成员:
<ul class="org-ul">
<li>object_value.mameber</li>
<li>object_value['member']</li>
</ul></li>
<li><p>
如果访问不存在的member,那么会报警
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">const</span>  <span style="color: #005e8b;">poet</span> = <span style="color: #000000;">{</span>
  born: 1935,
  name: <span style="color: #3548cf;">"Mary Oliver"</span>,
<span style="color: #000000;">}</span>;

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>poet<span style="color: #dd22dd;">[</span><span style="color: #3548cf;">'born'</span><span style="color: #dd22dd;">]</span><span style="color: #000000;">)</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>poet.name<span style="color: #000000;">)</span>;

<span style="color: #7f0000;">////////////////////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">error TS2339: Property 'end' does not exist on type '{ born: number; name: string; }'. //</span>
<span style="color: #7f0000;">////////////////////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">poet.end;</span>
</pre>
</div></li>
</ul>
</div>
<div id="outline-container-org9b5db41" class="outline-4">
<h4 id="org9b5db41"><span class="section-number-4">4.1.1.</span> Declaring Object Types</h4>
<div class="outline-text-4" id="text-4-1-1">
<ul class="org-ul">
<li>ts作为一个静态的类型系统语言,当然会提供"显式"定义object type的功能
<ul class="org-ul">
<li><p>
代码如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">poetLater</span>: <span style="color: #000000;">{</span>
  born: <span style="color: #531ab6;">number</span>;
  name: <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">ok</span>
poetLater = <span style="color: #000000;">{</span>
  born: 1935,
  name: <span style="color: #3548cf;">"Mary Oliver"</span>,
<span style="color: #000000;">}</span>;

<span style="color: #7f0000;">//////////////////////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">error TS2322: Type 'string' is not assignable to type '{ born: number; name: string; }'. //</span>
<span style="color: #7f0000;">//////////////////////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">poetLater = "Sappho";</span>
</pre>
</div></li>
<li>注意这里的类型就是type '{ born: number; name: string; }'</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org5c12dc2" class="outline-4">
<h4 id="org5c12dc2"><span class="section-number-4">4.1.2.</span> Aliased Object Types</h4>
<div class="outline-text-4" id="text-4-1-2">
<ul class="org-ul">
<li>我们发现上一节讲到的ts的类型名字都是这样的type '{ born: number; name: string; }', 这种名字是类似"匿名"
的这么一种方式(只有类型的属性,没有名字)</li>
<li><p>
如果我们想给不同的变量赋予类型,显然还是"非匿名"的方式更好,也就是给object type一个名字.这样一来,我们
的error message也会更加易读
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">type</span> <span style="color: #005f5f;">Poet</span> = <span style="color: #000000;">{</span>
  born: <span style="color: #531ab6;">number</span>;
  name: <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>;

<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">poetLater</span>: <span style="color: #005f5f;">Poet</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">ok</span>
poetLater = <span style="color: #000000;">{</span>
  born: 1935,
  name: <span style="color: #3548cf;">"Sara Teasdale"</span>,
<span style="color: #000000;">}</span>;

<span style="color: #7f0000;">///////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">error TS2322: Type 'string' is not assignable to type 'Poet'. //</span>
<span style="color: #7f0000;">///////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">poetLater = "Emily Dickinson"</span>
</pre>
</div></li>
<li>理解ts如何解析object literal对于我们理解ts的type system非常重要,本节内容对后面理解也非常重要</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org0b03970" class="outline-3">
<h3 id="org0b03970"><span class="section-number-3">4.2.</span> Structural Typing</h3>
<div class="outline-text-3" id="text-4-2">
<ul class="org-ul">
<li><p>
TypeScript的类型系统叫做structurally typed: 所谓structurally type,是说一个value"刚好"能满足一个类型,
那么就可以作为这个类型的value. 换句话说就是golang的所谓类型推断(Type inference),不需要显式的类型声明
</p>
<pre class="example" id="org915ba48">
Structurally typing means: any value that happens to satisfy a type is a allowed to be used
as a value of that type.
</pre></li>
<li>下面就是一个structural typing的例子:
<ul class="org-ul">
<li><p>
如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">type</span> <span style="color: #005f5f;">WithFirstName</span> = <span style="color: #000000;">{</span>
  firstName: <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>;

<span style="color: #531ab6;">type</span> <span style="color: #005f5f;">WithLastName</span> = <span style="color: #000000;">{</span>
  lastName: <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>;

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">hasBoth</span> = <span style="color: #000000;">{</span>
  firstName: <span style="color: #3548cf;">"Lucille"</span>,
  lastName: <span style="color: #3548cf;">"Clifton"</span>,
<span style="color: #000000;">}</span>;

<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">withFirstName</span>: <span style="color: #005f5f;">WithFirstName</span> = hasBoth;
<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">withLastName</span>: <span style="color: #005f5f;">WithLastName</span> = hasBoth;

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>withFirstName<span style="color: #000000;">)</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>withLastName<span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">{ firstName: 'Lucille', lastName: 'Clifton' }</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">{ firstName: 'Lucille', lastName: 'Clifton' }</span>
</pre>
</div></li>
<li>这个例子中我们有两个类型WithFirstName和WithLastName,每个类型都只有一个成员.</li>
<li>而hasBoth刚好这两个成员都有,那么即便我们没有"显式"的声明hashBoth属于这两个类型,但是hasBoth确实同
时符合这两个类型,那么一旦有这两个类型的变量需要value,我们的hashBoth就可以提供了.</li>
</ul></li>
<li>需要注意的是Structural typing和duck typing是两个概念:
<ul class="org-ul">
<li>structural tying是有staic system check的,在typescript这里就是type checker</li>
<li>duck typing是没有static system check的,它是在runtime遇到某个属性方法的时候,才去做check. Javascript
就是duck typing的编程语言</li>
</ul></li>
</ul>
</div>
<div id="outline-container-orgf572074" class="outline-4">
<h4 id="orgf572074"><span class="section-number-4">4.2.1.</span> Usage Checking</h4>
<div class="outline-text-4" id="text-4-2-1">
<ul class="org-ul">
<li>当我们在为一个value标记object type的时候,typescript会去check这个value是否满足了目标标记的type所需要
的所有成员. 如果缺少成员,那么就会报type error(多了其实也不行,后面会看到. 赋值的时候多了可以,声明的
时候多了不行)</li>
<li>下面就是一个缺少成员而报错的例子
<ul class="org-ul">
<li><p>
代码如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">type</span> <span style="color: #005f5f;">FirstAndLastNames</span> = <span style="color: #000000;">{</span>
  first: <span style="color: #531ab6;">string</span>;
  last: <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">ok</span>
<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">hasBoth</span>: <span style="color: #005f5f;">FirstAndLastNames</span> = <span style="color: #000000;">{</span>
  first: <span style="color: #3548cf;">"Sarojini"</span>,
  last: <span style="color: #3548cf;">"Naidu"</span>,
<span style="color: #000000;">}</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:12:7 - error TS2741: Property 'last' is missing in type '{ first: string; }' but required in type 'FirstAndLastNames'.</span>

<span style="color: #7f0000;">/////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">const hasOnlyOne: FirstAndLastNames = { //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">first: "Sappho",                      //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">};                                      //</span>
<span style="color: #7f0000;">/////////////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
<li>如果数量对上了,但是具体的类型没有满足,也是会报错的.
<ul class="org-ul">
<li><p>
如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">type</span> <span style="color: #005f5f;">TimeRange</span> = <span style="color: #000000;">{</span>
  start: <span style="color: #005f5f;">Date</span>;
<span style="color: #000000;">}</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:6:3 - error TS2322: Type 'string' is not assignable to type 'Date'.</span>

<span style="color: #7f0000;">/////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">const hasStartString: TimeRange = { //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">start: "1979-02-13",              //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">};                                  //</span>
<span style="color: #7f0000;">/////////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgc66b4c8" class="outline-4">
<h4 id="orgc66b4c8"><span class="section-number-4">4.2.2.</span> Excess Property Checking</h4>
<div class="outline-text-4" id="text-4-2-2">
<ul class="org-ul">
<li>我们对Typescript的structural typing印象深刻,一来是不需要声明,二来是成员满足即可,成员多了也能赋值成功</li>
<li>如果初始化变量的时候,我们声明了(同时标记了类型),那么成员就必须一模一样,不能少,也不能多了
<ul class="org-ul">
<li><p>
下面的例子中,就是我们在声明的时候,标记了类型,多一个成员activity就会报错
</p>
<div class="org-src-container">
<pre class="src src-js">type Poet = <span style="color: #000000;">{</span>
  born: number;
  name: string;
<span style="color: #000000;">}</span>;

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">poetMatch</span>: Poet = <span style="color: #000000;">{</span>
  born: 1928,
  name: <span style="color: #3548cf;">"Maya Angelou"</span>,
<span style="color: #000000;">}</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:12:3 - error TS2353: Object literal may only specify known properties, and 'activity' does not exist in type 'Poet'.</span>

<span style="color: #7f0000;">///////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">const extraProperty: Poet = { //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">activity: "walking",        //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">born: 1935,                 //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">name: "Mary Oliver",        //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">};                            //</span>
<span style="color: #7f0000;">///////////////////////////////////</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">existingObject</span> = <span style="color: #000000;">{</span>
  activity: <span style="color: #3548cf;">"walking"</span>,
  born: 1935,
  name: <span style="color: #3548cf;">"Mary Oliver"</span>,
<span style="color: #000000;">}</span>;

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">extraProperty</span>: Poet = existingObject; <span style="color: #7f0000;">// </span><span style="color: #7f0000;">Ok</span>
</pre>
</div></li>
<li>我们可以看到,初始化的时候多了是会有问题的(因为这时候往往是mistype), 但是用一个其他value赋值的时候多了是没问题的</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgde5b609" class="outline-4">
<h4 id="orgde5b609"><span class="section-number-4">4.2.3.</span> Nested Object Types</h4>
<div class="outline-text-4" id="text-4-2-3">
<ul class="org-ul">
<li>由于Javascript object可以nest很多其他的object, typescript也就必须能够表达nested object.</li>
<li>我们在type定义的类型,在使用object literal(而不是value)初始化的时候,必须完全一致
<ul class="org-ul">
<li><p>
下面代码中poemMismatch缺少author成员,所以初始化报错
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">type</span> <span style="color: #005f5f;">Poem</span> = <span style="color: #000000;">{</span>
  author: <span style="color: #dd22dd;">{</span>
    firstName: <span style="color: #531ab6;">string</span>;
    lastName: <span style="color: #531ab6;">string</span>;
  <span style="color: #dd22dd;">}</span>;
  name: <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">ok</span>
<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">poemMatch</span>: <span style="color: #005f5f;">Poem</span> = <span style="color: #000000;">{</span>
  author: <span style="color: #dd22dd;">{</span>
    firstName: <span style="color: #3548cf;">"Sylvia"</span>,
    lastName: <span style="color: #3548cf;">"Plath"</span>,
  <span style="color: #dd22dd;">}</span>,
  name: <span style="color: #3548cf;">"Lady Lazarus"</span>,
<span style="color: #000000;">}</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:20:5 - error TS2353: Object literal may only specify known properties, and 'name' does not exist in type '{ firstName: string; lastName: string; }'.</span>

<span style="color: #7f0000;">//////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">const poemMismatch: Poem = { //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">author: {                  //</span>
<span style="color: #7f0000;">//     </span><span style="color: #7f0000;">name: "Sylvia Plath",    //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">},                         //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">name: "Tuplips",           //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">};                           //</span>
<span style="color: #7f0000;">//////////////////////////////////</span>
</pre>
</div></li>
<li>上面的代码报错比较不容易理解,因为我们的author成员没有文字类型,只能用'{ firstName: string; lastName: string; }'来替代.</li>
<li><p>
一个更好的办法是把nested 类型给拆出来,给与一个名字,比如Author,那么代码更清晰,报错也更易读
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">type</span> <span style="color: #005f5f;">Author</span> = <span style="color: #000000;">{</span>
  firstName: <span style="color: #531ab6;">string</span>;
  lastName: <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>;

<span style="color: #531ab6;">type</span> <span style="color: #005f5f;">Poem</span> = <span style="color: #000000;">{</span>
  author: <span style="color: #005f5f;">Author</span>;
  name: <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:16:5 - error TS2353: Object literal may only specify known properties, and 'name' does not exist in type 'Author'.</span>

<span style="color: #7f0000;">//////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">const poemMismatch: Poem = { //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">author: {                  //</span>
<span style="color: #7f0000;">//     </span><span style="color: #7f0000;">name: "Sylvia Plath",    //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">},                         //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">name: "Tuplips",           //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">};                           //</span>
<span style="color: #7f0000;">//////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org6f6b03c" class="outline-4">
<h4 id="org6f6b03c"><span class="section-number-4">4.2.4.</span> Optional Properties</h4>
<div class="outline-text-4" id="text-4-2-4">
<ul class="org-ul">
<li>Object type可以包含一些"可选"成员,这些成员可以不出现,使用`?`标记
<ul class="org-ul">
<li><p>
比如下面的author成员可以不出现
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">type</span> <span style="color: #005f5f;">Book</span> = <span style="color: #000000;">{</span>
  author?: <span style="color: #531ab6;">string</span>;
  pages: <span style="color: #531ab6;">number</span>;
<span style="color: #000000;">}</span>;

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">ok</span>: <span style="color: #005f5f;">Book</span> = <span style="color: #000000;">{</span>
  author: <span style="color: #3548cf;">"Rita Dove"</span>,
  pages: 80,
<span style="color: #000000;">}</span>;

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">ok2</span>: <span style="color: #005f5f;">Book</span> = <span style="color: #000000;">{</span>
  pages: 90,
<span style="color: #000000;">}</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:15:7 - error TS2741: Property 'pages' is missing in type '{ author: string; }' but required in type 'Book'.</span>

<span style="color: #7f0000;">/////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">const missing: Book = { //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">author: "Rita Dove",  //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">};                      //</span>
<span style="color: #7f0000;">/////////////////////////////</span>
</pre>
</div></li>
<li>但是注意pages是必须出现的,不出现就会报错</li>
</ul></li>
<li>optional参数是可以不存在的,这个和类型为undefined(或者union包含undefined)不一样,后者即便是undefined也要存在
<ul class="org-ul">
<li><p>
例子如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">type</span> <span style="color: #005f5f;">Writers</span> = <span style="color: #000000;">{</span>
  author: <span style="color: #531ab6;">string</span> | <span style="color: #0000b0;">undefined</span>;
  editor?: <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">ok</span>
<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">hasRequired</span>: <span style="color: #005f5f;">Writers</span> = <span style="color: #000000;">{</span>
  author: <span style="color: #0000b0;">undefined</span>,
<span style="color: #000000;">}</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:11:7 - error TS2741: Property 'author' is missing in type '{}' but required in type 'Writers'.</span>

<span style="color: #7f0000;">//////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">const missingRequired: Writers = {}; //</span>
<span style="color: #7f0000;">//////////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org7e65dec" class="outline-3">
<h3 id="org7e65dec"><span class="section-number-3">4.3.</span> Unions of Object Types</h3>
<div class="outline-text-3" id="text-4-3">
<ul class="org-ul">
<li>既然普通类型有union,那么object类型的union需求也是合理的</li>
</ul>
</div>
<div id="outline-container-org0b5bdea" class="outline-4">
<h4 id="org0b5bdea"><span class="section-number-4">4.3.1.</span> Inferred Object-Type Unions</h4>
<div class="outline-text-4" id="text-4-3-1">
<ul class="org-ul">
<li>如果我们不明确的"声明"类型,而是直接赋值(通过?:),那么Typescript会自动的为我们创建union type
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">poem</span> =
  Math.<span style="color: #721045;">random</span><span style="color: #000000;">()</span> &gt; 0.5
    ? <span style="color: #000000;">{</span> name: <span style="color: #3548cf;">"The Double Image"</span>, pages: 7 <span style="color: #000000;">}</span>
    : <span style="color: #000000;">{</span> name: <span style="color: #3548cf;">"Her Kind"</span>, rhymes: <span style="color: #0000b0;">true</span> <span style="color: #000000;">}</span>;

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span><span style="color: #3548cf;">`|poem.name| =&gt; </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">poem.name</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #000000;">)</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span><span style="color: #3548cf;">`|poem.pages| =&gt; </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">poem.pages</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #000000;">)</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span><span style="color: #3548cf;">`|poem.rhymes| =&gt; </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">poem.rhymes</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT1====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|poem.name| =&gt; The Double Image</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|poem.pages| =&gt; 7</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|poem.rhymes| =&gt; undefined</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT2====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|poem.name| =&gt; Her Kind</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|poem.pages| =&gt; undefined</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|poem.rhymes| =&gt; true</span>
</pre>
</div></li>
<li>注意,这种Typescript内部帮我们创建的union type和真正的写出来的union type的不同:
<ol class="org-ol">
<li>真正的union type在没有narrow的情况下,只能使用"交集"的成员,比如name</li>
<li>这里的union type在没有narrow的情况下,还能使用"并集"的成员,比如pages, rhymes</li>
</ol></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org9bcf094" class="outline-4">
<h4 id="org9bcf094"><span class="section-number-4">4.3.2.</span> Explicit Object-Type Unions</h4>
<div class="outline-text-4" id="text-4-3-2">
<ul class="org-ul">
<li>explicit的把类型列出来做union,而不是让Typescript帮我们创建union是最高的选择,代码清晰,逻辑自然
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">type</span> <span style="color: #005f5f;">PoemWithPages</span> = <span style="color: #000000;">{</span>
  name: <span style="color: #531ab6;">string</span>;
  pages: <span style="color: #531ab6;">number</span>;
<span style="color: #000000;">}</span>;

<span style="color: #531ab6;">type</span> <span style="color: #005f5f;">PoemWithRhymes</span> = <span style="color: #000000;">{</span>
  name: <span style="color: #531ab6;">string</span>;
  rhymes: <span style="color: #531ab6;">boolean</span>;
<span style="color: #000000;">}</span>;

<span style="color: #531ab6;">type</span> <span style="color: #005f5f;">Poem</span> = PoemWithPages | PoemWithRhymes;

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">poem</span>: <span style="color: #005f5f;">Poem</span> =
  Math.<span style="color: #721045;">random</span><span style="color: #000000;">()</span> &gt; 0.5
    ? <span style="color: #000000;">{</span> name: <span style="color: #3548cf;">"The Double Image"</span>, pages: 7 <span style="color: #000000;">}</span>
    : <span style="color: #000000;">{</span> name: <span style="color: #3548cf;">"Her Kind"</span>, rhymes: <span style="color: #0000b0;">true</span> <span style="color: #000000;">}</span>;

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span><span style="color: #3548cf;">`|poem.name| =&gt; </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">poem.name</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT1====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|poem.name| =&gt; The Double Image</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT2====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|poem.name| =&gt; Her Kind</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:27:6 - error TS2339: Property 'pages' does not exist on type 'Poem'.</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">Property 'pages' does not exist on type 'PoemWithRhymes'.</span>

<span style="color: #7f0000;">/////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">poem.pages; //</span>
<span style="color: #7f0000;">/////////////////</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:35:6 - error TS2339: Property 'rhymes' does not exist on type 'Poem'.</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">Property 'rhymes' does not exist on type 'PoemWithPages'.</span>

<span style="color: #7f0000;">//////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">poem.rhymes; //</span>
<span style="color: #7f0000;">//////////////////</span>
</pre>
</div></li>
<li>注意,这里因为是列出来的union,所以只有"交集"name可以在没有narrow的情况下访问</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orge9f62e5" class="outline-4">
<h4 id="orge9f62e5"><span class="section-number-4">4.3.3.</span> Narrowing Object Types</h4>
<div class="outline-text-4" id="text-4-3-3">
<ul class="org-ul">
<li>有union,那么很显然也会有narrow,只不过object narrow的方法有所不同
<ul class="org-ul">
<li><p>
比如下面的例子,我们使用"page" in poem来进行narrow是可以的
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">type</span> <span style="color: #005f5f;">PoemWithPages</span> = <span style="color: #000000;">{</span>
  name: <span style="color: #531ab6;">string</span>;
  pages: <span style="color: #531ab6;">number</span>;
<span style="color: #000000;">}</span>;

<span style="color: #531ab6;">type</span> <span style="color: #005f5f;">PoemWithRhymes</span> = <span style="color: #000000;">{</span>
  name: <span style="color: #531ab6;">string</span>;
  rhymes: <span style="color: #531ab6;">boolean</span>;
<span style="color: #000000;">}</span>;

<span style="color: #531ab6;">type</span> <span style="color: #005f5f;">Poem</span> = PoemWithPages | PoemWithRhymes;

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">poem</span>: <span style="color: #005f5f;">Poem</span> =
  Math.<span style="color: #721045;">random</span><span style="color: #000000;">()</span> &gt; 0.5
    ? <span style="color: #000000;">{</span> name: <span style="color: #3548cf;">"The Double Image"</span>, pages: 7 <span style="color: #000000;">}</span>
    : <span style="color: #000000;">{</span> name: <span style="color: #3548cf;">"Her Kind"</span>, rhymes: <span style="color: #0000b0;">true</span> <span style="color: #000000;">}</span>;

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span><span style="color: #3548cf;">`|poem.name| =&gt; </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">poem.name</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #000000;">)</span>;

<span style="color: #531ab6;">if</span> <span style="color: #000000;">(</span><span style="color: #3548cf;">"pages"</span> <span style="color: #531ab6;">in</span> poem<span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">`|poem.pages| =&gt; </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">poem.pages</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span> <span style="color: #531ab6;">else</span> <span style="color: #000000;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">`|poem.rhymes| =&gt; </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">poem.rhymes</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT1====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|poem.name| =&gt; The Double Image</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|poem.pages| =&gt; 7</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT2====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|poem.name| =&gt; Her Kind</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|poem.rhymes| =&gt; true</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:34:10 - error TS2339: Property 'pages' does not exist on type 'Poem'.</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">Property 'pages' does not exist on type 'PoemWithRhymes'.</span>

<span style="color: #7f0000;">///////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">if (poem.</span><span style="color: #005e8b;">pages</span><span style="color: #7f0000;">) { //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">}                 //</span>
<span style="color: #7f0000;">///////////////////////</span>
</pre>
</div></li>
<li>但是不可以使用if (poem.pages), 因为试图访问一个不存在的property是会触发type error的</li>
<li>typescript足够聪明,判断出俩poem不是PoemWithPages的时候,它能够确定poem必然是PoemWithRhymes,所以else
里面的的poem.rhymes也能够触发而不报错</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org122c5a1" class="outline-4">
<h4 id="org122c5a1"><span class="section-number-4">4.3.4.</span> Discriminated Unions</h4>
<div class="outline-text-4" id="text-4-3-4">
<ul class="org-ul">
<li>discriminated union是一个在Javascript和Typescript里面都适用的概念,就是专门加一个property(通常是string)
用来indicate object的真实type</li>
<li>这个专门的用来indicate object的type就叫做discriminant, 而Typescript的narrow过程,如果有discriminant
的参与的话,就会事半功倍.
<ul class="org-ul">
<li><p>
示例如下, 下面例子中的poem.type就是discriminant
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">type</span> <span style="color: #005f5f;">PoemWithPages</span> = <span style="color: #000000;">{</span>
  name: <span style="color: #531ab6;">string</span>;
  pages: <span style="color: #531ab6;">number</span>;
  <span style="color: #000000; background-color: #fbf7f0;">type</span>: <span style="color: #3548cf;">"pages"</span>;
<span style="color: #000000;">}</span>;

<span style="color: #531ab6;">type</span> <span style="color: #005f5f;">PoemWithRhymes</span> = <span style="color: #000000;">{</span>
  name: <span style="color: #531ab6;">string</span>;
  rhymes: <span style="color: #531ab6;">boolean</span>;
  <span style="color: #000000; background-color: #fbf7f0;">type</span>: <span style="color: #3548cf;">"rhymes"</span>;
<span style="color: #000000;">}</span>;

<span style="color: #531ab6;">type</span> <span style="color: #005f5f;">Poem</span> = PoemWithPages | PoemWithRhymes;

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">poem</span>: <span style="color: #005f5f;">Poem</span> =
  Math.<span style="color: #721045;">random</span><span style="color: #000000;">()</span> &gt; 0.5
    ? <span style="color: #000000;">{</span> name: <span style="color: #3548cf;">"The Double Image"</span>, pages: 7, <span style="color: #000000; background-color: #fbf7f0;">type</span>: <span style="color: #3548cf;">"pages"</span> <span style="color: #000000;">}</span>
    : <span style="color: #000000;">{</span> name: <span style="color: #3548cf;">"Her Kind"</span>, rhymes: <span style="color: #0000b0;">true</span>, <span style="color: #000000; background-color: #fbf7f0;">type</span>: <span style="color: #3548cf;">"rhymes"</span> <span style="color: #000000;">}</span>;

<span style="color: #531ab6;">if</span> <span style="color: #000000;">(</span>poem.<span style="color: #531ab6;">type</span> === <span style="color: #3548cf;">"pages"</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">`|poem.pages| =&gt; </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">poem.pages</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span> <span style="color: #531ab6;">else</span> <span style="color: #000000;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">`|poem.rhymes| =&gt; </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">poem.rhymes</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span><span style="color: #3548cf;">`|poem.type| =&gt; </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">poem.type</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT1====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|poem.pages| =&gt; 7</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|poem.type| =&gt; pages</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">// &lt;====================OUTPUT2====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|poem.rhymes| =&gt; true</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|poem.type| =&gt; rhymes</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:36:6 - error TS2339: Property 'pages' does not exist on type 'Poem'.</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">Property 'pages' does not exist on type 'PoemWithRhymes'.</span>

<span style="color: #7f0000;">/////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">poem.pages; //</span>
<span style="color: #7f0000;">/////////////////</span>
</pre>
</div></li>
<li>poem.type在if判断后,可以选择书写poem.pages(或者poem.rhymes),否则还是会报错</li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgecd9590" class="outline-3">
<h3 id="orgecd9590"><span class="section-number-3">4.4.</span> Intersection Types</h3>
<div class="outline-text-3" id="text-4-4">
<ul class="org-ul">
<li>在集合里面中:
<ul class="org-ul">
<li>| 代表 union</li>
<li>&amp; 代表 intersection</li>
</ul></li>
<li>既然已经有了使用`|`的union type,会整活的typescript也没有放弃`&amp;`,创建了intersection type
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">type</span> <span style="color: #005f5f;">Artwork</span> = <span style="color: #000000;">{</span>
  genre: <span style="color: #531ab6;">string</span>;
  name: <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>;

<span style="color: #531ab6;">type</span> <span style="color: #005f5f;">Writing</span> = <span style="color: #000000;">{</span>
  pages: <span style="color: #531ab6;">number</span>;
  name: <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>;

<span style="color: #531ab6;">type</span> <span style="color: #005f5f;">WrittenArt</span> = Artwork &amp; Writing;

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">example</span>: <span style="color: #005f5f;">WrittenArt</span> = <span style="color: #000000;">{</span>
  genre: <span style="color: #3548cf;">"Fiction"</span>,
  name: <span style="color: #3548cf;">"The Great Novel"</span>,
  pages: 300,
<span style="color: #000000;">}</span>;

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>example<span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">{ genre: 'Fiction', name: 'The Great Novel', pages: 300 }</span>
</pre>
</div></li>
<li><p>
上面的WrittenArt其实就相当于如下的类型
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">type</span> <span style="color: #005f5f;">WrittenArt</span> = <span style="color: #000000;">{</span>
  genre: <span style="color: #531ab6;">string</span>;
  name: <span style="color: #531ab6;">string</span>;
  pages: <span style="color: #531ab6;">number</span>;
<span style="color: #000000;">}</span>;
</pre>
</div></li>
</ul></li>
<li>集合中的union和intersection可以混用,以提高编程语言的解释力
<ul class="org-ul">
<li><p>
示例如下: 在创建discriminated union的时候,共同类型可以通过,`&amp;`来间接的引入而不需要重复写一遍
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">type</span> <span style="color: #005f5f;">ShortPoem</span> = <span style="color: #000000;">{</span> author: <span style="color: #531ab6;">string</span> <span style="color: #000000;">}</span> &amp; <span style="color: #000000;">(</span>
  | <span style="color: #dd22dd;">{</span> kigo: <span style="color: #531ab6;">string</span>; <span style="color: #000000; background-color: #fbf7f0;">type</span>: <span style="color: #3548cf;">"haiku"</span> <span style="color: #dd22dd;">}</span>
  | <span style="color: #dd22dd;">{</span> meter: <span style="color: #531ab6;">number</span>; <span style="color: #000000; background-color: #fbf7f0;">type</span>: <span style="color: #3548cf;">"villanelle"</span> <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">)</span>;

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">morningGlory</span>: <span style="color: #005f5f;">ShortPoem</span> = <span style="color: #000000;">{</span>
  author: <span style="color: #3548cf;">"Fukuda Chiyo-ni"</span>,
  kigo: <span style="color: #3548cf;">"Morning Glory"</span>,
  <span style="color: #000000; background-color: #fbf7f0;">type</span>: <span style="color: #3548cf;">"haiku"</span>,
<span style="color: #000000;">}</span>;

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span><span style="color: #3548cf;">`|morningGlory| =&gt; </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">morningGlory</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|morningGlory| =&gt; [object Object]</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:17:7 - error TS2322: Type '{ author: string; </span><span style="color: #000000; background-color: #fbf7f0;">type</span><span style="color: #7f0000;">: "villanelle"; }' is not assignable to type 'ShortPoem'.</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">Type '{ author: string; </span><span style="color: #000000; background-color: #fbf7f0;">type</span><span style="color: #7f0000;">: "villanelle"; }' is not assignable to type '{ author: string; } &amp; { meter: number; </span><span style="color: #000000; background-color: #fbf7f0;">type</span><span style="color: #7f0000;">: "villanelle"; }'.</span>
<span style="color: #7f0000;">//     </span><span style="color: #7f0000;">Property 'meter' is missing in type '{ author: string; </span><span style="color: #000000; background-color: #fbf7f0;">type</span><span style="color: #7f0000;">: "villanelle"; }' but required in type '{ meter: number; </span><span style="color: #000000; background-color: #fbf7f0;">type</span><span style="color: #7f0000;">: "villanelle"; }'.</span>

<span style="color: #7f0000;">///////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">const oneArt: ShortPoem = {   //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">author: "Elizabeth Bishop", //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">type: "villanelle",         //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">};                            //</span>
<span style="color: #7f0000;">///////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
<div id="outline-container-org803b64e" class="outline-4">
<h4 id="org803b64e"><span class="section-number-4">4.4.1.</span> Dangers of Intersection Types</h4>
<div class="outline-text-4" id="text-4-4-1">
<ul class="org-ul">
<li>intersection type会让作者和编译器都困惑,我们最好不要使用这个特性</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-orge5ee814" class="outline-2">
<h2 id="orge5ee814"><span class="section-number-2">5.</span> Chapter 5: Functions</h2>
<div class="outline-text-2" id="text-5">
</div>
<div id="outline-container-orgb6edbe7" class="outline-3">
<h3 id="orgb6edbe7"><span class="section-number-3">5.1.</span> Function Parameters</h3>
<div class="outline-text-3" id="text-5-1">
<ul class="org-ul">
<li>对于typescript来说,函数参数也必须声明类型,否则会报错
<ul class="org-ul">
<li><p>
例子如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">sing</span><span style="color: #000000;">(</span><span style="color: #005e8b;">song</span>: <span style="color: #531ab6;">string</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">`Singing: </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">song</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">!`</span><span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>

<span style="color: #721045;">sing</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"hello world"</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:1:15 - error TS7006: Parameter 'song' implicitly has an 'any' type.</span>

<span style="color: #7f0000;">/////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">function sing(</span><span style="color: #005e8b;">song</span><span style="color: #7f0000;">) {               //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">console.</span><span style="color: #721045;">log</span><span style="color: #7f0000;">(`Singing: ${song}!`); //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">}                                   //</span>
<span style="color: #7f0000;">/////////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
<div id="outline-container-orgae2989c" class="outline-4">
<h4 id="orgae2989c"><span class="section-number-4">5.1.1.</span> Required Parameters</h4>
<div class="outline-text-4" id="text-5-1-1">
<ul class="org-ul">
<li>javascript的function并没有参数检查,你可以使用任意数目的参数来调用函数.即便这个数目和你声明的不一样
<ul class="org-ul">
<li><p>
示例如下,下面例子中我们的javascript函数声明了一个参数,但是可以分别使用0,1,2个参数成功调用
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #531ab6;">function</span> <span style="color: #721045;">greet</span><span style="color: #000000;">(</span><span style="color: #005e8b;">name</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  console.log<span style="color: #dd22dd;">(</span><span style="color: #3548cf;">"Hello, "</span> + name + <span style="color: #3548cf;">"!"</span><span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>

greet<span style="color: #000000;">(</span><span style="color: #3548cf;">"Alice"</span><span style="color: #000000;">)</span>; <span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#35843;&#29992;&#26102;&#20256;&#36882;&#19968;&#20010;&#21442;&#25968;&#65292;&#36755;&#20986;: Hello, Alice!</span>
greet<span style="color: #000000;">()</span>; <span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#35843;&#29992;&#26102;&#27809;&#26377;&#20256;&#36882;&#21442;&#25968;&#65292;&#36755;&#20986;: Hello, undefined!</span>
greet<span style="color: #000000;">(</span><span style="color: #3548cf;">"Alice"</span>, <span style="color: #3548cf;">"Bob"</span><span style="color: #000000;">)</span>; <span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#35843;&#29992;&#26102;&#20256;&#36882;&#20004;&#20010;&#21442;&#25968;&#65292;&#36755;&#20986;: Hello, Alice!</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Hello, Alice!</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Hello, undefined!</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Hello, Alice!</span>
</pre>
</div></li>
</ul></li>
<li>TypeScript则不可能延续这个策略,它会严格的进行测试,确保声明的函数参数和调用的函数参数数目一致
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">singTwo</span><span style="color: #000000;">(</span><span style="color: #005e8b;">first</span>: <span style="color: #531ab6;">string</span>, <span style="color: #005e8b;">second</span>: <span style="color: #531ab6;">string</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">`</span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">first</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;"> / </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">second</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>

<span style="color: #721045;">singTwo</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"hello"</span>, <span style="color: #3548cf;">"world"</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">hello / world</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:10:1 - error TS2554: Expected 2 arguments, but got 1.</span>

<span style="color: #7f0000;">///////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">singTwo("hello"); //</span>
<span style="color: #7f0000;">///////////////////////</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:18:27 - error TS2554: Expected 2 arguments, but got 3.</span>

<span style="color: #7f0000;">/////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">singTwo("hello", "world", "again"); //</span>
<span style="color: #7f0000;">/////////////////////////////////////////</span>
</pre>
</div>
<ul class="org-ul">
<li>用上面的例子区分两个概念:
<ol class="org-ol">
<li>parameter是函数声明时候希望接受的,上面例子的first, second就是pamameter</li>
<li>argument是函数调用时候赋予的,上面例子的"hello", "world"就是argument</li>
</ol></li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org3ac7c14" class="outline-4">
<h4 id="org3ac7c14"><span class="section-number-4">5.1.2.</span> Optional Parameters</h4>
<div class="outline-text-4" id="text-5-1-2">
<ul class="org-ul">
<li>在javascript里面,如果一个function parameter没有被提供,那么在使用的时候,其argument就是undefined</li>
<li>typescript作为类型安全的语言,为了能够满足parameter和argument数目不一致的场景,设计了特性:optional parameter
<ul class="org-ul">
<li><p>
示例如下,我们使用`?`来标记为optional parameter,所有的这些加`?`的参数类型默认加union为`| undefined`
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">announceSong</span><span style="color: #000000;">(</span><span style="color: #005e8b;">song</span>: <span style="color: #531ab6;">string</span>, <span style="color: #005e8b;">singer?</span>: <span style="color: #531ab6;">string</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">`Song: </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">song</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #dd22dd;">)</span>;

  <span style="color: #531ab6;">if</span> <span style="color: #dd22dd;">(</span>singer<span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #3548cf;">`Singer: </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">singer</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #721045;">announceSong</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Greensleeves"</span><span style="color: #000000;">)</span>;
<span style="color: #721045;">announceSong</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Greensleeves"</span>, <span style="color: #0000b0;">undefined</span><span style="color: #000000;">)</span>;
<span style="color: #721045;">announceSong</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Greensleeves"</span>, <span style="color: #3548cf;">"Sia"</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Song: Greensleeves</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Song: Greensleeves</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Song: Greensleeves</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Singer: Sia</span>
</pre>
</div></li>
<li><p>
注意,optional和"刚好加了|union的参数"不同,前者可以parameter和argument数目不一,后者不可以
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">announceSong</span><span style="color: #000000;">(</span><span style="color: #005e8b;">song</span>: <span style="color: #531ab6;">string</span>, <span style="color: #005e8b;">singer</span>: <span style="color: #531ab6;">string</span> | <span style="color: #0000b0;">undefined</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">`Song: </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">song</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #dd22dd;">)</span>;

  <span style="color: #531ab6;">if</span> <span style="color: #dd22dd;">(</span>singer<span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #3548cf;">`Singer: </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">singer</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #721045;">announceSong</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Greensleeves"</span>, <span style="color: #0000b0;">undefined</span><span style="color: #000000;">)</span>;
<span style="color: #721045;">announceSong</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Greensleeves"</span>, <span style="color: #3548cf;">"Sia"</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Song: Greensleeves</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Song: Greensleeves</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Singer: Sia</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:9:1 - error TS2554: Expected 2 arguments, but got 1.</span>

<span style="color: #7f0000;">///////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">announceSong("Greensleeves"); //</span>
<span style="color: #7f0000;">///////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
<li>optional parameter必须作为最后的参数,否则会报错
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:1:40 - error TS1016: A required parameter cannot follow an optional parameter.</span>

<span style="color: #7f0000;">/////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">function announceSong(</span><span style="color: #005e8b;">singer?</span><span style="color: #7f0000;">: string, </span><span style="color: #005e8b;">song</span><span style="color: #7f0000;">: string) {} //</span>
<span style="color: #7f0000;">/////////////////////////////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgbedd770" class="outline-4">
<h4 id="orgbedd770"><span class="section-number-4">5.1.3.</span> Default Parameters</h4>
<div class="outline-text-4" id="text-5-1-3">
<ul class="org-ul">
<li>参数默认值是比optional parameter更好的一种选择,它可以让我们的parameter在没有argument的情况下给一个默认值
<ul class="org-ul">
<li><p>
typescript的default parameter示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">rateSong</span><span style="color: #000000;">(</span><span style="color: #005e8b;">song</span>: <span style="color: #531ab6;">string</span>, rating = 0<span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">`|typeof rating| =&gt; </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">typeof rating</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #dd22dd;">)</span>;
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">`</span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">song</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;"> gets </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">rating</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">/5 stars!`</span><span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>

<span style="color: #721045;">rateSong</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Photograph"</span><span style="color: #000000;">)</span>;
<span style="color: #721045;">rateSong</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Set Fire to the Rain"</span>, 5<span style="color: #000000;">)</span>;
<span style="color: #721045;">rateSong</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Set Fire to the Rain"</span>, <span style="color: #0000b0;">undefined</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|typeof rating| =&gt; number</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Photograph gets 0/5 stars!</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|typeof rating| =&gt; number</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Set Fire to the Rain gets 5/5 stars!</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|typeof rating| =&gt; number</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Set Fire to the Rain gets 0/5 stars!</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:14:22 - error TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.</span>

<span style="color: #7f0000;">//////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">rateSong("At Last!", "100"); //</span>
<span style="color: #7f0000;">//////////////////////////////////</span>
</pre>
</div></li>
<li>我们调用的时候,想要默认值起作用可以:
<ol class="org-ol">
<li>缺少这个参数(这个和其他语言行为一致),</li>
<li>使用undefind替代(这个是为了和javascript语言特性一致)</li>
</ol></li>
<li><p>
我们发现一旦有了default parameter,那么argument的类型就确定了,在上例中必定是number.而不是像optional
parameter一样的union类型(number | undefiend).
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">rateSong</span><span style="color: #000000;">(</span><span style="color: #005e8b;">song</span>: <span style="color: #531ab6;">string</span>, <span style="color: #005e8b;">rating?</span>: <span style="color: #531ab6;">number</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">`|typeof rating| =&gt; </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">typeof rating</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #dd22dd;">)</span>;
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">`</span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">song</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;"> gets </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">rating</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">/5 stars!`</span><span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>

<span style="color: #721045;">rateSong</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Photograph"</span><span style="color: #000000;">)</span>;
<span style="color: #721045;">rateSong</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Set Fire to the Rain"</span>, 5<span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|typeof rating| =&gt; undefined</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Photograph gets undefined/5 stars!</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|typeof rating| =&gt; number</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Set Fire to the Rain gets 5/5 stars!</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org990e500" class="outline-4">
<h4 id="org990e500"><span class="section-number-4">5.1.4.</span> Rest Parameters</h4>
<div class="outline-text-4" id="text-5-1-4">
<ul class="org-ul">
<li>rest parametr也叫不定参数,是只最后一个参数可以是0个或者多个的情况
<ul class="org-ul">
<li><p>
在typescript里面,rest  parameter的类型会多一个`[]`,示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">singAllTheSongs</span><span style="color: #000000;">(</span><span style="color: #005e8b;">singer</span>: <span style="color: #531ab6;">string</span>, ...songs: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">[]</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">for</span> <span style="color: #dd22dd;">(</span><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">song</span> <span style="color: #531ab6;">of</span> songs<span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #3548cf;">`</span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">song</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">, by </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">singer</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #721045;">singAllTheSongs</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Alicia Keys"</span><span style="color: #000000;">)</span>;
<span style="color: #721045;">singAllTheSongs</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Lady Gaga"</span>, <span style="color: #3548cf;">"Bad Romance"</span>, <span style="color: #3548cf;">"Just Dance"</span>, <span style="color: #3548cf;">"Poker Face"</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Bad Romance, by Lady Gaga</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Just Dance, by Lady Gaga</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Poker Face, by Lady Gaga</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:18:36 - error TS2345: Argument of type 'number' is not assignable to parameter of type 'string'.</span>

<span style="color: #7f0000;">///////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">singAllTheSongs("Ella Fitzgerald", 2000); //</span>
<span style="color: #7f0000;">///////////////////////////////////////////////</span>
</pre>
</div></li>
<li>由于rest parameter有类型要求,所以传入number类型会导致typescript报错</li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org63cd35a" class="outline-3">
<h3 id="org63cd35a"><span class="section-number-3">5.2.</span> Return Types</h3>
<div class="outline-text-3" id="text-5-2">
<ul class="org-ul">
<li>TypeScript可以理解一个函数的所有可能返回值,并且给与其类型(多种返回值类型就是union类型)
<ul class="org-ul">
<li><p>
下面这个例子中,singSong返回值类型就是number
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">singSong</span><span style="color: #000000;">(</span><span style="color: #005e8b;">songs</span>: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">[]</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> songs.length;
<span style="color: #000000;">}</span>
</pre>
</div></li>
<li><p>
下面这个例子中,getSongAt的返回值就是一个string | undefined了
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">getSongAt</span><span style="color: #000000;">(</span><span style="color: #005e8b;">songs</span>: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">[]</span>, <span style="color: #005e8b;">index</span>: <span style="color: #531ab6;">number</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> index &lt; <span style="color: #005f5f;">songs</span>.<span style="color: #005f5f;">length</span> ? <span style="color: #005f5f;">songs</span><span style="color: #dd22dd;">[</span><span style="color: #005f5f;">index</span><span style="color: #dd22dd;">]</span> : <span style="color: #005f5f;">undefined</span>;
<span style="color: #000000;">}</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
<div id="outline-container-orgd9c8fc2" class="outline-4">
<h4 id="orgd9c8fc2"><span class="section-number-4">5.2.1.</span> Explicit Return Types</h4>
<div class="outline-text-4" id="text-5-2-1">
<ul class="org-ul">
<li>虽然typescript最佳实践就是不要给function明确的标记返回值类型.但是有几种特殊的情况下还是建议把返回值
类型给标记起来,这些情况分别是:
<ul class="org-ul">
<li>有很多种可能的return value,但是你希望只返回一种类型</li>
<li>typescript拒绝判断返回类型</li>
<li>在非常大的项目里面,标记函数返回类型,能减轻typescript的工作,从而提升代码检查效率,缩短时间</li>
</ul></li>
<li>下面是函数返回类型annotaion的书写方式:
<ul class="org-ul">
<li><p>
对于普通函数来说,就是在`{`之前加上类型
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">singSongRecursive</span><span style="color: #000000;">(</span><span style="color: #005e8b;">songs</span>: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">[]</span>, <span style="color: #005e8b;">count</span> = 0<span style="color: #000000;">)</span>: <span style="color: #531ab6;">number</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> songs.length ? <span style="color: #721045;">singSongRecursive</span><span style="color: #dd22dd;">(</span>songs.<span style="color: #721045;">slice</span><span style="color: #008899;">(</span>1<span style="color: #008899;">)</span>, count + 1<span style="color: #dd22dd;">)</span> : count;
<span style="color: #000000;">}</span>
</pre>
</div></li>
<li><p>
对于arrow function来说,就是在`=&gt;`之前加上类型
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">singSongRecursive</span> = <span style="color: #000000;">(</span>songs: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">[]</span>, count = 0<span style="color: #000000;">)</span>: <span style="color: #531ab6;">number</span> <span style="color: #531ab6;">=&gt;</span>
  songs.length ? <span style="color: #721045;">singSongRecursive</span><span style="color: #000000;">(</span>songs.<span style="color: #721045;">slice</span><span style="color: #dd22dd;">(</span>1<span style="color: #dd22dd;">)</span>, count + 1<span style="color: #000000;">)</span> : count;
</pre>
</div></li>
</ul></li>
<li>一旦设置的function return type,那么typescript会去进行检查的
<ul class="org-ul">
<li><p>
示例代码如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">getSongRecordingDate</span><span style="color: #000000;">(</span><span style="color: #005e8b;">song</span>: <span style="color: #531ab6;">string</span><span style="color: #000000;">)</span>: <span style="color: #005f5f;">Date</span> | <span style="color: #0000b0;">undefined</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">switch</span> <span style="color: #dd22dd;">(</span>song<span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">case</span> <span style="color: #3548cf;">"Strange Fruit"</span>:
      <span style="color: #531ab6;">return</span> <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Date</span><span style="color: #008899;">(</span><span style="color: #3548cf;">"April 20, 1939"</span><span style="color: #008899;">)</span>;
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:6:7 - error TS2322: Type 'string' is not assignable to type 'Date'.</span>

    <span style="color: #7f0000;">//////////////////////////</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">case "Greensleeves": //</span>
    <span style="color: #7f0000;">//   </span><span style="color: #7f0000;">return "unknown";  //</span>
    <span style="color: #7f0000;">//////////////////////////</span>
    <span style="color: #000000; background-color: #fbf7f0;">default</span>:
      <span style="color: #531ab6;">return</span> <span style="color: #0000b0;">undefined</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org2691324" class="outline-3">
<h3 id="org2691324"><span class="section-number-3">5.3.</span> Function Types</h3>
<div class="outline-text-3" id="text-5-3">
<ul class="org-ul">
<li>Javascript的函数是一等公民,可以把function作为value到处传递,那么我们的function也必须要有自己的类型</li>
<li>Function type和arrow function的样子很像,只不过"=&gt;"之后是返回值的类型,而不是{}
<ul class="org-ul">
<li><p>
nothingInGivesString函数是一个没有形参,返回值为string类型的函数
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">nothingInGivesString</span>: <span style="color: #000000;">()</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #531ab6;">string</span>;
</pre>
</div></li>
<li><p>
inputAndOutput函数有一个必选参数string[]类型的songs,一个可选参数count?,返回值为number类型
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">inputAndOutput</span>: <span style="color: #000000;">(</span>songs: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">[]</span>, <span style="color: #005e8b;">count</span>?: <span style="color: #531ab6;">number</span><span style="color: #000000;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #531ab6;">number</span>;
</pre>
</div></li>
</ul></li>
<li>function type的最常用的地方是callback parameter(这种参数会被像function一样被调用)
<ul class="org-ul">
<li><p>
下面就是这样一个例子,runOnSong的唯一参数就是一个callback parameter
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">songs</span> = <span style="color: #000000;">[</span><span style="color: #3548cf;">"Juice"</span>, <span style="color: #3548cf;">"Shake It Off"</span>, <span style="color: #3548cf;">"What's Up"</span><span style="color: #000000;">]</span>;

<span style="color: #531ab6;">function</span> <span style="color: #721045;">runOnSongs</span><span style="color: #000000;">(</span><span style="color: #005e8b;">getSongAtP</span>: <span style="color: #dd22dd;">(</span><span style="color: #005e8b;">index</span>: <span style="color: #531ab6;">number</span><span style="color: #dd22dd;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #531ab6;">string</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">for</span> <span style="color: #dd22dd;">(</span><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">i</span> = 0; i &lt; <span style="color: #005f5f;">songs</span>.<span style="color: #005f5f;">length</span>; <span style="color: #005f5f;">i</span> += 1<span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #721045;">getSongAtP</span><span style="color: #972500;">(</span>i<span style="color: #972500;">)</span><span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">function</span> <span style="color: #721045;">getSongAt</span><span style="color: #000000;">(</span><span style="color: #005e8b;">index</span>: <span style="color: #531ab6;">number</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> <span style="color: #3548cf;">`</span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">songs[index]</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span>;
<span style="color: #000000;">}</span>

<span style="color: #721045;">runOnSongs</span><span style="color: #000000;">(</span>getSongAt<span style="color: #000000;">)</span>;

<span style="color: #531ab6;">function</span> <span style="color: #721045;">longSong</span><span style="color: #000000;">(</span><span style="color: #005e8b;">song</span>: <span style="color: #531ab6;">string</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> <span style="color: #3548cf;">`</span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">song</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span>;
<span style="color: #000000;">}</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Juice</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Shake It Off</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">What's Up</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:24:12 - error TS2345: Argument of type '(song: string) =&gt; string' is not assignable to parameter of type '(index: number) =&gt; string'.</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">Types of parameters 'song' and 'index' are incompatible.</span>
<span style="color: #7f0000;">//     </span><span style="color: #7f0000;">Type 'number' is not assignable to type 'string'.</span>

<span style="color: #7f0000;">///////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">runOnSongs(longSong); //</span>
<span style="color: #7f0000;">///////////////////////////</span>
</pre>
</div></li>
<li>callback pameter的类型是形参为number,返回值为string, getSongAt符合要求, logSong则不符合</li>
</ul></li>
</ul>
</div>
<div id="outline-container-org1609c45" class="outline-4">
<h4 id="org1609c45"><span class="section-number-4">5.3.1.</span> Function Type Parentheses</h4>
<div class="outline-text-4" id="text-5-3-1">
<ul class="org-ul">
<li>function type是一个比较复杂的称谓(这个称谓的中间还有空格),所以我们需要在有些情况下在function type外面加上括号</li>
<li>union type就是这样一种情况:
<ul class="org-ul">
<li><p>
如果不加括号,那么returnsStringOrUndefined的function type的类型为: function that returns a union: string | undefined
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">returnsStringOrUndefined</span>: <span style="color: #000000;">()</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #531ab6;">string</span> | <span style="color: #0000b0;">undefined</span>;
</pre>
</div></li>
<li><p>
加了括号,那么mybeReturnsString要么是一个function that returns a string, 要么是一个undefined
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">maybeReturnsString</span>: <span style="color: #000000;">(</span><span style="color: #dd22dd;">()</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #531ab6;">string</span><span style="color: #000000;">)</span> | <span style="color: #0000b0;">undefined</span>;
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org4ebe69d" class="outline-4">
<h4 id="org4ebe69d"><span class="section-number-4">5.3.2.</span> Parameter Type Inferences</h4>
<div class="outline-text-4" id="text-5-3-2">
<ul class="org-ul">
<li>typescript可以聪明的让我们在类型明确的情况下,少些后续的类型.
<ul class="org-ul">
<li><p>
比如下面的例子,我们已经声明了singer的类型了,那么在赋值的时候我们不需要再给song声明其为string了
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">singer</span>: <span style="color: #000000;">(</span>song: <span style="color: #531ab6;">string</span><span style="color: #000000;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #531ab6;">string</span>;

singer = <span style="color: #531ab6;">function</span> <span style="color: #000000;">(</span><span style="color: #005e8b;">song</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> <span style="color: #3548cf;">`Sing: </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">song.toUpperCase()</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">!`</span>;
<span style="color: #000000;">}</span>;

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span><span style="color: #721045;">singer</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">"Hello"</span><span style="color: #dd22dd;">)</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Sing: HELLO!</span>
</pre>
</div></li>
<li><p>
因为不是stirng压根赋值不会成功,如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">singer</span>: <span style="color: #000000;">(</span>song: <span style="color: #531ab6;">string</span><span style="color: #000000;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #531ab6;">string</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:3:1 - error TS2322: Type '(song: number) =&gt; string' is not assignable to type '(song: string) =&gt; string'.</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">Types of parameters 'song' and 'song' are incompatible.</span>
<span style="color: #7f0000;">//     </span><span style="color: #7f0000;">Type 'string' is not assignable to type 'number'.</span>

<span style="color: #7f0000;">////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">singer = function (</span><span style="color: #005e8b;">song</span><span style="color: #7f0000;">: number) { //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">return `Sing: Something!`;       //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">};                                 //</span>
<span style="color: #7f0000;">////////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
<li>既然"已声明对象赋值"的时候,可以被infer. 那么把"函数作为参数"传递给另外函数的时候,类型也是可以被infer
的,因为另外的函数肯定在其他地方已经声明过"函数参数"的类型了
<ul class="org-ul">
<li><p>
示例如下:
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">songs</span> = <span style="color: #000000;">[</span><span style="color: #3548cf;">"Call Me"</span>, <span style="color: #3548cf;">"Jolene"</span>, <span style="color: #3548cf;">"The Chain"</span><span style="color: #000000;">]</span>;

songs.<span style="color: #721045;">forEach</span><span style="color: #000000;">(</span><span style="color: #dd22dd;">(</span><span style="color: #005e8b;">song</span>, <span style="color: #005e8b;">index</span><span style="color: #dd22dd;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #dd22dd;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #3548cf;">`</span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">song</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;"> is at index </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">index</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #008899;">)</span>
<span style="color: #dd22dd;">}</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Call Me is at index 0</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Jolene is at index 1</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">The Chain is at index 2</span>
</pre>
</div></li>
<li>forEach的函数参数已经声明过类型了,其callbackFn参数第二个成员为number类型,这里的inde也就直接被infer
成number类型</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org6380d26" class="outline-4">
<h4 id="org6380d26"><span class="section-number-4">5.3.3.</span> Function Type Aliases</h4>
<div class="outline-text-4" id="text-5-3-3">
<ul class="org-ul">
<li>type aliases 本来是实现"一人千面"作用的. 但是同时也能将复杂的类型转换成一个"看起来简单的类型"</li>
<li>function type一般来说,其都是比较复杂的类型,能够转成一个"看起来简单的类型"非常重要.
<ul class="org-ul">
<li><p>
示例如下,我们把(input: string) =&gt; number这么复杂的类型,alias成StringToNumber这么一个"看起来简单
的类型",然后这个类型还能在之后使用
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">type</span> <span style="color: #005f5f;">StringToNumber</span> = <span style="color: #000000;">(</span>input: <span style="color: #531ab6;">string</span><span style="color: #000000;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #531ab6;">number</span>;

<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">stringToNumber</span>: <span style="color: #005f5f;">StringToNumber</span>;

stringToNumber = <span style="color: #000000;">(</span>input<span style="color: #000000;">)</span> <span style="color: #531ab6;">=&gt;</span> input.length; <span style="color: #7f0000;">// </span><span style="color: #7f0000;">ok</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:8:29 - error TS2322: Type 'string' is not assignable to type 'number'.</span>

<span style="color: #7f0000;">//////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">stringToNumber = (input) =&gt; input.</span><span style="color: #721045;">toUpperCase</span><span style="color: #7f0000;">(); //</span>
<span style="color: #7f0000;">//////////////////////////////////////////////////////</span>
</pre>
</div></li>
<li><p>
我们当然可以把这个"看起来简单的类型"放到函数声明里面,比起原来的复杂的函数声明,当前的函数声明看起
来简单好多(虽然看起来不像function type)
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">type</span> <span style="color: #005f5f;">NumberToString</span> = <span style="color: #000000;">(</span>input: <span style="color: #531ab6;">number</span><span style="color: #000000;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #531ab6;">string</span>;

<span style="color: #531ab6;">function</span> <span style="color: #721045;">userNumberToString</span><span style="color: #000000;">(</span><span style="color: #005e8b;">numberToString</span>: <span style="color: #005f5f;">NumberToString</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">`Ths string is : </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">numberToString(123)</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>

<span style="color: #721045;">userNumberToString</span><span style="color: #000000;">(</span><span style="color: #dd22dd;">(</span>input<span style="color: #dd22dd;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #3548cf;">`</span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">input</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">! Hooray`</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Ths string is : 123! Hooray</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:9:31 - error TS2322: Type 'number' is not assignable to type 'string'.</span>

<span style="color: #7f0000;">///////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">userNumberToString((input) =&gt; input * 2); //</span>
<span style="color: #7f0000;">///////////////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org3b9843e" class="outline-3">
<h3 id="org3b9843e"><span class="section-number-3">5.4.</span> More Return Types</h3>
<div class="outline-text-3" id="text-5-4">
</div>
<div id="outline-container-org70a1ea7" class="outline-4">
<h4 id="org70a1ea7"><span class="section-number-4">5.4.1.</span> Void Returns</h4>
<div class="outline-text-4" id="text-5-4-1">
<ul class="org-ul">
<li>void return是绝大多数typescript都有的特性,其主要处理如下两种情况:
<ul class="org-ul">
<li>函数体没有return关键字</li>
<li>函数体的return后面直接就是分号,没返回任何东西</li>
</ul></li>
<li>void return一旦声明了之后,是不允许返回任何值的
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">songLogger</span>: <span style="color: #000000;">(</span>song: <span style="color: #531ab6;">string</span><span style="color: #000000;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #531ab6;">void</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:5:3 - error TS2322: Type 'boolean' is not assignable to type 'void'.</span>

<span style="color: #7f0000;">////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">songLogger = (</span><span style="color: #005e8b;">song</span><span style="color: #7f0000;">): void =&gt; { //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">console.</span><span style="color: #721045;">log</span><span style="color: #7f0000;">(`${song}`);      //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">return true;                 //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">};                             //</span>
<span style="color: #7f0000;">////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
<li>void return在function type里面非常重要,因为"=&gt;"后面必须得有点东西
<ul class="org-ul">
<li><p>
示例如下,注意声明时候的void在"=&gt;"后面,调用的时候void在"=&gt;"前面
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">songLogger</span>: <span style="color: #000000;">(</span>song: <span style="color: #531ab6;">string</span><span style="color: #000000;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #531ab6;">void</span>;

songLogger = <span style="color: #000000;">(</span><span style="color: #005e8b;">song</span><span style="color: #000000;">)</span>: <span style="color: #531ab6;">void</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #000000;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">`</span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">song</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>;

<span style="color: #721045;">songLogger</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Heart of Glass"</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Heart of Glass</span>
</pre>
</div></li>
</ul></li>
<li>注意,void是typescript里面的一个type,其和undefined是不一样的,两者不可以相互赋值
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">returnsVoid</span><span style="color: #000000;">()</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">lazyValue</span>: <span style="color: #531ab6;">string</span> | <span style="color: #0000b0;">undefined</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:7:1 - error TS2322: Type 'void' is not assignable to type 'string | undefined'.</span>

<span style="color: #7f0000;">////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">lazyValue = returnsVoid(); //</span>
<span style="color: #7f0000;">////////////////////////////////</span>
</pre>
</div></li>
<li><p>
注意上面的例子中function returnsVoid()并没有明确的写出返回值类型,那么其实是可以返回任意类型的,只
不过代码里面return;让Typescript编译器直接给他确认了返回值类型是void.如果你的代码里面有其他逻辑,可
以返回不同类型,编译器甚至能判断出这些类型!
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">returnsVoid</span><span style="color: #000000;">()</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">if</span> <span style="color: #dd22dd;">(</span>Math.<span style="color: #721045;">random</span><span style="color: #008899;">()</span> &gt; 0.5<span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">return</span> 123;
  <span style="color: #dd22dd;">}</span> <span style="color: #531ab6;">else</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">return</span> <span style="color: #3548cf;">"123"</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">lazyValue</span>: <span style="color: #531ab6;">string</span> | <span style="color: #0000b0;">undefined</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:14:1 - error TS2322: Type '123 | "123"' is not assignable to type 'string | undefined'.</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">Type 'number' is not assignable to type 'string'.</span>

<span style="color: #7f0000;">////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">lazyValue = returnsVoid(); //</span>
<span style="color: #7f0000;">////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
<li>void返回值的定义会产生一个问题,比如forEach函数,其要求第一个参数callbackFn的返回值为void,这样可以警
告forEach,不要去使用这个callbackFn的返回值.
<ul class="org-ul">
<li><p>
如果真的严格要求,那么我们的forEach只能这样调用
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">records</span>: <span style="color: #531ab6;">string</span><span style="color: #000000;">[]</span> = <span style="color: #000000;">[]</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>records<span style="color: #000000;">)</span>;

<span style="color: #531ab6;">function</span> <span style="color: #721045;">saveRecords</span><span style="color: #000000;">(</span><span style="color: #005e8b;">newRecords</span>: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">[]</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  newRecords.<span style="color: #721045;">forEach</span><span style="color: #dd22dd;">(</span><span style="color: #008899;">(</span><span style="color: #005e8b;">record</span><span style="color: #008899;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #008899;">{</span>
    records.<span style="color: #721045;">push</span><span style="color: #972500;">(</span>record<span style="color: #972500;">)</span>;
  <span style="color: #008899;">}</span><span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>

<span style="color: #721045;">saveRecords</span><span style="color: #000000;">(</span><span style="color: #dd22dd;">[</span><span style="color: #3548cf;">"21"</span>, <span style="color: #3548cf;">"Come On Over"</span>, <span style="color: #3548cf;">"The Bodyguard"</span><span style="color: #dd22dd;">]</span><span style="color: #000000;">)</span>;

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>records<span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">[]</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">[ '21', 'Come On Over', 'The Bodyguard' ]</span>
</pre>
</div></li>
<li><p>
但实际上,我们可以不要这个括号也能调用,这算是Typescript为数不多的"委曲求全",默认了也能在void返回值
的时候返回非void,只是用void警告大家不要使用这个返回值就可以了.
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">records</span>: <span style="color: #531ab6;">string</span><span style="color: #000000;">[]</span> = <span style="color: #000000;">[]</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>records<span style="color: #000000;">)</span>;

<span style="color: #531ab6;">function</span> <span style="color: #721045;">saveRecords</span><span style="color: #000000;">(</span><span style="color: #005e8b;">newRecords</span>: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">[]</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  newRecords.<span style="color: #721045;">forEach</span><span style="color: #dd22dd;">(</span><span style="color: #008899;">(</span>record<span style="color: #008899;">)</span> <span style="color: #531ab6;">=&gt;</span> records.<span style="color: #721045;">push</span><span style="color: #008899;">(</span>record<span style="color: #008899;">)</span><span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>

<span style="color: #721045;">saveRecords</span><span style="color: #000000;">(</span><span style="color: #dd22dd;">[</span><span style="color: #3548cf;">"21"</span>, <span style="color: #3548cf;">"Come On Over"</span>, <span style="color: #3548cf;">"The Bodyguard"</span><span style="color: #dd22dd;">]</span><span style="color: #000000;">)</span>;

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>records<span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">[]</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">[ '21', 'Come On Over', 'The Bodyguard' ]</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org0c1bb5c" class="outline-4">
<h4 id="org0c1bb5c"><span class="section-number-4">5.4.2.</span> Never Returns</h4>
<div class="outline-text-4" id="text-5-4-2">
<ul class="org-ul">
<li>never return是处理如下两种情况:
<ul class="org-ul">
<li><p>
总数抛出异常,例子如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">fail</span><span style="color: #000000;">(</span><span style="color: #005e8b;">message</span>: <span style="color: #531ab6;">string</span><span style="color: #000000;">)</span>: <span style="color: #531ab6;">never</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">throw</span> <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Error</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">`Invariant failure: </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">message</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">.`</span><span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">function</span> <span style="color: #721045;">workWithUnsafeParam</span><span style="color: #000000;">(</span><span style="color: #005e8b;">param</span>: <span style="color: #531ab6;">unknown</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">if</span> <span style="color: #dd22dd;">(</span><span style="color: #531ab6;">typeof</span> param != <span style="color: #3548cf;">"string"</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #721045;">fail</span><span style="color: #008899;">(</span><span style="color: #3548cf;">`param should be a string, not </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">typeof param</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #008899;">)</span>
  <span style="color: #dd22dd;">}</span>

  param.<span style="color: #721045;">toUpperCase</span><span style="color: #dd22dd;">()</span>;
<span style="color: #000000;">}</span>
</pre>
</div></li>
<li>无限循环,但是不返回.这种不太常见.</li>
</ul></li>
<li>注意,never和void不一样:
<ul class="org-ul">
<li>never是一个函数永远都不返回值</li>
<li>void是函数返回的值nothing,提醒使用者不用使用这个nothing</li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org625bb68" class="outline-3">
<h3 id="org625bb68"><span class="section-number-3">5.5.</span> Function Overloads</h3>
<div class="outline-text-3" id="text-5-5">
<ul class="org-ul">
<li>函数重载是编程语言经典的特性.typescript自然也是支持的
<ul class="org-ul">
<li><p>
下面就是一个重载的例子.
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">createDate</span><span style="color: #000000;">(</span><span style="color: #005e8b;">timestamp</span>: <span style="color: #531ab6;">number</span><span style="color: #000000;">)</span>: <span style="color: #005f5f;">Date</span>;
<span style="color: #531ab6;">function</span> <span style="color: #721045;">createDate</span><span style="color: #000000;">(</span><span style="color: #005e8b;">month</span>: <span style="color: #531ab6;">number</span>, <span style="color: #005e8b;">day</span>: <span style="color: #531ab6;">number</span>, <span style="color: #005e8b;">year</span>: <span style="color: #531ab6;">number</span><span style="color: #000000;">)</span>: <span style="color: #005f5f;">Date</span>;

<span style="color: #531ab6;">function</span> <span style="color: #721045;">createDate</span><span style="color: #000000;">(</span><span style="color: #005e8b;">monthOrTimestamp</span>: <span style="color: #531ab6;">number</span>, <span style="color: #005e8b;">day?</span>: <span style="color: #531ab6;">number</span>, <span style="color: #005e8b;">year?</span>: <span style="color: #531ab6;">number</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> day === <span style="color: #0000b0;">undefined</span> || year === <span style="color: #0000b0;">undefined</span>
    ? <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Date</span><span style="color: #dd22dd;">(</span><span style="color: #005e8b;">monthOrTimestamp</span><span style="color: #dd22dd;">)</span>
    : <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Date</span><span style="color: #dd22dd;">(</span>year, monthOrTimestamp, day<span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>

<span style="color: #721045;">createDate</span><span style="color: #000000;">(</span>554356800<span style="color: #000000;">)</span>;
<span style="color: #721045;">createDate</span><span style="color: #000000;">(</span>7, 27, 1987<span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:13:1 - error TS2575: No overload expects 2 arguments, but overloads do exist that expect either 1 or 3 arguments.</span>

<span style="color: #7f0000;">///////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">createDate(3, 1); //</span>
<span style="color: #7f0000;">///////////////////////</span>
</pre>
</div></li>
<li>注意上面的前两个是函数声明,第三个是函数实现.第三个函数实现虽然是支持两个参数调用的,但是由于声明的
时候没有两个参数的版本,所以调用两个参数的版本会失败</li>
<li><p>
上面重载的例子,其实就是在转换为javascript之后,会把代码改变成如下javascript逻辑,可以看到,已经完全
没有重载的痕迹了.
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #531ab6;">function</span> <span style="color: #721045;">createDate</span><span style="color: #000000;">(</span><span style="color: #005e8b;">monthOrTimestamp</span>, <span style="color: #005e8b;">day</span>, <span style="color: #005e8b;">year</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> day === <span style="color: #0000b0;">undefined</span> || year === <span style="color: #0000b0;">undefined</span>
    ? <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Datre</span><span style="color: #dd22dd;">(</span>monthOrTimestamp<span style="color: #dd22dd;">)</span>
    : <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Datre</span><span style="color: #dd22dd;">(</span>year, monthOrTimestamp, day<span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
<div id="outline-container-org7955f7a" class="outline-4">
<h4 id="org7955f7a"><span class="section-number-4">5.5.1.</span> Call-Signature Compatibility</h4>
<div class="outline-text-4" id="text-5-5-1">
<ul class="org-ul">
<li>由于typescript的重载办法,是在编译成javascript的时候,依靠逻辑来重写代码.那么我们就要求参数必须能够
相互转换(对位assignable),比如上一节例子中的timestamp和month都是string
<ul class="org-ul">
<li><p>
下面的例子中,第三个函数就因为无法和第一个函数对位assign,所以重载失败了
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">format</span><span style="color: #000000;">(</span><span style="color: #005e8b;">data</span>: <span style="color: #531ab6;">string</span><span style="color: #000000;">)</span>: <span style="color: #531ab6;">string</span>;
<span style="color: #531ab6;">function</span> <span style="color: #721045;">format</span><span style="color: #000000;">(</span><span style="color: #005e8b;">data</span>: <span style="color: #531ab6;">string</span>, <span style="color: #005e8b;">needle</span>: <span style="color: #531ab6;">string</span>, <span style="color: #005e8b;">haystack</span>: <span style="color: #531ab6;">string</span><span style="color: #000000;">)</span>: <span style="color: #531ab6;">string</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:4:10 - error TS2394: This overload signature is not compatible with its implementation signature.</span>

<span style="color: #7f0000;">/////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">function format(</span><span style="color: #005e8b;">getData</span><span style="color: #7f0000;">: () =&gt; </span><span style="color: #005e8b;">string</span><span style="color: #7f0000;">): string; //</span>
<span style="color: #7f0000;">/////////////////////////////////////////////////////</span>

<span style="color: #531ab6;">function</span> <span style="color: #721045;">format</span><span style="color: #000000;">(</span><span style="color: #005e8b;">data</span>: <span style="color: #531ab6;">string</span>, <span style="color: #005e8b;">needle?</span>: <span style="color: #531ab6;">string</span>, <span style="color: #005e8b;">haystack?</span>: <span style="color: #531ab6;">string</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> needle &amp;&amp; haystack ? data.<span style="color: #721045;">replace</span><span style="color: #dd22dd;">(</span><span style="color: #005e8b;">needle</span>, <span style="color: #005e8b;">haystack</span><span style="color: #dd22dd;">)</span> : data;
<span style="color: #000000;">}</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org62d5f59" class="outline-2">
<h2 id="org62d5f59"><span class="section-number-2">6.</span> Chapter 6: Arrays</h2>
<div class="outline-text-2" id="text-6">
</div>
<div id="outline-container-org5175a3b" class="outline-3">
<h3 id="org5175a3b"><span class="section-number-3">6.1.</span> Array Types</h3>
<div class="outline-text-3" id="text-6-1">
<ul class="org-ul">
<li>变量一般声明的时候,都是没有value的.array也同样,所以我们必须为"空的array"创建一个声明样式
<ul class="org-ul">
<li><p>
typescript肯定是希望你一开始就把array里面放置什么类型给标记出来的,如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">arrayOfNumbbers</span>: <span style="color: #531ab6;">number</span><span style="color: #000000;">[]</span>;

arrayOfNumbbers = <span style="color: #000000;">[</span>1, 2, 3, 4, 5<span style="color: #000000;">]</span>;
</pre>
</div></li>
<li>我们甚至可以使用Array&lt;number&gt;来替代number[],但是这种写法不太受欢迎</li>
</ul></li>
</ul>
</div>
<div id="outline-container-org345dc07" class="outline-4">
<h4 id="org345dc07"><span class="section-number-4">6.1.1.</span> Array and Function Types</h4>
<div class="outline-text-4" id="text-6-1-1">
<ul class="org-ul">
<li>我们之前说过,本身function type由于其类型过长,就容易需要配合(). 如果function type再加上array,那么使
用括号的概率,就更高了
<ul class="org-ul">
<li><p>
第一个例子函数的类型是: function that returns an array of strings
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">createStrings</span>: <span style="color: #000000;">()</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #531ab6;">string</span><span style="color: #000000;">[]</span>;
</pre>
</div></li>
<li><p>
第二个例子函数的类型是: functions that each return a string
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">strignCreators</span>: <span style="color: #000000;">(</span><span style="color: #dd22dd;">()</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #531ab6;">string</span><span style="color: #000000;">)[]</span>;
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org7e8b2d8" class="outline-4">
<h4 id="org7e8b2d8"><span class="section-number-4">6.1.2.</span> Union Type Arrays</h4>
<div class="outline-text-4" id="text-6-1-2">
<ul class="org-ul">
<li>array里面可以使用union type来明确array里面的成员可以是union中的一种.这种情况下,()的使用概率也很高:
<ul class="org-ul">
<li><p>
第一个例子变量的类型是: either a number or an array of strings
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">stringOrArrayOfNumbers</span>: <span style="color: #531ab6;">string</span> | <span style="color: #531ab6;">number</span><span style="color: #000000;">[]</span>;
</pre>
</div></li>
<li><p>
第二个例子变量的类型是: an array of elements that ar each either a number or a string
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">arrayOfStringOrNumbers</span>: <span style="color: #000000;">(</span><span style="color: #531ab6;">string</span> | <span style="color: #531ab6;">number</span><span style="color: #000000;">)[]</span>;
</pre>
</div></li>
</ul></li>
<li>如果一个typescript没有明确的declare它的类型,那么Typescript会自己infer这个数组的类型(通过数组中的数据)
<ul class="org-ul">
<li><p>
比如下面的例子中,我们可以通过错误提示来发现namesMaybe的类型
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">namesMaybe</span> = <span style="color: #000000;">[</span><span style="color: #3548cf;">"Aqualtune"</span>, <span style="color: #3548cf;">"Blenda"</span>, <span style="color: #0000b0;">undefined</span><span style="color: #000000;">]</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:3:5 - error TS2322: Type '(string | undefined)[]' is not assignable to type 'number'.</span>

<span style="color: #7f0000;">///////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">let tmp: number = namesMaybe; //</span>
<span style="color: #7f0000;">///////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orge0fb922" class="outline-4">
<h4 id="orge0fb922"><span class="section-number-4">6.1.3.</span> Evolving Any Arrays</h4>
<div class="outline-text-4" id="text-6-1-3">
<ul class="org-ul">
<li>如果声明数组的时候,没有写具体的类型,那么就相当于是any[]</li>
<li>any[]不是Typescript所希望的类型,因为这样配置失去了typescript的优势:类型. 所以typescript会随着any[]
数组里面增加不同类型的成员,而动态的改变自己的类型
<ul class="org-ul">
<li><p>
比如下面例子中,数组的类型从any[]到string[],再到(number | string)[]
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">values</span> = <span style="color: #000000;">[]</span>;                <span style="color: #7f0000;">// </span><span style="color: #7f0000;">Type: any[]</span>
values.<span style="color: #721045;">push</span><span style="color: #000000;">(</span><span style="color: #3548cf;">""</span><span style="color: #000000;">)</span>;                <span style="color: #7f0000;">// </span><span style="color: #005e8b;">Type</span><span style="color: #7f0000;">: string[]</span>
values<span style="color: #000000;">[</span>0<span style="color: #000000;">]</span> = 0;                  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">Type: (number | string)[]</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org859b6f2" class="outline-4">
<h4 id="org859b6f2"><span class="section-number-4">6.1.4.</span> Multidimensional Arrays</h4>
<div class="outline-text-4" id="text-6-1-4">
<ul class="org-ul">
<li>作为2D数组,我们会有两个[]
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">arrayOfArraysOfNumbers</span>: <span style="color: #531ab6;">number</span><span style="color: #000000;">[][]</span>;

arrayOfArraysOfNumbers = <span style="color: #000000;">[</span>
  <span style="color: #dd22dd;">[</span>1, 2, 3<span style="color: #dd22dd;">]</span>,
  <span style="color: #dd22dd;">[</span>2, 4, 6<span style="color: #dd22dd;">]</span>,
  <span style="color: #dd22dd;">[</span>3, 6, 9<span style="color: #dd22dd;">]</span>,
<span style="color: #000000;">]</span>;

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>arrayOfArraysOfNumbers<span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">[ [ 1, 2, 3 ], [ 2, 4, 6 ], [ 3, 6, 9 ] ]</span>
</pre>
</div></li>
</ul></li>
<li>对于3D数组,那么就会有3个[], 4D数组,会有4个[],5D数组,会有5个[].依此类推</li>
<li>多维数组其实只是语法糖.如下两种情况其实是等价的:
<ul class="org-ul">
<li>number[][]</li>
<li>(number[])[]</li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org70ecabb" class="outline-3">
<h3 id="org70ecabb"><span class="section-number-3">6.2.</span> Array Members</h3>
<div class="outline-text-3" id="text-6-2">
<ul class="org-ul">
<li>typescript可以理解数组[index]得到的数据的类型:
<ul class="org-ul">
<li><p>
如果数组是string[],那么数组[index]类型是string,这个容易理解
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">defenders</span> = <span style="color: #000000;">[</span><span style="color: #3548cf;">"Clarenza"</span>, <span style="color: #3548cf;">"Dina"</span><span style="color: #000000;">]</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Type: string</span>
<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">defender</span> = defenders<span style="color: #000000;">[</span>0<span style="color: #000000;">]</span>;
</pre>
</div></li>
<li><p>
如果数组是(string | Date)[],那么数组[index]类型是 string | Date.这个有点反直觉,本以为Typescript能
够判断出具体类型的
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">soldersOrDates</span> = <span style="color: #000000;">[</span><span style="color: #3548cf;">"Deborah Sampson"</span>, <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Date</span><span style="color: #dd22dd;">(</span>1782, 6, 3<span style="color: #dd22dd;">)</span><span style="color: #000000;">]</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Type: Date | string</span>
<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">soldersOrDate</span> = soldersOrDates<span style="color: #000000;">[</span>0<span style="color: #000000;">]</span>;
</pre>
</div></li>
</ul></li>
</ul>
</div>
<div id="outline-container-org20e8f4e" class="outline-4">
<h4 id="org20e8f4e"><span class="section-number-4">6.2.1.</span> Caveat: Unsound Members</h4>
<div class="outline-text-4" id="text-6-2-1">
<ul class="org-ul">
<li>有个术语叫做unsound,意思就是说类型判断大多数情况下是准确的,但不是每次都是准确的. Typescript的type
system就是unsound的
<ul class="org-ul">
<li><p>
示例如下, typescript在compile time没有发现9001是一个错误的index
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #7f0000;">// </span><span style="color: #7f0000;">TypeError: Cannot read properties of undefined (reading 'length')</span>

<span style="color: #7f0000;">/////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">function withElements(</span><span style="color: #005e8b;">elements</span><span style="color: #7f0000;">: string[]) { //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">console.</span><span style="color: #721045;">log</span><span style="color: #7f0000;">(elements[9001].length);       //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">}                                           //</span>
<span style="color: #7f0000;">//                                             </span><span style="color: #7f0000;">//</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">withElements(["A", "AB", "ABC"])            //</span>
<span style="color: #7f0000;">/////////////////////////////////////////////////</span>
</pre>
</div></li>
<li>虽然也有报错,但是我们看到这个错误是一个runtime错误</li>
<li>如果我们设置&#x2013;noUncheckedIndexedAccess flag那么能够捕捉到这个错误,但是这个flag太严格了,几乎没有项
目使用这个flag</li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgca91e84" class="outline-3">
<h3 id="orgca91e84"><span class="section-number-3">6.3.</span> Spreads and Rests</h3>
<div class="outline-text-3" id="text-6-3">
<ul class="org-ul">
<li>前面我们用过"&#x2026;"这个操作符,其在typescript里面和javascript的左右是一样的.:
<ul class="org-ul">
<li><p>
array spreading
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">fruits</span> = <span style="color: #000000;">[</span><span style="color: #3548cf;">"apple"</span>, <span style="color: #3548cf;">"banana"</span>, <span style="color: #3548cf;">"orange"</span><span style="color: #000000;">]</span>;
<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">moreFruits</span> = <span style="color: #000000;">[</span><span style="color: #3548cf;">"grape"</span>, ...fruits, <span style="color: #3548cf;">"pineapple"</span><span style="color: #000000;">]</span>;

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>moreFruits<span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">[ 'grape', 'apple', 'banana', 'orange', 'pineapple' ]</span>
</pre>
</div></li>
<li><p>
rest parameter
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">sum</span><span style="color: #000000;">(</span>...<span style="color: #005e8b;">numbers</span>: <span style="color: #531ab6;">number</span><span style="color: #dd22dd;">[]</span><span style="color: #000000;">)</span>: <span style="color: #531ab6;">number</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> numbers.<span style="color: #721045;">reduce</span><span style="color: #dd22dd;">(</span><span style="color: #008899;">(</span>total, num<span style="color: #008899;">)</span> <span style="color: #531ab6;">=&gt;</span> total + num, 0<span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">totalSum</span> = <span style="color: #721045;">sum</span><span style="color: #000000;">(</span>1, 2, 3, 4, 5<span style="color: #000000;">)</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>totalSum<span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">15</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
<div id="outline-container-org9dd825e" class="outline-4">
<h4 id="org9dd825e"><span class="section-number-4">6.3.1.</span> Spreads</h4>
<div class="outline-text-4" id="text-6-3-1">
<ul class="org-ul">
<li>Typescript足够聪明,可以知道两个不同类型的数组spread在一块得到的新数组,其类型是两个类型的union
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">soldiers</span> = <span style="color: #000000;">[</span><span style="color: #3548cf;">"Harriet Tubman"</span>, <span style="color: #3548cf;">"Joan of Arc"</span>, <span style="color: #3548cf;">"Khutulun"</span><span style="color: #000000;">]</span>; <span style="color: #7f0000;">// </span><span style="color: #7f0000;">Type: string[]</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">soldierAges</span> = <span style="color: #000000;">[</span>90, 19, 45<span style="color: #000000;">]</span>; <span style="color: #7f0000;">// </span><span style="color: #7f0000;">Type: number[]</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">conjoined</span> = <span style="color: #000000;">[</span>...soldiers, ...soldier<span style="color: #000000;">]</span>; <span style="color: #7f0000;">// </span><span style="color: #7f0000;">Type: (string | number)[]</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org9a177ce" class="outline-4">
<h4 id="org9a177ce"><span class="section-number-4">6.3.2.</span> Spreading Rest Parameters</h4>
<div class="outline-text-4" id="text-6-3-2">
<ul class="org-ul">
<li>如果"&#x2026;"作为rest parameters,那么我们的typescript就会进行严格检查了,不符合规定的实参传递不进去
<ul class="org-ul">
<li><p>
示例如下, string[]可以传入, number[]不能传入
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">logWarriers</span><span style="color: #000000;">(</span><span style="color: #005e8b;">greeting</span>: <span style="color: #531ab6;">string</span>, ...names: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">[]</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">for</span> <span style="color: #dd22dd;">(</span><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">name</span> <span style="color: #531ab6;">of</span> names<span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #3548cf;">`</span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">greeting</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">, </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">name</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">!`</span><span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">warriors</span> = <span style="color: #000000;">[</span><span style="color: #3548cf;">"Cathay Williams"</span>, <span style="color: #3548cf;">"Lozen"</span>, <span style="color: #3548cf;">"Nzinga"</span><span style="color: #000000;">]</span>;
<span style="color: #721045;">logWarriers</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Hello"</span>, ...warriors<span style="color: #000000;">)</span>;

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">brithYears</span> = <span style="color: #000000;">[</span>1844, 1840, 1583<span style="color: #000000;">]</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Hello, Cathay Williams!</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Hello, Lozen!</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Hello, Nzinga!</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:11:22 - error TS2345: Argument of type 'number' is not assignable to parameter of type 'string'.</span>

<span style="color: #7f0000;">//////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">logWarriers("Hello", ...brithYears); //</span>
<span style="color: #7f0000;">//////////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgdf92192" class="outline-3">
<h3 id="orgdf92192"><span class="section-number-3">6.4.</span> Tuples</h3>
<div class="outline-text-3" id="text-6-4">
<ul class="org-ul">
<li>所谓tuple,就是fixed size array. 在python中也有tuple这个概念,typescript是对这个概念的增强:因为typescript
自己有类型系统.所以typescript的tuple包含了如下两层含义:
<ul class="org-ul">
<li>fixed size</li>
<li>type for each index</li>
</ul></li>
<li>tuple需要为每个index都声明类型,这些类型组成的数组又标明了其fixed的长度
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">yearAndWarrier</span>: <span style="color: #000000;">[</span><span style="color: #531ab6;">number</span>, <span style="color: #531ab6;">string</span><span style="color: #000000;">]</span>;
yearAndWarrier = <span style="color: #000000;">[</span>530, <span style="color: #3548cf;">"Tomyris"</span><span style="color: #000000;">]</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:3:19 - error TS2322: Type 'boolean' is not assignable to type 'number'.</span>

<span style="color: #7f0000;">//////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">yearAndWarrier = [false, "Tomyris"]; //</span>
<span style="color: #7f0000;">//////////////////////////////////////////</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:11:1 - error TS2322: Type '[number]' is not assignable to type '[number, string]'.</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">Source has 1 element(s) but target requires 2.</span>

<span style="color: #7f0000;">/////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">yearAndWarrier = [530]; //</span>
<span style="color: #7f0000;">/////////////////////////////</span>
</pre>
</div></li>
</ul></li>
<li>tuple最常用的场景是array destructuring, 其作用是一次性assign多个value
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #000000;">[</span><span style="color: #005e8b;">year</span>, <span style="color: #005e8b;">warrier</span><span style="color: #000000;">]</span> =
  Math.<span style="color: #721045;">random</span><span style="color: #000000;">()</span> &gt; 0.5 ? <span style="color: #000000;">[</span>340, <span style="color: #3548cf;">"Archidamia"</span><span style="color: #000000;">]</span> : <span style="color: #000000;">[</span>1828, <span style="color: #3548cf;">"Rani of Jhansi"</span><span style="color: #000000;">]</span>;

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span><span style="color: #3548cf;">`|year| =&gt; </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">year</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #000000;">)</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span><span style="color: #3548cf;">`|warrier| =&gt; </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">warrier</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT1====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|year| =&gt; 1828</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|warrier| =&gt; Rani of Jhansi</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT2====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|year| =&gt; 340</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|warrier| =&gt; Archidamia</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
<div id="outline-container-orgc04397f" class="outline-4">
<h4 id="orgc04397f"><span class="section-number-4">6.4.1.</span> Tuple Assignability</h4>
<div class="outline-text-4" id="text-6-4-1">
<ul class="org-ul">
<li>由于tuple的类型信息里面包括了每个index的类型,所以tuple是比array更加specific的类型,那么我们很显然是
没办法把array赋值给tuple的
<ul class="org-ul">
<li><p>
下面就是这样一个例子,我们的pairLosse这个数组不是我们想象的[boolean, number],其类型其实是(boolean | number)[],
那么显然其无法赋值给类型我[boolean, number]的tuple
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">pairLosse</span> = <span style="color: #000000;">[</span><span style="color: #0000b0;">false</span>, 123<span style="color: #000000;">]</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:3:7 - error TS2322: Type '(number | boolean)[]' is not assignable to type '[boolean, number]'.</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">Target requires 2 element(s) but source may have fewer.</span>

<span style="color: #7f0000;">//////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">const pairTupleLoose: [boolean, number] = pairLosse; //</span>
<span style="color: #7f0000;">//////////////////////////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
<li>不同长度的tuple,显然是无法赋值的.这个很显然
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">tupleThree</span>: <span style="color: #000000;">[</span><span style="color: #531ab6;">boolean</span>, <span style="color: #531ab6;">number</span>, <span style="color: #531ab6;">string</span><span style="color: #000000;">]</span> = <span style="color: #000000;">[</span><span style="color: #0000b0;">false</span>, 1583, <span style="color: #3548cf;">"Nzinga"</span><span style="color: #000000;">]</span>;
<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">tupleTwoExact1</span>: <span style="color: #000000;">[</span><span style="color: #531ab6;">boolean</span>, <span style="color: #531ab6;">number</span><span style="color: #000000;">]</span> = <span style="color: #000000;">[</span>tupleThree<span style="color: #dd22dd;">[</span>0<span style="color: #dd22dd;">]</span>, tupleThree<span style="color: #dd22dd;">[</span>1<span style="color: #dd22dd;">]</span><span style="color: #000000;">]</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:3:7 - error TS2322: Type '[boolean, number, string]' is not assignable to type '[boolean, number]'.</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">Source has 3 element(s) but target allows only 2.</span>

<span style="color: #7f0000;">///////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">const tupleTwoExact2: [boolean, number] = tupleThree; //</span>
<span style="color: #7f0000;">///////////////////////////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
<li>由于tuple包含了fixed数组和每个index的类型信息,其非常适合作为rest parameter传递给函数
<ul class="org-ul">
<li><p>
示例如下,tuple可以赋值给函数,其类型在每个index上面是确定的
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">logPair</span><span style="color: #000000;">(</span><span style="color: #005e8b;">name</span>: <span style="color: #531ab6;">string</span>, <span style="color: #005e8b;">value</span>: <span style="color: #531ab6;">number</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">`</span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">name</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;"> has </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">value</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">pairTupleCorrect</span>: <span style="color: #000000;">[</span><span style="color: #531ab6;">string</span>, <span style="color: #531ab6;">number</span><span style="color: #000000;">]</span> = <span style="color: #000000;">[</span><span style="color: #3548cf;">"Amage"</span>, 1<span style="color: #000000;">]</span>;
<span style="color: #721045;">logPair</span><span style="color: #000000;">(</span>...pairTupleCorrect<span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Amage has 1</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">pairTupleIncorrect</span>: <span style="color: #000000;">[</span><span style="color: #531ab6;">number</span>, <span style="color: #531ab6;">string</span><span style="color: #000000;">]</span> = <span style="color: #000000;">[</span>1, <span style="color: #3548cf;">"Amage"</span><span style="color: #000000;">]</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:6:9 - error TS2345: Argument of type 'number' is not assignable to parameter of type 'string'.</span>

<span style="color: #7f0000;">/////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">logPair(...pairTupleIncorrect); //</span>
<span style="color: #7f0000;">/////////////////////////////////////</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">pairArray</span> = <span style="color: #000000;">[</span><span style="color: #3548cf;">"Amage"</span>, 1<span style="color: #000000;">]</span>;
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:6:9 - error TS2556: A spread argument must either have a tuple type or be passed to a rest parameter.</span>

<span style="color: #7f0000;">////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">logPair(...pairArray); //</span>
<span style="color: #7f0000;">////////////////////////////</span>
</pre>
</div></li>
<li>作为反例,index类型不正确的tuple是赋值不成功的</li>
<li>作为另一个反例,数组也不能赋值给函数,其类型是union()</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgcc8fde7" class="outline-4">
<h4 id="orgcc8fde7"><span class="section-number-4">6.4.2.</span> Tuple Inferences</h4>
<div class="outline-text-4" id="text-6-4-2">
<ul class="org-ul">
<li>Typescript总体上,如果不特殊配置,都是把"[]"的代码都解释为variable length array的,而不是tuple
<ul class="org-ul">
<li><p>
示例如下,下面的函数把其返回值给infer成(string | number)[]
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">firstCharAndSize</span><span style="color: #000000;">(</span><span style="color: #005e8b;">input</span>: <span style="color: #531ab6;">string</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> <span style="color: #dd22dd;">[</span>input<span style="color: #008899;">[</span>0<span style="color: #008899;">]</span>, input.length<span style="color: #dd22dd;">]</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #000000;">[</span><span style="color: #005e8b;">firstChar</span>, <span style="color: #005e8b;">size</span><span style="color: #000000;">]</span> = <span style="color: #721045;">firstCharAndSize</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Gudit"</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:7:7 - error TS2322: Type 'string | number' is not assignable to type 'strng</span>

<span style="color: #7f0000;">////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">const tmp: string = firstChar; //</span>
<span style="color: #7f0000;">////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
<li>Typescript如果经过如下两种"特殊配置",那么就可以把"[]"解析成tuple:
<ul class="org-ul">
<li>explicit tuple type</li>
<li>const assertion</li>
</ul></li>
</ul>
</div>
<ol class="org-ol">
<li><a id="org9607ecb"></a>Explicit tuple types<br />
<div class="outline-text-5" id="text-6-4-2-1">
<ul class="org-ul">
<li>如果一个函数的返回值明确的描述了自己要返回一个tuple type,并且代码里面使用了array literal(也就是"[]")
那么这种情况下,这个array literal会被infer成一个tuple,而不是数组
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">firstCharAndSizeExplicit</span><span style="color: #000000;">(</span><span style="color: #005e8b;">input</span>: <span style="color: #531ab6;">string</span><span style="color: #000000;">)</span>: <span style="color: #000000;">[</span><span style="color: #531ab6;">string</span>, <span style="color: #531ab6;">number</span><span style="color: #000000;">]</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> <span style="color: #dd22dd;">[</span>input<span style="color: #008899;">[</span>0<span style="color: #008899;">]</span>, input.length<span style="color: #dd22dd;">]</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #000000;">[</span><span style="color: #005e8b;">firstChar</span>, <span style="color: #005e8b;">size</span><span style="color: #000000;">]</span> = <span style="color: #721045;">firstCharAndSizeExplicit</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Cathay Williams"</span><span style="color: #000000;">)</span>;

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">typeStr</span>: <span style="color: #531ab6;">string</span> = firstChar;
<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">typeNum</span>: <span style="color: #531ab6;">number</span> = size;
</pre>
</div></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="orgacfb950"></a>Const asserted tuples<br />
<div class="outline-text-5" id="text-6-4-2-2">
<ul class="org-ul">
<li>如果每次都把类型明确的写出来,不仅非常的累,而且在更新代码的时候,还要同时更新这些类型,所以Typescript
也为我们提供了一种能够把array litral("[]")给直接解释成tuple的语法糖, as const
<ul class="org-ul">
<li><p>
示例如下,下面例子中的readonlyTuple就别infer成了tuple
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">unionArray</span> = <span style="color: #000000;">[</span>1157, <span style="color: #3548cf;">"Tomo"</span><span style="color: #000000;">]</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:3:7 - error TS2322: Type '(string | number)[]' is not assignable to type 'string'.</span>

<span style="color: #7f0000;">/////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">const typeStr: string = unionArray; //</span>
<span style="color: #7f0000;">/////////////////////////////////////////</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">readonlyTuple</span> = <span style="color: #000000;">[</span>1157, <span style="color: #3548cf;">"Tomoe"</span><span style="color: #000000;">]</span> <span style="color: #531ab6;">as</span> <span style="color: #531ab6;">const</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:12:7 - error TS2322: Type 'readonly [1157, "Tomoe"]' is not assignable to type 'string'.</span>

<span style="color: #7f0000;">////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">const typeStr: string = readonlyTuple; //</span>
<span style="color: #7f0000;">////////////////////////////////////////////</span>
</pre>
</div></li>
<li>从上面的例子中我们也可以看到使用as const返回的不仅仅是tuple,而是加了一个readonly的tuple,也就是readonly [1157, "Tomoe"]</li>
</ul></li>
<li>上面as const的副作用就是我们得到的tuple不仅仅是tuple,其是readonly的.这个readonly还不仅仅是对象不能重复被assign,而是每个成员都不能改动.
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">pairMutable</span>: <span style="color: #000000;">[</span><span style="color: #531ab6;">number</span>, <span style="color: #531ab6;">string</span><span style="color: #000000;">]</span> = <span style="color: #000000;">[</span>1157, <span style="color: #3548cf;">"Tomoe"</span><span style="color: #000000;">]</span>;
pairMutable<span style="color: #000000;">[</span>0<span style="color: #000000;">]</span> = 1247; <span style="color: #7f0000;">// </span><span style="color: #7f0000;">Ok</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">The type 'readonly [1157, "Tomoe"]' is 'readonly' and cannot be assigned to the mutable type '[number, string]'. (typescript-tide)</span>

<span style="color: #7f0000;">/////////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">const pairAlsoMutable: [number, string] = [1157, "Tomoe"] as const; //</span>
<span style="color: #7f0000;">/////////////////////////////////////////////////////////////////////////</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">pairConst</span> = <span style="color: #000000;">[</span>1157, <span style="color: #3548cf;">"Tomoe"</span><span style="color: #000000;">]</span> <span style="color: #531ab6;">as</span> <span style="color: #531ab6;">const</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:11:11 - error TS2540: Cannot assign to '0' because it is a read-only property.</span>

<span style="color: #7f0000;">//////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">pairConst[0] = 1247; //</span>
<span style="color: #7f0000;">//////////////////////////</span>
</pre>
</div></li>
</ul></li>
<li>在实践当中,read-only tuple最合适的使用场景是function return, 因为函数的返回值往往非常快的就被destructure
掉.用户只关心从function return里面取值,不关心其是否const
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">firstCharAndSizeAsConst</span><span style="color: #000000;">(</span><span style="color: #005e8b;">input</span>: <span style="color: #531ab6;">string</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> <span style="color: #dd22dd;">[</span>input<span style="color: #008899;">[</span>0<span style="color: #008899;">]</span>, input.length<span style="color: #dd22dd;">]</span> <span style="color: #531ab6;">as</span> <span style="color: #531ab6;">const</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #000000;">[</span><span style="color: #005e8b;">firstChar</span>, <span style="color: #005e8b;">size</span><span style="color: #000000;">]</span> = <span style="color: #721045;">firstCharAndSizeAsConst</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Ching Shih"</span><span style="color: #000000;">)</span>;

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span><span style="color: #3548cf;">`|firstChar| =&gt; </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">firstChar</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #000000;">)</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span><span style="color: #3548cf;">`|size| =&gt; </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">size</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|firstChar| =&gt; C</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|size| =&gt; 10</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-org2e38161" class="outline-2">
<h2 id="org2e38161"><span class="section-number-2">7.</span> Chapter 7: Interfaces</h2>
<div class="outline-text-2" id="text-7">
<ul class="org-ul">
<li>我们前面主要介绍了type,其主要功能是describe object shape</li>
<li>而本章介绍的interface,其主要功能也是describe shape,interface的功能和type基本一致,但是多数情况下,
interface更应该被Typescript开发者所选择,因为其:
<ul class="org-ul">
<li>错误信息更加友好</li>
<li>编译器能更加快速编译</li>
<li>和class更好的进行配合</li>
</ul></li>
</ul>
</div>
<div id="outline-container-org880f7bc" class="outline-3">
<h3 id="org880f7bc"><span class="section-number-3">7.1.</span> Type Aliases Versus Intrfaces</h3>
<div class="outline-text-3" id="text-7-1">
<ul class="org-ul">
<li>我们用下面的代码来对比下type和Interface
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">type</span> <span style="color: #005f5f;">Poet1</span> = <span style="color: #000000;">{</span>
  born: <span style="color: #531ab6;">number</span>;
  name: <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>;

<span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">Poet2</span> <span style="color: #000000;">{</span>
  born: <span style="color: #531ab6;">number</span>;
  name: <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>
</pre>
</div></li>
<li>我们可以看到,两者的syntax基本一致</li>
<li>但是type的最后有分号,而interface最后没有.这个可以从javascript的规范来推导:
<ol class="org-ol">
<li>javascript里面创建一个变量是加分号的</li>
<li>javascript里面创建一个class或者function是不加分号的</li>
</ol></li>
</ul></li>
<li>Type和interface有如下根本上的不同:
<ul class="org-ul">
<li>interface是可以把多个interface合成一个的</li>
<li>interface是可以type check class 声明的,但是type不行</li>
<li>interface的编译更快</li>
<li>interface被编译器认为是"named object", 而type被编译器认为是"alias for an unnamed object literal",
所以显然interface的错误信息更易读</li>
</ul></li>
<li><p>
上面虽然都是区别,但是很显然凸显出interface的优势.最佳实践中,我们会默认使用interface,直到你遇到必须
使用type的情况,比如union type(required)或者是function type(cleaner syntax)
</p>
<pre class="example" id="org8e2be21">
Use interfaces whenever possible, until you need features such as union types(required)
or function type (cleaner syntax)
</pre></li>
</ul>
</div>
</div>
<div id="outline-container-org6e3a45c" class="outline-3">
<h3 id="org6e3a45c"><span class="section-number-3">7.2.</span> Type of Proprties</h3>
<div class="outline-text-3" id="text-7-2">
<ul class="org-ul">
<li>真实世界的javascript object非常灵活(比如可选的property, setter和getter等), 为了能够适配这些灵活的情况,
typescript创建了一系列的type system tool</li>
<li>下面会介绍这些system tool,多说一句,这些tool竟然都能在type上面使用.可见type和interface有多相似.</li>
</ul>
</div>
<div id="outline-container-orgebb724e" class="outline-4">
<h4 id="orgebb724e"><span class="section-number-4">7.2.1.</span> Optional Properties</h4>
<div class="outline-text-4" id="text-7-2-1">
<ul class="org-ul">
<li>我们前面介绍object type的时候介绍过,某个object满足某个type可以有"可选的property",interface也同样拥有这个特性
<ul class="org-ul">
<li><p>
示例如下,任何object只需要pages存在,既可以被认为是Book interface
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">Book</span> <span style="color: #000000;">{</span>
  author?: <span style="color: #531ab6;">string</span>;
  pages: <span style="color: #531ab6;">number</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">ok</span>: <span style="color: #005f5f;">Book</span> = <span style="color: #000000;">{</span>
  author: <span style="color: #3548cf;">"Rita Dove"</span>,
  pages: 80,
<span style="color: #000000;">}</span>;

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">missing</span>: <span style="color: #005f5f;">Book</span> = <span style="color: #000000;">{</span>
  pages: 80,
<span style="color: #000000;">}</span>;
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org86a9d21" class="outline-4">
<h4 id="org86a9d21"><span class="section-number-4">7.2.2.</span> Read-Only Properties</h4>
<div class="outline-text-4" id="text-7-2-2">
<ul class="org-ul">
<li>typescript的interface可以设置某些property为readonly,一旦设置,那么实现这个interface的object的相应
property不能在初始化之后再被赋值
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">Page</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">readonly</span> text: <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">function</span> <span style="color: #721045;">read</span><span style="color: #000000;">(</span><span style="color: #005e8b;">page</span>: <span style="color: #005f5f;">Page</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #dd22dd;">(</span>page.text<span style="color: #dd22dd;">)</span>;

  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:8:8 - error TS2540: Cannot assign to 'text' because it is a read-only property.</span>

  <span style="color: #7f0000;">///////////////////////</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">page.text += "!"; //</span>
  <span style="color: #7f0000;">///////////////////////</span>
<span style="color: #000000;">}</span>
</pre>
</div></li>
<li>需要注意的是,readonly这个标签,只有像上面例子一样,某个object"显式地"和某个interface发生映射关系的
时候才起作用. 下面例子中的page2 虽然也"隐式"的符合interface Page,但是在没有被read函数"显式"的指派
给Page interface之前,是可以随便改动text的</li>
</ul></li>
<li>需要理解的是,readonly这个特性是类型系统的typescript才有的,目的也是在编译阶段进行检查,最终编译成javascript
之后,就不存在这个特性了</li>
</ul>
</div>
</div>
<div id="outline-container-org0c0ba01" class="outline-4">
<h4 id="org0c0ba01"><span class="section-number-4">7.2.3.</span> Functions and Methods</h4>
<div class="outline-text-4" id="text-7-2-3">
<ul class="org-ul">
<li>在javascript里面function作为object的member是很正常的事情, 所以作为object的抽象interface,其也会允许
声明interface member的类型为function type</li>
<li>typescript提供了两种声明interface function memeber 的方式,其实是映射了两种javascript定义function的
方式(arrow和非arrow):
<ul class="org-ul">
<li>method syntax:对应常规函数,this会在调用时候动态绑定,适合class的instance使用</li>
<li>property syntax:对应箭头函数,this在创建时候就绑定,除了class的instance以外的情况都使用这个</li>
</ul></li>
<li>我们来看一个interface的例子,其中混合使用了两种function member的声明方式:
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">HasBothFunctionTypes</span> <span style="color: #000000;">{</span>
  property: <span style="color: #dd22dd;">()</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #531ab6;">string</span>;
  <span style="color: #721045;">method</span><span style="color: #dd22dd;">()</span>: <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">hasBoth</span>: <span style="color: #005f5f;">HasBothFunctionTypes</span> = <span style="color: #000000;">{</span>
  property: <span style="color: #dd22dd;">()</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #3548cf;">"property return"</span>,
  <span style="color: #721045;">method</span><span style="color: #dd22dd;">()</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">return</span> <span style="color: #3548cf;">"method return"</span>;
  <span style="color: #dd22dd;">}</span>,
<span style="color: #000000;">}</span>;

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>hasBoth.<span style="color: #721045;">property</span><span style="color: #dd22dd;">()</span><span style="color: #000000;">)</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>hasBoth.<span style="color: #721045;">method</span><span style="color: #dd22dd;">()</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">property return</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">method return</span>
</pre>
</div></li>
<li><p>
上面的每种形式也支持使用?来配置成optional参数
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">OptionalFunctions</span> <span style="color: #000000;">{</span>
  property?: <span style="color: #dd22dd;">()</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #531ab6;">string</span>;
  method?<span style="color: #dd22dd;">()</span>: <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>
</pre>
</div></li>
<li><p>
readonly只能在method 声明上面使用
</p>
<div class="org-src-container">
<pre class="src src-typescript">jinterface ReadonlyFunctions <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">readonly</span> property: <span style="color: #dd22dd;">()</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #531ab6;">string</span>;
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:3:3 - error TS1024: 'readonly' modifier can only appear on a property declaration or index signature.</span>

  <span style="color: #7f0000;">////////////////////////////////</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">readonly method(): string; //</span>
  <span style="color: #7f0000;">////////////////////////////////</span>
<span style="color: #000000;">}</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org7b83c22" class="outline-4">
<h4 id="org7b83c22"><span class="section-number-4">7.2.4.</span> Call Signatures</h4>
<div class="outline-text-4" id="text-7-2-4">
<ul class="org-ul">
<li>call signature是一个非常重要的特性,其用来描述一个value是如何能被像function一样调用的</li>
<li>上面这句定义非常难懂,其实也没有什么意义.我们通过例子来了解call signature在interface的三个主要使用
场景:
<ul class="org-ul">
<li><p>
interface通常描述一个类型,但是有时候interface描述的本身就是一个function(function也是一个类型)
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">StringToNumberConverter</span> <span style="color: #000000;">{</span>
  <span style="color: #dd22dd;">(</span>input: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">)</span>: <span style="color: #531ab6;">number</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">stringLength</span>: <span style="color: #005f5f;">StringToNumberConverter</span> = <span style="color: #000000;">(</span><span style="color: #005e8b;">input</span><span style="color: #000000;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> input.length;
<span style="color: #000000;">}</span>

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span><span style="color: #721045;">stringLength</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">"Hello"</span><span style="color: #dd22dd;">)</span><span style="color: #000000;">)</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">5</span>
</pre>
</div></li>
<li><p>
interface通常描述一个类型,很多的时候,这个类型是一个对象,那么这个对象里面就得有对应的函数才行.这个
时候call signature要有函数名
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">PriceCalculator</span> <span style="color: #000000;">{</span>
  calculatePrice: <span style="color: #dd22dd;">(</span>quantity: <span style="color: #531ab6;">number</span>, pricePerUnit: <span style="color: #531ab6;">number</span><span style="color: #dd22dd;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #531ab6;">number</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">calculator</span>: <span style="color: #005f5f;">PriceCalculator</span> = <span style="color: #000000;">{</span>
  calculatePrice: <span style="color: #dd22dd;">(</span><span style="color: #005e8b;">quantity</span>, <span style="color: #005e8b;">pricePreUnit</span><span style="color: #dd22dd;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">return</span> quantity * pricePreUnit;
  <span style="color: #dd22dd;">}</span>,
<span style="color: #000000;">}</span>;

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>calculator.<span style="color: #721045;">calculatePrice</span><span style="color: #dd22dd;">(</span>5, 10<span style="color: #dd22dd;">)</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">50</span>
</pre>
</div></li>
<li><p>
interface描述的本身就是一个function,然后这个function还有一些自己的变量.这属于第一种情况的扩展
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">Logger</span> <span style="color: #000000;">{</span>
  <span style="color: #dd22dd;">(</span>message: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">)</span>: <span style="color: #531ab6;">void</span>;
  logLevel: <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">myLogger</span>: <span style="color: #005f5f;">Logger</span> = <span style="color: #000000;">(</span><span style="color: #005e8b;">message</span>: <span style="color: #531ab6;">string</span><span style="color: #000000;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #000000;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">`[</span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">myLogger.logLevel</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">] </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">message</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>;
myLogger.logLevel = <span style="color: #3548cf;">"INFO"</span>;

<span style="color: #721045;">myLogger</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"This is a log message."</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">[INFO] This is a log message.</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgdc6c168" class="outline-4">
<h4 id="orgdc6c168"><span class="section-number-4">7.2.5.</span> Index Signatures</h4>
<div class="outline-text-4" id="text-7-2-5">
<ul class="org-ul">
<li>有时候,你无法提前知道某个类型所有属性的名字,但是你知道这些属性值的类型(属性通常是字符串或者能转换成
字符串的类型,比如字符串,symbol, 所以这里强调属性值的类型)</li>
<li>在这种情况下,你可以使用index signature(索引签名)去描述可能的key和value的类型
<ul class="org-ul">
<li><p>
示例如下,只有number类型的value可以赋值成功
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">WordCounts</span> <span style="color: #000000;">{</span>
  <span style="color: #dd22dd;">[</span>i: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">]</span>: <span style="color: #531ab6;">number</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">counts</span>: <span style="color: #005f5f;">WordCounts</span> = <span style="color: #000000;">{}</span>;
counts.apple = 0;
counts.banana = 1;

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>counts<span style="color: #dd22dd;">[</span><span style="color: #3548cf;">"apple"</span><span style="color: #dd22dd;">]</span><span style="color: #000000;">)</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>counts<span style="color: #dd22dd;">[</span><span style="color: #3548cf;">"banana"</span><span style="color: #dd22dd;">]</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">0</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">1</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:12:1 - error TS2322: Type 'boolean' is not assignable to type 'number'.</span>

<span style="color: #7f0000;">////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">counts.cherry = false; //</span>
<span style="color: #7f0000;">////////////////////////////</span>
</pre>
</div></li>
</ul></li>
<li><p>
Index signature的存在的意义是:一个对象必须返回一个value,不管对象触发的property是什么.所以index signature
的重点,在于"不管触发的property是什么",而不在于typesafe
</p>
<pre class="example" id="orgd405af6">
Index Signature indicates that an object should give back a value no matter
what proprty is being accessed
</pre></li>
<li>下面例子就是这样一种情况, publishDate的Beloved明明没设置,但是还是返回值了(undefined)
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">DatesByName</span> <span style="color: #000000;">{</span>
  <span style="color: #dd22dd;">[</span>i: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">]</span>: <span style="color: #005f5f;">Date</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">publishDates</span>: <span style="color: #005f5f;">DatesByName</span> = <span style="color: #000000;">{</span>
  Frankenstein: <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Date</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">"1 January 1818"</span><span style="color: #dd22dd;">)</span>,
<span style="color: #000000;">}</span>;

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>publishDates.Frankenstein<span style="color: #000000;">)</span>;

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>publishDates.Beloved<span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">1817-12-31T15:54:17.000Z</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">undefined</span>
</pre>
</div></li>
<li>上面这种情况下更应该的选择是Map</li>
</ul></li>
</ul>
</div>
<ol class="org-ol">
<li><a id="org55b3ee0"></a>Mixing properties and index signatures<br />
<div class="outline-text-5" id="text-7-2-5-1">
<ul class="org-ul">
<li><p>
interface 甚至可以把index signature和一个具体的named property并列的列出来. 但是需要注意的是:
</p>
<pre class="example" id="org0310bfd">
这个named property的key和value,必须能够assign给index signature
</pre></li>
<li>换句话说,就是named property列出大的范围, named property是这个大的范围里面的一个特例.这个特例也要符
合大的范围,并且object是必须要有property满足这个特例的,其他的property满足大范围就可以了
<ul class="org-ul">
<li><p>
完全匹配的例子(完全匹配必然可以assign)如下. 注意这例子中的`i`是一个占位符,其可以随意更改,必须改成`key`,这里写成`i`是因为这里代表index signature
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">HistorialNovels</span> <span style="color: #000000;">{</span>
  Oroonoko: <span style="color: #531ab6;">number</span>;
  <span style="color: #dd22dd;">[</span>i: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">]</span>: <span style="color: #531ab6;">number</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">novels</span>: <span style="color: #005f5f;">HistorialNovels</span> = <span style="color: #000000;">{</span>
  Outlander: 1991,
  Oroonoko: 1688,
<span style="color: #000000;">}</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:11:7 - error TS2741: Property 'Oroonoko' is missing in type '{ Outlander: number; }' but required in type 'HistorialNovels'.</span>

<span style="color: #7f0000;">////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">const missingOroonoko: HistorialNovels = { //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">Outlander: 1991,                         //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">};                                         //</span>
<span style="color: #7f0000;">////////////////////////////////////////////////</span>
</pre>
</div></li>
<li><p>
不完全匹配,但是可以assign的例子如下(0作为primitive是可以assign给number的,类似的还有literal可以assign给string)
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">ChapterStarts</span> <span style="color: #000000;">{</span>
  preface: 0;
  <span style="color: #dd22dd;">[</span>i: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">]</span>: <span style="color: #531ab6;">number</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">correctPreface</span>: <span style="color: #005f5f;">ChapterStarts</span> = <span style="color: #000000;">{</span>
  preface: 0,
  night: 1,
  shopping: 5,
<span style="color: #000000;">}</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:13:3 - error TS2322: Type '1' is not assignable to type '0'.</span>

<span style="color: #7f0000;">///////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">const wrongPreface: ChapterStarts = { //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">preface: 1,                         //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">};                                    //</span>
<span style="color: #7f0000;">///////////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org29f0534"></a>Numeric index signatures<br />
<div class="outline-text-5" id="text-7-2-5-2">
<ul class="org-ul">
<li>虽然绝大部分情况下,我们使用string来作为object的key(因为javascript其实是隐式的将object key转换为string
的),但是也有时候,特别是在typescript里面,我们会以number来作为key.</li>
<li>不过这个number key其地位是类似named property,是一个特例,其还是要在string key限定的范围里面
<ul class="org-ul">
<li><p>
示例如下, [i:number]: string 是一个特例,类似上面的preface:0, 其value类型string必须能赋给catchall的string index
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">MoreNarrowNumbers</span> <span style="color: #000000;">{</span>
  <span style="color: #dd22dd;">[</span>i: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">]</span>: <span style="color: #531ab6;">string</span>;
  <span style="color: #dd22dd;">[</span>i: <span style="color: #531ab6;">number</span><span style="color: #dd22dd;">]</span>: <span style="color: #531ab6;">string</span> | <span style="color: #0000b0;">undefined</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">mixesNumberAndString</span>: <span style="color: #005f5f;">MoreNarrowNumbers</span> = <span style="color: #000000;">{</span>
  0: <span style="color: #3548cf;">""</span>,
  key1: <span style="color: #3548cf;">""</span>,
  key2: <span style="color: #0000b0;">undefined</span>,
<span style="color: #000000;">}</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:3:3 - error TS2413: 'number' index type 'string | undefined' is not assignable to 'string' index type 'string'.</span>

<span style="color: #7f0000;">////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">interface MoreNarrowStrings {      //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">[i: number]: string | undefined; //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">[i: string]: string;             //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">}                                  //</span>
<span style="color: #7f0000;">////////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</li>
</ol>
</div>
<div id="outline-container-orgd8c582a" class="outline-4">
<h4 id="orgd8c582a"><span class="section-number-4">7.2.6.</span> Nested Interfaces</h4>
<div class="outline-text-4" id="text-7-2-6">
<ul class="org-ul">
<li>就像object typeA可以nested成为 object typeB的property, interfaceA也能作为其他interface的property
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">Novel</span> <span style="color: #000000;">{</span>
  author: <span style="color: #dd22dd;">{</span>
    name: <span style="color: #531ab6;">string</span>;
  <span style="color: #dd22dd;">}</span>;
  setting: <span style="color: #005f5f;">Settings</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">Settings</span> <span style="color: #000000;">{</span>
  place: <span style="color: #531ab6;">string</span>;
  year: <span style="color: #531ab6;">number</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">myNovel</span>: <span style="color: #005f5f;">Novel</span>;

myNovel = <span style="color: #000000;">{</span>
  author: <span style="color: #dd22dd;">{</span>
    name: <span style="color: #3548cf;">"Jane Austen"</span>,
  <span style="color: #dd22dd;">}</span>,
  setting: <span style="color: #dd22dd;">{</span>
    place: <span style="color: #3548cf;">"England"</span>,
    year: 1812,
  <span style="color: #dd22dd;">}</span>,
<span style="color: #000000;">}</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:29:3 - error TS2741: Property 'year' is missing in type '{ place: string; }' but required in type 'Settings'.</span>

<span style="color: #7f0000;">//////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">myNovel = {                  //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">author: {                  //</span>
<span style="color: #7f0000;">//     </span><span style="color: #7f0000;">name: "Emilly Bronte",   //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">},                         //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">setting: {                 //</span>
<span style="color: #7f0000;">//     </span><span style="color: #7f0000;">place: "West Yorkshire", //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">},                         //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">};                           //</span>
<span style="color: #7f0000;">//////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org9fd7c67" class="outline-3">
<h3 id="org9fd7c67"><span class="section-number-3">7.3.</span> Interface Extensions</h3>
<div class="outline-text-3" id="text-7-3">
<ul class="org-ul">
<li>和java一样typescript的interface可以进行"继承",方法就是使用extends关键字
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">Writing</span> <span style="color: #000000;">{</span>
  title: <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">Novella</span> <span style="color: #531ab6;">extends</span> <span style="color: #005f5f;">Writing</span> <span style="color: #000000;">{</span>
  pages: <span style="color: #531ab6;">number</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">myNovella</span>: <span style="color: #005f5f;">Novella</span> = <span style="color: #000000;">{</span>
  pages: 195,
  title: <span style="color: #3548cf;">"Ethan Frome"</span>,
<span style="color: #000000;">}</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:14:5 - error TS2741: Property 'pages' is missing in type '{ title: string; }' but required in type 'Novella'.</span>

<span style="color: #7f0000;">///////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">let missingPages: Novella = { //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">title: "The Awakening",     //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">};                            //</span>
<span style="color: #7f0000;">///////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
<div id="outline-container-orge8c47dc" class="outline-4">
<h4 id="orge8c47dc"><span class="section-number-4">7.3.1.</span> Overridden Properties</h4>
<div class="outline-text-4" id="text-7-3-1">
<ul class="org-ul">
<li>derive interface 可以override base interface的property.这里的override和cpp里面的override是不一样的,
这里的override是说新的overridden property,比如能够assign 给base property:</li>
<li>assignable的方法一般有两种:
<ul class="org-ul">
<li><p>
使用subset of a typeo union
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#29238;&#25509;&#21475;</span>
<span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">Base</span> <span style="color: #000000;">{</span>
  status: <span style="color: #3548cf;">"active"</span> | <span style="color: #3548cf;">"inactive"</span> | <span style="color: #3548cf;">"archived"</span>; <span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#32852;&#21512;&#31867;&#22411;</span>
<span style="color: #000000;">}</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#27966;&#29983;&#25509;&#21475;</span>
<span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">Derived</span> <span style="color: #531ab6;">extends</span> <span style="color: #005f5f;">Base</span> <span style="color: #000000;">{</span>
  status: <span style="color: #3548cf;">"active"</span> | <span style="color: #3548cf;">"inactive"</span>; <span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#26356;&#20855;&#20307;&#30340;&#23376;&#38598;&#31867;&#22411;</span>
<span style="color: #000000;">}</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#31034;&#20363;&#20351;&#29992;</span>
<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">item1</span>: <span style="color: #005f5f;">Derived</span> = <span style="color: #000000;">{</span>
  status: <span style="color: #3548cf;">"active"</span>, <span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#21512;&#27861;</span>
<span style="color: #000000;">}</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:17:3 - error TS2322: Type '"archived"' is not assignable to type '"active" | "inactive"'.</span>

<span style="color: #7f0000;">//////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">const item2: Derived = { //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">status: "archived",    //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">};                       //</span>
<span style="color: #7f0000;">//////////////////////////////</span>
</pre>
</div></li>
<li><p>
使用从base interface type extend出来的type
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#29238;&#25509;&#21475;</span>
<span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">Base</span> <span style="color: #000000;">{</span>
  details: <span style="color: #dd22dd;">{</span>
    id: <span style="color: #531ab6;">number</span>;
  <span style="color: #dd22dd;">}</span>; <span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#22522;&#30784;&#31867;&#22411;</span>
<span style="color: #000000;">}</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#27966;&#29983;&#25509;&#21475;</span>
<span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">Derived</span> <span style="color: #531ab6;">extends</span> <span style="color: #005f5f;">Base</span> <span style="color: #000000;">{</span>
  details: <span style="color: #dd22dd;">{</span>
    id: <span style="color: #531ab6;">number</span>;
    name: <span style="color: #531ab6;">string</span>; <span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#26032;&#22686;&#23383;&#27573;</span>
  <span style="color: #dd22dd;">}</span>; <span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#25193;&#23637;&#31867;&#22411;</span>
<span style="color: #000000;">}</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#31034;&#20363;&#20351;&#29992;</span>
<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">item1</span>: <span style="color: #005f5f;">Derived</span> = <span style="color: #000000;">{</span>
  details: <span style="color: #dd22dd;">{</span>
    id: 1,
    name: <span style="color: #3548cf;">"Item 1"</span>, <span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#21512;&#27861;&#65292;&#22240;&#20026;&#27966;&#29983;&#25509;&#21475;&#25193;&#23637;&#20102;&#29238;&#25509;&#21475;&#30340;&#23646;&#24615;</span>
  <span style="color: #dd22dd;">}</span>,
<span style="color: #000000;">}</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:25:3 - error TS2741: Property 'name' is missing in type '{ id: number; }' but required in type '{ id: number; name: string; }'.</span>

<span style="color: #7f0000;">//////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">const item2: Derived = { //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">details: {             //</span>
<span style="color: #7f0000;">//     </span><span style="color: #7f0000;">id: 2,               //</span>
<span style="color: #7f0000;">//     </span><span style="color: #7f0000;">// name &#32570;&#22833;         //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">},                     //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">};                       //</span>
<span style="color: #7f0000;">//////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgde0da25" class="outline-4">
<h4 id="orgde0da25"><span class="section-number-4">7.3.2.</span> Extending Multiple Interfaces</h4>
<div class="outline-text-4" id="text-7-3-2">
<ul class="org-ul">
<li>interface的extends可以extends多个不同的interface,用","隔开
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">GivesNumber</span> <span style="color: #000000;">{</span>
  <span style="color: #721045;">giveNumber</span><span style="color: #dd22dd;">()</span>: <span style="color: #531ab6;">number</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">GivesString</span> <span style="color: #000000;">{</span>
  <span style="color: #721045;">giveString</span><span style="color: #dd22dd;">()</span>: <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">GivesBothAndEither</span> <span style="color: #531ab6;">extends</span> <span style="color: #005f5f;">GivesNumber</span>, GivesString <span style="color: #000000;">{</span>
  <span style="color: #721045;">giveEither</span><span style="color: #dd22dd;">()</span>: <span style="color: #531ab6;">number</span> | <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">function</span> <span style="color: #721045;">useGivesBoth</span><span style="color: #000000;">(</span><span style="color: #005e8b;">instance</span>: <span style="color: #005f5f;">GivesBothAndEither</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  instance.<span style="color: #721045;">giveEither</span><span style="color: #dd22dd;">()</span>;
  instance.<span style="color: #721045;">giveNumber</span><span style="color: #dd22dd;">()</span>;
  instance.<span style="color: #721045;">giveString</span><span style="color: #dd22dd;">()</span>;
<span style="color: #000000;">}</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org031f886" class="outline-3">
<h3 id="org031f886"><span class="section-number-3">7.4.</span> Interface Merging</h3>
<div class="outline-text-3" id="text-7-4">
<ul class="org-ul">
<li>Interface Merging是typescript中非常特殊的特性,在其他语言中很少见.interface merging是说在同一个scope
定义的两个名字相同的interface,那么他们自动合并成一个更大的interface
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">Merged</span> <span style="color: #000000;">{</span>
  fromFirst: <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">Merged</span> <span style="color: #000000;">{</span>
  fromSecond: <span style="color: #531ab6;">number</span>;
<span style="color: #000000;">}</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Equivalent to</span>
<span style="color: #7f0000;">///////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">interface Merged {    //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">fromFirst: string;  //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">fromSecond: number; //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">}                     //</span>
<span style="color: #7f0000;">///////////////////////////</span>
</pre>
</div></li>
</ul></li>
<li>注意:Interface merging是一个让代码不容易被人理解的特性,普通程序不建议使用</li>
</ul>
</div>
<div id="outline-container-org5878b1c" class="outline-4">
<h4 id="org5878b1c"><span class="section-number-4">7.4.1.</span> Member Naming Conflicts</h4>
<div class="outline-text-4" id="text-7-4-1">
<ul class="org-ul">
<li>虽然我们不会太使用interface merging,但是我们这里还是介绍一下interface merging在property和method方
面的一个不同:
<ul class="org-ul">
<li><p>
在不同的merging interfaces里面是不能定义"名字相同,但是类型不同的"property的(arrow function)
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">MergedProperties</span> <span style="color: #000000;">{</span>
  same: <span style="color: #dd22dd;">(</span>input: <span style="color: #531ab6;">boolean</span><span style="color: #dd22dd;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #531ab6;">string</span>;
  different: <span style="color: #dd22dd;">(</span>input: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">MergedProperties</span> <span style="color: #000000;">{</span>
  same: <span style="color: #dd22dd;">(</span>input: <span style="color: #531ab6;">boolean</span><span style="color: #dd22dd;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #531ab6;">string</span>;

  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:8:3 - error TS2717: Subsequent property declarations must have the same type.  Property 'different' must be of type '(input: string) =&gt; string', but here has type '(input: number) =&gt; string'.</span>

  <span style="color: #7f0000;">///////////////////////////////////////////</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">different: (input: number) =&gt; string; //</span>
  <span style="color: #7f0000;">///////////////////////////////////////////</span>
<span style="color: #000000;">}</span>
</pre>
</div></li>
<li><p>
在不同的merging interfaces里面是可以定义"名字相同,但是类型不同的"method的(非arrow function)
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">MergedMethods</span> <span style="color: #000000;">{</span>
  <span style="color: #721045;">different</span><span style="color: #dd22dd;">(</span><span style="color: #005e8b;">input</span>: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">)</span>: <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">MergedMethods</span> <span style="color: #000000;">{</span>
  <span style="color: #721045;">different</span><span style="color: #dd22dd;">(</span><span style="color: #005e8b;">input</span>: <span style="color: #531ab6;">number</span><span style="color: #dd22dd;">)</span>: <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org28ae132" class="outline-2">
<h2 id="org28ae132"><span class="section-number-2">8.</span> Chapter 8: Classes</h2>
<div class="outline-text-2" id="text-8">
</div>
<div id="outline-container-org0f4e88c" class="outline-3">
<h3 id="org0f4e88c"><span class="section-number-3">8.1.</span> Class Methods</h3>
<div class="outline-text-3" id="text-8-1">
<ul class="org-ul">
<li>在typescript看来,如下两个概念是没有区别的,都是需要些参数(没设置就是any类型), 返回值如果不是递归的,
就可以infer到:
<ul class="org-ul">
<li>class里面的method</li>
<li>普通的function</li>
</ul></li>
<li>下面就是一个简单的Greetr class(拥有greet class method)的例子
<ul class="org-ul">
<li><p>
普通class method示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">Greeter</span> <span style="color: #000000;">{</span>
  <span style="color: #721045;">greet</span><span style="color: #dd22dd;">(</span><span style="color: #005e8b;">name</span>: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #3548cf;">`</span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">name</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">, do your stuff !`</span><span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Greeter</span><span style="color: #000000;">()</span>.<span style="color: #721045;">greet</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Miss Frizzle"</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:9:15 - error TS2554: Expected 1 arguments, but got 0.</span>

<span style="color: #7f0000;">////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">new Greeter().</span><span style="color: #721045;">greet</span><span style="color: #7f0000;">(); //</span>
<span style="color: #7f0000;">////////////////////////////</span>
</pre>
</div></li>
<li><p>
constructor也被看做是普通个class method而已
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">Greeter</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">constructor</span><span style="color: #dd22dd;">(</span>message: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #3548cf;">`As I always say: </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">message</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">!`</span><span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Greeter</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"take chances, make mistaks, get messy"</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:9:1 - error TS2554: Expected 1 arguments, but got 0.</span>

<span style="color: #7f0000;">////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">new Greeter(); //</span>
<span style="color: #7f0000;">////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgece86a0" class="outline-3">
<h3 id="orgece86a0"><span class="section-number-3">8.2.</span> Class Properties</h3>
<div class="outline-text-3" id="text-8-2">
<ul class="org-ul">
<li>如果一个typescript的class里面的property需要写入和读取,必须explicitly的在class内部声明,没有声明的property
不会被编译器所识别
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">FieldTrip</span> <span style="color: #000000;">{</span>
  destination: <span style="color: #531ab6;">string</span>;

  <span style="color: #531ab6;">constructor</span><span style="color: #dd22dd;">(</span>destitnation: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">this</span>.destination = destitnation;
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #3548cf;">`We're going to </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">this.destination</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #008899;">)</span>;

    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:8:10 - error TS2339: Property 'nonexistent' does not exist on type 'FieldTrip'.</span>

    <span style="color: #7f0000;">//////////////////////////////////////</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">this.nonexistent = destitnation; //</span>
    <span style="color: #7f0000;">//////////////////////////////////////</span>
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">trip</span> = <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">FieldTrip</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"planetarium"</span><span style="color: #000000;">)</span>;

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>trip.destination<span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:21:18 - error TS2339: Property 'nonexistent' does not exist on type 'FieldTrip'.</span>

<span style="color: #7f0000;">////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">console.</span><span style="color: #721045;">log</span><span style="color: #7f0000;">(trip.nonexistent); //</span>
<span style="color: #7f0000;">////////////////////////////////////</span>
</pre>
</div></li>
<li>一旦在class里面创建了property,那么使用的时候就知道哪些property可以使用了,没有声明过的nonexistent显然无法使用</li>
</ul></li>
</ul>
</div>
<div id="outline-container-orgfe2b5dd" class="outline-4">
<h4 id="orgfe2b5dd"><span class="section-number-4">8.2.1.</span> Function Properties</h4>
<div class="outline-text-4" id="text-8-2-1">
<ul class="org-ul">
<li>我们回顾下javascript的method scoping和syntax fundamentals,以便更好的理解typescript的特性:javascript
在class里面可以声明两种member的callable function:
<ul class="org-ul">
<li>method: 第一种是直接定义一个method,这是最传统的做法</li>
<li>property: 第二种是定义一个property,只是这个property的类型刚好是function</li>
</ul></li>
<li>这两种方法在typescript上面当然也必须有相应的映射:</li>
</ul>
</div>
<ol class="org-ol">
<li><a id="org69b5a92"></a>使用方法(method)<br />
<div class="outline-text-5" id="text-8-2-1-1">
<ul class="org-ul">
<li>这是最常见的的一种方式,方法是直接定义在类上掉函数
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">CallableClass</span> <span style="color: #000000;">{</span>
  <span style="color: #721045;">callableMethod</span><span style="color: #dd22dd;">()</span>: <span style="color: #531ab6;">void</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #3548cf;">"This is a callable method!"</span><span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">instance</span> = <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">CallableClass</span><span style="color: #000000;">()</span>;
instance.<span style="color: #721045;">callableMethod</span><span style="color: #000000;">()</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>
  <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">CallableClass</span><span style="color: #dd22dd;">()</span>.callableMethod === <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">CallableClass</span><span style="color: #dd22dd;">()</span>.callableMethod,
<span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">This is a callable method!</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">true</span>
</pre>
</div></li>
</ul></li>
<li>这种定义有如下特点:
<ul class="org-ul">
<li>定义的方法会存储在类的prototype上,因此对于多个实例来说,它们共享一个函数,不会占用额外的内存</li>
<li><p>
this是动态绑定的
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">Example</span> <span style="color: #000000;">{</span>
  <span style="color: #721045;">regularFunction</span><span style="color: #dd22dd;">()</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #0000b0;">this</span><span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">obj</span> = <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Example</span><span style="color: #000000;">()</span>;
obj.<span style="color: #721045;">regularFunction</span><span style="color: #000000;">()</span>;

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">detachedFunction</span> = obj.regularFunction;
<span style="color: #721045;">detachedFunction</span><span style="color: #000000;">()</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Example {}</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">undefined</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org2709b3a"></a>使用属性赋值为函数(Property as Function)<br />
<div class="outline-text-5" id="text-8-2-1-2">
<ul class="org-ul">
<li>这种方式是通过类的属性值直接赋值为一个函数
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">CallableClass</span> <span style="color: #000000;">{</span>
  callbleProperty = <span style="color: #dd22dd;">()</span>: <span style="color: #531ab6;">void</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #3548cf;">"This is a callable property !"</span><span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">instance</span> = <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">CallableClass</span><span style="color: #000000;">()</span>;
instance.<span style="color: #721045;">callbleProperty</span><span style="color: #000000;">()</span>;

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>
  <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">CallableClass</span><span style="color: #dd22dd;">()</span>.callbleProperty === <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">CallableClass</span><span style="color: #dd22dd;">()</span>.callbleProperty,
<span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">This is a callable property !</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">false</span>
</pre>
</div></li>
</ul></li>
<li>这种定义有如下特点:
<ul class="org-ul">
<li>函数是直接绑定在实例上的,而不是类的prototype上,因此每个实例都会有一份独立的函数</li>
<li><p>
this是自动绑定定义时的上下文的
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">Example</span> <span style="color: #000000;">{</span>
  arrowFunction = <span style="color: #dd22dd;">()</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #0000b0;">this</span><span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">obj</span> = <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Example</span><span style="color: #000000;">()</span>;
obj.<span style="color: #721045;">arrowFunction</span><span style="color: #000000;">()</span>;

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">detachedFunction</span> = obj.arrowFunction;
<span style="color: #721045;">detachedFunction</span><span style="color: #000000;">()</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Example { arrowFunction: [Function (anonymous)] }</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Example { arrowFunction: [Function (anonymous)] }</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</li>
</ol>
</div>
<div id="outline-container-orgd932fab" class="outline-4">
<h4 id="orgd932fab"><span class="section-number-4">8.2.2.</span> Initialization Checking</h4>
<div class="outline-text-4" id="text-8-2-2">
<ul class="org-ul">
<li>如果设置了strict compiler setting enable,那么typescript会check每个被设置为undefined的property
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">WithValue</span> <span style="color: #000000;">{</span>
  immediate = 0;
  later: <span style="color: #531ab6;">number</span>;
  mayBeUndefined: <span style="color: #531ab6;">number</span> | <span style="color: #0000b0;">undefined</span>;

  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:6:3 - error TS2564: Property 'unused' has no initializer and is not definitely assigned in the constructor.</span>

  unused: <span style="color: #531ab6;">number</span>;

  <span style="color: #531ab6;">constructor</span><span style="color: #dd22dd;">()</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">this</span>.later = 1;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>
</pre>
</div></li>
<li>注意如果strict compiler setting没有设置的话,上面的例子是可以编译通过的</li>
</ul></li>
<li>在极端情况下,我们甚至可以通过在property后面加一个 `!` 来disable check.这通常发生在我们很确信在使用
之前我们会通过一个非constructor的方法来初始化这个property
<ul class="org-ul">
<li><p>
示例如下, 我们通过initialize()函数来初始化了pending
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">ActivitiesQueue</span> <span style="color: #000000;">{</span>
  pending!: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">[]</span>;
  <span style="color: #721045;">initialize</span><span style="color: #dd22dd;">(</span><span style="color: #005e8b;">pending</span>: <span style="color: #531ab6;">string</span><span style="color: #008899;">[]</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">this</span>.pending = pending;
  <span style="color: #dd22dd;">}</span>
  <span style="color: #721045;">next</span><span style="color: #dd22dd;">()</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">return</span> <span style="color: #531ab6;">this</span>.pending.<span style="color: #721045;">pop</span><span style="color: #008899;">()</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">activities</span> = <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">ActivitiesQueue</span><span style="color: #000000;">()</span>;

activities.<span style="color: #721045;">initialize</span><span style="color: #000000;">(</span><span style="color: #dd22dd;">[</span><span style="color: #3548cf;">"eat"</span>, <span style="color: #3548cf;">"sleep"</span>, <span style="color: #3548cf;">"learn"</span><span style="color: #dd22dd;">]</span><span style="color: #000000;">)</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>activities.<span style="color: #721045;">next</span><span style="color: #dd22dd;">()</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">learn</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org77f0d7e" class="outline-4">
<h4 id="org77f0d7e"><span class="section-number-4">8.2.3.</span> Optional Properties</h4>
<div class="outline-text-4" id="text-8-2-3">
<ul class="org-ul">
<li>和interface一样,class的property也可以设置为optional的.
<ul class="org-ul">
<li><p>
示例如下,一旦设置为property,那么即便不在constructor里面配置,编译器也不会抱怨
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">MissingInitializer</span> <span style="color: #000000;">{</span>
  proprty?: <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span><span style="color: #531ab6;">new</span> <span style="color: #005f5f;">MissingInitializer</span><span style="color: #dd22dd;">()</span>.proprty?.length<span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">undefined</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:6:13 - error TS2532: Object is possibly 'undefined'.</span>

<span style="color: #7f0000;">///////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">console.</span><span style="color: #721045;">log</span><span style="color: #7f0000;">(new MissingInitializer().proprty.length); //</span>
<span style="color: #7f0000;">///////////////////////////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org14d67d0" class="outline-4">
<h4 id="org14d67d0"><span class="section-number-4">8.2.4.</span> Read-Only Properties</h4>
<div class="outline-text-4" id="text-8-2-4">
<ul class="org-ul">
<li>就和interface一样, class里面也能设置某些property为readonly
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">Quote</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">readonly</span> text: <span style="color: #531ab6;">string</span>;

  <span style="color: #531ab6;">constructor</span><span style="color: #dd22dd;">(</span>text: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">this</span>.text = text;
  <span style="color: #dd22dd;">}</span>

  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:9:10 - error TS2540: Cannot assign to 'text' because it is a read-only property.</span>

  <span style="color: #7f0000;">/////////////////////////</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">emphasize() {       //</span>
  <span style="color: #7f0000;">//   </span><span style="color: #7f0000;">this.text += "!"; //</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">}                   //</span>
  <span style="color: #7f0000;">/////////////////////////</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">quote</span> = <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Quote</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Hello"</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:21:7 - error TS2540: Cannot assign to 'text' because it is a read-only property.</span>

<span style="color: #7f0000;">////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">quote.text = 'Ha!" //</span>
<span style="color: #7f0000;">////////////////////////</span>
</pre>
</div></li>
</ul></li>
<li>readonly property只能在如下两个地方初始化:
<ul class="org-ul">
<li>要么是在declare的时候</li>
<li>要么是在constructor里面</li>
</ul></li>
<li>定义为readonly的类型有一个特别特别细节的优化:它们在被typescript infer类型的时候,会尽可能的"严格"
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript">jclass RandomQuote <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">readonly</span> explicit: <span style="color: #531ab6;">string</span> = <span style="color: #3548cf;">"Explicit Original"</span>;
  <span style="color: #531ab6;">readonly</span> implicit = <span style="color: #3548cf;">"Implicit Original"</span>;

  <span style="color: #531ab6;">constructor</span><span style="color: #dd22dd;">()</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">if</span> <span style="color: #008899;">(</span>Math.<span style="color: #721045;">random</span><span style="color: #972500;">()</span> &gt; 0.5<span style="color: #008899;">)</span> <span style="color: #008899;">{</span>
      <span style="color: #531ab6;">this</span>.explicit = <span style="color: #3548cf;">"Explicit New"</span>;
      <span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
      <span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:8:7 - error TS2322: Type '"Implicit New"' is not assignable to type '"Implicit Original"'.</span>

      <span style="color: #7f0000;">////////////////////////////////////</span>
      <span style="color: #7f0000;">// </span><span style="color: #7f0000;">this.implicit = "Implicit New" //</span>
      <span style="color: #7f0000;">////////////////////////////////////</span>
    <span style="color: #008899;">}</span>
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>
</pre>
</div></li>

<li>我们可以看到,如果不加string, implicit直接被infer成了更严格的literal type,也就是"Implicit Original"</li>
<li>只有加了string的explicit才真正获得了string的类型</li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org7a76cd2" class="outline-3">
<h3 id="org7a76cd2"><span class="section-number-3">8.3.</span> Classes as Types</h3>
<div class="outline-text-3" id="text-8-3">
<ul class="org-ul">
<li>Class在类型系统里面是比较特殊的,因为一个class declaration会创建两个东西:
<ul class="org-ul">
<li><p>
运行时的值-也就是类本身,可以被实例化(其实本质是一个函数),甚至是直接使用. 比如类的静态属性就是类
本身的值,不需要实例化就可以使用,如下例
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">MathUtils</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">static</span> pi = 3.14159;
  <span style="color: #531ab6;">static</span> <span style="color: #721045;">calculateArea</span><span style="color: #dd22dd;">(</span><span style="color: #005e8b;">radius</span>: <span style="color: #531ab6;">number</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">return</span> MathUtils.pi * radius * radius;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>MathUtils.pi<span style="color: #000000;">)</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>MathUtils.<span style="color: #721045;">calculateArea</span><span style="color: #dd22dd;">(</span>10<span style="color: #dd22dd;">)</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">3.14159</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">314.159</span>
</pre>
</div></li>
<li><p>
同时还是类型系统中的一个类型
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">MathUtils</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">static</span> pi = 3.14159;
  <span style="color: #531ab6;">static</span> <span style="color: #721045;">calculateArea</span><span style="color: #dd22dd;">(</span><span style="color: #005e8b;">radius</span>: <span style="color: #531ab6;">number</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">return</span> MathUtils.pi * radius * radius;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">mathUtils</span>: <span style="color: #005f5f;">MathUtils</span> = <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">MathUtils</span><span style="color: #000000;">()</span>;

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>mathUtils<span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">MathUtils {}</span>
</pre>
</div></li>
</ul></li>
<li>还有一个有意思(但是非常少发生的情况),就是我们如果一个参数是一个class,由于class也可以作为一个type,
那么我们竟然可以传递把一个符合这个type的object(不需要实例化自class).
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">SchoolBus</span> <span style="color: #000000;">{</span>
  <span style="color: #721045;">getAbilities</span><span style="color: #dd22dd;">()</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">return</span> <span style="color: #008899;">[</span><span style="color: #3548cf;">"magic"</span>, <span style="color: #3548cf;">"shapeshifting"</span><span style="color: #008899;">]</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">function</span> <span style="color: #721045;">withSchoolBus</span><span style="color: #000000;">(</span><span style="color: #005e8b;">bus</span>: <span style="color: #005f5f;">SchoolBus</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #dd22dd;">(</span>bus.<span style="color: #721045;">getAbilities</span><span style="color: #008899;">()</span><span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>

<span style="color: #721045;">withSchoolBus</span><span style="color: #000000;">(</span><span style="color: #531ab6;">new</span> <span style="color: #005f5f;">SchoolBus</span><span style="color: #dd22dd;">()</span><span style="color: #000000;">)</span>;

<span style="color: #721045;">withSchoolBus</span><span style="color: #000000;">(</span><span style="color: #dd22dd;">{</span>
  getAbilities: <span style="color: #008899;">()</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #008899;">[</span><span style="color: #3548cf;">"transmogrification"</span><span style="color: #008899;">]</span>,
<span style="color: #dd22dd;">}</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">[ 'magic', 'shapeshifting' ]</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">[ 'transmogrification' ]</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:19:23 - error TS2322: Type 'number' is not assignable to type 'string[]'.</span>

<span style="color: #7f0000;">////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">withSchoolBus({            //</span>
<span style="color: #7f0000;">//                            </span><span style="color: #7f0000;">//</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">getAbilities: () =&gt; 123; //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">});                        //</span>
<span style="color: #7f0000;">////////////////////////////////</span>
</pre>
</div></li>
<li>这么做看起来是把class当做了interface,所以多数情况下是应该使用interface,而不是class</li>
<li>这么做能成功的深层次原因是typescript是"隐式"类型判断(只要你符合shape of object就可以),不需要显式的体现</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgd01d732" class="outline-3">
<h3 id="orgd01d732"><span class="section-number-3">8.4.</span> Classes and Interfaces</h3>
<div class="outline-text-3" id="text-8-4">
<ul class="org-ul">
<li><p>
typescript里面当然也支持class和interface最原始的"编程语言定义": 那就是让class implements某个interface,
在编译器通过的情况下,class的instance都可以放在interface声明的位置
</p>
<pre class="example" id="org18550d5">
Class can implements interfaces, doing so indicates to TypeScript that
instance of the class should be assignable to each of those interfaces
</pre></li>
<li>我们前面说过,interface有两种定义callable function成员的方法: member function和property.如果你想要
class来implements你的interface,那么推荐使用ember function的声明方法,因为class里面的实例化的样子和
interface里面声明的样子是相同的.这样写起来更让人容易理解
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">Learner</span> <span style="color: #000000;">{</span>
  name: <span style="color: #531ab6;">string</span>;
  <span style="color: #721045;">study</span><span style="color: #dd22dd;">(</span><span style="color: #005e8b;">hours</span>: <span style="color: #531ab6;">number</span><span style="color: #dd22dd;">)</span>: <span style="color: #531ab6;">void</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">class</span> <span style="color: #005f5f;">Student</span> <span style="color: #531ab6;">implements</span> <span style="color: #005f5f;">Learner</span> <span style="color: #000000;">{</span>
  name: <span style="color: #531ab6;">string</span>;
  <span style="color: #531ab6;">constructor</span><span style="color: #dd22dd;">(</span>name: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">this</span>.name = name;
  <span style="color: #dd22dd;">}</span>

  <span style="color: #721045;">study</span><span style="color: #dd22dd;">(</span><span style="color: #005e8b;">hours</span>: <span style="color: #531ab6;">number</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">for</span> <span style="color: #008899;">(</span><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">i</span> = 0; i &lt; <span style="color: #005f5f;">hours</span>; <span style="color: #005f5f;">i</span> += 1<span style="color: #008899;">)</span> <span style="color: #008899;">{</span>
      <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #972500;">(</span><span style="color: #3548cf;">"...studying..."</span><span style="color: #972500;">)</span>;
    <span style="color: #008899;">}</span>
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:19:7 - error TS2420: Class 'Slacker' incorrectly implements interface 'Learner'.</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">Property 'study' is missing in type 'Slacker' but required in type 'Learner'.</span>

<span style="color: #7f0000;">////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">class Slacker implements Learner { //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">name = "Rocky";                  //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">}                                  //</span>
<span style="color: #7f0000;">////////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
<li>需要注意的是,class implements interface的情况下, typescript主要是对class内部的成员进行check而已,
并不会自动帮class里面的类型进行infer(特别是从any infer到符合interface的类型).这是由Typescript的立场
决定的: 它主要做类型检查!
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">Learner</span> <span style="color: #000000;">{</span>
  name: <span style="color: #531ab6;">string</span>;
  <span style="color: #721045;">study</span><span style="color: #dd22dd;">(</span><span style="color: #005e8b;">hours</span>: <span style="color: #531ab6;">number</span><span style="color: #dd22dd;">)</span>: <span style="color: #531ab6;">void</span>;
<span style="color: #000000;">}</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:8:9 - error TS7006: Parameter 'hours' implicitly has an 'any' type.</span>

<span style="color: #7f0000;">////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">class Slacker implements Learner { //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">name = "Rocky";                  //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">study(</span><span style="color: #005e8b;">hours</span><span style="color: #7f0000;">) {}                  //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">}                                  //</span>
<span style="color: #7f0000;">////////////////////////////////////////</span>
</pre>
</div></li>
<li>上例中的hours还是any类型,不不会因为implements了Learner而被infer成number类型</li>
</ul></li>
</ul>
</div>
<div id="outline-container-org6fa546c" class="outline-4">
<h4 id="org6fa546c"><span class="section-number-4">8.4.1.</span> Implementing Multiple Interfaces</h4>
<div class="outline-text-4" id="text-8-4-1">
<ul class="org-ul">
<li><p>
和其他语言一样,TypeScript也允许一个class implements多个interface, 示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">Graded</span> <span style="color: #000000;">{</span>
  grades: <span style="color: #531ab6;">number</span><span style="color: #dd22dd;">[]</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">Reporter</span> <span style="color: #000000;">{</span>
  report: <span style="color: #dd22dd;">()</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">class</span> <span style="color: #005f5f;">ReportCard</span> <span style="color: #531ab6;">implements</span> <span style="color: #005f5f;">Graded</span>, <span style="color: #005f5f;">Reporter</span> <span style="color: #000000;">{</span>
  grades: <span style="color: #531ab6;">number</span><span style="color: #dd22dd;">[]</span>;

  <span style="color: #531ab6;">constructor</span><span style="color: #dd22dd;">(</span>grades: <span style="color: #531ab6;">number</span><span style="color: #008899;">[]</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">this</span>.grades = grades;
  <span style="color: #dd22dd;">}</span>

  <span style="color: #721045;">report</span><span style="color: #dd22dd;">()</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">return</span> <span style="color: #531ab6;">this</span>.grades.<span style="color: #721045;">join</span><span style="color: #008899;">(</span><span style="color: #3548cf;">", "</span><span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:21:7 - error TS2420: Class 'Empty' incorrectly implements interface 'Graded'.</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">Property 'grades' is missing in type 'Empty' but required in type 'Graded'.</span>

<span style="color: #7f0000;">////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">class Empty implements Graded, Reporter {} //</span>
<span style="color: #7f0000;">////////////////////////////////////////////////</span>
</pre>
</div></li>
<li>当然这几个interface要相互"容忍"对方,如果不同interface里面的成员定义相抵触,那么显然同时实现这些interface是不合理的
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">AgeIsANumber</span> <span style="color: #000000;">{</span>
  age: <span style="color: #531ab6;">number</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">AgeIsNotANumber</span> <span style="color: #000000;">{</span>
  age: <span style="color: #dd22dd;">()</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:10:3 - error TS2416: Property 'age' in type 'AsNumber' is not assignable to the same property in base type 'AgeIsNotANumber'.</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">Type 'number' is not assignable to type '() =&gt; string'.</span>

<span style="color: #7f0000;">///////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">class AsNumber implements AgeIsANumber, AgeIsNotANumber { //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">age = 0;                                                //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">}                                                         //</span>
<span style="color: #7f0000;">///////////////////////////////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgae0c272" class="outline-3">
<h3 id="orgae0c272"><span class="section-number-3">8.5.</span> Extending a Class</h3>
<div class="outline-text-3" id="text-8-5">
<ul class="org-ul">
<li>和其他编程语言一样, class之间可以相互继承.
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">Teacher</span> <span style="color: #000000;">{</span>
  <span style="color: #721045;">teach</span><span style="color: #dd22dd;">()</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #3548cf;">"The surest test of discipline is its absense."</span><span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">class</span> <span style="color: #005f5f;">StudentTeacher</span> <span style="color: #531ab6;">extends</span> <span style="color: #005f5f;">Teacher</span> <span style="color: #000000;">{</span>
  <span style="color: #721045;">learn</span><span style="color: #dd22dd;">()</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #3548cf;">"I cannot afford the luxury of a closed mind."</span><span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">teacher</span> = <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">StudentTeacher</span><span style="color: #000000;">()</span>;
teacher.<span style="color: #721045;">teach</span><span style="color: #000000;">()</span>;
teacher.<span style="color: #721045;">learn</span><span style="color: #000000;">()</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">The surest test of discipline is its absense.</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">I cannot afford the luxury of a closed mind.</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
<div id="outline-container-orgb7031a4" class="outline-4">
<h4 id="orgb7031a4"><span class="section-number-4">8.5.1.</span> Extension Assignability</h4>
<div class="outline-text-4" id="text-8-5-1">
<ul class="org-ul">
<li>subclass extends 一个base class类似于class implements一个interface.那么:
<ul class="org-ul">
<li>由于interface声明的地方,都可以使用implements它的class</li>
<li><p>
那么base class声明的地方,必然可以使用subclass,示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">Lesson</span> <span style="color: #000000;">{</span>
  subject: <span style="color: #531ab6;">string</span>;

  <span style="color: #531ab6;">constructor</span><span style="color: #dd22dd;">(</span>subject: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">this</span>.subject = subject;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">class</span> <span style="color: #005f5f;">OnlineLesson</span> <span style="color: #531ab6;">extends</span> <span style="color: #005f5f;">Lesson</span> <span style="color: #000000;">{</span>
  url: <span style="color: #531ab6;">string</span>;

  <span style="color: #531ab6;">constructor</span><span style="color: #dd22dd;">(</span>subject: <span style="color: #531ab6;">string</span>, url: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">super</span><span style="color: #008899;">(</span>subject<span style="color: #008899;">)</span>;
    <span style="color: #531ab6;">this</span>.url = url;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">lesson</span>: <span style="color: #005f5f;">Lesson</span>;

lesson = <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Lesson</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"coding"</span><span style="color: #000000;">)</span>;
lesson = <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">OnlineLesson</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"coding"</span>, <span style="color: #3548cf;">"oreilly.com"</span><span style="color: #000000;">)</span>;

<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">online</span>: <span style="color: #005f5f;">OnlineLesson</span>;
online = <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">OnlineLesson</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"coding"</span>, <span style="color: #3548cf;">"oreilly.com"</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:26:1 - error TS2741: Property 'url' is missing in type 'Lesson' but required in type 'OnlineLesson'.</span>

<span style="color: #7f0000;">////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">online = new Lesson("coding"); //</span>
<span style="color: #7f0000;">////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
<li>同时,拜Typescript的structural checking(也就是隐式类型检查)所赐,如果subclass没有引入新的memeber(换句
话说,subclass和base的函数和property都一样),那么subclass声明的地方也能放置base class
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">PastGrades</span> <span style="color: #000000;">{</span>
  grades: <span style="color: #531ab6;">number</span><span style="color: #dd22dd;">[]</span> = <span style="color: #dd22dd;">[]</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">class</span> <span style="color: #005f5f;">LabeledPastGrades</span> <span style="color: #531ab6;">extends</span> <span style="color: #005f5f;">PastGrades</span> <span style="color: #000000;">{</span>
  label?: <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">subClass</span>: <span style="color: #005f5f;">LabeledPastGrades</span>;

subClass = <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">LabeledPastGrades</span><span style="color: #000000;">()</span>;
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">this can work because of TypeScript's structural typing!</span>
subClass = <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">PastGrades</span><span style="color: #000000;">()</span>;
</pre>
</div></li>
<li>由于subclass LabeledPastGrades只增加了一个optional property,所以base class竟然可以subclass声明的
地方.</li>
<li>注意!这个例子更多的是介绍Typescript的structural checking带来的副作用,常规代码中,subclass总会带来
"确定性"的不同,不会让base class能否在subclass放置的地方起作用</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgea42979" class="outline-4">
<h4 id="orgea42979"><span class="section-number-4">8.5.2.</span> Overriddeng Constructors</h4>
<div class="outline-text-4" id="text-8-5-2">
<ul class="org-ul">
<li>继承其实是需要调用base class的constructor的. TypeScript会帮我们进行这方面的检查,比如:
<ul class="org-ul">
<li><p>
强制要求调用base class的constructor,如果不调用就报错
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">GradeAnnouncer</span> <span style="color: #000000;">{</span>
  message: <span style="color: #531ab6;">string</span>;
  <span style="color: #531ab6;">constructor</span><span style="color: #dd22dd;">(</span>grade: <span style="color: #531ab6;">number</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">this</span>.message = grade &gt;= 65 ? <span style="color: #3548cf;">"You Pass"</span> : <span style="color: #3548cf;">"Maybe next time"</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">class</span> <span style="color: #005f5f;">PassingAnnouncer</span> <span style="color: #531ab6;">extends</span> <span style="color: #005f5f;">GradeAnnouncer</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">constructor</span><span style="color: #dd22dd;">()</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">super</span><span style="color: #008899;">(</span>100<span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:15:3 - error TS2377: Constructors for derived classes must contain a 'super' call.</span>

<span style="color: #7f0000;">//////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">class FaillingAnnouncer extends GradeAnnouncer { //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">constructor() {}                               //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">}                                                //</span>
<span style="color: #7f0000;">//////////////////////////////////////////////////////</span>
</pre>
</div></li>
<li><p>
subclass 如果调用constructor(下面的例子中不调用constructor就没事)需要调用base class的constructor
(通过super)之后,才能使用this,如果顺序不对,就报错
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">GradesTally</span> <span style="color: #000000;">{</span>
  grades: <span style="color: #531ab6;">number</span><span style="color: #dd22dd;">[]</span> = <span style="color: #dd22dd;">[]</span>;
  <span style="color: #721045;">addGrades</span><span style="color: #dd22dd;">(</span>...<span style="color: #005e8b;">grades</span>: <span style="color: #531ab6;">number</span><span style="color: #008899;">[]</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">this</span>.grades.<span style="color: #721045;">push</span><span style="color: #008899;">(</span>...grades<span style="color: #008899;">)</span>;
    <span style="color: #531ab6;">return</span> <span style="color: #531ab6;">this</span>.grades.length;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">class</span> <span style="color: #005f5f;">ContinueGradesTally</span> <span style="color: #531ab6;">extends</span> <span style="color: #005f5f;">GradesTally</span> <span style="color: #000000;">{</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:11:5 - error TS17009: 'super' must be called before accessing 'this' in the constructor of a derived class.</span>
  <span style="color: #7f0000;">////////////////////////////////////////////////////////////////</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">constructor(</span><span style="color: #005e8b;">previousGrades</span><span style="color: #7f0000;">: number[]) {                    //</span>
  <span style="color: #7f0000;">//   </span><span style="color: #7f0000;">this.grades = [...previousGrades];                       //</span>
  <span style="color: #7f0000;">//   </span><span style="color: #7f0000;">super();                                                 //</span>
  <span style="color: #7f0000;">//   </span><span style="color: #7f0000;">console.</span><span style="color: #721045;">log</span><span style="color: #7f0000;">("Starting with length", this.grades.length); //</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">}                                                          //</span>
  <span style="color: #7f0000;">////////////////////////////////////////////////////////////////</span>
<span style="color: #000000;">}</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgf4e924a" class="outline-4">
<h4 id="orgf4e924a"><span class="section-number-4">8.5.3.</span> Overridden Methods</h4>
<div class="outline-text-4" id="text-8-5-3">
<ul class="org-ul">
<li>subclass可以redeclare base class的同名函数,只要新的类型是assignable给老类型的(所谓assignable我们之
前在函数重载部分讲到过,大意就是对应类型可以不存在,但是有必须类型相同).
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">GradeCounter</span> <span style="color: #000000;">{</span>
  <span style="color: #721045;">countGrades</span><span style="color: #dd22dd;">(</span><span style="color: #005e8b;">grades</span>: <span style="color: #531ab6;">string</span><span style="color: #008899;">[]</span>, <span style="color: #005e8b;">letter</span>: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">return</span> grades.<span style="color: #721045;">filter</span><span style="color: #008899;">(</span><span style="color: #972500;">(</span>grade<span style="color: #972500;">)</span> <span style="color: #531ab6;">=&gt;</span> grade === letter<span style="color: #008899;">)</span>.length;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">class</span> <span style="color: #005f5f;">FailureCounter</span> <span style="color: #531ab6;">extends</span> <span style="color: #005f5f;">GradeCounter</span> <span style="color: #000000;">{</span>
  <span style="color: #721045;">countGrades</span><span style="color: #dd22dd;">(</span><span style="color: #005e8b;">grades</span>: <span style="color: #531ab6;">string</span><span style="color: #008899;">[]</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">return</span> <span style="color: #531ab6;">super</span>.<span style="color: #721045;">countGrades</span><span style="color: #008899;">(</span>grades, <span style="color: #3548cf;">"F"</span><span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:14:3 - error TS2416: Property 'countGrades' in type 'AnyFailureChecker' is not assignable to the same property in base type 'GradeCounter'.</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">Type '(grades: string[]) =&gt; boolean' is not assignable to type '(grades: string[], letter: string) =&gt; number'.</span>
<span style="color: #7f0000;">//     </span><span style="color: #7f0000;">Type 'boolean' is not assignable to type 'number'.</span>

<span style="color: #7f0000;">//////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">class AnyFailureChecker extends GradeCounter {   //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">countGrades(</span><span style="color: #005e8b;">grades</span><span style="color: #7f0000;">: string[]) {                //</span>
<span style="color: #7f0000;">//     </span><span style="color: #7f0000;">return super.</span><span style="color: #721045;">countGrades</span><span style="color: #7f0000;">(grades, "F") !== 0; //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">}                                              //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">}                                                //</span>
<span style="color: #7f0000;">//////////////////////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgeaa3509" class="outline-4">
<h4 id="orgeaa3509"><span class="section-number-4">8.5.4.</span> Overridden Properties</h4>
<div class="outline-text-4" id="text-8-5-4">
<ul class="org-ul">
<li>既然能够重载method,那么重载property也是非常正常的.</li>
<li>重载property类型一定能够assignable, 对于property来说,assiable一般意味着更加specific的类型,比如union
type中少一些类型
<ul class="org-ul">
<li><p>
示例如下, 类型从头string | undefined, 变成了string,更specific
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">Assignment</span> <span style="color: #000000;">{</span>
  grade?: <span style="color: #531ab6;">number</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">class</span> <span style="color: #005f5f;">GradeAssignment</span> <span style="color: #531ab6;">extends</span> <span style="color: #005f5f;">Assignment</span> <span style="color: #000000;">{</span>
  grade: <span style="color: #531ab6;">number</span>;

  <span style="color: #531ab6;">constructor</span><span style="color: #dd22dd;">(</span>grade: <span style="color: #531ab6;">number</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">super</span><span style="color: #008899;">()</span>;
    <span style="color: #531ab6;">this</span>.grade = grade;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>
</pre>
</div></li>
</ul></li>
<li>相反,如果我们在继承的时候,expand了我们property的union type,那么是会报错的,原因很简单,我们没办法把一
个可能性更广的subclass值给base class,因为代码是根据base class来写的,根本没考虑到新增的类型.
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">NumericGrade</span> <span style="color: #000000;">{</span>
  value = 0;
<span style="color: #000000;">}</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:6:3 - error TS2416: Property 'value' in type 'VagueGrade' is not assignable to the same property in base type 'NumericGrade'.</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">Type 'string | number' is not assignable to type 'number'.</span>
<span style="color: #7f0000;">//     </span><span style="color: #7f0000;">Type 'string' is not assignable to type 'number'.</span>

<span style="color: #7f0000;">////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">class VagueGrade extends NumericGrade {    //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">value = Math.</span><span style="color: #721045;">random</span><span style="color: #7f0000;">() &gt; 0.5 ? 1 : "..."; //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">}                                          //</span>
<span style="color: #7f0000;">////////////////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org1e60c6d" class="outline-3">
<h3 id="org1e60c6d"><span class="section-number-3">8.6.</span> Abstract Classes</h3>
<div class="outline-text-3" id="text-8-6">
<ul class="org-ul">
<li>有时候我们希望创建一个base class,它的部分method是没有implementation的(换言之,其他部分都提供了实现),
而是希望subclass来实现这部分method
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">abstract</span> <span style="color: #531ab6;">class</span> <span style="color: #005f5f;">School</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">readonly</span> name: <span style="color: #531ab6;">string</span>;
  <span style="color: #531ab6;">constructor</span><span style="color: #dd22dd;">(</span>name: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">this</span>.name = name;
  <span style="color: #dd22dd;">}</span>

  <span style="color: #531ab6;">abstract</span> <span style="color: #721045;">getStudentTypes</span><span style="color: #dd22dd;">()</span>: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">[]</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">class</span> <span style="color: #005f5f;">Preschool</span> <span style="color: #531ab6;">extends</span> <span style="color: #005f5f;">School</span> <span style="color: #000000;">{</span>
  <span style="color: #721045;">getStudentTypes</span><span style="color: #dd22dd;">()</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">return</span> <span style="color: #008899;">[</span><span style="color: #3548cf;">"preschooler"</span><span style="color: #008899;">]</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:16:7 - error TS18052: Non-abstract class 'Absence' does not implement all abstract members of 'School'</span>

<span style="color: #7f0000;">/////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">class Absence extends School {} //</span>
<span style="color: #7f0000;">/////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
<li>由于abstract class缺少某些method的实现,所以abstract class是不能初始化的.
<ul class="org-ul">
<li><p>
试图初始化一个abstrct class会报错
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">abstract</span> <span style="color: #531ab6;">class</span> <span style="color: #005f5f;">School</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">readonly</span> name: <span style="color: #531ab6;">string</span>;
  <span style="color: #531ab6;">constructor</span><span style="color: #dd22dd;">(</span>name: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">this</span>.name = name;
  <span style="color: #dd22dd;">}</span>

  <span style="color: #531ab6;">abstract</span> <span style="color: #721045;">getStudentTypes</span><span style="color: #dd22dd;">()</span>: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">[]</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">class</span> <span style="color: #005f5f;">Preschool</span> <span style="color: #531ab6;">extends</span> <span style="color: #005f5f;">School</span> <span style="color: #000000;">{</span>
  <span style="color: #721045;">getStudentTypes</span><span style="color: #dd22dd;">()</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">return</span> <span style="color: #008899;">[</span><span style="color: #3548cf;">"preschooler"</span><span style="color: #008899;">]</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">school</span>: <span style="color: #005f5f;">School</span>;
school = <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Preschool</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Sunnyside Daycare"</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:19:10 - error TS2511: Cannot create an instance of an abstract class.</span>

<span style="color: #7f0000;">////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">school = new School("somewhere else"); //</span>
<span style="color: #7f0000;">////////////////////////////////////////////</span>
</pre>
</div></li>

<li>abstract class通常应用于framework: 实现了部分细节,但是留给用户来实现剩下的细节.同时我还能使用abstract
class来在需要的地方只用abstract class类型的变量站位(比如上面例子中的school: School)</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgd5c8376" class="outline-3">
<h3 id="orgd5c8376"><span class="section-number-3">8.7.</span> Member Visibility</h3>
<div class="outline-text-3" id="text-8-7">
<ul class="org-ul">
<li>JavaScript引入了`#`关键字来表示某个class的member是private的
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #531ab6;">class</span> Person <span style="color: #000000;">{</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#31169;&#26377;&#23383;&#27573;</span>
  #name;

  constructor<span style="color: #dd22dd;">(</span>name<span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #0000b0;">this</span>.#name = name; <span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#21482;&#33021;&#22312;&#31867;&#20869;&#37096;&#35775;&#38382;</span>
  <span style="color: #dd22dd;">}</span>

  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#20844;&#20849;&#26041;&#27861;&#65292;&#29992;&#20110;&#35775;&#38382;&#31169;&#26377;&#23383;&#27573;</span>
  getName<span style="color: #dd22dd;">()</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">return</span> <span style="color: #0000b0;">this</span>.#name;
  <span style="color: #dd22dd;">}</span>

  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#20844;&#20849;&#26041;&#27861;&#65292;&#29992;&#20110;&#20462;&#25913;&#31169;&#26377;&#23383;&#27573;</span>
  setName<span style="color: #dd22dd;">(</span>newName<span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #0000b0;">this</span>.#name = newName;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">person</span> = <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Person</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Alice"</span><span style="color: #000000;">)</span>;

console.log<span style="color: #000000;">(</span>person.getName<span style="color: #dd22dd;">()</span><span style="color: #000000;">)</span>; <span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#36755;&#20986;: Alice</span>
person.setName<span style="color: #000000;">(</span><span style="color: #3548cf;">"Bob"</span><span style="color: #000000;">)</span>;
console.log<span style="color: #000000;">(</span>person.getName<span style="color: #dd22dd;">()</span><span style="color: #000000;">)</span>; <span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#36755;&#20986;: Bob</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Alice</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Bob</span>


<span style="color: #7f0000;">// </span><span style="color: #7f0000;">SyntaxError: Private field '#name' must be declared in an enclosing class</span>
<span style="color: #7f0000;">////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">console.log(person.#name); //</span>
<span style="color: #7f0000;">////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
<li>Typescript当然支持`#`关键字,但是它同时引入了和其他编程语言类似的三级visibility系统,关键字分别是:
<ul class="org-ul">
<li>public (default): 允许任何人访问</li>
<li>protected: 只有class和其他subclas可以访问</li>
<li>private: 只有class自己可以访问</li>
</ul></li>
<li>注意,这些关键字只是在type system里面起作用,转换为javascript的时候,就被去掉了
<ul class="org-ul">
<li><p>
我们来看一个包括这些关键字的例子
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">Base</span> <span style="color: #000000;">{</span>
  isPublicImplicit = 0;
  <span style="color: #531ab6;">public</span> isPublicExplicit = 1;
  <span style="color: #531ab6;">protected</span> isProtected = 2;
  <span style="color: #531ab6;">private</span> isPrivate = 3;
  #truePrivate = 4;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">class</span> <span style="color: #005f5f;">Subclass</span> <span style="color: #531ab6;">extends</span> <span style="color: #005f5f;">Base</span> <span style="color: #000000;">{</span>
  <span style="color: #721045;">examples</span><span style="color: #dd22dd;">()</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #531ab6;">this</span>.isPublicImplicit<span style="color: #008899;">)</span>;
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #531ab6;">this</span>.isPublicExplicit<span style="color: #008899;">)</span>;
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #531ab6;">this</span>.isProtected<span style="color: #008899;">)</span>;

    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:15:10 - error TS2341: Property 'isPrivate' is private and only accessible within class 'Base'.</span>

    <span style="color: #7f0000;">/////////////////////</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">this.isPrivate; //</span>
    <span style="color: #7f0000;">/////////////////////</span>

    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:21:10 - error TS18013: Property '#truePrivate' is not accessible outside class 'Base' because it has a private identifier.</span>

    <span style="color: #7f0000;">////////////////////////</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">this.#truePrivate; //</span>
    <span style="color: #7f0000;">////////////////////////</span>
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Subclass</span><span style="color: #000000;">()</span>.isPublicImplicit;
<span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Subclass</span><span style="color: #000000;">()</span>.isPublicExplicit;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:33:16 - error TS2445: Property 'isProtected' is protected and only accessible within class 'Base' and its subclasses.</span>

<span style="color: #7f0000;">/////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">new Subclass().isProtected; //</span>
<span style="color: #7f0000;">/////////////////////////////////</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:41:16 - error TS2341: Property 'isPrivate' is private and only accessible within class 'Base'.</span>

<span style="color: #7f0000;">///////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">new Subclass().isPrivate; //</span>
<span style="color: #7f0000;">///////////////////////////////</span>

<span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Subclass</span><span style="color: #000000;">()</span>.<span style="color: #721045;">examples</span><span style="color: #000000;">()</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">0</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">1</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">2</span>
</pre>
</div></li>
</ul></li>

<li>visibility modifier 可以和readonly一起使用, visibility modifier在前, readonly在后
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">TwoKeywords</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">private</span> <span style="color: #531ab6;">readonly</span> name: <span style="color: #531ab6;">string</span>;

  <span style="color: #531ab6;">constructor</span><span style="color: #dd22dd;">()</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">this</span>.name = <span style="color: #3548cf;">"Anne Sullivan"</span>;
  <span style="color: #dd22dd;">}</span>

  <span style="color: #721045;">log</span><span style="color: #dd22dd;">()</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #531ab6;">this</span>.name<span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">two</span> = <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">TwoKeywords</span><span style="color: #000000;">()</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:15:5 - error TS2341: Property 'name' is private and only accessible within class 'TwoKeywords'.</span>

<span style="color: #7f0000;">////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">two.name = "Savitribai Phule"; //</span>
<span style="color: #7f0000;">////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
<div id="outline-container-org0c0f13f" class="outline-4">
<h4 id="org0c0f13f"><span class="section-number-4">8.7.1.</span> Static Field Modifiers</h4>
<div class="outline-text-4" id="text-8-7-1">
<ul class="org-ul">
<li>javascript的static关键字用来表示某个member是class的,而不是instance的</li>
<li>TypeScript是支持这个关键字的,而且支持这个关键字和readonly一起使用.
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">Question</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">protected</span> <span style="color: #531ab6;">static</span> <span style="color: #531ab6;">readonly</span> answer: <span style="color: #3548cf;">"bash"</span>;
  <span style="color: #531ab6;">protected</span> <span style="color: #531ab6;">static</span> <span style="color: #531ab6;">readonly</span> prompt =
    <span style="color: #3548cf;">"What's an ogre's favorite programming language?"</span>;

  <span style="color: #721045;">guess</span><span style="color: #dd22dd;">(</span><span style="color: #005e8b;">getAnswer</span>: <span style="color: #008899;">(</span><span style="color: #005e8b;">prompt</span>: <span style="color: #531ab6;">string</span><span style="color: #008899;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">const</span> <span style="color: #005e8b;">answer</span> = <span style="color: #721045;">getAnswer</span><span style="color: #008899;">(</span>Question.prompt<span style="color: #008899;">)</span>;

    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">Ok</span>
    <span style="color: #531ab6;">if</span> <span style="color: #008899;">(</span>answer === Question.answer<span style="color: #008899;">)</span> <span style="color: #008899;">{</span>
      <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #972500;">(</span><span style="color: #3548cf;">"You got it!"</span><span style="color: #972500;">)</span>;
    <span style="color: #008899;">}</span> <span style="color: #531ab6;">else</span> <span style="color: #008899;">{</span>
      <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #972500;">(</span><span style="color: #3548cf;">"Try again..."</span><span style="color: #972500;">)</span>;
    <span style="color: #008899;">}</span>
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:19:22 - error TS2445: Property 'answer' is protected and only accessible within class 'Question' and its subclasses.</span>

<span style="color: #7f0000;">//////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">console.</span><span style="color: #721045;">log</span><span style="color: #7f0000;">(Question.answer) //</span>
<span style="color: #7f0000;">//////////////////////////////////</span>
</pre>
</div></li>
<li>从上面的例子来看,不同关键字放置的顺序是:
<ol class="org-ol">
<li>visibility modifier</li>
<li>static</li>
<li>readonly</li>
</ol></li>
</ul></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org14038df" class="outline-2">
<h2 id="org14038df"><span class="section-number-2">9.</span> Chapter 9: Type Modifiers</h2>
<div class="outline-text-2" id="text-9">
</div>
<div id="outline-container-orgcda06a8" class="outline-3">
<h3 id="orgcda06a8"><span class="section-number-3">9.1.</span> Top Types</h3>
<div class="outline-text-3" id="text-9-1">
</div>
<div id="outline-container-org8b40967" class="outline-4">
<h4 id="org8b40967"><span class="section-number-4">9.1.1.</span> any, Again</h4>
<div class="outline-text-4" id="text-9-1-1">
<ul class="org-ul">
<li>any类型可以作为top type,所谓top type是指提供一个location来放置任意类型</li>
<li>any一般放置的位置是那些所有类型都可以放置的位置,比如console.log</li>
<li>any的问题是,它其实是告诉TypeScript不要再做类型检查了,这样做降低了TypeScript的作用
<ul class="org-ul">
<li><p>
示例如下,下面的代码,在把一个对象赋值给string的时候,TypeScript本来可以报错的,但是由于name定义成了
any类型,所以TypeScript也就不进行检查了
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">greetComedian</span><span style="color: #000000;">(</span><span style="color: #005e8b;">name</span>: <span style="color: #531ab6;">any</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">`Announcing </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">name.toUpperCase()</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>

<span style="color: #721045;">greetComedian</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Bea Arthur"</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Announcing BEA ARTHUR</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TypeError: name.toUpperCase is not a function</span>

<span style="color: #7f0000;">////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">greetComedian({ name: "Bea Arthur" }); //</span>
<span style="color: #7f0000;">////////////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orga73426c" class="outline-4">
<h4 id="orga73426c"><span class="section-number-4">9.1.2.</span> unknown</h4>
<div class="outline-text-4" id="text-9-1-2">
<ul class="org-ul">
<li><p>
any的危害我们已经看到了,其实TypeScript真正希望你使用的top type是unknown,而不是any
</p>
<pre class="example" id="org256d4c3">
You should generally prefer using unknown instead of any when possible
</pre></li>
<li>unknown初看起来非常的严格:
<ul class="org-ul">
<li><p>
不允许直接访问unknown(经过value narrow后就可以了哈,否则没法使用了)
</p>
<div class="org-src-container">
<pre class="src src-typescript"> <span style="color: #531ab6;">function</span> <span style="color: #721045;">greetComedian</span><span style="color: #000000;">(</span><span style="color: #005e8b;">name</span>: <span style="color: #531ab6;">unknown</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:2:29 - error TS18046: 'name' is of type 'unknown'.</span>
  <span style="color: #7f0000;">/////////////////////////////////////////////////////////</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">console.</span><span style="color: #721045;">log</span><span style="color: #7f0000;">(`Announcing ${name.</span><span style="color: #721045;">toUpperCase</span><span style="color: #7f0000;">()} !`);  //</span>
  <span style="color: #7f0000;">/////////////////////////////////////////////////////////</span>
<span style="color: #000000;">}</span>
</pre>
</div></li>
<li>unknown只允许被赋值为top type(any或者unknown)</li>
</ul></li>
<li>我们只有通过typeof或者instanceof进行了type narrow之后,我们就可以使用unknown了
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">greetComedianSafety</span><span style="color: #000000;">(</span><span style="color: #005e8b;">name</span>: <span style="color: #531ab6;">unknown</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">if</span> <span style="color: #dd22dd;">(</span><span style="color: #531ab6;">typeof</span> name === <span style="color: #3548cf;">"string"</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #3548cf;">`Announcing </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">name.toUpperCase()</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;"> !`</span><span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span> <span style="color: #531ab6;">else</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #3548cf;">"Well, I'm off."</span><span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #721045;">greetComedianSafety</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Betty White"</span><span style="color: #000000;">)</span>;
<span style="color: #721045;">greetComedianSafety</span><span style="color: #000000;">(</span><span style="color: #dd22dd;">{}</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Announcing BETTY WHITE !</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Well, I'm off.</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org8ed881b" class="outline-3">
<h3 id="org8ed881b"><span class="section-number-3">9.2.</span> Type Prddicates</h3>
<div class="outline-text-3" id="text-9-2">
<ul class="org-ul">
<li>前面我们知道了,如果使用了unknown,那么必须和typeof和instanceof来确定真实的类型,然后进行操作
<ul class="org-ul">
<li><p>
下面就是这样一个例子.
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">isNumberOrString</span><span style="color: #000000;">(</span><span style="color: #005e8b;">value</span>: <span style="color: #531ab6;">unknown</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> <span style="color: #dd22dd;">[</span><span style="color: #3548cf;">"number"</span>, <span style="color: #3548cf;">"string"</span><span style="color: #dd22dd;">]</span>.<span style="color: #721045;">includes</span><span style="color: #dd22dd;">(</span><span style="color: #531ab6;">typeof</span> value<span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">function</span> <span style="color: #721045;">logValueIfExists</span><span style="color: #000000;">(</span><span style="color: #005e8b;">value</span>: <span style="color: #531ab6;">number</span> | <span style="color: #531ab6;">string</span> | <span style="color: #0000b0;">null</span> | <span style="color: #0000b0;">undefined</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">if</span> <span style="color: #dd22dd;">(</span><span style="color: #721045;">isNumberOrString</span><span style="color: #008899;">(</span>value<span style="color: #008899;">)</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:7:5 - error TS18049: 'value' is possibly 'null' or 'undefined'.</span>

    <span style="color: #7f0000;">///////////////////////</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">value.</span><span style="color: #721045;">toString</span><span style="color: #7f0000;">(); //</span>
    <span style="color: #7f0000;">///////////////////////</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #3548cf;">"string"</span><span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span> <span style="color: #531ab6;">else</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #3548cf;">"value does not exist"</span><span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>
</pre>
</div></li>
<li>这个例子中的isNumberOrString只是返回了boolean,但是Typescript编译器并不知道value的类型是什么,所以无法调用toString</li>
</ul></li>
<li>那么有没有那么一种特性,能在返回boolean的同时,还能给Typescript编译器捎句话,告诉他参数是什么类型呢?
(unkown是非常合适的场景,因为用户创建的时候压根没写,也没法infer)
<ul class="org-ul">
<li><p>
答案是有的,就是所谓的type predicates,其原型如下
</p>
<pre class="example" id="org3da96ac">
function typePredicate(input: WideType): input is NarrowType;
</pre></li>
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">isNumberOrString</span><span style="color: #000000;">(</span><span style="color: #005e8b;">value</span>: <span style="color: #531ab6;">unknown</span><span style="color: #000000;">)</span>: value is <span style="color: #531ab6;">number</span> | <span style="color: #531ab6;">string</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> <span style="color: #dd22dd;">[</span><span style="color: #3548cf;">"number"</span>, <span style="color: #3548cf;">"string"</span><span style="color: #dd22dd;">]</span>.<span style="color: #721045;">includes</span><span style="color: #dd22dd;">(</span><span style="color: #531ab6;">typeof</span> value<span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">function</span> <span style="color: #721045;">logValueIfExists</span><span style="color: #000000;">(</span><span style="color: #005e8b;">value</span>: <span style="color: #531ab6;">number</span> | <span style="color: #531ab6;">string</span> | <span style="color: #0000b0;">null</span> | <span style="color: #0000b0;">undefined</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">if</span> <span style="color: #dd22dd;">(</span><span style="color: #721045;">isNumberOrString</span><span style="color: #008899;">(</span>value<span style="color: #008899;">)</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #3548cf;">`toString(): </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">value.toString()</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span> <span style="color: #531ab6;">else</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #3548cf;">"value does not exist:"</span>, value<span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #721045;">logValueIfExists</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"abc"</span><span style="color: #000000;">)</span>;
<span style="color: #721045;">logValueIfExists</span><span style="color: #000000;">(</span>123<span style="color: #000000;">)</span>;
<span style="color: #721045;">logValueIfExists</span><span style="color: #000000;">(</span><span style="color: #0000b0;">undefined</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">toString(): abc</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">toString(): 123</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">value does not exist: undefined</span>
</pre>
</div></li>
<li>上例会告诉Typescript:在返回为true的情况下, value的类型是number | string</li>
</ul></li>
<li>除了unknown以外,还有一个type predicate应用的场景是把interface给narrow成更加specific的interface
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">Comedian</span> <span style="color: #000000;">{</span>
  funny: <span style="color: #531ab6;">boolean</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">StandupComedian</span> <span style="color: #531ab6;">extends</span> <span style="color: #005f5f;">Comedian</span> <span style="color: #000000;">{</span>
  routine: <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">function</span> <span style="color: #721045;">isStandupComedian</span><span style="color: #000000;">(</span><span style="color: #005e8b;">value</span>: <span style="color: #005f5f;">Comedian</span><span style="color: #000000;">)</span>: <span style="color: #005e8b;">value</span> <span style="color: #531ab6;">is</span> <span style="color: #005f5f;">StandupComedian</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> <span style="color: #3548cf;">"routine"</span> <span style="color: #531ab6;">in</span> value;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">function</span> <span style="color: #721045;">workWithComedian</span><span style="color: #000000;">(</span><span style="color: #005e8b;">value</span>: <span style="color: #005f5f;">Comedian</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">if</span> <span style="color: #dd22dd;">(</span><span style="color: #721045;">isStandupComedian</span><span style="color: #008899;">(</span>value<span style="color: #008899;">)</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span>value.routine<span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span>

  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:18:21 - error TS2339: Property 'routine' does not exist on type 'Comedian'.</span>

  <span style="color: #7f0000;">/////////////////////////////////</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">console.</span><span style="color: #721045;">log</span><span style="color: #7f0000;">(value.routine); //</span>
  <span style="color: #7f0000;">/////////////////////////////////</span>
<span style="color: #000000;">}</span>
</pre>
</div></li>
<li>我们可以看到,在isStandupComedian返回true的情况下,Typescript就知道value是更加specifi的StandupComedian,
所以可以调用其routine成员</li>
</ul></li>
<li>Typescript如此精密,其不仅仅在type predicate的true case里面知道类型为更specific值,还会再false case里
面自动判断出"原始类型-specific类型"剩下的类型
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">isLongString</span><span style="color: #000000;">(</span><span style="color: #005e8b;">input</span>: <span style="color: #531ab6;">string</span> | <span style="color: #0000b0;">undefined</span><span style="color: #000000;">)</span>: input is <span style="color: #531ab6;">string</span> <span style="color: #000000;">{</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">!! &#26159;&#19968;&#20010;&#21452;&#21542;&#23450;&#25805;&#20316;&#31526;&#65292;&#23427;&#23558;&#34920;&#36798;&#24335;&#36716;&#25442;&#20026;&#24067;&#23572;&#20540;&#12290;&#36890;&#24120;&#29992;&#20110;&#30830;&#20445;&#36820;&#22238;&#30340;&#26159; true &#25110; false</span>
  <span style="color: #531ab6;">return</span> !!<span style="color: #dd22dd;">(</span>input &amp;&amp; input.length &gt;= 7<span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">function</span> <span style="color: #721045;">workWithText</span><span style="color: #000000;">(</span><span style="color: #005e8b;">text</span>: <span style="color: #531ab6;">string</span> | <span style="color: #0000b0;">undefined</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">if</span> <span style="color: #dd22dd;">(</span><span style="color: #721045;">isLongString</span><span style="color: #008899;">(</span>text<span style="color: #008899;">)</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #3548cf;">"Long Text: "</span>, text.length<span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span> <span style="color: #531ab6;">else</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:10:32 - error TS18048: 'text' is possibly 'undefined'.</span>
    <span style="color: #7f0000;">//////////////////////////////////////////////</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">console.</span><span style="color: #721045;">log</span><span style="color: #7f0000;">("Short Text:", text.length); //</span>
    <span style="color: #7f0000;">//////////////////////////////////////////////</span>
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>
</pre>
</div></li>

<li><p>
上例中的false case中,Typescript知道如果为true case是string,那么false case就是undefined了,因为
</p>
<pre class="example" id="org3fc43d0">
string | undefined - string = undefined
</pre></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org7284896" class="outline-3">
<h3 id="org7284896"><span class="section-number-3">9.3.</span> Type Operators</h3>
<div class="outline-text-3" id="text-9-3">
</div>
<div id="outline-container-org466c593" class="outline-4">
<h4 id="org466c593"><span class="section-number-4">9.3.1.</span> keyof</h4>
<div class="outline-text-4" id="text-9-3-1">
<ul class="org-ul">
<li>Javascript object的访问,可以在`[]`里面传入一个字符串(通常来说是字符串,但是也可以是其他类型,比如数组就是传入整型number)
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">obj</span> = <span style="color: #000000;">{</span>
  hello: <span style="color: #3548cf;">"world"</span>,
<span style="color: #000000;">}</span>;
console.log<span style="color: #000000;">(</span>obj<span style="color: #dd22dd;">[</span><span style="color: #3548cf;">"hello"</span><span style="color: #dd22dd;">]</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">world</span>
</pre>
</div></li>
</ul></li>
<li>Typescript里面,如果想传入object的这个key,那么最先想到的是把key声明为stirng类型,但是我们会看到,这样
口子开太大了,不存在的字符串也可以传递进来. 所以编译不成功
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">Ratings</span> <span style="color: #000000;">{</span>
  audience: <span style="color: #531ab6;">number</span>;
  critics: <span style="color: #531ab6;">number</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">function</span> <span style="color: #721045;">getRating</span><span style="color: #000000;">(</span><span style="color: #005e8b;">ratings</span>: <span style="color: #005f5f;">Ratings</span>, <span style="color: #005e8b;">key</span>: <span style="color: #531ab6;">string</span><span style="color: #000000;">)</span>: <span style="color: #531ab6;">number</span> <span style="color: #000000;">{</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:7:10 - error TS7053: Element implicitly has an 'any' type because expression of type 'string' can't be used to index type 'Ratings'.</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">No index signature with a parameter of type 'string' was found on type 'Ratings'.</span>

  <span style="color: #7f0000;">//////////////////////////</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">return ratings[key]; //</span>
  <span style="color: #7f0000;">//////////////////////////</span>
  <span style="color: #531ab6;">return</span> 1;
<span style="color: #000000;">}</span>
</pre>
</div></li>
<li><p>
从编译报错来看,我们最容易的改动方法,就是使用union of literal (使用那些允许的key)
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">Ratings</span> <span style="color: #000000;">{</span>
  audience: <span style="color: #531ab6;">number</span>;
  critics: <span style="color: #531ab6;">number</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">function</span> <span style="color: #721045;">getRating</span><span style="color: #000000;">(</span><span style="color: #005e8b;">ratings</span>: <span style="color: #005f5f;">Ratings</span>, <span style="color: #005e8b;">key</span>: <span style="color: #3548cf;">"audience"</span> | <span style="color: #3548cf;">"critics"</span><span style="color: #000000;">)</span>: <span style="color: #531ab6;">number</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> ratings<span style="color: #dd22dd;">[</span>key<span style="color: #dd22dd;">]</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">ratings</span>: <span style="color: #005f5f;">Ratings</span> = <span style="color: #000000;">{</span> audience: 66, critics: 86 <span style="color: #000000;">}</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span><span style="color: #721045;">getRating</span><span style="color: #dd22dd;">(</span>ratings, <span style="color: #3548cf;">"audience"</span><span style="color: #dd22dd;">)</span><span style="color: #000000;">)</span>;


<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:13:32 - error TS2345: Argument of type '"not valid"' is not assignable to parameter of type '"audience" | "critics"'.</span>

<span style="color: #7f0000;">///////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">console.</span><span style="color: #721045;">log</span><span style="color: #7f0000;">(getRating(ratings, "not valid")); //</span>
<span style="color: #7f0000;">///////////////////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
<li>union of literal的问题,是如果合理的literal有成千上万个,那么我们就不可能一一列出来,所以Typescript发明了一个语法糖来返回union of all the keys allowed on the type
<ul class="org-ul">
<li><p>
示例代码如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">Ratings</span> <span style="color: #000000;">{</span>
  audience: <span style="color: #531ab6;">number</span>;
  critics: <span style="color: #531ab6;">number</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">function</span> <span style="color: #721045;">getRating</span><span style="color: #000000;">(</span><span style="color: #005e8b;">ratings</span>: <span style="color: #005f5f;">Ratings</span>, <span style="color: #005e8b;">key</span>: <span style="color: #531ab6;">keyof</span> Ratings<span style="color: #000000;">)</span>: <span style="color: #531ab6;">number</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> ratings<span style="color: #dd22dd;">[</span>key<span style="color: #dd22dd;">]</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">ratings</span>: <span style="color: #005f5f;">Ratings</span> = <span style="color: #000000;">{</span> audience: 66, critics: 86 <span style="color: #000000;">}</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span><span style="color: #721045;">getRating</span><span style="color: #dd22dd;">(</span>ratings, <span style="color: #3548cf;">"audience"</span><span style="color: #dd22dd;">)</span><span style="color: #000000;">)</span>;


<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:13:32 - error TS2345: Argument of type '"not valid"' is not assignable to parameter of type '"audience" | "critics"'.</span>

<span style="color: #7f0000;">///////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">console.</span><span style="color: #721045;">log</span><span style="color: #7f0000;">(getRating(ratings, "not valid")); //</span>
<span style="color: #7f0000;">///////////////////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org14f2d32" class="outline-4">
<h4 id="org14f2d32"><span class="section-number-4">9.3.2.</span> typeof</h4>
<div class="outline-text-4" id="text-9-3-2">
<ul class="org-ul">
<li>有些情况下,某些value的type是非常难以书写的(或者手写很难写对),Typescript提供了一个语法糖来直接获得某个value的type
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">original</span> = <span style="color: #000000;">{</span>
  medium: <span style="color: #3548cf;">"movie"</span>,
  title: <span style="color: #3548cf;">"Mean Girls"</span>,
<span style="color: #000000;">}</span>;

<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">adaptation</span>: <span style="color: #531ab6;">typeof</span> original;

<span style="color: #531ab6;">if</span> <span style="color: #000000;">(</span>Math.<span style="color: #721045;">random</span><span style="color: #dd22dd;">()</span> &gt; 0.5<span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  adaptation = <span style="color: #dd22dd;">{</span> ...original, medium: <span style="color: #3548cf;">"play"</span> <span style="color: #dd22dd;">}</span>;
<span style="color: #000000;">}</span> <span style="color: #531ab6;">else</span> <span style="color: #000000;">{</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:11:31 - error TS2322: Type 'number' is not assignable to type 'string'.</span>
  <span style="color: #7f0000;">//////////////////////////////////////////////</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">adaptation = { ...original, medium: 2 }; //</span>
  <span style="color: #7f0000;">//////////////////////////////////////////////</span>
<span style="color: #000000;">}</span>
</pre>
</div></li>
</ul></li>

<li>注意!typeof在Typescript和Javascript里面的区别:
<ul class="org-ul">
<li>TypeScript里面的typeof是一个compile time的概念, Typescript的typeof只在type里面有效,编译成javascript
后就消失</li>
<li><p>
Javascript里面的typeof是一个runtime的概念,其在runtime返回一个字符串
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span><span style="color: #531ab6;">typeof</span> 32<span style="color: #000000;">)</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span><span style="color: #531ab6;">typeof</span> <span style="color: #0000b0;">true</span><span style="color: #000000;">)</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span><span style="color: #531ab6;">typeof</span> <span style="color: #3548cf;">"hello"</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">number</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">boolean</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">string</span>
</pre>
</div></li>
</ul></li>
<li>keyof和typeof还可以联合起来使用,对于没有明确interface type的value来说,这能节省大量的书写工作.而且
能跟着value内容改变而改变,无需手动更新.
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">ratings</span> = <span style="color: #000000;">{</span>
  imdb: 8.8,
  metacritic: 82,
<span style="color: #000000;">}</span>;

<span style="color: #531ab6;">function</span> <span style="color: #721045;">logRating</span><span style="color: #000000;">(</span><span style="color: #005e8b;">key</span>: <span style="color: #531ab6;">keyof</span> <span style="color: #531ab6;">typeof</span> ratings<span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #dd22dd;">(</span>ratings<span style="color: #008899;">[</span>key<span style="color: #008899;">]</span><span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>

<span style="color: #721045;">logRating</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"imdb"</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">8.8</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:11:11 - error TS2345: Argument of type '"invalid"' is not assignable to parameter of type '"imdb" | "metacritic"'.</span>

<span style="color: #7f0000;">///////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">logRating("invalid"); //</span>
<span style="color: #7f0000;">///////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org0686fb0" class="outline-3">
<h3 id="org0686fb0"><span class="section-number-3">9.4.</span> Type Assertions</h3>
<div class="outline-text-3" id="text-9-4">
<ul class="org-ul">
<li>有些情况下,代码开发者比编译器更加了解类型的时候(比如JSON.parse就只能将类型全部设置为any),可以强制"断言"类型,也就是type assertion</li>
<li>type assertion有两种形式:
<ul class="org-ul">
<li><p>
尖括号语法(因为可能与jsx相冲突,已经不推荐使用)
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">someValue</span>: <span style="color: #531ab6;">any</span> = <span style="color: #3548cf;">"this is a string"</span>;
<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">strLength</span>: <span style="color: #531ab6;">number</span> = <span style="color: #000000;">(</span>&lt;<span style="color: #531ab6;">string</span>&gt;someValue<span style="color: #000000;">)</span>.length;
</pre>
</div></li>
<li><p>
as语法
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">someValue</span>: <span style="color: #531ab6;">any</span> = <span style="color: #3548cf;">"this is a string"</span>;
<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">strLength</span>: <span style="color: #531ab6;">number</span> = <span style="color: #000000;">(</span>someValue <span style="color: #531ab6;">as</span> <span style="color: #531ab6;">string</span><span style="color: #000000;">)</span>.length;
</pre>
</div></li>
</ul></li>
<li>Typescript的最佳实践就是:能不用type assertion就不要用type assertion,尽量fully type,从而让Typescript来全盘理解类型</li>
</ul>
</div>
<div id="outline-container-orgc957515" class="outline-4">
<h4 id="orgc957515"><span class="section-number-4">9.4.1.</span> Asserting Caught Error Types</h4>
<div class="outline-text-4" id="text-9-4-1">
<ul class="org-ul">
<li>error handling是可能用到type assertion的地方
<ul class="org-ul">
<li><p>
比如你很确信,只会抛出Error类型的错误,那么你可以这么写
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">try</span> <span style="color: #000000;">{</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">(code that may throw an error)</span>
<span style="color: #000000;">}</span> <span style="color: #531ab6;">catch</span> <span style="color: #000000;">(</span>error<span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">warn</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">"Oh no !"</span>, <span style="color: #008899;">(</span>error <span style="color: #531ab6;">as</span> Error<span style="color: #008899;">)</span>.message<span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>
</pre>
</div></li>
<li><p>
但是其实还有更好的办法,就是使用instanceof来判断类型,进而调用Error的message
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">try</span> <span style="color: #000000;">{</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">(code that may throw an error)</span>
<span style="color: #000000;">}</span> <span style="color: #531ab6;">catch</span> <span style="color: #000000;">(</span>error<span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">warn</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">"Oh no !"</span>, error <span style="color: #531ab6;">instanceof</span> <span style="color: #005f5f;">Error</span> ? error.message : error<span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org65d1d1b" class="outline-4">
<h4 id="org65d1d1b"><span class="section-number-4">9.4.2.</span> Non-Null Assertions</h4>
<div class="outline-text-4" id="text-9-4-2">
<ul class="org-ul">
<li>另外一种可能用到type assertion的情况,是我们要把一个variable里面的null(undefined)去掉. 这种通常null
(and/or undefined)只在理论上存在,实际业务逻辑上不可能存在,所以我们就要去掉
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">maybeDate</span> = Math.<span style="color: #721045;">random</span><span style="color: #000000;">()</span> &gt; 0.5 ? <span style="color: #005e8b;">undefined</span> : <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Date</span><span style="color: #000000;">()</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Asserted type: Date</span>
maybeDate <span style="color: #531ab6;">as</span> Date;
</pre>
</div></li>
<li><p>
由于去掉null and /or undefined如此的常用,Typescript增加了一个"后缀!"语法糖 (也就是Non-null assertion)
来专门去掉null和undefind,下面代码和上面的代码等价
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">maybeDate</span> = Math.<span style="color: #721045;">random</span><span style="color: #000000;">()</span> &gt; 0.5 ? <span style="color: #005e8b;">undefined</span> : <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Date</span><span style="color: #000000;">()</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">same with: maybeDate as Date;</span>
maybeDate!;
</pre>
</div></li>
</ul></li>
<li>Non-null assertion对于Map.get来说非常有用,因为Map.get在key存在的时候返回value,不存在的时候返回undefined,
所以其返回类型是包含undefined的union
<ul class="org-ul">
<li><p>
使用non-null assertion就会让Map.get使用起来非常容易
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">seasonCounts</span> = <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Map</span><span style="color: #000000;">(</span><span style="color: #dd22dd;">[</span>
  <span style="color: #008899;">[</span><span style="color: #3548cf;">"I Love Lucy"</span>, <span style="color: #3548cf;">"abc"</span><span style="color: #008899;">]</span>,
  <span style="color: #008899;">[</span><span style="color: #3548cf;">"The Golden Girls"</span>, <span style="color: #3548cf;">"def"</span><span style="color: #008899;">]</span>,
<span style="color: #dd22dd;">]</span><span style="color: #000000;">)</span>;

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">maybeValue</span> = seasonCounts.<span style="color: #721045;">get</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"I Love Lucy"</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:12:13 - error TS18048: 'maybeValue' is possibly 'undefined'.</span>

<span style="color: #7f0000;">/////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">console.</span><span style="color: #721045;">log</span><span style="color: #7f0000;">(maybeValue.</span><span style="color: #721045;">toUpperCase</span><span style="color: #7f0000;">());  //</span>
<span style="color: #7f0000;">/////////////////////////////////////////////</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">knownValue</span> = seasonCounts.<span style="color: #721045;">get</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"I Love Lucy"</span><span style="color: #000000;">)</span>!;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>knownValue.<span style="color: #721045;">toUpperCase</span><span style="color: #dd22dd;">()</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">ABC</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org6171523" class="outline-4">
<h4 id="org6171523"><span class="section-number-4">9.4.3.</span> Type Assertin Caveats</h4>
<div class="outline-text-4" id="text-9-4-3">
<ul class="org-ul">
<li>和any一样,type assertion是Typescript的"逃生舱",换句话说,我们应该尽可能的避免使用他们,除非迫不得已</li>
<li>很多时候,我们的type assertion都是错误的:
<ul class="org-ul">
<li>要么在你写代码的时候已经错了</li>
<li>要么在后续漫长的代码维护过程中由于业务逻辑改变,之前正确的assertion也会变成错的了.</li>
</ul></li>
<li>Typescript只运行type assertion发生在这样两个type之间:"一个type可以assign给另一个type的",否则会报错
<ul class="org-ul">
<li><p>
示例如下, 在两个primitive直接assertion是不被允许的
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:1:15 - error TS2352: Conversion of type 'string' to type 'number' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first.</span>

<span style="color: #7f0000;">////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">let myValue = "Stella!" as number; //</span>
<span style="color: #7f0000;">////////////////////////////////////////</span>
</pre>
</div></li>
<li><p>
上面例子中提示我们,可以用先把myValue as成unknown,再as成number.虽然可以成功,但是这只是能编译成功而已,这是应该完全避免的写法
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">myValueDouble</span> = <span style="color: #3548cf;">"1337"</span> <span style="color: #531ab6;">as</span> <span style="color: #531ab6;">unknown</span> <span style="color: #531ab6;">as</span> <span style="color: #531ab6;">number</span>;
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org7cc0916" class="outline-3">
<h3 id="org7cc0916"><span class="section-number-3">9.5.</span> Const Assertions</h3>
<div class="outline-text-3" id="text-9-5">
<ul class="org-ul">
<li>虽然as不太推荐使用,但是as const却非常推荐使用,其作用总体上来说是让一个类型变成constant, immutable version
的它们自己,具体来说就是:
<ul class="org-ul">
<li><p>
array会被看成是reaonly tuple,而不再是mutable array
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#19968;&#20010;&#25968;&#32452;</span>
<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">colors</span> = <span style="color: #000000;">[</span><span style="color: #3548cf;">"red"</span>, <span style="color: #3548cf;">"green"</span>, <span style="color: #3548cf;">"blue"</span><span style="color: #000000;">]</span>;
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#40664;&#35748;&#24773;&#20917;&#19979;&#65292;TypeScript &#20250;&#25512;&#26029;&#20026; string[] &#31867;&#22411;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">colors &#30340;&#31867;&#22411;&#26159; (string[])</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#20351;&#29992; as const</span>
<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">colorsConst</span> = <span style="color: #000000;">[</span><span style="color: #3548cf;">"red"</span>, <span style="color: #3548cf;">"green"</span>, <span style="color: #3548cf;">"blue"</span><span style="color: #000000;">]</span> <span style="color: #531ab6;">as</span> <span style="color: #531ab6;">const</span>;
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#20351;&#29992; as const &#21518;&#65292;colorsConst &#30340;&#31867;&#22411;&#26159; readonly ["red", "green", "blue"]</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#31867;&#22411;&#21464;&#25104;&#20102;&#19968;&#20010;&#21482;&#35835;&#30340;&#20803;&#32452;&#65292;&#24182;&#19988;&#27599;&#20010;&#20803;&#32032;&#37117;&#20855;&#26377;&#20855;&#20307;&#30340;&#23383;&#38754;&#37327;&#31867;&#22411; "red", "green", "blue"</span>
</pre>
</div></li>
<li>literal会被认为是literal类型,而不是更加general的primitive类型(比如字符串"abc"会被认为是abc类型,
而不是string,这样能保证其只能被"abc"赋值,也就是readonly啦)</li>
<li>object的property变成了readonly</li>
</ul></li>
</ul>
</div>
<div id="outline-container-orgf6c0b4a" class="outline-4">
<h4 id="orgf6c0b4a"><span class="section-number-4">9.5.1.</span> Literals to Primitives</h4>
<div class="outline-text-4" id="text-9-5-1">
<ul class="org-ul">
<li>在Typescript中,literal通常会被推断为其对应的原始类型,比如"hello"会被推断为string,而不是literal类型
"hello",但是加了as const之后,就会被推断成"hello"类型了
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#19981;&#20351;&#29992; as const</span>
<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">greeting</span> = <span style="color: #3548cf;">"hello"</span>;
<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">example</span>: <span style="color: #531ab6;">typeof</span> greeting;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#25512;&#26029;&#31867;&#22411;&#20026; string&#65292;&#32780;&#19981;&#26159;&#20855;&#20307;&#30340; "hello"</span>
example = <span style="color: #3548cf;">"hello"</span>;              <span style="color: #7f0000;">// </span><span style="color: #7f0000;">ok</span>
example = <span style="color: #3548cf;">"world"</span>;              <span style="color: #7f0000;">// </span><span style="color: #7f0000;">ok</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#20351;&#29992; as const</span>
<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">greetingConst</span> = <span style="color: #3548cf;">"hello"</span> <span style="color: #531ab6;">as</span> <span style="color: #531ab6;">const</span>;
<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">exampleConst</span>: <span style="color: #531ab6;">typeof</span> greetingConst;

exampleConst = <span style="color: #3548cf;">"hello"</span>;
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:7:1 - error TS2322: Type '"world"' is not assignable to type '"hello"'.</span>

<span style="color: #7f0000;">/////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">exampleConst = "world"; //</span>
<span style="color: #7f0000;">/////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgbef7bc9" class="outline-4">
<h4 id="orgbef7bc9"><span class="section-number-4">9.5.2.</span> Read-Only Objects</h4>
<div class="outline-text-4" id="text-9-5-2">
<ul class="org-ul">
<li>我们一旦在object定义的时候加上as const,那么相当于给object的所有成员都加上as const
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">describePreference</span><span style="color: #000000;">(</span><span style="color: #005e8b;">preference</span>: <span style="color: #3548cf;">"maybe"</span> | <span style="color: #3548cf;">"no"</span> | <span style="color: #3548cf;">"yes"</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">switch</span> <span style="color: #dd22dd;">(</span>preference<span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">case</span> <span style="color: #3548cf;">"maybe"</span>:
      <span style="color: #531ab6;">return</span> <span style="color: #3548cf;">"I suppose..."</span>;
    <span style="color: #531ab6;">case</span> <span style="color: #3548cf;">"no"</span>:
      <span style="color: #531ab6;">return</span> <span style="color: #3548cf;">"No thanks."</span>;
    <span style="color: #531ab6;">case</span> <span style="color: #3548cf;">"yes"</span>:
      <span style="color: #531ab6;">return</span> <span style="color: #3548cf;">"Yes please !"</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">preferencesMutable</span> = <span style="color: #000000;">{</span>
  movie: <span style="color: #3548cf;">"maybe"</span>,
  standup: <span style="color: #3548cf;">"yes"</span>,
<span style="color: #000000;">}</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:18:20 - error TS2345: Argument of type 'string' is not assignable to parameter of type '"maybe" | "no" | "yes"'.</span>

<span style="color: #7f0000;">///////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">describePreference(preferencesMutable.movie); //</span>
<span style="color: #7f0000;">///////////////////////////////////////////////////</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">preferencesReadonly</span> = <span style="color: #000000;">{</span>
  movie: <span style="color: #3548cf;">"maybe"</span>,
  standup: <span style="color: #3548cf;">"yes"</span>,
<span style="color: #000000;">}</span> <span style="color: #531ab6;">as</span> <span style="color: #531ab6;">const</span>;

<span style="color: #721045;">describePreference</span><span style="color: #000000;">(</span>preferencesReadonly.movie<span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:30:21 - error TS2540: Cannot assign to 'movie' because it is a read-only property.</span>

<span style="color: #7f0000;">//////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">preferencesReadonly.movie = "new value"; //</span>
<span style="color: #7f0000;">//////////////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-orgb16f4d5" class="outline-2">
<h2 id="orgb16f4d5"><span class="section-number-2">10.</span> Chapter 10: Generics</h2>
<div class="outline-text-2" id="text-10">
<ul class="org-ul">
<li>前面我们所有的讨论,都是基于在写代码的时候,类型是确定好的.</li>
<li>但是也有某些情况,我们在写代码的时候不知道具体类型是什么(可能只知道比如输入和输出是同一种类型)</li>
<li>Javascript使用如下代码来允许所有类型的输入和输出
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">identity</span><span style="color: #000000;">(</span><span style="color: #005e8b;">input</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> input;
<span style="color: #000000;">}</span>

console.log<span style="color: #000000;">(</span>identity<span style="color: #dd22dd;">(</span><span style="color: #3548cf;">"abc"</span><span style="color: #dd22dd;">)</span><span style="color: #000000;">)</span>;
console.log<span style="color: #000000;">(</span>identity<span style="color: #dd22dd;">(</span>123<span style="color: #dd22dd;">)</span><span style="color: #000000;">)</span>;
console.log<span style="color: #000000;">(</span>identity<span style="color: #dd22dd;">(</span><span style="color: #008899;">{</span> quote: <span style="color: #3548cf;">"hello"</span> <span style="color: #008899;">}</span><span style="color: #dd22dd;">)</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">abc</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">123</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">{ quote: 'hello' }</span>
</pre>
</div></li>
</ul></li>
<li>对应的,typescript可以使用any来表示输入和输出是任意类型
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">identity</span><span style="color: #000000;">(</span><span style="color: #005e8b;">input</span>: <span style="color: #531ab6;">any</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> input;
<span style="color: #000000;">}</span>

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span><span style="color: #721045;">identity</span><span style="color: #dd22dd;">(</span>32<span style="color: #dd22dd;">)</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">32</span>
</pre>
</div></li>
<li><p>
上面的例子显然和Javascript例子,没有什么区别.我们没有能够把握住输入类型和输出类型的关系(在这个例子
中是相同的类型)
</p>
<pre class="example" id="org36ce43a">
Given that input is allowed to be any input, we need a way to say that
there is a relationship between the input type and the type the function
returns.
</pre></li>
<li>在Typescript中,能够把握住这种关系的方法,叫做泛型</li>
</ul></li>
<li>Typescript的泛型通常会有type parameter,一般使用
<ul class="org-ul">
<li>单个字母比如T,U</li>
<li>驼峰单词,比如Key,Value</li>
</ul></li>
<li>注意!上述这种占位符是Type Parameter,而实例化的时候提供的具体类型就是Type Argument
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">CrateLike</span>&lt;<span style="color: #005f5f;">T</span>&gt; <span style="color: #000000;">{</span>
  contents: T;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">missingGeneric</span>: <span style="color: #005f5f;">CrateLike</span>&lt;<span style="color: #531ab6;">string</span>&gt; = <span style="color: #000000;">{</span>
  contents: <span style="color: #3548cf;">""</span>,
<span style="color: #000000;">}</span>;
</pre>
</div></li>

<li>上面例子中的T就是type parameter</li>
<li>上面例子中的string就是type argument</li>
</ul></li>
</ul>
</div>
<div id="outline-container-org0012ebc" class="outline-3">
<h3 id="org0012ebc"><span class="section-number-3">10.1.</span> Generic Functions</h3>
<div class="outline-text-3" id="text-10-1">
<ul class="org-ul">
<li>泛型最常见的场景就是函数了,需要在原来的函数里面,多处加上type parameter
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">identity</span>&lt;<span style="color: #005f5f;">T</span>&gt;<span style="color: #000000;">(</span><span style="color: #005e8b;">input</span>: T<span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> input;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">numeric</span> = <span style="color: #721045;">identity</span><span style="color: #000000;">(</span>123<span style="color: #000000;">)</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>numeric<span style="color: #000000;">)</span>;
<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">stringy</span> = <span style="color: #721045;">identity</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"me"</span><span style="color: #000000;">)</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>stringy<span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">123</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">me</span>
</pre>
</div></li>
<li><p>
arrow版本的示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">identity</span> = &lt;T&gt;<span style="color: #000000;">(</span>input: T<span style="color: #000000;">)</span> <span style="color: #531ab6;">=&gt;</span> input;

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">numeric</span> = <span style="color: #721045;">identity</span><span style="color: #000000;">(</span>123<span style="color: #000000;">)</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>numeric<span style="color: #000000;">)</span>;
<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">stringy</span> = <span style="color: #721045;">identity</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"me"</span><span style="color: #000000;">)</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>stringy<span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">123</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">me</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
<div id="outline-container-orgc8c2db4" class="outline-4">
<h4 id="orgc8c2db4"><span class="section-number-4">10.1.1.</span> Explicit Generic Call Types</h4>
<div class="outline-text-4" id="text-10-1-1">
<ul class="org-ul">
<li>绝大部分情况下,Typescript都可以通过你的输入来确认我们的T,U到底是什么类型,但是极个别情况却不可以.比
如参数是一个callback,callback的参数也是T,U,这种情况下,有两种方式来让TypeScript正常运行:
<ul class="org-ul">
<li><p>
明确callback的参数,比如下面例子中,明确其为string,否则Typescript无法infer
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">logWrapper</span>&lt;<span style="color: #005f5f;">Input</span>&gt;<span style="color: #000000;">(</span><span style="color: #005e8b;">callback</span>: <span style="color: #dd22dd;">(</span><span style="color: #005e8b;">input</span>: <span style="color: #005f5f;">Input</span><span style="color: #dd22dd;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #531ab6;">void</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">"inside logWrapper"</span><span style="color: #dd22dd;">)</span>;
  <span style="color: #531ab6;">return</span> <span style="color: #dd22dd;">(</span><span style="color: #005e8b;">input</span>: <span style="color: #005f5f;">Input</span><span style="color: #dd22dd;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #3548cf;">"Input:"</span>, input<span style="color: #008899;">)</span>;
    <span style="color: #721045;">callback</span><span style="color: #008899;">(</span>input<span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">lw</span> = <span style="color: #721045;">logWrapper</span><span style="color: #000000;">(</span><span style="color: #dd22dd;">(</span><span style="color: #005e8b;">input</span>: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #dd22dd;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span>input.length<span style="color: #008899;">)</span>;
<span style="color: #dd22dd;">}</span><span style="color: #000000;">)</span>;

<span style="color: #721045;">lw</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"abc"</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">inside logWrapper</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Input: abc</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">3</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:21:15 - error TS18046: 'input' is of type 'unknown'.</span>

<span style="color: #7f0000;">//////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">logWrapper((</span><span style="color: #005e8b;">input</span><span style="color: #7f0000;">) =&gt; {      //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">console.</span><span style="color: #721045;">log</span><span style="color: #7f0000;">(input.length); //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">});                          //</span>
<span style="color: #7f0000;">//////////////////////////////////</span>
</pre>
</div></li>
<li><p>
明确T,U的类型,比如下面例子中的做法
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">logWrapper</span>&lt;<span style="color: #005f5f;">Input</span>&gt;<span style="color: #000000;">(</span><span style="color: #005e8b;">callback</span>: <span style="color: #dd22dd;">(</span><span style="color: #005e8b;">input</span>: <span style="color: #005f5f;">Input</span><span style="color: #dd22dd;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #531ab6;">void</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">"inside logWrapper"</span><span style="color: #dd22dd;">)</span>;
  <span style="color: #531ab6;">return</span> <span style="color: #dd22dd;">(</span><span style="color: #005e8b;">input</span>: <span style="color: #005f5f;">Input</span><span style="color: #dd22dd;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #3548cf;">"Input:"</span>, input<span style="color: #008899;">)</span>;
    <span style="color: #721045;">callback</span><span style="color: #008899;">(</span>input<span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">lw</span> = <span style="color: #721045;">logWrapper</span>&lt;<span style="color: #005f5f;">String</span>&gt;<span style="color: #000000;">(</span><span style="color: #dd22dd;">(</span><span style="color: #005e8b;">input</span><span style="color: #dd22dd;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #dd22dd;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span>input.length<span style="color: #008899;">)</span>;
<span style="color: #dd22dd;">}</span><span style="color: #000000;">)</span>;

<span style="color: #721045;">lw</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"abc"</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">inside logWrapper</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Input: abc</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">3</span>
</pre>
</div></li>
</ul></li>
<li>明确T,U的类型的情况下,如果传入和明确的不一样,也会报警
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">logWrapper</span>&lt;<span style="color: #005f5f;">Input</span>&gt;<span style="color: #000000;">(</span><span style="color: #005e8b;">callback</span>: <span style="color: #dd22dd;">(</span><span style="color: #005e8b;">input</span>: <span style="color: #005f5f;">Input</span><span style="color: #dd22dd;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #531ab6;">void</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">"inside logWrapper"</span><span style="color: #dd22dd;">)</span>;
  <span style="color: #531ab6;">return</span> <span style="color: #dd22dd;">(</span><span style="color: #005e8b;">input</span>: <span style="color: #005f5f;">Input</span><span style="color: #dd22dd;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #3548cf;">"Input:"</span>, input<span style="color: #008899;">)</span>;
    <span style="color: #721045;">callback</span><span style="color: #008899;">(</span>input<span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span>;
<span style="color: #000000;">}</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:9:31 - error TS2345: Argument of type '(input: boolean) =&gt; void' is not assignable to parameter of type '(input: String) =&gt; void'.</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">Types of parameters 'input' and 'input' are incompatible.</span>
<span style="color: #7f0000;">//     </span><span style="color: #7f0000;">Type 'String' is not assignable to type 'boolean'.</span>

<span style="color: #7f0000;">/////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">const lw = logWrapper&lt;String&gt;((</span><span style="color: #005e8b;">input</span><span style="color: #7f0000;">: boolean) =&gt; { //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">console.</span><span style="color: #721045;">log</span><span style="color: #7f0000;">(input.length);                        //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">});                                                 //</span>
<span style="color: #7f0000;">/////////////////////////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
<li>明确T,U的类型,只是一种辅助手段,除非TypeScript自己抱怨了infer不出类型,我们不要主动使用这种方法</li>
</ul>
</div>
</div>
<div id="outline-container-orgd86c56b" class="outline-4">
<h4 id="orgd86c56b"><span class="section-number-4">10.1.2.</span> Multiple Function Type Parameters</h4>
<div class="outline-text-4" id="text-10-1-2">
<ul class="org-ul">
<li>我们可以在代码中使用任意个数的type parameter(但是最佳实践是最多两个,因为太多了代码太难以理解)
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">makeTuple</span>&lt;<span style="color: #005f5f;">First</span>, <span style="color: #005f5f;">Second</span>&gt;<span style="color: #000000;">(</span><span style="color: #005e8b;">first</span>: <span style="color: #005f5f;">First</span>, <span style="color: #005e8b;">second</span>: <span style="color: #005f5f;">Second</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> <span style="color: #dd22dd;">[</span>first, second<span style="color: #dd22dd;">]</span> <span style="color: #531ab6;">as</span> <span style="color: #531ab6;">const</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">tuple</span> = <span style="color: #721045;">makeTuple</span><span style="color: #000000;">(</span><span style="color: #0000b0;">true</span>, <span style="color: #3548cf;">"abc"</span><span style="color: #000000;">)</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>tuple<span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">[ true, 'abc' ]</span>
</pre>
</div></li>
</ul></li>

<li>一旦使用了多个type parameter:
<ul class="org-ul">
<li><p>
要么全部都不explicit的说明
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">makePair</span>&lt;<span style="color: #005f5f;">Key</span>, <span style="color: #005f5f;">Value</span>&gt;<span style="color: #000000;">(</span><span style="color: #005e8b;">key</span>: <span style="color: #005f5f;">Key</span>, <span style="color: #005e8b;">value</span>: <span style="color: #005f5f;">Value</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> <span style="color: #dd22dd;">{</span> key, value <span style="color: #dd22dd;">}</span>;
<span style="color: #000000;">}</span>

<span style="color: #721045;">makePair</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"abc"</span>, 123<span style="color: #000000;">)</span>;
</pre>
</div></li>
<li><p>
要么全部都explicit的说明, 这种也是有可能的,比如下例中,如果你不写,编译器肯定推断为&lt;string, number&gt;
但是如果你想要更加精细的literal类型,那么你就要自己explicit的写出来.
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">makePair</span>&lt;<span style="color: #005f5f;">Key</span>, <span style="color: #005f5f;">Value</span>&gt;<span style="color: #000000;">(</span><span style="color: #005e8b;">key</span>: <span style="color: #005f5f;">Key</span>, <span style="color: #005e8b;">value</span>: <span style="color: #005f5f;">Value</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> <span style="color: #dd22dd;">{</span> key, value <span style="color: #dd22dd;">}</span>;
<span style="color: #000000;">}</span>

<span style="color: #721045;">makePair</span>&lt;<span style="color: #531ab6;">string</span>, <span style="color: #531ab6;">number</span>&gt;<span style="color: #000000;">(</span><span style="color: #3548cf;">"abc"</span>, 123<span style="color: #000000;">)</span>;
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;&gt;&#37324;&#38754;&#30340;"abc"&#26159;string literal &#31867;&#22411;, &lt;&gt;&#37324;&#38754;&#30340;123&#26159;number literal&#31867;&#22411;</span>
<span style="color: #721045;">makePair</span>&lt;<span style="color: #3548cf;">"abc"</span>, 123&gt;<span style="color: #000000;">(</span><span style="color: #3548cf;">"abc"</span>, 123<span style="color: #000000;">)</span>;
</pre>
</div></li>
<li><p>
只说明一部分的话,Typescript是无法理解的
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">makePair</span>&lt;<span style="color: #005f5f;">Key</span>, <span style="color: #005f5f;">Value</span>&gt;<span style="color: #000000;">(</span><span style="color: #005e8b;">key</span>: <span style="color: #005f5f;">Key</span>, <span style="color: #005e8b;">value</span>: <span style="color: #005f5f;">Value</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> <span style="color: #dd22dd;">{</span> key, value <span style="color: #dd22dd;">}</span>;
<span style="color: #000000;">}</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:5:10 - error TS2558: Expected 2 type arguments, but got 1.</span>

<span style="color: #7f0000;">///////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">makePair&lt;string&gt;("abc", 123); //</span>
<span style="color: #7f0000;">///////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org32864cd" class="outline-3">
<h3 id="org32864cd"><span class="section-number-3">10.2.</span> Generic Interface</h3>
<div class="outline-text-3" id="text-10-2">
<ul class="org-ul">
<li>Typescript的interface也可以使用泛型,type parameter用来为interface内部的成员声明类型
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">Box</span>&lt;<span style="color: #005f5f;">T</span>&gt; <span style="color: #000000;">{</span>
  inside: T;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">stringyBox</span>: <span style="color: #005f5f;">Box</span>&lt;<span style="color: #531ab6;">string</span>&gt; = <span style="color: #000000;">{</span>
  inside: <span style="color: #3548cf;">"abc"</span>,
<span style="color: #000000;">}</span>;

<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">numberBox</span>: <span style="color: #005f5f;">Box</span>&lt;<span style="color: #531ab6;">number</span>&gt; = <span style="color: #000000;">{</span>
  inside: 123,
<span style="color: #000000;">}</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:14:3 - error TS2322: Type 'boolean' is not assignable to type 'number'.</span>

<span style="color: #7f0000;">///////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">let incorrectBox: Box&lt;number&gt; = { //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">inside: false,                  //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">};                                //</span>
<span style="color: #7f0000;">///////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
<li>Typescript内置的Array method就是定义在TypeScript里面作为generic interface
<ul class="org-ul">
<li><p>
具体源代码精简如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">Array</span>&lt;<span style="color: #005f5f;">T</span>&gt; <span style="color: #000000;">{</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">...</span>
  <span style="color: #721045;">pop</span><span style="color: #dd22dd;">()</span>: T | <span style="color: #0000b0;">undefined</span>;

  <span style="color: #721045;">push</span><span style="color: #dd22dd;">(</span>...<span style="color: #005e8b;">items</span>: T<span style="color: #008899;">[]</span><span style="color: #dd22dd;">)</span>: <span style="color: #531ab6;">number</span>;
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">...</span>
<span style="color: #000000;">}</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
<div id="outline-container-org6e2318d" class="outline-4">
<h4 id="org6e2318d"><span class="section-number-4">10.2.1.</span> Inferred Generic Interface Types</h4>
<div class="outline-text-4" id="text-10-2-1">
<ul class="org-ul">
<li>就像generic function一样, generic interface也可以尽可能的infer类型
<ul class="org-ul">
<li><p>
示例如下,编译器能察觉是否有足够的函数,已经类型是否匹配
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">LinkedNode</span>&lt;<span style="color: #005f5f;">Value</span>&gt; <span style="color: #000000;">{</span>
  next?: <span style="color: #005f5f;">LinkedNode</span>&lt;<span style="color: #005f5f;">Value</span>&gt;;
  value: <span style="color: #005f5f;">Value</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">function</span> <span style="color: #721045;">getLast</span>&lt;<span style="color: #005f5f;">Value</span>&gt;<span style="color: #000000;">(</span><span style="color: #005e8b;">node</span>: <span style="color: #005f5f;">LinkedNode</span>&lt;<span style="color: #005f5f;">Value</span>&gt;<span style="color: #000000;">)</span>: <span style="color: #005f5f;">Value</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> node.next ? <span style="color: #721045;">getLast</span><span style="color: #dd22dd;">(</span>node.next<span style="color: #dd22dd;">)</span> : node.value;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">lastDate</span> = <span style="color: #721045;">getLast</span><span style="color: #000000;">(</span><span style="color: #dd22dd;">{</span>
  value: <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Date</span><span style="color: #008899;">(</span><span style="color: #3548cf;">"09-13-1993"</span><span style="color: #008899;">)</span>,
<span style="color: #dd22dd;">}</span><span style="color: #000000;">)</span>;

<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">lastFruit</span> = <span style="color: #721045;">getLast</span><span style="color: #000000;">(</span><span style="color: #dd22dd;">{</span>
  next: <span style="color: #008899;">{</span>
    value: <span style="color: #3548cf;">"banana"</span>,
  <span style="color: #008899;">}</span>,
  value: <span style="color: #3548cf;">"apple"</span>,
<span style="color: #dd22dd;">}</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:25:3 - error TS2322: Type 'boolean' is not assignable to type 'number'.</span>

<span style="color: #7f0000;">//////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">let lastMismatch = getLast({ //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">next: {                    //</span>
<span style="color: #7f0000;">//     </span><span style="color: #7f0000;">value: 123,              //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">},                         //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">value: false,              //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">});                          //</span>
<span style="color: #7f0000;">//////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
<li>如果generic interface声明定义里面包含type parameter,那么所有使用到这个interface的type annotation必
须要传递type argument
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">CrateLike</span>&lt;<span style="color: #005f5f;">T</span>&gt; <span style="color: #000000;">{</span>
  contents: T;
<span style="color: #000000;">}</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:5:21 - error TS2314: Generic type 'CrateLike&lt;T&gt;' requires 1 type argument(s).</span>

<span style="color: #7f0000;">///////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">let missingGeneric: CrateLike = { //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">inside: "",                     //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">};                                //</span>
<span style="color: #7f0000;">///////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgc28bfec" class="outline-3">
<h3 id="orgc28bfec"><span class="section-number-3">10.3.</span> Generic Classes</h3>
<div class="outline-text-3" id="text-10-3">
<ul class="org-ul">
<li>和function, interface一样,class也可以使用type parameter
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">Secret</span>&lt;<span style="color: #005f5f;">Key</span>, <span style="color: #005f5f;">Value</span>&gt; <span style="color: #000000;">{</span>
  key: <span style="color: #005f5f;">Key</span>;
  value: <span style="color: #005f5f;">Value</span>;

  <span style="color: #531ab6;">constructor</span><span style="color: #dd22dd;">(</span>key: <span style="color: #005f5f;">Key</span>, value: <span style="color: #005f5f;">Value</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">this</span>.key = key;
    <span style="color: #531ab6;">this</span>.value = value;
  <span style="color: #dd22dd;">}</span>

  <span style="color: #721045;">getValue</span><span style="color: #dd22dd;">(</span><span style="color: #005e8b;">key</span>: <span style="color: #005f5f;">Key</span><span style="color: #dd22dd;">)</span>: <span style="color: #005f5f;">Value</span> | <span style="color: #0000b0;">undefined</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">return</span> <span style="color: #531ab6;">this</span>.key === key ? <span style="color: #531ab6;">this</span>.value : <span style="color: #0000b0;">undefined</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">storage</span> = <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Secret</span><span style="color: #000000;">(</span>12345, <span style="color: #3548cf;">"luggage"</span><span style="color: #000000;">)</span>;

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>storage.<span style="color: #721045;">getValue</span><span style="color: #dd22dd;">(</span>1987<span style="color: #dd22dd;">)</span><span style="color: #000000;">)</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>storage.<span style="color: #721045;">getValue</span><span style="color: #dd22dd;">(</span>12345<span style="color: #dd22dd;">)</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">undefined</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">luggage</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
<div id="outline-container-orgee5c18e" class="outline-4">
<h4 id="orgee5c18e"><span class="section-number-4">10.3.1.</span> Explicit Generic Class Types</h4>
<div class="outline-text-4" id="text-10-3-1">
<ul class="org-ul">
<li>实例化generic class的过程和调用generic function是一样的:
<ul class="org-ul">
<li>如果能够从参数判断出type argument,那么就不用type argument.</li>
<li>如果能够从参数不能判断出type argument,那么类型就是unknown,这时候需要提供type argument</li>
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">CurriedCallback</span>&lt;<span style="color: #005f5f;">Input</span>&gt; <span style="color: #000000;">{</span>
  #callback: <span style="color: #dd22dd;">(</span>input: <span style="color: #005f5f;">Input</span><span style="color: #dd22dd;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #531ab6;">void</span>;
  <span style="color: #531ab6;">constructor</span><span style="color: #dd22dd;">(</span>callback: <span style="color: #008899;">(</span>input: <span style="color: #005f5f;">Input</span><span style="color: #008899;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #531ab6;">void</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">this</span>.#callback = <span style="color: #008899;">(</span><span style="color: #005e8b;">input</span>: <span style="color: #005f5f;">Input</span><span style="color: #008899;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #008899;">{</span>
      <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #972500;">(</span><span style="color: #3548cf;">"Input"</span>, input<span style="color: #972500;">)</span>;
      <span style="color: #721045;">callback</span><span style="color: #972500;">(</span>input<span style="color: #972500;">)</span>;
    <span style="color: #008899;">}</span>;
  <span style="color: #dd22dd;">}</span>

  <span style="color: #721045;">call</span><span style="color: #dd22dd;">(</span><span style="color: #005e8b;">input</span>: <span style="color: #005f5f;">Input</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">this</span>.#<span style="color: #721045;">callback</span><span style="color: #008899;">(</span>input<span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">new</span> <span style="color: #005f5f;">CurriedCallback</span><span style="color: #000000;">(</span><span style="color: #dd22dd;">(</span><span style="color: #005e8b;">input</span>: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #dd22dd;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span>input.length<span style="color: #008899;">)</span>;
<span style="color: #dd22dd;">}</span><span style="color: #000000;">)</span>;

<span style="color: #531ab6;">new</span> <span style="color: #005f5f;">CurriedCallback</span>&lt;<span style="color: #531ab6;">string</span>&gt;<span style="color: #000000;">(</span><span style="color: #dd22dd;">(</span><span style="color: #005e8b;">input</span><span style="color: #dd22dd;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #dd22dd;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span>input.length<span style="color: #008899;">)</span>;
<span style="color: #dd22dd;">}</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:26:15 - error TS18046: 'input' is of type 'unknown'.</span>

<span style="color: #7f0000;">//////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">new CurriedCallback((</span><span style="color: #005e8b;">input</span><span style="color: #7f0000;">) =&gt; { //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">console.</span><span style="color: #721045;">log</span><span style="color: #7f0000;">(input.length)      //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">});                              //</span>
<span style="color: #7f0000;">//////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org0e0ccad" class="outline-4">
<h4 id="org0e0ccad"><span class="section-number-4">10.3.2.</span> Extending Generic Classes</h4>
<div class="outline-text-4" id="text-10-3-2">
<ul class="org-ul">
<li>在涉及到继承的时候,如果base class是generic的,那么编译器是不会去infer type argument的. 这时候,derived class有两种选择:
<ul class="org-ul">
<li><p>
要么,在base class里面使用明确的type argument(string[]),然后derived class来 extends这个实际上已经"实例化"了的generic base class
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">Quote</span>&lt;<span style="color: #005f5f;">T</span>&gt; <span style="color: #000000;">{</span>
  lines: T;
  <span style="color: #531ab6;">constructor</span><span style="color: #dd22dd;">(</span>lines: T<span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">this</span>.lines = lines;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">class</span> <span style="color: #005f5f;">SpokenQuote</span> <span style="color: #531ab6;">extends</span> <span style="color: #005f5f;">Quote</span>&lt;<span style="color: #531ab6;">string</span><span style="color: #000000;">[]</span>&gt; <span style="color: #000000;">{</span>
  <span style="color: #721045;">speak</span><span style="color: #dd22dd;">()</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #531ab6;">this</span>.lines.<span style="color: #721045;">join</span><span style="color: #972500;">(</span><span style="color: #3548cf;">"\n"</span><span style="color: #972500;">)</span><span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span><span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Quote</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">"The only one"</span><span style="color: #dd22dd;">)</span>.lines<span style="color: #000000;">)</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span><span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Quote</span><span style="color: #dd22dd;">(</span><span style="color: #008899;">[</span>8, 7, 5, 6<span style="color: #008899;">]</span><span style="color: #dd22dd;">)</span>.lines<span style="color: #000000;">)</span>;

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span><span style="color: #531ab6;">new</span> <span style="color: #005f5f;">SpokenQuote</span><span style="color: #dd22dd;">(</span><span style="color: #008899;">[</span><span style="color: #3548cf;">"Here I am"</span>, <span style="color: #3548cf;">"This is new"</span><span style="color: #008899;">]</span><span style="color: #dd22dd;">)</span>.lines<span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:19:18 - error TS2322: Type 'number' is not assignable to type 'string'.</span>

<span style="color: #7f0000;">//////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">new SpokenQuote([8, 7, 5, 6]).lines; //</span>
<span style="color: #7f0000;">//////////////////////////////////////////</span>
</pre>
</div></li>
<li><p>
或者,在base class里面使用derived class的type parameter(Value)
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">Quote</span>&lt;<span style="color: #005f5f;">T</span>&gt; <span style="color: #000000;">{</span>
  lines: T;
  <span style="color: #531ab6;">constructor</span><span style="color: #dd22dd;">(</span>lines: T<span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">this</span>.lines = lines;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">class</span> <span style="color: #005f5f;">AttributeQuote</span>&lt;<span style="color: #005f5f;">Value</span>&gt; <span style="color: #531ab6;">extends</span> <span style="color: #005f5f;">Quote</span>&lt;<span style="color: #005f5f;">Value</span>&gt; <span style="color: #000000;">{</span>
  speaker: <span style="color: #531ab6;">string</span>;

  <span style="color: #531ab6;">constructor</span><span style="color: #dd22dd;">(</span>value: <span style="color: #005f5f;">Value</span>, speaker: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">super</span><span style="color: #008899;">(</span>value<span style="color: #008899;">)</span>;
    <span style="color: #531ab6;">this</span>.speaker = speaker;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">aq</span> = <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">AttributeQuote</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Here I am"</span>, <span style="color: #3548cf;">"This is new"</span><span style="color: #000000;">)</span>;

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>aq.lines<span style="color: #000000;">)</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>aq.speaker<span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Here I am</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">This is new</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgae22724" class="outline-4">
<h4 id="orgae22724"><span class="section-number-4">10.3.3.</span> Implementing Generic Interfaces</h4>
<div class="outline-text-4" id="text-10-3-3">
<ul class="org-ul">
<li>就像derived class继承base class一样, class 实现generic interfae也是可以的.但是只有generic interface
提供type argument这一条路了.
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">ActingCredit</span>&lt;<span style="color: #005f5f;">Role</span>&gt; <span style="color: #000000;">{</span>
  role: <span style="color: #005f5f;">Role</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">class</span> <span style="color: #005f5f;">MoviePart</span> <span style="color: #531ab6;">implements</span> <span style="color: #005f5f;">ActingCredit</span>&lt;<span style="color: #531ab6;">string</span>&gt; <span style="color: #000000;">{</span>
  role: <span style="color: #531ab6;">string</span>;
  speaking: <span style="color: #531ab6;">boolean</span>;

  <span style="color: #531ab6;">constructor</span><span style="color: #dd22dd;">(</span>role: <span style="color: #531ab6;">string</span>, speaking: <span style="color: #531ab6;">boolean</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">this</span>.role = role;
    <span style="color: #531ab6;">this</span>.speaking = speaking;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">part</span> = <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">MoviePart</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Miranda Priestly"</span>, <span style="color: #0000b0;">true</span><span style="color: #000000;">)</span>;

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>part.role<span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:20:3 - error TS2416: Property 'role' in type 'IncorrectExtension' is not assignable to the same property in base type 'ActingCredit&lt;string&gt;'.</span>

<span style="color: #7f0000;">////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">class IncorrectExtension implements ActingCredit&lt;string&gt; { //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">role: boolean;                                           //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">}                                                          //</span>
<span style="color: #7f0000;">////////////////////////////////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org66e77a5" class="outline-4">
<h4 id="org66e77a5"><span class="section-number-4">10.3.4.</span> Method Generics</h4>
<div class="outline-text-4" id="text-10-3-4">
<ul class="org-ul">
<li>class method甚至可以设置自己的generic type(可以和class instance的generic type不一样)
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">CreatePairFactory</span>&lt;<span style="color: #005f5f;">Key</span>&gt; <span style="color: #000000;">{</span>
  key: <span style="color: #005f5f;">Key</span>;
  <span style="color: #531ab6;">constructor</span><span style="color: #dd22dd;">(</span>key: <span style="color: #005f5f;">Key</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">this</span>.key = key;
  <span style="color: #dd22dd;">}</span>

  <span style="color: #721045;">createPair</span>&lt;<span style="color: #005f5f;">Value</span>&gt;<span style="color: #dd22dd;">(</span><span style="color: #005e8b;">value</span>: <span style="color: #005f5f;">Value</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">return</span> <span style="color: #008899;">{</span> key: <span style="color: #531ab6;">this</span>.key, value <span style="color: #008899;">}</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">factory</span> = <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">CreatePairFactory</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"role"</span><span style="color: #000000;">)</span>;

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">numberPair</span> = factory.<span style="color: #721045;">createPair</span><span style="color: #000000;">(</span>10<span style="color: #000000;">)</span>;

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>numberPair<span style="color: #000000;">)</span>;

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">stringPair</span> = factory.<span style="color: #721045;">createPair</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Sophie"</span><span style="color: #000000;">)</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>stringPair<span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">{ key: 'role', value: 10 }</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">{ key: 'role', value: 'Sophie' }</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgdc3c94c" class="outline-4">
<h4 id="orgdc3c94c"><span class="section-number-4">10.3.5.</span> Static Class Generics</h4>
<div class="outline-text-4" id="text-10-3-5">
<ul class="org-ul">
<li>class的static member也可以拥有自己的type parameter,但是由于其无法访问instance member,所以其无法知道
instance的type parameter,它和class的联系并不紧密
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">BothLogger</span>&lt;<span style="color: #005f5f;">OnInstance</span>&gt; <span style="color: #000000;">{</span>
  <span style="color: #721045;">instanceLog</span><span style="color: #dd22dd;">(</span><span style="color: #005e8b;">value</span>: <span style="color: #005f5f;">OnInstance</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span>value<span style="color: #008899;">)</span>;
    <span style="color: #531ab6;">return</span> value;
  <span style="color: #dd22dd;">}</span>

  <span style="color: #531ab6;">static</span> <span style="color: #721045;">staticLog</span>&lt;<span style="color: #005f5f;">OnStatic</span>&gt;<span style="color: #dd22dd;">(</span><span style="color: #005e8b;">value</span>: <span style="color: #005f5f;">OnStatic</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:8:23 - error TS2302: Static members cannot reference class type parameters.</span>

    <span style="color: #7f0000;">///////////////////////////////////</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">let fromInstance: OnInstance; //</span>
    <span style="color: #7f0000;">///////////////////////////////////</span>

    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span>value<span style="color: #008899;">)</span>;
    <span style="color: #531ab6;">return</span> value;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">logger</span> = <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">BothLogger</span>&lt;<span style="color: #531ab6;">number</span><span style="color: #000000;">[]</span>&gt;<span style="color: #000000;">()</span>;
logger.<span style="color: #721045;">instanceLog</span><span style="color: #000000;">(</span><span style="color: #dd22dd;">[</span>1, 2, 3<span style="color: #dd22dd;">]</span><span style="color: #000000;">)</span>;

BothLogger.<span style="color: #721045;">staticLog</span><span style="color: #000000;">(</span><span style="color: #dd22dd;">[</span><span style="color: #0000b0;">false</span>, <span style="color: #0000b0;">true</span><span style="color: #dd22dd;">]</span><span style="color: #000000;">)</span>;

BothLogger.<span style="color: #721045;">staticLog</span>&lt;<span style="color: #531ab6;">string</span>&gt;<span style="color: #000000;">(</span><span style="color: #3548cf;">"You can't change the music of your soul"</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">[ 1, 2, 3 ]</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">[ false, true ]</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">You can't change the music of your soul</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org7b181dd" class="outline-3">
<h3 id="org7b181dd"><span class="section-number-3">10.4.</span> Generic Type Aliases</h3>
<div class="outline-text-3" id="text-10-4">
<ul class="org-ul">
<li>type alias后面还可以跟着type argument(具体类型),这可以用来处理一些typescript里面的需要和null, undefined打交道的情况
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">type</span> <span style="color: #005f5f;">Nullish</span>&lt;<span style="color: #005f5f;">T</span>&gt; = T | <span style="color: #0000b0;">null</span> | <span style="color: #0000b0;">undefined</span>;

<span style="color: #531ab6;">type</span> <span style="color: #005f5f;">Handler</span>&lt;<span style="color: #005f5f;">T</span>&gt; = <span style="color: #000000;">(</span>input: <span style="color: #005f5f;">Nullish</span>&lt;<span style="color: #005f5f;">T</span>&gt;, defaultValue: T<span style="color: #000000;">)</span> <span style="color: #531ab6;">=&gt;</span> T;

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">handleNullish</span>: <span style="color: #005f5f;">Handler</span>&lt;<span style="color: #531ab6;">number</span>&gt; = <span style="color: #000000;">(</span><span style="color: #005e8b;">input</span>, <span style="color: #005e8b;">defaultValue</span><span style="color: #000000;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> input !== <span style="color: #0000b0;">null</span> &amp;&amp; input !== <span style="color: #0000b0;">undefined</span> ? input : defaultValue;
<span style="color: #000000;">}</span>;

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span><span style="color: #721045;">handleNullish</span><span style="color: #dd22dd;">(</span>5, 10<span style="color: #dd22dd;">)</span><span style="color: #000000;">)</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span><span style="color: #721045;">handleNullish</span><span style="color: #dd22dd;">(</span><span style="color: #0000b0;">null</span>, 10<span style="color: #dd22dd;">)</span><span style="color: #000000;">)</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span><span style="color: #721045;">handleNullish</span><span style="color: #dd22dd;">(</span><span style="color: #0000b0;">undefined</span>, 10<span style="color: #dd22dd;">)</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">5</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">10</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">10</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
<div id="outline-container-orgb0bb822" class="outline-4">
<h4 id="orgb0bb822"><span class="section-number-4">10.4.1.</span> Generic Discriminated Unions</h4>
<div class="outline-text-4" id="text-10-4-1">
<ul class="org-ul">
<li>discriminated union(object包含相同的判断field,也包含不同的field,通过union组合起来),如果能结合generic,
会产生更加好的效果.
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">type</span> <span style="color: #005f5f;">Result</span>&lt;<span style="color: #005f5f;">Data</span>&gt; = FailureResult | SuccessfulResult&lt;<span style="color: #005f5f;">Data</span>&gt;;

<span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">FailureResult</span> <span style="color: #000000;">{</span>
  error: <span style="color: #005f5f;">Error</span>;
  succeeded: <span style="color: #0000b0;">false</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">SuccessfulResult</span>&lt;<span style="color: #005f5f;">Data</span>&gt; <span style="color: #000000;">{</span>
  data: <span style="color: #005f5f;">Data</span>;
  succeeded: <span style="color: #0000b0;">true</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">function</span> <span style="color: #721045;">handleResult</span><span style="color: #000000;">(</span><span style="color: #005e8b;">result</span>: <span style="color: #005f5f;">Result</span>&lt;<span style="color: #531ab6;">string</span>&gt;<span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">if</span> <span style="color: #dd22dd;">(</span>result.succeeded<span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">Type of result: SuccessfulResult</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #3548cf;">`We did it ! </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">result.data</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span> <span style="color: #531ab6;">else</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">Type of result: Failureresult</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #3548cf;">`Awww... </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">result.error</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #721045;">handleResult</span><span style="color: #000000;">(</span><span style="color: #dd22dd;">{</span> data: <span style="color: #3548cf;">"ok"</span>, succeeded: <span style="color: #0000b0;">true</span> <span style="color: #dd22dd;">}</span><span style="color: #000000;">)</span>;
<span style="color: #721045;">handleResult</span><span style="color: #000000;">(</span><span style="color: #dd22dd;">{</span> error: <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Error</span><span style="color: #008899;">(</span><span style="color: #3548cf;">"not ok"</span><span style="color: #008899;">)</span>, succeeded: <span style="color: #0000b0;">false</span> <span style="color: #dd22dd;">}</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">We did it ! ok</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Awww... Error: not ok</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org2be1da1" class="outline-3">
<h3 id="org2be1da1"><span class="section-number-3">10.5.</span> Generic Modifiers</h3>
<div class="outline-text-3" id="text-10-5">
</div>
<div id="outline-container-org40501d2" class="outline-4">
<h4 id="org40501d2"><span class="section-number-4">10.5.1.</span> Generic Defaults</h4>
<div class="outline-text-4" id="text-10-5-1">
<ul class="org-ul">
<li>类似函数有默认参数,泛型也可以指定一个默认类型,在没有明确的type argument的情况下就会默认使用这个类型
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">Quote</span>&lt;<span style="color: #005f5f;">T</span> = <span style="color: #531ab6;">string</span>&gt; <span style="color: #000000;">{</span>
  value: T;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">explicit</span>: <span style="color: #005f5f;">Quote</span>&lt;<span style="color: #531ab6;">number</span>&gt; = <span style="color: #000000;">{</span> value: 123 <span style="color: #000000;">}</span>;
<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">implicit</span>: <span style="color: #005f5f;">Quote</span> = <span style="color: #000000;">{</span> value: <span style="color: #3548cf;">"Be yourself"</span> <span style="color: #000000;">}</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:7:25 - error TS2322: Type 'number' is not assignable to type 'string'.</span>

<span style="color: #7f0000;">///////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">let mismatch: Quote = { value: 123 }; //</span>
<span style="color: #7f0000;">///////////////////////////////////////////</span>
</pre>
</div></li>
<li>上面例子的情况是type annotation,是必须要提供type argument的情况</li>
</ul></li>
<li>我们甚至后面的type parameter可以使用前面的type parameter来作为default
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">KeyValuePair</span>&lt;<span style="color: #005f5f;">Key</span>, <span style="color: #005f5f;">Value</span> = <span style="color: #005f5f;">Key</span>&gt; <span style="color: #000000;">{</span>
  key: <span style="color: #005f5f;">Key</span>;
  value: <span style="color: #005f5f;">Value</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">allExplicit</span>: <span style="color: #005f5f;">KeyValuePair</span>&lt;<span style="color: #531ab6;">string</span>, <span style="color: #531ab6;">number</span>&gt; = <span style="color: #000000;">{</span>
  key: <span style="color: #3548cf;">"rating"</span>,
  value: 10,
<span style="color: #000000;">}</span>;

<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">oneDefaulting</span>: <span style="color: #005f5f;">KeyValuePair</span>&lt;<span style="color: #531ab6;">string</span>&gt; = <span style="color: #000000;">{</span>
  key: <span style="color: #3548cf;">"rating"</span>,
  value: <span style="color: #3548cf;">"ten"</span>,
<span style="color: #000000;">}</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:16:19 - error TS2707: Generic type 'KeyValuePair&lt;Key, Value&gt;' requires between 1 and 2 type arguments.</span>

<span style="color: #7f0000;">////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">let firstMissing: KeyValuePair = { //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">key: "rating",                   //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">value: 10,                       //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">};                                 //</span>
<span style="color: #7f0000;">////////////////////////////////////////</span>
</pre>
</div></li>
<li>我们可以看到Value使用Key作为default paramter,所以,只提供一个type argument的情况下,两者一样,但是提
供两个type argument的情况下,两者可以不一样</li>
<li>另外注意,不能一个type argument也不提供,因为这样Key都无法知晓自己的具体类型</li>
</ul></li>
<li>default type parameter的后面不能有其他type parameter,换句话说,default type parameter们必须在所有的
type parameter的最后
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">inTheEnd</span>&lt;<span style="color: #005f5f;">First</span>, <span style="color: #005f5f;">Second</span>, <span style="color: #005f5f;">Third</span> = <span style="color: #531ab6;">number</span>, <span style="color: #005f5f;">Fourth</span> = <span style="color: #531ab6;">string</span>&gt;<span style="color: #000000;">()</span> <span style="color: #000000;">{}</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:2:63 - error TS2706: Required type parameters may not follow optional type parameters.</span>

<span style="color: #7f0000;">////////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">function inTheMiddle&lt;First, Second = boolean, Third = number, Fourth&gt;() {} //</span>
<span style="color: #7f0000;">////////////////////////////////////////////////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org691645f" class="outline-3">
<h3 id="org691645f"><span class="section-number-3">10.6.</span> Constrained Generic Types</h3>
<div class="outline-text-3" id="text-10-6">
<ul class="org-ul">
<li>泛型的type argument可以是任意的类型(class, interface, primitive, union)等等,但是有些情况下,我们只能
跟特定的某些类型进行合作.</li>
<li>这里所谓的"特定的某些类型",不是用union能够列举的.而是更加抽象的"特定类型",为了抽象出这种类型,typescript
引入了constrained generic type
<ul class="org-ul">
<li><p>
constrained generic type具体做法,就是在 type parameter后面加上一个extends, extends后面就是我们要
做的"抽象约束",示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">WithLength</span> <span style="color: #000000;">{</span>
  length: <span style="color: #531ab6;">number</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">function</span> <span style="color: #721045;">logWithLength</span>&lt;<span style="color: #005f5f;">T</span> <span style="color: #531ab6;">extends</span> <span style="color: #005f5f;">WithLength</span>&gt;<span style="color: #000000;">(</span><span style="color: #005e8b;">input</span>: T<span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">`Length: </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">input.length</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #dd22dd;">)</span>;
  <span style="color: #531ab6;">return</span> input;
<span style="color: #000000;">}</span>

<span style="color: #721045;">logWithLength</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"No one can figure outt your worth but you"</span><span style="color: #000000;">)</span>;
<span style="color: #721045;">logWithLength</span><span style="color: #000000;">(</span><span style="color: #dd22dd;">[</span><span style="color: #0000b0;">false</span>, <span style="color: #0000b0;">true</span><span style="color: #dd22dd;">]</span><span style="color: #000000;">)</span>;
<span style="color: #721045;">logWithLength</span><span style="color: #000000;">(</span><span style="color: #dd22dd;">{</span> length: 23 <span style="color: #dd22dd;">}</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Length: 41</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Length: 2</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Length: 23</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:19:15 - error TS2345: Argument of type 'Date' is not assignable to parameter of type 'WithLength'.</span>

<span style="color: #7f0000;">////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">logWithLength(new Date()); //</span>
<span style="color: #7f0000;">////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
<div id="outline-container-orga5ed573" class="outline-4">
<h4 id="orga5ed573"><span class="section-number-4">10.6.1.</span> keyof and Constrained Type Parameters</h4>
<div class="outline-text-4" id="text-10-6-1">
<ul class="org-ul">
<li>值得注意的是, Constrained Type Parameters是一种"无法列举"的union,这种情况下想描述这些列举,就只好用
keyof了
<ul class="org-ul">
<li><p>
示例如下,keyof能够很好的从generic中获取key列表("favorite | others")
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">get</span>&lt;<span style="color: #005f5f;">T</span>, <span style="color: #005f5f;">Key</span> <span style="color: #531ab6;">extends</span> <span style="color: #005f5f;">keyof</span> <span style="color: #005f5f;">T</span>&gt;<span style="color: #000000;">(</span><span style="color: #005e8b;">container</span>: T, <span style="color: #005e8b;">key</span>: <span style="color: #005f5f;">Key</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> container<span style="color: #dd22dd;">[</span>key<span style="color: #dd22dd;">]</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">roles</span> = <span style="color: #000000;">{</span>
  favorite: <span style="color: #3548cf;">"Fargo"</span>,
  others: <span style="color: #dd22dd;">[</span><span style="color: #3548cf;">"Almost Famous"</span>, <span style="color: #3548cf;">"Burn After Reading"</span>, <span style="color: #3548cf;">"Nomadland"</span><span style="color: #dd22dd;">]</span>,
<span style="color: #000000;">}</span>;

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">favorite</span> = <span style="color: #531ab6;">get</span><span style="color: #000000;">(</span>roles, <span style="color: #3548cf;">"favorite"</span><span style="color: #000000;">)</span>; <span style="color: #7f0000;">// </span><span style="color: #005e8b;">Type</span><span style="color: #7f0000;">: </span><span style="color: #005e8b;">string</span>
<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">others</span> = <span style="color: #531ab6;">get</span><span style="color: #000000;">(</span>roles, <span style="color: #3548cf;">"others"</span><span style="color: #000000;">)</span>;     <span style="color: #7f0000;">// </span><span style="color: #005e8b;">Type</span><span style="color: #7f0000;">: string[]</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:12:28 - error TS2345: Argument of type '"extra"' is not assignable to parameter of type '"favorite" | "others"'.</span>

<span style="color: #7f0000;">//////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">const missing = get(roles, "extra"); //</span>
<span style="color: #7f0000;">//////////////////////////////////////////</span>
</pre>
</div></li>
<li><p>
上面例子key为"favorite"的时候,返回值类型为string, key为"others"的时候,返回值类型为string[],如此
精妙的逻辑,是由于有Key(constrained type parameter)的参与.如果是一个平反的泛型加keyof的组合,那么返
回值会是一个union类型(string | string[])
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">get</span>&lt;<span style="color: #005f5f;">T</span>&gt;<span style="color: #000000;">(</span><span style="color: #005e8b;">container</span>: T, <span style="color: #005e8b;">key</span>: <span style="color: #531ab6;">keyof</span> T<span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> container<span style="color: #dd22dd;">[</span>key<span style="color: #dd22dd;">]</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">roles</span> = <span style="color: #000000;">{</span>
  favorite: <span style="color: #3548cf;">"Fargo"</span>,
  others: <span style="color: #dd22dd;">[</span><span style="color: #3548cf;">"Almost Famous"</span>, <span style="color: #3548cf;">"Burn After Reading"</span>, <span style="color: #3548cf;">"Nomadland"</span><span style="color: #dd22dd;">]</span>,
<span style="color: #000000;">}</span>;

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">favorite</span> = <span style="color: #531ab6;">get</span><span style="color: #000000;">(</span>roles, <span style="color: #3548cf;">"favorite"</span><span style="color: #000000;">)</span>;

<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">again</span>: <span style="color: #531ab6;">string</span> = <span style="color: #3548cf;">"again"</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:15:1 - error TS2322: Type 'string | string[]' is not assignable to type 'string'.</span>

<span style="color: #7f0000;">///////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">again = favorite; //</span>
<span style="color: #7f0000;">///////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgd0b3afd" class="outline-3">
<h3 id="orgd0b3afd"><span class="section-number-3">10.7.</span> Promises</h3>
<div class="outline-text-3" id="text-10-7">
<ul class="org-ul">
<li>在Typescript中,我们把Promise变成了一个泛型,其只有一个type parameter
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">fetchData</span><span style="color: #000000;">(</span><span style="color: #005e8b;">success</span>: <span style="color: #531ab6;">boolean</span><span style="color: #000000;">)</span>: <span style="color: #005f5f;">Promise</span>&lt;<span style="color: #531ab6;">string</span>&gt; <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Promise</span><span style="color: #dd22dd;">(</span><span style="color: #008899;">(</span><span style="color: #005e8b;">resolve</span>, <span style="color: #005e8b;">reject</span><span style="color: #008899;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #008899;">{</span>
    <span style="color: #721045;">setTimeout</span><span style="color: #972500;">(</span><span style="color: #808000;">()</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #808000;">{</span>
      <span style="color: #531ab6;">if</span> <span style="color: #531ab6;">(</span>success<span style="color: #531ab6;">)</span> <span style="color: #531ab6;">{</span>
        <span style="color: #721045;">resolve</span><span style="color: #008900;">(</span><span style="color: #3548cf;">"Data Load Successfully"</span><span style="color: #008900;">)</span>;
      <span style="color: #531ab6;">}</span> <span style="color: #531ab6;">else</span> <span style="color: #531ab6;">{</span>
        <span style="color: #721045;">reject</span><span style="color: #008900;">(</span><span style="color: #3548cf;">"Data Load Failed"</span><span style="color: #008900;">)</span>;
      <span style="color: #531ab6;">}</span>
    <span style="color: #808000;">}</span>, 2000<span style="color: #972500;">)</span>;
  <span style="color: #008899;">}</span><span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>

<span style="color: #721045;">fetchData</span><span style="color: #000000;">(</span><span style="color: #0000b0;">true</span><span style="color: #000000;">)</span>
  .<span style="color: #721045;">then</span><span style="color: #000000;">(</span><span style="color: #dd22dd;">(</span><span style="color: #005e8b;">data</span><span style="color: #dd22dd;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span>data<span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span><span style="color: #000000;">)</span>
  .<span style="color: #721045;">catch</span><span style="color: #000000;">(</span><span style="color: #dd22dd;">(</span><span style="color: #005e8b;">error</span><span style="color: #dd22dd;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">error</span><span style="color: #008899;">(</span>error<span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span><span style="color: #000000;">)</span>;

<span style="color: #721045;">fetchData</span><span style="color: #000000;">(</span><span style="color: #0000b0;">false</span><span style="color: #000000;">)</span>
  .<span style="color: #721045;">then</span><span style="color: #000000;">(</span><span style="color: #dd22dd;">(</span><span style="color: #005e8b;">data</span><span style="color: #dd22dd;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span>data<span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span><span style="color: #000000;">)</span>
  .<span style="color: #721045;">catch</span><span style="color: #000000;">(</span><span style="color: #dd22dd;">(</span><span style="color: #005e8b;">error</span><span style="color: #dd22dd;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">error</span><span style="color: #008899;">(</span>error<span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Data Load Successfully</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Data Load Failed</span>
</pre>
</div></li>
<li><p>
这里的type argument是string,也就说resolve和reject必须为stirng.我们如果改type argument为number,就会报错,如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:5:17 - error TS2345: Argument of type 'string' is not assignable to parameter of type 'number | PromiseLike&lt;number&gt;'.</span>

<span style="color: #7f0000;">//          </span><span style="color: #7f0000;">resolve("Data Load Successfully");</span>
<span style="color: #7f0000;">//                   </span><span style="color: #7f0000;">~~~~~~~~~~~~~~~~~~~~~~~~</span>

<span style="color: #7f0000;">/////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">function fetchData(</span><span style="color: #005e8b;">success</span><span style="color: #7f0000;">: boolean): Promise&lt;number&gt; { //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">return new Promise((</span><span style="color: #005e8b;">resolve</span><span style="color: #7f0000;">, </span><span style="color: #005e8b;">reject</span><span style="color: #7f0000;">) =&gt; {             //</span>
<span style="color: #7f0000;">//     </span><span style="color: #7f0000;">setTimeout(() =&gt; {                                  //</span>
<span style="color: #7f0000;">//       </span><span style="color: #7f0000;">if (</span><span style="color: #005e8b;">success</span><span style="color: #7f0000;">) {                                    //</span>
<span style="color: #7f0000;">//         </span><span style="color: #7f0000;">resolve("Data Load Successfully");              //</span>
<span style="color: #7f0000;">//       </span><span style="color: #7f0000;">} else {                                          //</span>
<span style="color: #7f0000;">//         </span><span style="color: #7f0000;">reject("Data Load Failed");                     //</span>
<span style="color: #7f0000;">//       </span><span style="color: #7f0000;">}                                                 //</span>
<span style="color: #7f0000;">//     </span><span style="color: #7f0000;">}, 2000);                                           //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">});                                                   //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">}                                                       //</span>
<span style="color: #7f0000;">/////////////////////////////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
<div id="outline-container-org914930f" class="outline-4">
<h4 id="org914930f"><span class="section-number-4">10.7.1.</span> Creating Promises</h4>
<div class="outline-text-4" id="text-10-7-1">
<ul class="org-ul">
<li>在type annotion的时候,设置type argument与否会有不同的效果:
<ul class="org-ul">
<li><p>
如果不设置type argument,如下例,那么resolveUnknown类型是Promise&lt;unknown&gt;
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">resolvesUnknown</span> = <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Promise</span><span style="color: #000000;">(</span><span style="color: #dd22dd;">(</span><span style="color: #005e8b;">resolve</span><span style="color: #dd22dd;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #dd22dd;">{</span>
  <span style="color: #721045;">setTimeout</span><span style="color: #008899;">(</span><span style="color: #972500;">()</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #721045;">resolve</span><span style="color: #972500;">(</span><span style="color: #3548cf;">"Done !"</span><span style="color: #972500;">)</span>, 1000<span style="color: #008899;">)</span>;
<span style="color: #dd22dd;">}</span><span style="color: #000000;">)</span>;
</pre>
</div></li>
<li><p>
如果设置type argument为string,如下例,那么resolveString类型是Promise&lt;string&gt;
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">resolvesString</span> = <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Promise</span>&lt;<span style="color: #531ab6;">string</span>&gt;<span style="color: #000000;">(</span><span style="color: #dd22dd;">(</span><span style="color: #005e8b;">resolve</span><span style="color: #dd22dd;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #dd22dd;">{</span>
  <span style="color: #721045;">setTimeout</span><span style="color: #008899;">(</span><span style="color: #972500;">()</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #721045;">resolve</span><span style="color: #972500;">(</span><span style="color: #3548cf;">"Done !"</span><span style="color: #972500;">)</span>, 1000<span style="color: #008899;">)</span>;
<span style="color: #dd22dd;">}</span><span style="color: #000000;">)</span>;
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org61dc62d" class="outline-4">
<h4 id="org61dc62d"><span class="section-number-4">10.7.2.</span> Async Functions</h4>
<div class="outline-text-4" id="text-10-7-2">
<ul class="org-ul">
<li>在Javascrip里面一切以async开头的函数都会返回一个Promise. 如果async function的返回值不是Thenable(不含then()函数),
那么它会自动被包裹成Promise,比如下面的两个代码是等价的:
<ul class="org-ul">
<li><p>
直接返回一个string
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #531ab6;">async</span> <span style="color: #531ab6;">function</span> myAsyncFunction<span style="color: #000000;">()</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> <span style="color: #3548cf;">"Hello, async!"</span>;
<span style="color: #000000;">}</span>
</pre>
</div></li>
<li><p>
相当于返回一个Promise
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #531ab6;">function</span> <span style="color: #721045;">myAsyncFunction</span><span style="color: #000000;">()</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> Promise.resolve<span style="color: #dd22dd;">(</span><span style="color: #3548cf;">"Hello, async!"</span><span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>
</pre>
</div></li>
</ul></li>
<li><p>
Typescript肯定是要遵循Javascript的设置的,另外加上它自己的类型设置,返回的不再是Promise,而是Promise&lt;target_rgument&gt;
比如下面的例子返回的都是Promise&lt;number&gt;
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">async</span> <span style="color: #531ab6;">function</span> <span style="color: #721045;">lengthImmediately</span><span style="color: #000000;">(</span><span style="color: #005e8b;">text</span>: <span style="color: #531ab6;">string</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> text.length;
<span style="color: #000000;">}</span>
</pre>
</div></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orga46781d" class="outline-3">
<h3 id="orga46781d"><span class="section-number-3">10.8.</span> Using Generics Right</h3>
<div class="outline-text-3" id="text-10-8">
<ul class="org-ul">
<li>Typescript使用泛型的最佳实践是只有必须使用泛型的情况下才会使用泛型</li>
<li>应用代码使用泛型的机会较少,多是library代码使用泛型会较多</li>
</ul>
</div>
<div id="outline-container-org1987bb1" class="outline-4">
<h4 id="org1987bb1"><span class="section-number-4">10.8.1.</span> The Golden Rule of Generics</h4>
<div class="outline-text-4" id="text-10-8-1">
<ul class="org-ul">
<li>一个最简答的判断是否用泛型的方法就是:只有使用至少两次以上的function才需要泛型</li>
</ul>
</div>
</div>
<div id="outline-container-org19a8afa" class="outline-4">
<h4 id="org19a8afa"><span class="section-number-4">10.8.2.</span> Generic Naming Conventions</h4>
<div class="outline-text-4" id="text-10-8-2">
<ul class="org-ul">
<li>一般来说,我们使用如下顺序来给type parameter命名:
<ul class="org-ul">
<li>T</li>
<li>U</li>
<li>V</li>
</ul></li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: harrifeng@outlook.com</p>
<p class="date">Created: 2025-04-09 Wed 10:58</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
