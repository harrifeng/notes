<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2025-04-01 Tue 17:20 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>lts</title>
<meta name="author" content="harrifeng@outlook.com" />
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="src/readtheorg_theme/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="src/readtheorg_theme/css/readtheorg.css"/>
<script type="text/javascript" src="src/lib/js/jquery.min.js"></script>
<script type="text/javascript" src="src/lib/js/bootstrap.min.js"></script>
<script type="text/javascript" src="src/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="src/readtheorg_theme/js/readtheorg.js"></script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">lts</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org502712a">1. Chapter 1: From JavaScript to TypeScript</a>
<ul>
<li><a href="#orgcdd86c9">1.1. History of JavaScript</a></li>
<li><a href="#org33d558d">1.2. Vanilla JavaScript's Pitfalls</a>
<ul>
<li><a href="#org3740ab4">1.2.1. Costly Freedom</a></li>
<li><a href="#orgc496cd4">1.2.2. Losse Documentation</a></li>
<li><a href="#orgdeba5e4">1.2.3. Weaker Developer Tooling</a></li>
</ul>
</li>
<li><a href="#orgacf0032">1.3. Typescript!</a></li>
<li><a href="#org7fc4a33">1.4. Getting Started in the TypeScript Playground</a>
<ul>
<li><a href="#orgfdacf66">1.4.1. TypeScript in Action</a></li>
<li><a href="#org511c3ac">1.4.2. Freedom Through Restriction</a></li>
<li><a href="#org6a6706b">1.4.3. Precise Documentation</a></li>
<li><a href="#orge6b3c20">1.4.4. Stronger Developer Tooling</a></li>
<li><a href="#org55233aa">1.4.5. Compiling Syntax</a></li>
</ul>
</li>
<li><a href="#orgc3dc3c4">1.5. Getting Started Locally</a>
<ul>
<li><a href="#orgde1c404">1.5.1. Running Locally</a></li>
<li><a href="#orgd1e3a2a">1.5.2. Editor Features</a></li>
</ul>
</li>
<li><a href="#org9fa1695">1.6. What TypeScript is Not</a>
<ul>
<li><a href="#orgad01cb2">1.6.1. A Remedy for Bad Code</a></li>
<li><a href="#org63f96c6">1.6.2. Extensions to JavaScript(Mostly)</a></li>
<li><a href="#orgf50030e">1.6.3. SLower Than JavaScript</a></li>
<li><a href="#orgbe069a1">1.6.4. Finished Evolving</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org3f9136a">2. Chapter 2: The Type System</a>
<ul>
<li><a href="#org795f75e">2.1. What's in a Type?</a>
<ul>
<li><a href="#org9af01ad">2.1.1. Type Systems</a></li>
<li><a href="#orgb698714">2.1.2. Kinds of Errors</a></li>
</ul>
</li>
<li><a href="#org1601e3a">2.2. Assignability</a>
<ul>
<li><a href="#org9e8e62f">2.2.1. Understanding Assignability Errors</a></li>
</ul>
</li>
<li><a href="#orge5a71c9">2.3. Type Annotations</a>
<ul>
<li><a href="#org4466de3">2.3.1. Unnecessary Type Annotaions</a></li>
</ul>
</li>
<li><a href="#org49d6605">2.4. Type Shapes</a>
<ul>
<li><a href="#org5640a2e">2.4.1. Modules</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org482fff4">3. Chapter 3: Unions and Literals</a>
<ul>
<li><a href="#orgcdd3d44">3.1. Union Types</a>
<ul>
<li><a href="#orgf52ba07">3.1.1. Declaring Union Types</a></li>
<li><a href="#orgb4f4e03">3.1.2. Union Preperties</a></li>
</ul>
</li>
<li><a href="#org89b1bf9">3.2. Narrowing</a>
<ul>
<li><a href="#orga8b0384">3.2.1. Assignment Narrowing</a></li>
<li><a href="#org28a89ed">3.2.2. Conditional Checks</a></li>
<li><a href="#orgca245e4">3.2.3. Typeof Checks</a></li>
</ul>
</li>
<li><a href="#orgc59a10f">3.3. Literal Types</a>
<ul>
<li><a href="#org17f2fb0">3.3.1. Literal Assignability</a></li>
</ul>
</li>
<li><a href="#orga6b3af7">3.4. Strict Null Checking</a>
<ul>
<li><a href="#org0f584c6">3.4.1. The Billion-Dollar Mistake</a></li>
<li><a href="#orgdd30484">3.4.2. Truthiness Narrowing</a></li>
<li><a href="#org01e6a7b">3.4.3. Variables Without Initial Values</a></li>
</ul>
</li>
<li><a href="#org1f8f96d">3.5. Type Aliases</a>
<ul>
<li><a href="#org32d5405">3.5.1. Type Aliases Are Not JavaScript</a></li>
<li><a href="#orgc131390">3.5.2. Combining Type Aliases</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgb4e8a19">4. Chapter 4: Objects</a>
<ul>
<li><a href="#orgc4525c2">4.1. Object Types</a>
<ul>
<li><a href="#orgfe85b59">4.1.1. Declaring Object Types</a></li>
<li><a href="#org4449b64">4.1.2. Aliased Object Types</a></li>
</ul>
</li>
<li><a href="#org0e2dc67">4.2. Structural Typing</a>
<ul>
<li><a href="#org1a11e9c">4.2.1. Usage Checking</a></li>
<li><a href="#orgedc3911">4.2.2. Excess Property Checking</a></li>
<li><a href="#orgdcfc5f3">4.2.3. Nested Object Types</a></li>
<li><a href="#org4e09453">4.2.4. Optional Properties</a></li>
</ul>
</li>
<li><a href="#orgf8f69ce">4.3. Unions of Object Types</a>
<ul>
<li><a href="#org4043a65">4.3.1. Inferred Object-Type Unions</a></li>
<li><a href="#org9db6d58">4.3.2. Explicit Object-Type Unions</a></li>
<li><a href="#org0d641b6">4.3.3. Narrowing Object Types</a></li>
<li><a href="#org7d165ae">4.3.4. Discriminated Unions</a></li>
</ul>
</li>
<li><a href="#orgb8a54bb">4.4. Intersection Types</a>
<ul>
<li><a href="#orgcceada0">4.4.1. Dangers of Intersection Types</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgf74a7c0">5. Chapter 5: Functions</a>
<ul>
<li><a href="#org9a20b0e">5.1. Function Parameters</a>
<ul>
<li><a href="#org294aa51">5.1.1. Required Parameters</a></li>
<li><a href="#org5179ba6">5.1.2. Optional Parameters</a></li>
<li><a href="#org404d473">5.1.3. Default Parameters</a></li>
<li><a href="#org7f2cf16">5.1.4. Rest Parameters</a></li>
</ul>
</li>
<li><a href="#org62e394b">5.2. Return Types</a>
<ul>
<li><a href="#orgbf1c6f3">5.2.1. Explicit Return Types</a></li>
</ul>
</li>
<li><a href="#org17b8376">5.3. Function Types</a>
<ul>
<li><a href="#orgaa48f49">5.3.1. Function Type Parentheses</a></li>
<li><a href="#org3ab6c0c">5.3.2. Parameter Type Inferences</a></li>
<li><a href="#org983f9ef">5.3.3. Function Type Aliases</a></li>
</ul>
</li>
<li><a href="#org680fb1e">5.4. More Return Types</a>
<ul>
<li><a href="#orgf709a06">5.4.1. Void Returns</a></li>
<li><a href="#org527e26b">5.4.2. Never Returns</a></li>
</ul>
</li>
<li><a href="#orga05e21a">5.5. Function Overloads</a>
<ul>
<li><a href="#org008d529">5.5.1. Call-Signature Compatibility</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org28ac7c3">6. Chapter 6: Arrays</a>
<ul>
<li><a href="#orge722912">6.1. Array Types</a>
<ul>
<li><a href="#orga763b26">6.1.1. Array and Function Types</a></li>
<li><a href="#orgd5c48bf">6.1.2. Union Type Arrays</a></li>
<li><a href="#orga917548">6.1.3. Evolving Any Arrays</a></li>
<li><a href="#orgc7a5f41">6.1.4. Multidimensional Arrays</a></li>
</ul>
</li>
<li><a href="#org208109d">6.2. Array Members</a>
<ul>
<li><a href="#org7fb6dd1">6.2.1. Caveat: Unsound Members</a></li>
</ul>
</li>
<li><a href="#orgf0cda23">6.3. Spreads and Rests</a>
<ul>
<li><a href="#orgb1c7e12">6.3.1. Spreads</a></li>
<li><a href="#orgaf888e0">6.3.2. Spreading Rest Parameters</a></li>
</ul>
</li>
<li><a href="#orgb661dfe">6.4. Tuples</a>
<ul>
<li><a href="#org9706d80">6.4.1. Tuple Assignability</a></li>
<li><a href="#orgfe2a701">6.4.2. Tuple Inferences</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org1b779e7">7. Chapter 7: Interfaces</a>
<ul>
<li><a href="#orgd138a7b">7.1. Type Aliases Versus Intrfaces</a></li>
<li><a href="#org0b95143">7.2. Type of Proprties</a>
<ul>
<li><a href="#org60b6f22">7.2.1. Optional Properties</a></li>
<li><a href="#orgef24bd5">7.2.2. Read-Only Properties</a></li>
<li><a href="#org10a17c6">7.2.3. Functions and Methods</a></li>
<li><a href="#org1f8e184">7.2.4. Call Signatures</a></li>
<li><a href="#orgada1013">7.2.5. Index Signatures</a></li>
<li><a href="#orgb07e401">7.2.6. Nested Interfaces</a></li>
</ul>
</li>
<li><a href="#org2cbfd29">7.3. Interface Extensions</a>
<ul>
<li><a href="#orga4b3c39">7.3.1. Overridden Properties</a></li>
<li><a href="#org677304c">7.3.2. Extending Multiple Interfaces</a></li>
</ul>
</li>
<li><a href="#org5eaceef">7.4. Interface Merging</a>
<ul>
<li><a href="#orgd253d84">7.4.1. Member Naming Conflicts</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orga1c387d">8. Chapter 8: Classes</a>
<ul>
<li><a href="#orgb93a484">8.1. Class Methods</a></li>
<li><a href="#org63e022e">8.2. Class Properties</a>
<ul>
<li><a href="#org3af7103">8.2.1. Function Properties</a></li>
<li><a href="#org6b51ac7">8.2.2. Initialization Checking</a></li>
<li><a href="#org4674311">8.2.3. Optional Properties</a></li>
<li><a href="#orga540090">8.2.4. Read-Only Properties</a></li>
</ul>
</li>
<li><a href="#orgd995bc4">8.3. Classes as Types</a></li>
<li><a href="#org62d7750">8.4. Classes and Interfaces</a>
<ul>
<li><a href="#org3c94283">8.4.1. Implementing Multiple Interfaces</a></li>
</ul>
</li>
<li><a href="#org1694aaf">8.5. Extending a Class</a>
<ul>
<li><a href="#orga181959">8.5.1. Extension Assignability</a></li>
<li><a href="#org8787823">8.5.2. Overriddeng Constructors</a></li>
<li><a href="#org0eeb311">8.5.3. Overridden Methods</a></li>
<li><a href="#orgac8d716">8.5.4. Overridden Properties</a></li>
</ul>
</li>
<li><a href="#orgd00e261">8.6. Abstract Classes</a></li>
<li><a href="#org0e8b002">8.7. Member Visibility</a>
<ul>
<li><a href="#org3f48ca1">8.7.1. Static Field Modifiers</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orge68ed46">9. Chapter 9: Type Modifiers</a>
<ul>
<li><a href="#org597d9a5">9.1. Top Types</a>
<ul>
<li><a href="#org6a83986">9.1.1. any, Again</a></li>
<li><a href="#org7f7915a">9.1.2. unknown</a></li>
</ul>
</li>
<li><a href="#org038ec38">9.2. Type Prddicates</a></li>
<li><a href="#org6227ac7">9.3. Type Operators</a>
<ul>
<li><a href="#org32b9631">9.3.1. keyof</a></li>
<li><a href="#org85df7dc">9.3.2. typeof</a></li>
</ul>
</li>
<li><a href="#org447f46b">9.4. Type Assertions</a>
<ul>
<li><a href="#org45bf2ad">9.4.1. Asserting Caught Error Types</a></li>
<li><a href="#org4b13142">9.4.2. Non-Null Assertions</a></li>
<li><a href="#org4827b39">9.4.3. Type Assertin Caveats</a></li>
</ul>
</li>
<li><a href="#org5ac8eb5">9.5. Const Assertions</a>
<ul>
<li><a href="#orgf82b50b">9.5.1. Literals to Primitives</a></li>
<li><a href="#org5b8077d">9.5.2. Read-Only Objects</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-org502712a" class="outline-2">
<h2 id="org502712a"><span class="section-number-2">1.</span> Chapter 1: From JavaScript to TypeScript</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-orgcdd86c9" class="outline-3">
<h3 id="orgcdd86c9"><span class="section-number-3">1.1.</span> History of JavaScript</h3>
<div class="outline-text-3" id="text-1-1">
<ul class="org-ul">
<li>javascript是Brendan Eich在1995年用十天时间发明的语言,由于时间仓促,javascript有很多奇怪的地方</li>
<li>从2015年开始,javascript的规范化组织ECMAScript(因为javascript是火狐浏览器的商标),就每年发布新版本,并
且保证向前兼容</li>
</ul>
</div>
</div>
<div id="outline-container-org33d558d" class="outline-3">
<h3 id="org33d558d"><span class="section-number-3">1.2.</span> Vanilla JavaScript's Pitfalls</h3>
<div class="outline-text-3" id="text-1-2">
<ul class="org-ul">
<li>开发者把没有使用任何框架的javascript叫做vanilla(因为香草味是最常见的味道)</li>
<li>实际上很少有项目使用vanilla javascript,因为原生javascript的陷阱实在是太多了,这也是为什么Typescript会诞生的原因</li>
</ul>
</div>
<div id="outline-container-org3740ab4" class="outline-4">
<h4 id="org3740ab4"><span class="section-number-4">1.2.1.</span> Costly Freedom</h4>
<div class="outline-text-4" id="text-1-2-1">
<ul class="org-ul">
<li>javascript太过于自由了,导致有很多的问题.
<ul class="org-ul">
<li><p>
比如下面的代码:
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #531ab6;">function</span> <span style="color: #721045;">paintPainting</span><span style="color: #000000;">(</span><span style="color: #005e8b;">painter</span>, <span style="color: #005e8b;">painting</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> painter
    .prepare<span style="color: #dd22dd;">()</span>
    .paint<span style="color: #dd22dd;">(</span>painting, painter.ownMaterials<span style="color: #dd22dd;">)</span>
    .finish<span style="color: #dd22dd;">()</span>;
<span style="color: #000000;">}</span>
</pre>
</div></li>
<li>由于不经过编译器确认,那么一旦paint()函数改名字了,那么代码毫无感觉,直到代码运行到这个地方</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgc496cd4" class="outline-4">
<h4 id="orgc496cd4"><span class="section-number-4">1.2.2.</span> Losse Documentation</h4>
<div class="outline-text-4" id="text-1-2-2">
<ul class="org-ul">
<li>由于是动态语言,所以维持js代码的文档是非常困难的,因为:
<ul class="org-ul">
<li>很有可能JSDoc是错误的,因为它和代码是分离的</li>
<li>即便我们JSDoc是正确的,但是随着代码的重构,我们要经常性的去更改那些now-invalid JSDoc,这个是非常困难
也复杂的</li>
<li>描述复杂的对象会非常的复杂</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgdeba5e4" class="outline-4">
<h4 id="orgdeba5e4"><span class="section-number-4">1.2.3.</span> Weaker Developer Tooling</h4>
<div class="outline-text-4" id="text-1-2-3">
<ul class="org-ul">
<li>Js作为动态语言,天然的没有太多开发者支持工具,比如重命名成员和跳转到定义等</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgacf0032" class="outline-3">
<h3 id="orgacf0032"><span class="section-number-3">1.3.</span> Typescript!</h3>
<div class="outline-text-3" id="text-1-3">
<ul class="org-ul">
<li>Typescript由C#,Pascal语言的作者 Anders Hejlsberg在2010年发明,并在2012年开源</li>
<li>我们可以把Typescript看成是如下四个东西:
<ul class="org-ul">
<li>programming language: 一个包含所有Js的syntax的语言,外加新的TypeScript-specific syntax用来定义和使用type</li>
<li>Type checker: 还可以把ts看成是一个程序,用来检查输入的js和ts代码是否正确</li>
<li>Compiler: 还可以把ts卡成是一个编译器,用来把ts代码编译成js代码</li>
<li>Language service: 还可以把ts看成是一个服务,提供给编辑器(比如vs code)来帮助开发者开发代码</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org7fc4a33" class="outline-3">
<h3 id="org7fc4a33"><span class="section-number-3">1.4.</span> Getting Started in the TypeScript Playground</h3>
<div class="outline-text-3" id="text-1-4">
<ul class="org-ul">
<li>TypeScript主页包含了一个在线的编辑器,叫TypeScript Playground,地址如下 <a href="https://www.typescriptlang.org/play">https://www.typescriptlang.org/play</a></li>
</ul>
</div>
<div id="outline-container-orgfdacf66" class="outline-4">
<h4 id="orgfdacf66"><span class="section-number-4">1.4.1.</span> TypeScript in Action</h4>
<div class="outline-text-4" id="text-1-4-1">
<ul class="org-ul">
<li><p>
我们先来看看一个代码片段
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">firstName</span> = <span style="color: #3548cf;">"Georgia"</span>;
<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">nameLangth</span> = firstName.length<span style="color: #000000;">()</span>;
</pre>
</div></li>
<li>这段如果是js代码的话,在运行时会爆出问题,因为字符串没有length()函数</li>
<li><p>
我们把这段代码贴到Typescript Playground,我们会发现,ts作为language service会帮我们分析到
</p>
<pre class="example" id="org2464945">
This expression is not callable.
  Type 'Number' has no call signatures. ts(2349)
</pre></li>
<li>在代码书写阶段就得到警告,好过运行的时候整个程序崩溃</li>
</ul>
</div>
</div>
<div id="outline-container-org511c3ac" class="outline-4">
<h4 id="org511c3ac"><span class="section-number-4">1.4.2.</span> Freedom Through Restriction</h4>
<div class="outline-text-4" id="text-1-4-2">
<ul class="org-ul">
<li>ts允许我们选定参数和变量能够使用的类型</li>
<li>ts还允许我们在函数的定义改变的时候,做出告警</li>
</ul>
</div>
</div>
<div id="outline-container-org6a6706b" class="outline-4">
<h4 id="org6a6706b"><span class="section-number-4">1.4.3.</span> Precise Documentation</h4>
<div class="outline-text-4" id="text-1-4-3">
<ul class="org-ul">
<li><p>
我们来看看ts版本的paintPainting,即便我们还没引入ts的内容,但是你也可以看出这就是代码本身就是documentation的范本
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">Painter</span> <span style="color: #000000;">{</span>
  <span style="color: #721045;">finish</span><span style="color: #dd22dd;">()</span>: <span style="color: #531ab6;">boolean</span>;
  ownMaterials: <span style="color: #005f5f;">Material</span><span style="color: #dd22dd;">[]</span>;
  <span style="color: #721045;">paint</span><span style="color: #dd22dd;">(</span><span style="color: #005e8b;">painting</span>: <span style="color: #531ab6;">string</span>, <span style="color: #005e8b;">materials</span>: <span style="color: #005f5f;">Material</span><span style="color: #008899;">[]</span><span style="color: #dd22dd;">)</span>: <span style="color: #531ab6;">boolean</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">function</span> <span style="color: #721045;">paintPainting</span><span style="color: #000000;">(</span><span style="color: #005e8b;">painter</span>: <span style="color: #005f5f;">Painter</span>, <span style="color: #005e8b;">painting</span>: <span style="color: #531ab6;">string</span><span style="color: #000000;">)</span>: <span style="color: #531ab6;">boolean</span><span style="color: #000000;">{</span><span style="color: #7f0000;">/* </span><span style="color: #7f0000;">... */</span><span style="color: #000000;">}</span>
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-orge6b3c20" class="outline-4">
<h4 id="orge6b3c20"><span class="section-number-4">1.4.4.</span> Stronger Developer Tooling</h4>
<div class="outline-text-4" id="text-1-4-4">
<ul class="org-ul">
<li>Typescript 自己就能为vs code 提供自动补全等功能</li>
</ul>
</div>
</div>
<div id="outline-container-org55233aa" class="outline-4">
<h4 id="org55233aa"><span class="section-number-4">1.4.5.</span> Compiling Syntax</h4>
<div class="outline-text-4" id="text-1-4-5">
<ul class="org-ul">
<li>Typescript不仅能把ts编译成js,还能把新版本的js编译成老版本的js</li>
<li>我们可以在Typescript playground页面的右侧看到编译好的js代码</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgc3dc3c4" class="outline-3">
<h3 id="orgc3dc3c4"><span class="section-number-3">1.5.</span> Getting Started Locally</h3>
<div class="outline-text-3" id="text-1-5">
<ul class="org-ul">
<li><p>
typescript是作为nodejs的一个module被安装的,如果要本地使用,记得全局安装
</p>
<div class="org-src-container">
<pre class="src src-shell">npm i -g typescript
</pre>
</div></li>
<li><p>
一旦全局安装typescript module成功之后,会有一个tsc的命令放在path
</p>
<div class="org-src-container">
<pre class="src src-shell">$ tsc --version
Version 5.0.4
</pre>
</div></li>
</ul>
</div>
<div id="outline-container-orgde1c404" class="outline-4">
<h4 id="orgde1c404"><span class="section-number-4">1.5.1.</span> Running Locally</h4>
<div class="outline-text-4" id="text-1-5-1">
<ul class="org-ul">
<li><p>
在一个空白的文件夹下面运行如下命令,就能在root目录创建一个新的tsconfig.json配置文件
</p>
<div class="org-src-container">
<pre class="src src-shell">$ tsc --init

Created a new tsconfig.json with:
                                                                                                              TS
  target: es2016
  module: commonjs
  strict: true
  esModuleInterop: true
  skipLibCheck: true
  forceConsistentCasingInFileNames: true


You can learn more at https://aka.ms/tsconfig
$ ls -al .
total 24
drwxr-xr-x   3 fenghaoran  staff     96 May  8 17:58 .
drwxr-xr-x  23 fenghaoran  staff    736 May  8 17:58 ..
-rw-r--r--   1 fenghaoran  staff  12288 May  8 17:58 tsconfig.json
</pre>
</div></li>
<li><p>
我们在这个文件夹里面创建一个文件index.ts并且添加如下文本
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #005f5f;">console</span>.<span style="color: #721045;">blub</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Nothing is worth more than laughter."</span><span style="color: #000000;">)</span>;
</pre>
</div></li>
<li><p>
我们如果使用tsc编译的话,会出现如下错误
</p>
<div class="org-src-container">
<pre class="src src-shell">$ tsc index.ts
index.ts:1:9 - error TS2339: Property <span style="color: #3548cf;">'blub'</span> does not exist on type <span style="color: #3548cf;">'Console'</span>.

1 console.blub<span style="color: #000000;">(</span><span style="color: #3548cf;">"Nothing is worth more than laughter."</span><span style="color: #000000;">)</span>;
          ~~~~


Found 1 error<span style="color: #531ab6;"> in</span> index.ts:1
</pre>
</div></li>
<li><p>
虽然你的写法tsc认为有问题,但是它还是给你创建了一个新的index.js文件
</p>
<div class="org-src-container">
<pre class="src src-shell">$ cat index.js
<span style="color: #721045;">console.blub</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Nothing is worth more than laughter."</span><span style="color: #000000;">)</span>;
</pre>
</div></li>
<li>从这里看tsc的编译和我们之前理解的gcc等还是有差别的.</li>
<li><p>
我们更改错误之后,编译就不会有问题了,而且会产生新的正确的js代码
</p>
<div class="org-src-container">
<pre class="src src-shell">$ cat index.ts
<span style="color: #721045;">console.log</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Nothing is worth more than laughter."</span><span style="color: #000000;">)</span>;
$ tsc index.ts
$ cat index.js
<span style="color: #721045;">console.log</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Nothing is worth more than laughter."</span><span style="color: #000000;">)</span>;
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-orgd1e3a2a" class="outline-4">
<h4 id="orgd1e3a2a"><span class="section-number-4">1.5.2.</span> Editor Features</h4>
<div class="outline-text-4" id="text-1-5-2">
<ul class="org-ul">
<li>tsconfig.json配置文件的巨大作用,在于让vs code(或者其他编辑器,IDE)能够识别出ts project root folder</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org9fa1695" class="outline-3">
<h3 id="org9fa1695"><span class="section-number-3">1.6.</span> What TypeScript is Not</h3>
<div class="outline-text-3" id="text-1-6">
<ul class="org-ul">
<li>每个工具都有其优点,也有其局限性. ts的局限性总计起来就是</li>
</ul>
</div>
<div id="outline-container-orgad01cb2" class="outline-4">
<h4 id="orgad01cb2"><span class="section-number-4">1.6.1.</span> A Remedy for Bad Code</h4>
<div class="outline-text-4" id="text-1-6-1">
<ul class="org-ul">
<li>ts只会enforce type safety,它不会强制你使用任何的structure(比如class等)</li>
</ul>
</div>
</div>
<div id="outline-container-org63f96c6" class="outline-4">
<h4 id="org63f96c6"><span class="section-number-4">1.6.2.</span> Extensions to JavaScript(Mostly)</h4>
<div class="outline-text-4" id="text-1-6-2">
<ul class="org-ul">
<li>ts的设计目标说,it should:
<ul class="org-ul">
<li>遵守当前的,以及未来的ECMAScript proposal</li>
<li>能够适配所有js的runtime(比如老版本的IE11)</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgf50030e" class="outline-4">
<h4 id="orgf50030e"><span class="section-number-4">1.6.3.</span> SLower Than JavaScript</h4>
<div class="outline-text-4" id="text-1-6-3">
<ul class="org-ul">
<li>关于ts比js慢的观点,是不准确,而且有诱导性的,因为ts慢是因为它首先要转成js,而且编译的时候有类型检查</li>
</ul>
</div>
</div>
<div id="outline-container-orgbe069a1" class="outline-4">
<h4 id="orgbe069a1"><span class="section-number-4">1.6.4.</span> Finished Evolving</h4>
<div class="outline-text-4" id="text-1-6-4">
<ul class="org-ul">
<li>随着web的继续发展,ts也会不断演进</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org3f9136a" class="outline-2">
<h2 id="org3f9136a"><span class="section-number-2">2.</span> Chapter 2: The Type System</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-org795f75e" class="outline-3">
<h3 id="org795f75e"><span class="section-number-3">2.1.</span> What's in a Type?</h3>
<div class="outline-text-3" id="text-2-1">
<ul class="org-ul">
<li>所谓的shape,是指有哪些property和method在一个value上,也可以理解为内置的typeof操作符对这个value的解释</li>
<li><p>
比如下面的js代码,如果给ts来理解,它肯定能知道singer是一个string type的变量
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">singer</span> = <span style="color: #3548cf;">"Aretha"</span>
</pre>
</div></li>
<li>js中有如下七中原生类型,ts也同样视他们为原生类型:
<ul class="org-ul">
<li>null</li>
<li>undefined</li>
<li>boolean</li>
<li>string</li>
<li>number</li>
<li>bigint</li>
<li>symbol</li>
</ul></li>
</ul>
</div>
<div id="outline-container-org9af01ad" class="outline-4">
<h4 id="org9af01ad"><span class="section-number-4">2.1.1.</span> Type Systems</h4>
<div class="outline-text-4" id="text-2-1-1">
<ul class="org-ul">
<li>TypeScript的type system总体上是安装如下流程工作的:
<ul class="org-ul">
<li>读取你的代码,理解代码中所有的type,和所有的value</li>
<li>对每个value,试着从其初始化的地方理解其可能有的类型</li>
<li>对每个value,看看在后续代码里面其使用的方式(有没有超过其类型所限)</li>
<li>如果value采用了不符合其类型的操作,反馈给用户</li>
</ul></li>
<li>我们以一个例子来介绍下上面的几步都是什么意思:
<ul class="org-ul">
<li><p>
代码如下
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">firstName</span> = <span style="color: #3548cf;">"Whiteney"</span>;
firstName.length<span style="color: #000000;">()</span>;
<span style="color: #7f0000;">//        </span><span style="color: #7f0000;">~~~~~~</span>
<span style="color: #7f0000;">//  </span><span style="color: #7f0000;">This expression is not callable.</span>
<span style="color: #7f0000;">//    </span><span style="color: #7f0000;">Type 'Number' has no call signatures</span>
</pre>
</div></li>
<li>ts能够得到上面的报警,是依次通过如下步骤获得的:
<ol class="org-ol">
<li>读取代码,并且理解了代码里面有个变量叫做firstName</li>
<li>总结出来firstName是string类型的,因为它的初始化值为"Whitney"</li>
<li>发现代码会去让firstName去调用.length这个method</li>
<li>终于得到机会进行警告: .length是一个member,而不是一个函数</li>
</ol></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgb698714" class="outline-4">
<h4 id="orgb698714"><span class="section-number-4">2.1.2.</span> Kinds of Errors</h4>
<div class="outline-text-4" id="text-2-1-2">
<ul class="org-ul">
<li>在ts里面一般会遇到两种错误:
<ul class="org-ul">
<li>syntax error: 可以认为是严重错误,导致ts无法转换成js代码(虽然也会产生js代码,但是肯定是错误的,无法运行的)</li>
<li><p>
type error: 可以认为是普通告警,syntax error不存在的情况下(所以ts成功转换成了js代码),但是ts 编译器
认为你的代码可能出错.注意type error是说,从type类型的角度上讲,你是错误的.但是从动态语言的角度讲,
不一定是错误的.比如下面的代码,一个变量开始是字符类型,后来被赋值了true,在ts看来就是type error,但是js
看来,这是再正常不过的代码
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">lastName</span> = <span style="color: #3548cf;">"King"</span>;
lastName = <span style="color: #0000b0;">true</span>;
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org1601e3a" class="outline-3">
<h3 id="org1601e3a"><span class="section-number-3">2.2.</span> Assignability</h3>
<div class="outline-text-3" id="text-2-2">
<ul class="org-ul">
<li><p>
ts会读取变量的初始化值来判断其类型,如果后面赋值的时候类型一样还好,如果类型不一样,那么报警是跑不了
的了,而且报的就是Type error
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">lastName</span> = <span style="color: #3548cf;">"King"</span>;
lastName = <span style="color: #0000b0;">true</span>;
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Error: Type 'boolean' is not assignable to type 'string'.</span>
</pre>
</div></li>
</ul>
</div>
<div id="outline-container-org9e8e62f" class="outline-4">
<h4 id="org9e8e62f"><span class="section-number-4">2.2.1.</span> Understanding Assignability Errors</h4>
<div class="outline-text-4" id="text-2-2-1">
<ul class="org-ul">
<li>我们要试着理解Type Error报警:
<ul class="org-ul">
<li>比如 Type 'A' is not assignable to type 'B'</li>
<li>意思就是类型A无法赋值给类型B, 类型B是接受者(变量), 类型A是赋值者(新的类型)</li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orge5a71c9" class="outline-3">
<h3 id="orge5a71c9"><span class="section-number-3">2.3.</span> Type Annotations</h3>
<div class="outline-text-3" id="text-2-3">
<ul class="org-ul">
<li>如果一个变量没有设置初始化的值,那么ts显然不能assume它的类型,这种情况下,ts认为这个变量的类型是any</li>
<li>any类型很奇怪:
<ul class="org-ul">
<li><p>
一个any类型的变量可以先后被赋值任何类型的数值.如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">rocker</span>;                     <span style="color: #7f0000;">// </span><span style="color: #7f0000;">Type: any</span>
rocker.<span style="color: #721045;">toUpperCase</span><span style="color: #000000;">()</span>;

rocker = 19.58;
rocker.<span style="color: #721045;">toPrecision</span><span style="color: #000000;">(</span>1<span style="color: #000000;">)</span>;
</pre>
</div></li>
<li><p>
但是每次赋值相当于让当前变量处于某个类型,不过不能调用其他类型的method,如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">rocker</span>;                     <span style="color: #7f0000;">// </span><span style="color: #7f0000;">Type: any</span>
rocker.<span style="color: #721045;">toUpperCase</span><span style="color: #000000;">()</span>;

rocker = 19.58;
rocker.<span style="color: #721045;">toPrecision</span><span style="color: #000000;">(</span>1<span style="color: #000000;">)</span>;

rocker.<span style="color: #721045;">toUpperCase</span><span style="color: #000000;">()</span>;           <span style="color: #7f0000;">// </span><span style="color: #7f0000;">error    2339   Property 'toUpperCase' does not exist on type 'number'. (typescript-</span><span style="color: #005e8b;">tide</span><span style="color: #7f0000;">)</span>

</pre>
</div></li>
</ul></li>
<li>使用any类型是不推荐的,因为它本质上是一种妥协,一旦设置了any, ts的很多类型检查就不再起作用了</li>
<li>如果没有初始化值,但是还想要设置类型怎么办? ts给出的解决方案是type annotation:
<ul class="org-ul">
<li><p>
type annotation的代码如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">rocker</span>: <span style="color: #531ab6;">string</span>;
rocker = <span style="color: #3548cf;">"Joan Jett"</span>;
</pre>
</div></li>
<li><p>
type annotation是ts的特有syntax, js无法理解. tsc会把上面的ts代码编译成如下的js代码
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #531ab6;">var</span> <span style="color: #005e8b;">rocker</span>;
rocker = <span style="color: #3548cf;">"Joan Jett"</span>;
</pre>
</div></li>
</ul></li>
</ul>
</div>
<div id="outline-container-org4466de3" class="outline-4">
<h4 id="org4466de3"><span class="section-number-4">2.3.1.</span> Unnecessary Type Annotaions</h4>
<div class="outline-text-4" id="text-2-3-1">
<ul class="org-ul">
<li>只有在没有初始化值的情况下才需要type annotation,否则:
<ul class="org-ul">
<li>如果类型和初始化值一样,那么type annotation是多此一举</li>
<li>如果类型和初始化值不一样,那么还会报错</li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org49d6605" class="outline-3">
<h3 id="org49d6605"><span class="section-number-3">2.4.</span> Type Shapes</h3>
<div class="outline-text-3" id="text-2-4">
<ul class="org-ul">
<li>typescript不仅仅能检查赋值的时候类型是否匹配,还会理解object的shape</li>
<li>所谓object的shape,就是object能够拥有哪些:
<ul class="org-ul">
<li>property</li>
<li>method</li>
</ul></li>
</ul>
</div>
<div id="outline-container-org5640a2e" class="outline-4">
<h4 id="org5640a2e"><span class="section-number-4">2.4.1.</span> Modules</h4>
<div class="outline-text-4" id="text-2-4-1">
<ul class="org-ul">
<li>js自己是没有包版本管理系统的,直到2015年ECMAScript添加了ECMAScript modules(ESM),标准化了如下两个命令:
<ul class="org-ul">
<li><p>
import: 用来从其他文件读取value
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #531ab6;">import</span> <span style="color: #000000;">{</span> value <span style="color: #000000;">}</span> from <span style="color: #3548cf;">"./values"</span>;
</pre>
</div></li>
<li><p>
export: 用来把value导出到其他文件
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #531ab6;">export</span> <span style="color: #531ab6;">const</span> <span style="color: #005e8b;">doubled</span> = value * 2;
</pre>
</div></li>
</ul></li>
<li>本书为了和ECAMScript规范相一致,会严格区分如下两个概念:
<ul class="org-ul">
<li>Module: 包含export或者import的文件</li>
<li>Script: 不是module的文件,都是script</li>
</ul></li>
<li>ts自然是能和Module以及Script都处理好关系的,这是最低要求</li>
<li>moduleA里面如果定义了一个变量, 并不会和moduleB里面定义的其他同名变量相conflict(例外情况是你非要从
moduleB里面import那肯定不行,比如下面的例子),这也是module的魅力
<ul class="org-ul">
<li><p>
两个module里面相同名字,没问题
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #7f0000;">// </span><span style="color: #7f0000;">a.ts</span>
<span style="color: #531ab6;">export</span> <span style="color: #531ab6;">const</span> <span style="color: #005e8b;">shared</span> = <span style="color: #3548cf;">"Cher"</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">b.ts</span>
<span style="color: #531ab6;">export</span> <span style="color: #531ab6;">const</span> <span style="color: #005e8b;">shared</span> = <span style="color: #3548cf;">"Cher"</span>;
</pre>
</div></li>
<li><p>
两个module里面相同名字,但是你要从另外一个module import,那么就会declaration conflicts啦
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #7f0000;">// </span><span style="color: #7f0000;">a.ts</span>
<span style="color: #531ab6;">export</span> <span style="color: #531ab6;">const</span> <span style="color: #005e8b;">shared</span> = <span style="color: #3548cf;">"Cher"</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">c.ts</span>
<span style="color: #531ab6;">import</span> <span style="color: #000000;">{</span> shared <span style="color: #000000;">}</span> <span style="color: #531ab6;">from</span> <span style="color: #3548cf;">"./a"</span>;
<span style="color: #7f0000;">//       </span><span style="color: #7f0000;">~~~~~~</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Error: Import declaration conflicts with local declaration of 'shared'.</span>

<span style="color: #531ab6;">export</span> <span style="color: #531ab6;">const</span> <span style="color: #005e8b;">shared</span> = <span style="color: #3548cf;">"Cher"</span>;
<span style="color: #7f0000;">//           </span><span style="color: #7f0000;">~~~~~~</span>
<span style="color: #7f0000;">//  </span><span style="color: #7f0000;">Error: Individual declarations in merged declaration</span>
<span style="color: #7f0000;">//  </span><span style="color: #7f0000;">'shared' must b all exported or all local</span>
</pre>
</div></li>
</ul></li>
<li>在script里面,可以就不一样了,scriptA里面定义了一个变量,那么ts就认为他是全局的,同一个project下面的另
外一个scriptB文件就完全不能再定义同一个名字的变量了.
<ul class="org-ul">
<li><p>
例子如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #7f0000;">// </span><span style="color: #7f0000;">a.ts</span>
<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">shared</span> = <span style="color: #3548cf;">"Cher"</span>;
<span style="color: #7f0000;">//    </span><span style="color: #7f0000;">~~~~~~</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Cannot redeclare block-scoped variable 'shared'.</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">b.ts</span>
<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">shared</span> = <span style="color: #3548cf;">"Cher"</span>;
<span style="color: #7f0000;">//    </span><span style="color: #7f0000;">~~~~~~</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Cannot redeclare block-scoped variable 'shared'.</span>
</pre>
</div></li>
<li>上面的俩个文件虽然是.ts文件,但是由于没有import也没有export,那么就认为是普通script(不是module),于
是两个文件里面连同名变量都不能有</li>
<li>以后一旦看到"Cannot redeclare &#x2026;",那么看看是不是你的文件可能是script,避免这个错误的办法可以是转
换script成module</li>
<li><p>
如果实在不需要export和import,还想让你的script成为module,那么可以使用一个export {}.如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #7f0000;">// </span><span style="color: #7f0000;">a.ts and b.ts</span>
<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">shared</span> = <span style="color: #3548cf;">"Cher"</span>           <span style="color: #7f0000;">// </span><span style="color: #7f0000;">ok</span>
<span style="color: #531ab6;">export</span> <span style="color: #000000;">{}</span>;
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org482fff4" class="outline-2">
<h2 id="org482fff4"><span class="section-number-2">3.</span> Chapter 3: Unions and Literals</h2>
<div class="outline-text-2" id="text-3">
<ul class="org-ul">
<li>本章主要介绍如下两个特性:
<ul class="org-ul">
<li>Unions: 可以让一个value承载两种或者多种类型</li>
<li>Narrowing: 可以让一个value承载除了某几种类型以外的类型</li>
</ul></li>
</ul>
</div>
<div id="outline-container-orgcdd3d44" class="outline-3">
<h3 id="orgcdd3d44"><span class="section-number-3">3.1.</span> Union Types</h3>
<div class="outline-text-3" id="text-3-1">
<ul class="org-ul">
<li>有种情况,某个类型可能是多种类型
<ul class="org-ul">
<li><p>
代码如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">mathematician</span> = Math.<span style="color: #721045;">random</span><span style="color: #000000;">()</span> &gt; 0.5
  ? <span style="color: #0000b0;">undefined</span>
  : <span style="color: #3548cf;">"Mark Goldberg"</span>;
</pre>
</div></li>
<li>mathematician是一个either undefined or string的变量.这种"either or"类型在ts
里面就叫做union</li>
<li><p>
Typescript的编译器会分析出来,并且给出mathematician的类型判断如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">mathematician</span>: <span style="color: #531ab6;">string</span> | <span style="color: #0000b0;">undefined</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
<div id="outline-container-orgf52ba07" class="outline-4">
<h4 id="orgf52ba07"><span class="section-number-4">3.1.1.</span> Declaring Union Types</h4>
<div class="outline-text-4" id="text-3-1-1">
<ul class="org-ul">
<li><p>
union type的定义例子如下: 虽然thinker已经有了初始化值null,但是因为它有可能后面变成string,所以还是
给它一个string的定义
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">thinker</span>: <span style="color: #531ab6;">string</span> | <span style="color: #0000b0;">null</span> = <span style="color: #0000b0;">null</span>;

<span style="color: #531ab6;">if</span> <span style="color: #000000;">(</span>Math.<span style="color: #721045;">random</span><span style="color: #dd22dd;">()</span> &gt; 0.5<span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  thinker = <span style="color: #3548cf;">"Susanne Langer"</span>;   <span style="color: #7f0000;">// </span><span style="color: #7f0000;">ok</span>
<span style="color: #000000;">}</span>
</pre>
</div></li>
<li>union里面的多个类型的先后顺序是不重要的</li>
</ul>
</div>
</div>
<div id="outline-container-orgb4f4e03" class="outline-4">
<h4 id="orgb4f4e03"><span class="section-number-4">3.1.2.</span> Union Preperties</h4>
<div class="outline-text-4" id="text-3-1-2">
<ul class="org-ul">
<li><p>
如果一个类型是union的,那么ts只允许你访问union内部所有类型都有的member property. 访问只有部分类型有
的member property是会报type-checking error的,例子如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">physicist</span> = Math.<span style="color: #721045;">random</span><span style="color: #000000;">()</span> &gt; 0.5
  ? <span style="color: #3548cf;">"Marie Curie"</span>
  : 84;

physicist.<span style="color: #721045;">toString</span><span style="color: #000000;">()</span>;


<span style="color: #7f0000;">////////////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">error TS2339: Property 'toUpperCase' does not exist on type 'string | number'. //</span>
<span style="color: #7f0000;">////////////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">physicist.</span><span style="color: #721045;">toUpperCase</span><span style="color: #7f0000;">();</span>


<span style="color: #7f0000;">////////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">error TS2339: Property 'toFixed' does not exist on type 'string | number'. //</span>
<span style="color: #7f0000;">////////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">physicist.</span><span style="color: #721045;">toFixed</span><span style="color: #7f0000;">();</span>
</pre>
</div></li>
<li>为了能够使用只有某一种类型上才有的property, 代码需要告诉ts,在某处的code是one of those more specific
type:这个过程叫做narrowing</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org89b1bf9" class="outline-3">
<h3 id="org89b1bf9"><span class="section-number-3">3.2.</span> Narrowing</h3>
<div class="outline-text-3" id="text-3-2">
<ul class="org-ul">
<li>narrowing的方法有两种:
<ul class="org-ul">
<li>一种通过assignment</li>
<li>另外一种通过check</li>
</ul></li>
</ul>
</div>
<div id="outline-container-orga8b0384" class="outline-4">
<h4 id="orga8b0384"><span class="section-number-4">3.2.1.</span> Assignment Narrowing</h4>
<div class="outline-text-4" id="text-3-2-1">
<ul class="org-ul">
<li>assignment narrowing又有两种情况:
<ul class="org-ul">
<li><p>
初始化为其中一个类型
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">physicist</span>: <span style="color: #531ab6;">number</span> | <span style="color: #531ab6;">string</span> = 83;

physicist.<span style="color: #721045;">toString</span><span style="color: #000000;">()</span>;

<span style="color: #7f0000;">////////////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">error TS2339: Property 'toUpperCase' does not exist on type 'string | number'. //</span>
<span style="color: #7f0000;">////////////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">physicist.</span><span style="color: #721045;">toUpperCase</span><span style="color: #7f0000;">();</span>

physicist.<span style="color: #721045;">toFixed</span><span style="color: #000000;">()</span>;
</pre>
</div></li>
<li><p>
赋值为其中一个类型
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">physicist</span> = Math.<span style="color: #721045;">random</span><span style="color: #000000;">()</span> &gt; 0.5 ? <span style="color: #3548cf;">"Marie Curie"</span> : 84;

physicist.<span style="color: #721045;">toString</span><span style="color: #000000;">()</span>;

physicist = <span style="color: #3548cf;">"Hedy Lamarr"</span>;
physicist.<span style="color: #721045;">toUpperCase</span><span style="color: #000000;">()</span>;

<span style="color: #7f0000;">////////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">error TS2339: Property 'toFixed' does not exist on type 'string | number'. //</span>
<span style="color: #7f0000;">////////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">physicist.</span><span style="color: #721045;">toFixed</span><span style="color: #7f0000;">();</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org28a89ed" class="outline-4">
<h4 id="org28a89ed"><span class="section-number-4">3.2.2.</span> Conditional Checks</h4>
<div class="outline-text-4" id="text-3-2-2">
<ul class="org-ul">
<li><p>
ts非常聪明,能够判定if statement里面的变量当前是什么类型.下面的例子中在if里面scientist是字符串类型,
但是出了循环scientist就不再单单是字符串类型了
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">scientist</span> = Math.<span style="color: #721045;">random</span><span style="color: #000000;">()</span> &gt; 0.5 ? <span style="color: #3548cf;">"Rosalind Franklin"</span> : 51;

<span style="color: #531ab6;">if</span> <span style="color: #000000;">(</span>scientist === <span style="color: #3548cf;">"Rosalind Franklin"</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">Type of scientist: string</span>
  scientist.<span style="color: #721045;">toUpperCase</span><span style="color: #dd22dd;">()</span>; <span style="color: #7f0000;">// </span><span style="color: #005e8b;">ok</span>
<span style="color: #000000;">}</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">error TS2339: Property 'toUpperCase' does not exist on type 'string | number'.</span>
<span style="color: #7f0000;">//////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">scientist.</span><span style="color: #721045;">toUpperCase</span><span style="color: #7f0000;">(); //</span>
<span style="color: #7f0000;">//////////////////////////////</span>
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-orgca245e4" class="outline-4">
<h4 id="orgca245e4"><span class="section-number-4">3.2.3.</span> Typeof Checks</h4>
<div class="outline-text-4" id="text-3-2-3">
<ul class="org-ul">
<li>除了用直接的等于(<code>=</code>)判断,typescript还支持typeof的结果</li>
<li><p>
typeof首先可以判断true的情况
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">researcher</span> = Math.<span style="color: #721045;">random</span><span style="color: #000000;">()</span> &gt; 0.5 ? <span style="color: #3548cf;">"Rosalind Franklin"</span> : 51;

<span style="color: #531ab6;">if</span> <span style="color: #000000;">(</span><span style="color: #531ab6;">typeof</span> researcher === <span style="color: #3548cf;">"string"</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  researcher.<span style="color: #721045;">toUpperCase</span><span style="color: #dd22dd;">()</span>; <span style="color: #7f0000;">// </span><span style="color: #005e8b;">ok</span>
<span style="color: #000000;">}</span>
</pre>
</div></li>
<li><p>
typeof也可以判断false的情况
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">researcher</span> = Math.<span style="color: #721045;">random</span><span style="color: #000000;">()</span> &gt; 0.5 ? <span style="color: #3548cf;">"Rosalind Franklin"</span> : 51;

<span style="color: #531ab6;">if</span> <span style="color: #000000;">(</span>!<span style="color: #dd22dd;">(</span><span style="color: #531ab6;">typeof</span> researcher === <span style="color: #3548cf;">"string"</span><span style="color: #dd22dd;">)</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  researcher.<span style="color: #721045;">toFixed</span><span style="color: #dd22dd;">()</span>; <span style="color: #7f0000;">// </span><span style="color: #005e8b;">ok</span>
<span style="color: #000000;">}</span> <span style="color: #531ab6;">else</span> <span style="color: #000000;">{</span>
  researcher.<span style="color: #721045;">toUpperCase</span><span style="color: #dd22dd;">()</span>; <span style="color: #7f0000;">// </span><span style="color: #005e8b;">ok</span>
<span style="color: #000000;">}</span>
</pre>
</div></li>
<li><p>
我们还可以把typeof写成三元表达式的情况
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">researcher</span> = Math.<span style="color: #721045;">random</span><span style="color: #000000;">()</span> &gt; 0.5 ? <span style="color: #3548cf;">"Rosalind Franklin"</span> : 51;

<span style="color: #531ab6;">typeof</span> researcher === <span style="color: #3548cf;">"string"</span>
  ? researcher.<span style="color: #721045;">toUpperCase</span><span style="color: #000000;">()</span> <span style="color: #7f0000;">// </span><span style="color: #005e8b;">ok</span>
  : researcher.<span style="color: #721045;">toFixed</span><span style="color: #000000;">()</span>; <span style="color: #7f0000;">// </span><span style="color: #005e8b;">ok</span>
</pre>
</div></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgc59a10f" class="outline-3">
<h3 id="orgc59a10f"><span class="section-number-3">3.3.</span> Literal Types</h3>
<div class="outline-text-3" id="text-3-3">
<ul class="org-ul">
<li>先来看个例子
<ul class="org-ul">
<li><p>
例子如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">philosopher</span> = <span style="color: #3548cf;">"Hypatia"</span>;
</pre>
</div></li>
<li>这个例子中的philosopher是一个string类型,这也是我们之前学到的内容</li>
<li>我们这里要学到的是,philosopher不仅仅是string类型,它还是一个更具体的类型,叫做"specific Hypatia"类型</li>
<li><p>
这种"更具体的类型",就是literal type,具体点说就是
</p>
<pre class="example" id="orge7c6169">
The type of a value that is known to be a specific value of a primitive,
rather than any of those primitive's value at all
</pre></li>
</ul></li>
<li>我们来看看"string类型"和"Hypatia类型"的区别:
<ul class="org-ul">
<li>primitive type string代表了所有可能的字符串</li>
<li>literal type Hypatia只能代表一种字符串</li>
</ul></li>
<li><p>
如果你创建了变量,并且给它设置为const,那么ts就直接给这个变量设置为literal type,比如下面的例子中,
mathematician的类型就是 "Mark Goldberg"
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">mathematician</span> = <span style="color: #3548cf;">"Mark Goldberg"</span>;
</pre>
</div></li>
<li><p>
你可以把每个primitive type都看成是所有可能的literal value的union
</p>
<pre class="example" id="org75f3010">
You can think of each primitive type as a union of every possible matching literal value
</pre></li>
<li><p>
union type annotation可以混合literal和primitive,比如下面的例子
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">lifespan</span>: <span style="color: #531ab6;">number</span> | <span style="color: #3548cf;">"ongoing"</span> | <span style="color: #3548cf;">"uncertain"</span>;

lifespan = 89;                   <span style="color: #7f0000;">// </span><span style="color: #7f0000;">ok</span>
lifespan = <span style="color: #3548cf;">"ongoing"</span>;            <span style="color: #7f0000;">// </span><span style="color: #7f0000;">ok</span>

<span style="color: #7f0000;">/////////////////////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">error TS2322: Type 'true' is not assignable to type 'number | "ongoing" | "uncertain"'. //</span>
<span style="color: #7f0000;">/////////////////////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">//</span><span style="color: #7f0000;">lifespan = true;</span>
</pre>
</div></li>
</ul>
</div>
<div id="outline-container-org17f2fb0" class="outline-4">
<h4 id="org17f2fb0"><span class="section-number-4">3.3.1.</span> Literal Assignability</h4>
<div class="outline-text-4" id="text-3-3-1">
<ul class="org-ul">
<li>literal type可不是简单说说一下,它真的是一个类型:
<ul class="org-ul">
<li>我们知道,不通的primitive 类型相互之间不能赋值:比如number和string不能相互赋值</li>
<li>不同的literal type之间也不能相互赋值(虽然他们属于同一种primitive type)</li>
</ul></li>
<li>我们可以从下面的例子证明这一点:
<ul class="org-ul">
<li><p>
例子如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">specificallyAda</span>: <span style="color: #3548cf;">"Ada"</span>;
specificallyAda = <span style="color: #3548cf;">"Ada"</span>;         <span style="color: #7f0000;">// </span><span style="color: #7f0000;">ok</span>

<span style="color: #7f0000;">/////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">error TS2322: Type '"Byron"' is not assignable to type '"Ada"'. //</span>
<span style="color: #7f0000;">/////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">specificallyAda = "Byron";</span>

<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">someStirng</span> = <span style="color: #3548cf;">""</span>;            <span style="color: #7f0000;">// </span><span style="color: #7f0000;">Type: string</span>

<span style="color: #7f0000;">////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">error TS2322: Type 'string' is not assignable to type '"Ada"'. //</span>
<span style="color: #7f0000;">////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">specificallyAda = someStirng</span>
</pre>
</div></li>
<li><p>
注意,创建一个literal type除了使用const,还可以把literal 类型像其他类型一样写在':'后面,但是注意,虽
然specificallyAda的值只能是"Ada"(因为他是"Ada"类型的),但是初始化之后没有赋值,还是不能访问的,否则
会报错.例子如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">specificallyAda</span>: <span style="color: #3548cf;">"Ada"</span>;

<span style="color: #7f0000;">/////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">error TS2454: Variable 'specificallyAda' is used before being assigned. //</span>
<span style="color: #7f0000;">/////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">console.</span><span style="color: #721045;">log</span><span style="color: #7f0000;">(specificallyAda)</span>

specificallyAda = <span style="color: #3548cf;">"Ada"</span>;         <span style="color: #7f0000;">// </span><span style="color: #7f0000;">ok</span>
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>specificallyAda<span style="color: #000000;">)</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Ada</span>
</pre>
</div></li>
</ul></li>
<li>literal type相互之间不可用赋值,但是literal type却可以"向上"赋值给自己所在的primitive type,这也是
literal type作为比primitive低一个级别类型的特点."向上"赋值随时可见,只是我们没有想到.比如下面这两个
都是向上赋值:
<ul class="org-ul">
<li><p>
比较"严谨"的向上赋值
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">smile</span> : <span style="color: #3548cf;">":)"</span>;
smile = <span style="color: #3548cf;">":)"</span>;
<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">something</span> = <span style="color: #3548cf;">""</span>;

something = smile
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>something<span style="color: #000000;">)</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">:)</span>
</pre>
</div></li>
<li><p>
比较"常见"的向上赋值,其实是上面"严谨"版本的简化版
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">someString</span> = <span style="color: #3548cf;">":)"</span>;
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orga6b3af7" class="outline-3">
<h3 id="orga6b3af7"><span class="section-number-3">3.4.</span> Strict Null Checking</h3>
<div class="outline-text-3" id="text-3-4">
<ul class="org-ul">
<li>narrowed union在加上literal能够让ts非常从容的处理strict null checking</li>
</ul>
</div>
<div id="outline-container-org0f584c6" class="outline-4">
<h4 id="org0f584c6"><span class="section-number-4">3.4.1.</span> The Billion-Dollar Mistake</h4>
<div class="outline-text-4" id="text-3-4-1">
<ul class="org-ul">
<li>所谓的billion-dollar mistake是指, null value的发明者认为这不是一个好的发明,把null value引入编程语言
导致了几十亿美元的损失.</li>
<li>ts的编译器包含了很多option,允许我们配置编译器,最著名的一个选项就是strictNullChecks:
<ul class="org-ul">
<li><p>
如果enable,那么null(undefined)不能赋值给其他类型变量,默认的配置就是这样的
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">someString</span> = <span style="color: #3548cf;">"abc"</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>someString<span style="color: #000000;">)</span>

<span style="color: #7f0000;">///////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">error TS2322: Type 'null' is not assignable to type 'string'. //</span>
<span style="color: #7f0000;">///////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">someString = null;</span>
</pre>
</div></li>
<li><p>
如果disable,那么显然就是null(undefined)可以赋值给其他变量.其实质上的原理,就是给每个类型添加如下
代码
</p>
<div class="org-src-container">
<pre class="src src-typescript">| <span style="color: #0000b0;">null</span> | <span style="color: #0000b0;">undefined</span>
</pre>
</div></li>
</ul></li>
<li>ts的最佳实践就是开启strictNullCheck,否则无法规避某些null和undefined对代码的破坏</li>
</ul>
</div>
</div>
<div id="outline-container-orgdd30484" class="outline-4">
<h4 id="orgdd30484"><span class="section-number-4">3.4.2.</span> Truthiness Narrowing</h4>
<div class="outline-text-4" id="text-3-4-2">
<ul class="org-ul">
<li>在js里面,判断一个变量是否为true原理如下:变量只要不是如下值,那么它们就是true:
<ul class="org-ul">
<li>false</li>
<li>0</li>
<li>-0</li>
<li>0n</li>
<li>""</li>
<li>null</li>
<li>undefined</li>
<li>NaN</li>
</ul></li>
<li>基于js的这些设置,那么ts可以在某些if为true的case里面,narrowing类型成功(到一种)
<ul class="org-ul">
<li><p>
例子如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">geneticist</span> = Math.<span style="color: #721045;">random</span><span style="color: #000000;">()</span> &gt; 0.5
  ? <span style="color: #3548cf;">"Barbara McClintock"</span>
  : <span style="color: #0000b0;">undefined</span>;

<span style="color: #531ab6;">if</span> <span style="color: #000000;">(</span>geneticist<span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  geneticist.<span style="color: #721045;">toUpperCase</span><span style="color: #dd22dd;">()</span>;      <span style="color: #7f0000;">// </span><span style="color: #005e8b;">ok</span><span style="color: #7f0000;">: </span><span style="color: #005e8b;">string</span>
<span style="color: #000000;">}</span>

<span style="color: #7f0000;">//////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">error TS18048: 'geneticist' is possibly 'undefined'. //</span>
<span style="color: #7f0000;">//////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">geneticist.</span><span style="color: #721045;">toUpperCase</span><span style="color: #7f0000;">();</span>
</pre>
</div></li>
<li>上面例子中,由于undefined是不可能为true的,那么if 里面是必然是string类型的</li>
<li>在if之外,就不能narrowing了,强制调用toUpperCase()会失败</li>
</ul></li>
<li>注意,这种narrowing只能在true case里面起作用,无法在false case里面起作用,因为空字符串("")和undefined
都被认为是false</li>
</ul>
</div>
</div>
<div id="outline-container-org01e6a7b" class="outline-4">
<h4 id="org01e6a7b"><span class="section-number-4">3.4.3.</span> Variables Without Initial Values</h4>
<div class="outline-text-4" id="text-3-4-3">
<ul class="org-ul">
<li>在js里面,如果一个变量声明之后,没有给初始化值,那么这个变量就会初始化成undefined</li>
<li>在ts中如果试图使用一个值为undefined的变量(声明之后没有赋值的变量),ts会报一个特定的错误,
<ul class="org-ul">
<li><p>
代码如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">mathematician</span>: <span style="color: #531ab6;">string</span>;
<span style="color: #7f0000;">///////////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">error TS2454: Variable 'mathematician' is used before being assigned. //</span>
<span style="color: #7f0000;">///////////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">mathematician?.length;</span>

mathematician = <span style="color: #3548cf;">"Mark Goldberg"</span>;
mathematician.length;
</pre>
</div></li>
<li><p>
上面例子中出现了 `?`, 这是ts里面特有的安全链式调用,详细解释如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#36825;&#37324; Error&#23545;&#35937;&#23450;&#20041;&#30340;stack&#26159;&#21487;&#36873;&#21442;&#25968;&#65292;&#22914;&#26524;&#36825;&#26679;&#20889;&#30340;&#35805;&#32534;&#35793;&#22120;&#20250;&#25552;&#31034;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#20986;&#38169; TS2532: Object is possibly 'undefined'.</span>
<span style="color: #531ab6;">return</span> <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Error</span><span style="color: #000000;">()</span>.stack.<span style="color: #721045;">split</span><span style="color: #000000;">(</span><span style="color: #3548cf;">'\n'</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#25105;&#20204;&#21487;&#20197;&#28155;&#21152;?&#25805;&#20316;&#31526;&#65292;&#24403;stack&#23646;&#24615;&#23384;&#22312;&#26102;&#65292;&#35843;&#29992; stack.split&#12290;&#33509;stack&#19981;&#23384;&#22312;&#65292;&#21017;&#36820;&#22238;&#31354;</span>
<span style="color: #531ab6;">return</span> <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Error</span><span style="color: #000000;">()</span>.stack?.<span style="color: #721045;">split</span><span style="color: #000000;">(</span><span style="color: #3548cf;">'\n'</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#20197;&#19978;&#20195;&#30721;&#31561;&#21516;&#20197;&#19979;&#20195;&#30721;</span>
<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">err</span> = <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Error</span><span style="color: #000000;">()</span>;
<span style="color: #531ab6;">return</span> err.stack &amp;&amp; err.stack.<span style="color: #721045;">split</span><span style="color: #000000;">(</span><span style="color: #3548cf;">'\n'</span><span style="color: #000000;">)</span>;
</pre>
</div></li>
<li><p>
注意,如果类型里面union了undefined,那么上面的错误不会发生
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">mathematician</span>: <span style="color: #531ab6;">string</span> | <span style="color: #0000b0;">undefined</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>mathematician?.length<span style="color: #000000;">)</span>;

mathematician = <span style="color: #3548cf;">"Mark Goldberg"</span>;
mathematician.length;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">undefined</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org1f8f96d" class="outline-3">
<h3 id="org1f8f96d"><span class="section-number-3">3.5.</span> Type Aliases</h3>
<div class="outline-text-3" id="text-3-5">
<ul class="org-ul">
<li><p>
绝大多数情况下,union只有两三个成员,但是也有出现很多成员的情况,如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">rawDataFirst</span>: <span style="color: #531ab6;">boolean</span> | <span style="color: #531ab6;">number</span> | <span style="color: #531ab6;">string</span> | <span style="color: #0000b0;">null</span> | <span style="color: #0000b0;">undefined</span>
<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">rawDataSecond</span>: <span style="color: #531ab6;">boolean</span> | <span style="color: #531ab6;">number</span> | <span style="color: #531ab6;">string</span> | <span style="color: #0000b0;">null</span> | <span style="color: #0000b0;">undefined</span>
<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">rawDataThird</span>: <span style="color: #531ab6;">boolean</span> | <span style="color: #531ab6;">number</span> | <span style="color: #531ab6;">string</span> | <span style="color: #0000b0;">null</span> | <span style="color: #0000b0;">undefined</span>
</pre>
</div></li>
<li><p>
上述例子中的 `boolean | number | string | null | undefined` 被使用了多次,为了保证DRY原则,ts又设计了
重用type列表的type alias,上面的例子就可以改写成如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">type</span> <span style="color: #005f5f;">RawData</span> = <span style="color: #531ab6;">boolean</span> | <span style="color: #531ab6;">number</span> | <span style="color: #531ab6;">string</span> | <span style="color: #0000b0;">null</span> | <span style="color: #0000b0;">undefined</span>

<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">rawDataFirst</span>: <span style="color: #005f5f;">RawData</span>
<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">rawDataSecond</span>: <span style="color: #005f5f;">RawData</span>
<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">rawDataThird</span>: <span style="color: #005f5f;">RawData</span>
</pre>
</div></li>
</ul>
</div>
<div id="outline-container-org32d5405" class="outline-4">
<h4 id="org32d5405"><span class="section-number-4">3.5.1.</span> Type Aliases Are Not JavaScript</h4>
<div class="outline-text-4" id="text-3-5-1">
<ul class="org-ul">
<li>type alias不会编译成javascript,它只存在于typescript里面</li>
<li><p>
既然不会被编译成js,那么你在运行时想access这个变量就是违法的,ts会报警
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">type</span> <span style="color: #005f5f;">SomeType</span> = <span style="color: #531ab6;">string</span> | <span style="color: #0000b0;">undefined</span>;

<span style="color: #7f0000;">////////////////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">error TS2693: 'SomeType' only refers to a type, but is being used as a value here. //</span>
<span style="color: #7f0000;">////////////////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">console.</span><span style="color: #721045;">log</span><span style="color: #7f0000;">(SomeType)</span>
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-orgc131390" class="outline-4">
<h4 id="orgc131390"><span class="section-number-4">3.5.2.</span> Combining Type Aliases</h4>
<div class="outline-text-4" id="text-3-5-2">
<ul class="org-ul">
<li><p>
type alias还可以互相引用
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">type</span> <span style="color: #005f5f;">Id</span> = <span style="color: #531ab6;">number</span> | <span style="color: #531ab6;">string</span>

<span style="color: #531ab6;">type</span> <span style="color: #005f5f;">IdMaybe</span> = Id | <span style="color: #0000b0;">undefined</span> | <span style="color: #0000b0;">null</span>; <span style="color: #7f0000;">// </span><span style="color: #7f0000;">Equivalent to: number | string | undefind | null</span>
</pre>
</div></li>
<li><p>
互相引用的时候,不必要又顺序,ts编译器会全局考虑,所以使用未定义的type alias也是允许的
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">type</span> <span style="color: #005f5f;">IdMaybe</span> = Id | <span style="color: #0000b0;">undefined</span> | <span style="color: #0000b0;">null</span>; <span style="color: #7f0000;">// </span><span style="color: #7f0000;">Equivalent to: number | string | undefind | null</span>
<span style="color: #531ab6;">type</span> <span style="color: #005f5f;">Id</span> = <span style="color: #531ab6;">number</span> | <span style="color: #531ab6;">string</span>
</pre>
</div></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-orgb4e8a19" class="outline-2">
<h2 id="orgb4e8a19"><span class="section-number-2">4.</span> Chapter 4: Objects</h2>
<div class="outline-text-2" id="text-4">
</div>
<div id="outline-container-orgc4525c2" class="outline-3">
<h3 id="orgc4525c2"><span class="section-number-3">4.1.</span> Object Types</h3>
<div class="outline-text-3" id="text-4-1">
<ul class="org-ul">
<li>在ts/js里面,有种创建object的方法叫做object literal
<ul class="org-ul">
<li><p>
样子如下
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">person</span> = <span style="color: #000000;">{</span>
  name: <span style="color: #3548cf;">"adam"</span>,
  age: 23,
<span style="color: #000000;">}</span>;
console.log<span style="color: #000000;">(</span>person<span style="color: #000000;">)</span>
console.log<span style="color: #000000;">(</span><span style="color: #531ab6;">typeof</span><span style="color: #dd22dd;">(</span>person<span style="color: #dd22dd;">)</span><span style="color: #000000;">)</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">{ name: 'adam', age: 23 }</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">object</span>
</pre>
</div></li>
<li>在js的语境中person的类型就是object</li>
</ul></li>
<li>ts中当然也承认这种用法,并且ts还做了js没有做的事情,给新的object person一个更加具体的类型
<ul class="org-ul">
<li>类型名字叫'{name: string; age: number;}'</li>
<li><p>
这个类型我们可以通过typescript playground可以看到,也可以通过如下的"错误"代码看到
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">person</span> = <span style="color: #000000;">{</span>
  name: <span style="color: #3548cf;">"adam"</span>,
  age: 23,
<span style="color: #000000;">}</span>;

<span style="color: #7f0000;">/////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Property 'foo' does not exist on type '{ name: string; age: number; }'. //</span>
<span style="color: #7f0000;">/////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">person.</span><span style="color: #721045;">foo</span><span style="color: #7f0000;">()</span>
</pre>
</div></li>
</ul></li>
<li>在js和ts中,我们都可以使用如下两种方式访问object value的成员:
<ul class="org-ul">
<li>object_value.mameber</li>
<li>object_value['member']</li>
</ul></li>
<li><p>
如果访问不存在的member,那么会报警
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">const</span>  <span style="color: #005e8b;">poet</span> = <span style="color: #000000;">{</span>
  born: 1935,
  name: <span style="color: #3548cf;">"Mary Oliver"</span>,
<span style="color: #000000;">}</span>;

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>poet<span style="color: #dd22dd;">[</span><span style="color: #3548cf;">'born'</span><span style="color: #dd22dd;">]</span><span style="color: #000000;">)</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>poet.name<span style="color: #000000;">)</span>;

<span style="color: #7f0000;">////////////////////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">error TS2339: Property 'end' does not exist on type '{ born: number; name: string; }'. //</span>
<span style="color: #7f0000;">////////////////////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">poet.end;</span>
</pre>
</div></li>
</ul>
</div>
<div id="outline-container-orgfe85b59" class="outline-4">
<h4 id="orgfe85b59"><span class="section-number-4">4.1.1.</span> Declaring Object Types</h4>
<div class="outline-text-4" id="text-4-1-1">
<ul class="org-ul">
<li>ts作为一个静态的类型系统语言,当然会提供"显式"定义object type的功能
<ul class="org-ul">
<li><p>
代码如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">poetLater</span>: <span style="color: #000000;">{</span>
  born: <span style="color: #531ab6;">number</span>;
  name: <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">ok</span>
poetLater = <span style="color: #000000;">{</span>
  born: 1935,
  name: <span style="color: #3548cf;">"Mary Oliver"</span>,
<span style="color: #000000;">}</span>;

<span style="color: #7f0000;">//////////////////////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">error TS2322: Type 'string' is not assignable to type '{ born: number; name: string; }'. //</span>
<span style="color: #7f0000;">//////////////////////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">poetLater = "Sappho";</span>
</pre>
</div></li>
<li>注意这里的类型就是type '{ born: number; name: string; }'</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org4449b64" class="outline-4">
<h4 id="org4449b64"><span class="section-number-4">4.1.2.</span> Aliased Object Types</h4>
<div class="outline-text-4" id="text-4-1-2">
<ul class="org-ul">
<li>我们发现上一节讲到的ts的类型名字都是这样的type '{ born: number; name: string; }', 这种名字是类似"匿名"
的这么一种方式(只有类型的属性,没有名字)</li>
<li><p>
如果我们想给不同的变量赋予类型,显然还是"非匿名"的方式更好,也就是给object type一个名字.这样一来,我们
的error message也会更加易读
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">type</span> <span style="color: #005f5f;">Poet</span> = <span style="color: #000000;">{</span>
  born: <span style="color: #531ab6;">number</span>;
  name: <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>;

<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">poetLater</span>: <span style="color: #005f5f;">Poet</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">ok</span>
poetLater = <span style="color: #000000;">{</span>
  born: 1935,
  name: <span style="color: #3548cf;">"Sara Teasdale"</span>,
<span style="color: #000000;">}</span>;

<span style="color: #7f0000;">///////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">error TS2322: Type 'string' is not assignable to type 'Poet'. //</span>
<span style="color: #7f0000;">///////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">poetLater = "Emily Dickinson"</span>
</pre>
</div></li>
<li>理解ts如何解析object literal对于我们理解ts的type system非常重要,本节内容对后面理解也非常重要</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org0e2dc67" class="outline-3">
<h3 id="org0e2dc67"><span class="section-number-3">4.2.</span> Structural Typing</h3>
<div class="outline-text-3" id="text-4-2">
<ul class="org-ul">
<li><p>
TypeScript的类型系统叫做structurally typed: 所谓structurally type,是说一个value"刚好"能满足一个类型,
那么就可以作为这个类型的value. 换句话说就是golang的所谓类型推断(Type inference),不需要显式的类型声明
</p>
<pre class="example" id="org81c0a01">
Structurally typing means: any value that happens to satisfy a type is a allowed to be used
as a value of that type.
</pre></li>
<li>下面就是一个structural typing的例子:
<ul class="org-ul">
<li><p>
如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">type</span> <span style="color: #005f5f;">WithFirstName</span> = <span style="color: #000000;">{</span>
  firstName: <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>;

<span style="color: #531ab6;">type</span> <span style="color: #005f5f;">WithLastName</span> = <span style="color: #000000;">{</span>
  lastName: <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>;

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">hasBoth</span> = <span style="color: #000000;">{</span>
  firstName: <span style="color: #3548cf;">"Lucille"</span>,
  lastName: <span style="color: #3548cf;">"Clifton"</span>,
<span style="color: #000000;">}</span>;

<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">withFirstName</span>: <span style="color: #005f5f;">WithFirstName</span> = hasBoth;
<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">withLastName</span>: <span style="color: #005f5f;">WithLastName</span> = hasBoth;

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>withFirstName<span style="color: #000000;">)</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>withLastName<span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">{ firstName: 'Lucille', lastName: 'Clifton' }</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">{ firstName: 'Lucille', lastName: 'Clifton' }</span>
</pre>
</div></li>
<li>这个例子中我们有两个类型WithFirstName和WithLastName,每个类型都只有一个成员.</li>
<li>而hasBoth刚好这两个成员都有,那么即便我们没有"显式"的声明hashBoth属于这两个类型,但是hasBoth确实同
时符合这两个类型,那么一旦有这两个类型的变量需要value,我们的hashBoth就可以提供了.</li>
</ul></li>
<li>需要注意的是Structural typing和duck typing是两个概念:
<ul class="org-ul">
<li>structural tying是有staic system check的,在typescript这里就是type checker</li>
<li>duck typing是没有static system check的,它是在runtime遇到某个属性方法的时候,才去做check. Javascript
就是duck typing的编程语言</li>
</ul></li>
</ul>
</div>
<div id="outline-container-org1a11e9c" class="outline-4">
<h4 id="org1a11e9c"><span class="section-number-4">4.2.1.</span> Usage Checking</h4>
<div class="outline-text-4" id="text-4-2-1">
<ul class="org-ul">
<li>当我们在为一个value标记object type的时候,typescript会去check这个value是否满足了目标标记的type所需要
的所有成员. 如果缺少成员,那么就会报type error(多了其实也不行,后面会看到. 赋值的时候多了可以,声明的
时候多了不行)</li>
<li>下面就是一个缺少成员而报错的例子
<ul class="org-ul">
<li><p>
代码如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">type</span> <span style="color: #005f5f;">FirstAndLastNames</span> = <span style="color: #000000;">{</span>
  first: <span style="color: #531ab6;">string</span>;
  last: <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">ok</span>
<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">hasBoth</span>: <span style="color: #005f5f;">FirstAndLastNames</span> = <span style="color: #000000;">{</span>
  first: <span style="color: #3548cf;">"Sarojini"</span>,
  last: <span style="color: #3548cf;">"Naidu"</span>,
<span style="color: #000000;">}</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:12:7 - error TS2741: Property 'last' is missing in type '{ first: string; }' but required in type 'FirstAndLastNames'.</span>

<span style="color: #7f0000;">/////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">const hasOnlyOne: FirstAndLastNames = { //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">first: "Sappho",                      //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">};                                      //</span>
<span style="color: #7f0000;">/////////////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
<li>如果数量对上了,但是具体的类型没有满足,也是会报错的.
<ul class="org-ul">
<li><p>
如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">type</span> <span style="color: #005f5f;">TimeRange</span> = <span style="color: #000000;">{</span>
  start: <span style="color: #005f5f;">Date</span>;
<span style="color: #000000;">}</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:6:3 - error TS2322: Type 'string' is not assignable to type 'Date'.</span>

<span style="color: #7f0000;">/////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">const hasStartString: TimeRange = { //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">start: "1979-02-13",              //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">};                                  //</span>
<span style="color: #7f0000;">/////////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgedc3911" class="outline-4">
<h4 id="orgedc3911"><span class="section-number-4">4.2.2.</span> Excess Property Checking</h4>
<div class="outline-text-4" id="text-4-2-2">
<ul class="org-ul">
<li>我们对Typescript的structural typing印象深刻,一来是不需要声明,二来是成员满足即可,成员多了也能赋值成功</li>
<li>如果初始化变量的时候,我们声明了(同时标记了类型),那么成员就必须一模一样,不能少,也不能多了
<ul class="org-ul">
<li><p>
下面的例子中,就是我们在声明的时候,标记了类型,多一个成员activity就会报错
</p>
<div class="org-src-container">
<pre class="src src-js">type Poet = <span style="color: #000000;">{</span>
  born: number;
  name: string;
<span style="color: #000000;">}</span>;

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">poetMatch</span>: Poet = <span style="color: #000000;">{</span>
  born: 1928,
  name: <span style="color: #3548cf;">"Maya Angelou"</span>,
<span style="color: #000000;">}</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:12:3 - error TS2353: Object literal may only specify known properties, and 'activity' does not exist in type 'Poet'.</span>

<span style="color: #7f0000;">///////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">const extraProperty: Poet = { //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">activity: "walking",        //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">born: 1935,                 //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">name: "Mary Oliver",        //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">};                            //</span>
<span style="color: #7f0000;">///////////////////////////////////</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">existingObject</span> = <span style="color: #000000;">{</span>
  activity: <span style="color: #3548cf;">"walking"</span>,
  born: 1935,
  name: <span style="color: #3548cf;">"Mary Oliver"</span>,
<span style="color: #000000;">}</span>;

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">extraProperty</span>: Poet = existingObject; <span style="color: #7f0000;">// </span><span style="color: #7f0000;">Ok</span>
</pre>
</div></li>
<li>我们可以看到,初始化的时候多了是会有问题的(因为这时候往往是mistype), 但是用一个其他value赋值的时候多了是没问题的</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgdcfc5f3" class="outline-4">
<h4 id="orgdcfc5f3"><span class="section-number-4">4.2.3.</span> Nested Object Types</h4>
<div class="outline-text-4" id="text-4-2-3">
<ul class="org-ul">
<li>由于Javascript object可以nest很多其他的object, typescript也就必须能够表达nested object.</li>
<li>我们在type定义的类型,在使用object literal(而不是value)初始化的时候,必须完全一致
<ul class="org-ul">
<li><p>
下面代码中poemMismatch缺少author成员,所以初始化报错
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">type</span> <span style="color: #005f5f;">Poem</span> = <span style="color: #000000;">{</span>
  author: <span style="color: #dd22dd;">{</span>
    firstName: <span style="color: #531ab6;">string</span>;
    lastName: <span style="color: #531ab6;">string</span>;
  <span style="color: #dd22dd;">}</span>;
  name: <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">ok</span>
<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">poemMatch</span>: <span style="color: #005f5f;">Poem</span> = <span style="color: #000000;">{</span>
  author: <span style="color: #dd22dd;">{</span>
    firstName: <span style="color: #3548cf;">"Sylvia"</span>,
    lastName: <span style="color: #3548cf;">"Plath"</span>,
  <span style="color: #dd22dd;">}</span>,
  name: <span style="color: #3548cf;">"Lady Lazarus"</span>,
<span style="color: #000000;">}</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:20:5 - error TS2353: Object literal may only specify known properties, and 'name' does not exist in type '{ firstName: string; lastName: string; }'.</span>

<span style="color: #7f0000;">//////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">const poemMismatch: Poem = { //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">author: {                  //</span>
<span style="color: #7f0000;">//     </span><span style="color: #7f0000;">name: "Sylvia Plath",    //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">},                         //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">name: "Tuplips",           //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">};                           //</span>
<span style="color: #7f0000;">//////////////////////////////////</span>
</pre>
</div></li>
<li>上面的代码报错比较不容易理解,因为我们的author成员没有文字类型,只能用'{ firstName: string; lastName: string; }'来替代.</li>
<li><p>
一个更好的办法是把nested 类型给拆出来,给与一个名字,比如Author,那么代码更清晰,报错也更易读
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">type</span> <span style="color: #005f5f;">Author</span> = <span style="color: #000000;">{</span>
  firstName: <span style="color: #531ab6;">string</span>;
  lastName: <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>;

<span style="color: #531ab6;">type</span> <span style="color: #005f5f;">Poem</span> = <span style="color: #000000;">{</span>
  author: <span style="color: #005f5f;">Author</span>;
  name: <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:16:5 - error TS2353: Object literal may only specify known properties, and 'name' does not exist in type 'Author'.</span>

<span style="color: #7f0000;">//////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">const poemMismatch: Poem = { //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">author: {                  //</span>
<span style="color: #7f0000;">//     </span><span style="color: #7f0000;">name: "Sylvia Plath",    //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">},                         //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">name: "Tuplips",           //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">};                           //</span>
<span style="color: #7f0000;">//////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org4e09453" class="outline-4">
<h4 id="org4e09453"><span class="section-number-4">4.2.4.</span> Optional Properties</h4>
<div class="outline-text-4" id="text-4-2-4">
<ul class="org-ul">
<li>Object type可以包含一些"可选"成员,这些成员可以不出现,使用`?`标记
<ul class="org-ul">
<li><p>
比如下面的author成员可以不出现
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">type</span> <span style="color: #005f5f;">Book</span> = <span style="color: #000000;">{</span>
  author?: <span style="color: #531ab6;">string</span>;
  pages: <span style="color: #531ab6;">number</span>;
<span style="color: #000000;">}</span>;

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">ok</span>: <span style="color: #005f5f;">Book</span> = <span style="color: #000000;">{</span>
  author: <span style="color: #3548cf;">"Rita Dove"</span>,
  pages: 80,
<span style="color: #000000;">}</span>;

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">ok2</span>: <span style="color: #005f5f;">Book</span> = <span style="color: #000000;">{</span>
  pages: 90,
<span style="color: #000000;">}</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:15:7 - error TS2741: Property 'pages' is missing in type '{ author: string; }' but required in type 'Book'.</span>

<span style="color: #7f0000;">/////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">const missing: Book = { //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">author: "Rita Dove",  //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">};                      //</span>
<span style="color: #7f0000;">/////////////////////////////</span>
</pre>
</div></li>
<li>但是注意pages是必须出现的,不出现就会报错</li>
</ul></li>
<li>optional参数是可以不存在的,这个和类型为undefined(或者union包含undefined)不一样,后者即便是undefined也要存在
<ul class="org-ul">
<li><p>
例子如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">type</span> <span style="color: #005f5f;">Writers</span> = <span style="color: #000000;">{</span>
  author: <span style="color: #531ab6;">string</span> | <span style="color: #0000b0;">undefined</span>;
  editor?: <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">ok</span>
<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">hasRequired</span>: <span style="color: #005f5f;">Writers</span> = <span style="color: #000000;">{</span>
  author: <span style="color: #0000b0;">undefined</span>,
<span style="color: #000000;">}</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:11:7 - error TS2741: Property 'author' is missing in type '{}' but required in type 'Writers'.</span>

<span style="color: #7f0000;">//////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">const missingRequired: Writers = {}; //</span>
<span style="color: #7f0000;">//////////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgf8f69ce" class="outline-3">
<h3 id="orgf8f69ce"><span class="section-number-3">4.3.</span> Unions of Object Types</h3>
<div class="outline-text-3" id="text-4-3">
<ul class="org-ul">
<li>既然普通类型有union,那么object类型的union需求也是合理的</li>
</ul>
</div>
<div id="outline-container-org4043a65" class="outline-4">
<h4 id="org4043a65"><span class="section-number-4">4.3.1.</span> Inferred Object-Type Unions</h4>
<div class="outline-text-4" id="text-4-3-1">
<ul class="org-ul">
<li>如果我们不明确的"声明"类型,而是直接赋值(通过?:),那么Typescript会自动的为我们创建union type
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">poem</span> =
  Math.<span style="color: #721045;">random</span><span style="color: #000000;">()</span> &gt; 0.5
    ? <span style="color: #000000;">{</span> name: <span style="color: #3548cf;">"The Double Image"</span>, pages: 7 <span style="color: #000000;">}</span>
    : <span style="color: #000000;">{</span> name: <span style="color: #3548cf;">"Her Kind"</span>, rhymes: <span style="color: #0000b0;">true</span> <span style="color: #000000;">}</span>;

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span><span style="color: #3548cf;">`|poem.name| =&gt; </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">poem.name</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #000000;">)</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span><span style="color: #3548cf;">`|poem.pages| =&gt; </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">poem.pages</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #000000;">)</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span><span style="color: #3548cf;">`|poem.rhymes| =&gt; </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">poem.rhymes</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT1====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|poem.name| =&gt; The Double Image</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|poem.pages| =&gt; 7</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|poem.rhymes| =&gt; undefined</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT2====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|poem.name| =&gt; Her Kind</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|poem.pages| =&gt; undefined</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|poem.rhymes| =&gt; true</span>
</pre>
</div></li>
<li>注意,这种Typescript内部帮我们创建的union type和真正的写出来的union type的不同:
<ol class="org-ol">
<li>真正的union type在没有narrow的情况下,只能使用"交集"的成员,比如name</li>
<li>这里的union type在没有narrow的情况下,还能使用"并集"的成员,比如pages, rhymes</li>
</ol></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org9db6d58" class="outline-4">
<h4 id="org9db6d58"><span class="section-number-4">4.3.2.</span> Explicit Object-Type Unions</h4>
<div class="outline-text-4" id="text-4-3-2">
<ul class="org-ul">
<li>explicit的把类型列出来做union,而不是让Typescript帮我们创建union是最高的选择,代码清晰,逻辑自然
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">type</span> <span style="color: #005f5f;">PoemWithPages</span> = <span style="color: #000000;">{</span>
  name: <span style="color: #531ab6;">string</span>;
  pages: <span style="color: #531ab6;">number</span>;
<span style="color: #000000;">}</span>;

<span style="color: #531ab6;">type</span> <span style="color: #005f5f;">PoemWithRhymes</span> = <span style="color: #000000;">{</span>
  name: <span style="color: #531ab6;">string</span>;
  rhymes: <span style="color: #531ab6;">boolean</span>;
<span style="color: #000000;">}</span>;

<span style="color: #531ab6;">type</span> <span style="color: #005f5f;">Poem</span> = PoemWithPages | PoemWithRhymes;

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">poem</span>: <span style="color: #005f5f;">Poem</span> =
  Math.<span style="color: #721045;">random</span><span style="color: #000000;">()</span> &gt; 0.5
    ? <span style="color: #000000;">{</span> name: <span style="color: #3548cf;">"The Double Image"</span>, pages: 7 <span style="color: #000000;">}</span>
    : <span style="color: #000000;">{</span> name: <span style="color: #3548cf;">"Her Kind"</span>, rhymes: <span style="color: #0000b0;">true</span> <span style="color: #000000;">}</span>;

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span><span style="color: #3548cf;">`|poem.name| =&gt; </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">poem.name</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT1====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|poem.name| =&gt; The Double Image</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT2====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|poem.name| =&gt; Her Kind</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:27:6 - error TS2339: Property 'pages' does not exist on type 'Poem'.</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">Property 'pages' does not exist on type 'PoemWithRhymes'.</span>

<span style="color: #7f0000;">/////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">poem.pages; //</span>
<span style="color: #7f0000;">/////////////////</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:35:6 - error TS2339: Property 'rhymes' does not exist on type 'Poem'.</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">Property 'rhymes' does not exist on type 'PoemWithPages'.</span>

<span style="color: #7f0000;">//////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">poem.rhymes; //</span>
<span style="color: #7f0000;">//////////////////</span>
</pre>
</div></li>
<li>注意,这里因为是列出来的union,所以只有"交集"name可以在没有narrow的情况下访问</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org0d641b6" class="outline-4">
<h4 id="org0d641b6"><span class="section-number-4">4.3.3.</span> Narrowing Object Types</h4>
<div class="outline-text-4" id="text-4-3-3">
<ul class="org-ul">
<li>有union,那么很显然也会有narrow,只不过object narrow的方法有所不同
<ul class="org-ul">
<li><p>
比如下面的例子,我们使用"page" in poem来进行narrow是可以的
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">type</span> <span style="color: #005f5f;">PoemWithPages</span> = <span style="color: #000000;">{</span>
  name: <span style="color: #531ab6;">string</span>;
  pages: <span style="color: #531ab6;">number</span>;
<span style="color: #000000;">}</span>;

<span style="color: #531ab6;">type</span> <span style="color: #005f5f;">PoemWithRhymes</span> = <span style="color: #000000;">{</span>
  name: <span style="color: #531ab6;">string</span>;
  rhymes: <span style="color: #531ab6;">boolean</span>;
<span style="color: #000000;">}</span>;

<span style="color: #531ab6;">type</span> <span style="color: #005f5f;">Poem</span> = PoemWithPages | PoemWithRhymes;

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">poem</span>: <span style="color: #005f5f;">Poem</span> =
  Math.<span style="color: #721045;">random</span><span style="color: #000000;">()</span> &gt; 0.5
    ? <span style="color: #000000;">{</span> name: <span style="color: #3548cf;">"The Double Image"</span>, pages: 7 <span style="color: #000000;">}</span>
    : <span style="color: #000000;">{</span> name: <span style="color: #3548cf;">"Her Kind"</span>, rhymes: <span style="color: #0000b0;">true</span> <span style="color: #000000;">}</span>;

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span><span style="color: #3548cf;">`|poem.name| =&gt; </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">poem.name</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #000000;">)</span>;

<span style="color: #531ab6;">if</span> <span style="color: #000000;">(</span><span style="color: #3548cf;">"pages"</span> <span style="color: #531ab6;">in</span> poem<span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">`|poem.pages| =&gt; </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">poem.pages</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span> <span style="color: #531ab6;">else</span> <span style="color: #000000;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">`|poem.rhymes| =&gt; </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">poem.rhymes</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT1====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|poem.name| =&gt; The Double Image</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|poem.pages| =&gt; 7</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT2====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|poem.name| =&gt; Her Kind</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|poem.rhymes| =&gt; true</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:34:10 - error TS2339: Property 'pages' does not exist on type 'Poem'.</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">Property 'pages' does not exist on type 'PoemWithRhymes'.</span>

<span style="color: #7f0000;">///////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">if (poem.</span><span style="color: #005e8b;">pages</span><span style="color: #7f0000;">) { //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">}                 //</span>
<span style="color: #7f0000;">///////////////////////</span>
</pre>
</div></li>
<li>但是不可以使用if (poem.pages), 因为试图访问一个不存在的property是会触发type error的</li>
<li>typescript足够聪明,判断出俩poem不是PoemWithPages的时候,它能够确定poem必然是PoemWithRhymes,所以else
里面的的poem.rhymes也能够触发而不报错</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org7d165ae" class="outline-4">
<h4 id="org7d165ae"><span class="section-number-4">4.3.4.</span> Discriminated Unions</h4>
<div class="outline-text-4" id="text-4-3-4">
<ul class="org-ul">
<li>discriminated union是一个在Javascript和Typescript里面都适用的概念,就是专门加一个property(通常是string)
用来indicate object的真实type</li>
<li>这个专门的用来indicate object的type就叫做discriminant, 而Typescript的narrow过程,如果有discriminant
的参与的话,就会事半功倍.
<ul class="org-ul">
<li><p>
示例如下, 下面例子中的poem.type就是discriminant
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">type</span> <span style="color: #005f5f;">PoemWithPages</span> = <span style="color: #000000;">{</span>
  name: <span style="color: #531ab6;">string</span>;
  pages: <span style="color: #531ab6;">number</span>;
  <span style="color: #000000; background-color: #fbf7f0;">type</span>: <span style="color: #3548cf;">"pages"</span>;
<span style="color: #000000;">}</span>;

<span style="color: #531ab6;">type</span> <span style="color: #005f5f;">PoemWithRhymes</span> = <span style="color: #000000;">{</span>
  name: <span style="color: #531ab6;">string</span>;
  rhymes: <span style="color: #531ab6;">boolean</span>;
  <span style="color: #000000; background-color: #fbf7f0;">type</span>: <span style="color: #3548cf;">"rhymes"</span>;
<span style="color: #000000;">}</span>;

<span style="color: #531ab6;">type</span> <span style="color: #005f5f;">Poem</span> = PoemWithPages | PoemWithRhymes;

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">poem</span>: <span style="color: #005f5f;">Poem</span> =
  Math.<span style="color: #721045;">random</span><span style="color: #000000;">()</span> &gt; 0.5
    ? <span style="color: #000000;">{</span> name: <span style="color: #3548cf;">"The Double Image"</span>, pages: 7, <span style="color: #000000; background-color: #fbf7f0;">type</span>: <span style="color: #3548cf;">"pages"</span> <span style="color: #000000;">}</span>
    : <span style="color: #000000;">{</span> name: <span style="color: #3548cf;">"Her Kind"</span>, rhymes: <span style="color: #0000b0;">true</span>, <span style="color: #000000; background-color: #fbf7f0;">type</span>: <span style="color: #3548cf;">"rhymes"</span> <span style="color: #000000;">}</span>;

<span style="color: #531ab6;">if</span> <span style="color: #000000;">(</span>poem.<span style="color: #531ab6;">type</span> === <span style="color: #3548cf;">"pages"</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">`|poem.pages| =&gt; </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">poem.pages</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span> <span style="color: #531ab6;">else</span> <span style="color: #000000;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">`|poem.rhymes| =&gt; </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">poem.rhymes</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span><span style="color: #3548cf;">`|poem.type| =&gt; </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">poem.type</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT1====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|poem.pages| =&gt; 7</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|poem.type| =&gt; pages</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">// &lt;====================OUTPUT2====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|poem.rhymes| =&gt; true</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|poem.type| =&gt; rhymes</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:36:6 - error TS2339: Property 'pages' does not exist on type 'Poem'.</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">Property 'pages' does not exist on type 'PoemWithRhymes'.</span>

<span style="color: #7f0000;">/////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">poem.pages; //</span>
<span style="color: #7f0000;">/////////////////</span>
</pre>
</div></li>
<li>poem.type在if判断后,可以选择书写poem.pages(或者poem.rhymes),否则还是会报错</li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgb8a54bb" class="outline-3">
<h3 id="orgb8a54bb"><span class="section-number-3">4.4.</span> Intersection Types</h3>
<div class="outline-text-3" id="text-4-4">
<ul class="org-ul">
<li>在集合里面中:
<ul class="org-ul">
<li>| 代表 union</li>
<li>&amp; 代表 intersection</li>
</ul></li>
<li>既然已经有了使用`|`的union type,会整活的typescript也没有放弃`&amp;`,创建了intersection type
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">type</span> <span style="color: #005f5f;">Artwork</span> = <span style="color: #000000;">{</span>
  genre: <span style="color: #531ab6;">string</span>;
  name: <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>;

<span style="color: #531ab6;">type</span> <span style="color: #005f5f;">Writing</span> = <span style="color: #000000;">{</span>
  pages: <span style="color: #531ab6;">number</span>;
  name: <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>;

<span style="color: #531ab6;">type</span> <span style="color: #005f5f;">WrittenArt</span> = Artwork &amp; Writing;

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">example</span>: <span style="color: #005f5f;">WrittenArt</span> = <span style="color: #000000;">{</span>
  genre: <span style="color: #3548cf;">"Fiction"</span>,
  name: <span style="color: #3548cf;">"The Great Novel"</span>,
  pages: 300,
<span style="color: #000000;">}</span>;

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>example<span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">{ genre: 'Fiction', name: 'The Great Novel', pages: 300 }</span>
</pre>
</div></li>
<li><p>
上面的WrittenArt其实就相当于如下的类型
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">type</span> <span style="color: #005f5f;">WrittenArt</span> = <span style="color: #000000;">{</span>
  genre: <span style="color: #531ab6;">string</span>;
  name: <span style="color: #531ab6;">string</span>;
  pages: <span style="color: #531ab6;">number</span>;
<span style="color: #000000;">}</span>;
</pre>
</div></li>
</ul></li>
<li>集合中的union和intersection可以混用,以提高编程语言的解释力
<ul class="org-ul">
<li><p>
示例如下: 在创建discriminated union的时候,共同类型可以通过,`&amp;`来间接的引入而不需要重复写一遍
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">type</span> <span style="color: #005f5f;">ShortPoem</span> = <span style="color: #000000;">{</span> author: <span style="color: #531ab6;">string</span> <span style="color: #000000;">}</span> &amp; <span style="color: #000000;">(</span>
  | <span style="color: #dd22dd;">{</span> kigo: <span style="color: #531ab6;">string</span>; <span style="color: #000000; background-color: #fbf7f0;">type</span>: <span style="color: #3548cf;">"haiku"</span> <span style="color: #dd22dd;">}</span>
  | <span style="color: #dd22dd;">{</span> meter: <span style="color: #531ab6;">number</span>; <span style="color: #000000; background-color: #fbf7f0;">type</span>: <span style="color: #3548cf;">"villanelle"</span> <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">)</span>;

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">morningGlory</span>: <span style="color: #005f5f;">ShortPoem</span> = <span style="color: #000000;">{</span>
  author: <span style="color: #3548cf;">"Fukuda Chiyo-ni"</span>,
  kigo: <span style="color: #3548cf;">"Morning Glory"</span>,
  <span style="color: #000000; background-color: #fbf7f0;">type</span>: <span style="color: #3548cf;">"haiku"</span>,
<span style="color: #000000;">}</span>;

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span><span style="color: #3548cf;">`|morningGlory| =&gt; </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">morningGlory</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|morningGlory| =&gt; [object Object]</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:17:7 - error TS2322: Type '{ author: string; </span><span style="color: #000000; background-color: #fbf7f0;">type</span><span style="color: #7f0000;">: "villanelle"; }' is not assignable to type 'ShortPoem'.</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">Type '{ author: string; </span><span style="color: #000000; background-color: #fbf7f0;">type</span><span style="color: #7f0000;">: "villanelle"; }' is not assignable to type '{ author: string; } &amp; { meter: number; </span><span style="color: #000000; background-color: #fbf7f0;">type</span><span style="color: #7f0000;">: "villanelle"; }'.</span>
<span style="color: #7f0000;">//     </span><span style="color: #7f0000;">Property 'meter' is missing in type '{ author: string; </span><span style="color: #000000; background-color: #fbf7f0;">type</span><span style="color: #7f0000;">: "villanelle"; }' but required in type '{ meter: number; </span><span style="color: #000000; background-color: #fbf7f0;">type</span><span style="color: #7f0000;">: "villanelle"; }'.</span>

<span style="color: #7f0000;">///////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">const oneArt: ShortPoem = {   //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">author: "Elizabeth Bishop", //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">type: "villanelle",         //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">};                            //</span>
<span style="color: #7f0000;">///////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
<div id="outline-container-orgcceada0" class="outline-4">
<h4 id="orgcceada0"><span class="section-number-4">4.4.1.</span> Dangers of Intersection Types</h4>
<div class="outline-text-4" id="text-4-4-1">
<ul class="org-ul">
<li>intersection type会让作者和编译器都困惑,我们最好不要使用这个特性</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-orgf74a7c0" class="outline-2">
<h2 id="orgf74a7c0"><span class="section-number-2">5.</span> Chapter 5: Functions</h2>
<div class="outline-text-2" id="text-5">
</div>
<div id="outline-container-org9a20b0e" class="outline-3">
<h3 id="org9a20b0e"><span class="section-number-3">5.1.</span> Function Parameters</h3>
<div class="outline-text-3" id="text-5-1">
<ul class="org-ul">
<li>对于typescript来说,函数参数也必须声明类型,否则会报错
<ul class="org-ul">
<li><p>
例子如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">sing</span><span style="color: #000000;">(</span><span style="color: #005e8b;">song</span>: <span style="color: #531ab6;">string</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">`Singing: </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">song</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">!`</span><span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>

<span style="color: #721045;">sing</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"hello world"</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:1:15 - error TS7006: Parameter 'song' implicitly has an 'any' type.</span>

<span style="color: #7f0000;">/////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">function sing(</span><span style="color: #005e8b;">song</span><span style="color: #7f0000;">) {               //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">console.</span><span style="color: #721045;">log</span><span style="color: #7f0000;">(`Singing: ${song}!`); //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">}                                   //</span>
<span style="color: #7f0000;">/////////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
<div id="outline-container-org294aa51" class="outline-4">
<h4 id="org294aa51"><span class="section-number-4">5.1.1.</span> Required Parameters</h4>
<div class="outline-text-4" id="text-5-1-1">
<ul class="org-ul">
<li>javascript的function并没有参数检查,你可以使用任意数目的参数来调用函数.即便这个数目和你声明的不一样
<ul class="org-ul">
<li><p>
示例如下,下面例子中我们的javascript函数声明了一个参数,但是可以分别使用0,1,2个参数成功调用
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #531ab6;">function</span> <span style="color: #721045;">greet</span><span style="color: #000000;">(</span><span style="color: #005e8b;">name</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  console.log<span style="color: #dd22dd;">(</span><span style="color: #3548cf;">"Hello, "</span> + name + <span style="color: #3548cf;">"!"</span><span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>

greet<span style="color: #000000;">(</span><span style="color: #3548cf;">"Alice"</span><span style="color: #000000;">)</span>; <span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#35843;&#29992;&#26102;&#20256;&#36882;&#19968;&#20010;&#21442;&#25968;&#65292;&#36755;&#20986;: Hello, Alice!</span>
greet<span style="color: #000000;">()</span>; <span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#35843;&#29992;&#26102;&#27809;&#26377;&#20256;&#36882;&#21442;&#25968;&#65292;&#36755;&#20986;: Hello, undefined!</span>
greet<span style="color: #000000;">(</span><span style="color: #3548cf;">"Alice"</span>, <span style="color: #3548cf;">"Bob"</span><span style="color: #000000;">)</span>; <span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#35843;&#29992;&#26102;&#20256;&#36882;&#20004;&#20010;&#21442;&#25968;&#65292;&#36755;&#20986;: Hello, Alice!</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Hello, Alice!</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Hello, undefined!</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Hello, Alice!</span>
</pre>
</div></li>
</ul></li>
<li>TypeScript则不可能延续这个策略,它会严格的进行测试,确保声明的函数参数和调用的函数参数数目一致
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">singTwo</span><span style="color: #000000;">(</span><span style="color: #005e8b;">first</span>: <span style="color: #531ab6;">string</span>, <span style="color: #005e8b;">second</span>: <span style="color: #531ab6;">string</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">`</span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">first</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;"> / </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">second</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>

<span style="color: #721045;">singTwo</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"hello"</span>, <span style="color: #3548cf;">"world"</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">hello / world</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:10:1 - error TS2554: Expected 2 arguments, but got 1.</span>

<span style="color: #7f0000;">///////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">singTwo("hello"); //</span>
<span style="color: #7f0000;">///////////////////////</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:18:27 - error TS2554: Expected 2 arguments, but got 3.</span>

<span style="color: #7f0000;">/////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">singTwo("hello", "world", "again"); //</span>
<span style="color: #7f0000;">/////////////////////////////////////////</span>
</pre>
</div>
<ul class="org-ul">
<li>用上面的例子区分两个概念:
<ol class="org-ol">
<li>parameter是函数声明时候希望接受的,上面例子的first, second就是pamameter</li>
<li>argument是函数调用时候赋予的,上面例子的"hello", "world"就是argument</li>
</ol></li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org5179ba6" class="outline-4">
<h4 id="org5179ba6"><span class="section-number-4">5.1.2.</span> Optional Parameters</h4>
<div class="outline-text-4" id="text-5-1-2">
<ul class="org-ul">
<li>在javascript里面,如果一个function parameter没有被提供,那么在使用的时候,其argument就是undefined</li>
<li>typescript作为类型安全的语言,为了能够满足parameter和argument数目不一致的场景,设计了特性:optional parameter
<ul class="org-ul">
<li><p>
示例如下,我们使用`?`来标记为optional parameter,所有的这些加`?`的参数类型默认加union为`| undefined`
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">announceSong</span><span style="color: #000000;">(</span><span style="color: #005e8b;">song</span>: <span style="color: #531ab6;">string</span>, <span style="color: #005e8b;">singer?</span>: <span style="color: #531ab6;">string</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">`Song: </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">song</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #dd22dd;">)</span>;

  <span style="color: #531ab6;">if</span> <span style="color: #dd22dd;">(</span>singer<span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #3548cf;">`Singer: </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">singer</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #721045;">announceSong</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Greensleeves"</span><span style="color: #000000;">)</span>;
<span style="color: #721045;">announceSong</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Greensleeves"</span>, <span style="color: #0000b0;">undefined</span><span style="color: #000000;">)</span>;
<span style="color: #721045;">announceSong</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Greensleeves"</span>, <span style="color: #3548cf;">"Sia"</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Song: Greensleeves</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Song: Greensleeves</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Song: Greensleeves</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Singer: Sia</span>
</pre>
</div></li>
<li><p>
注意,optional和"刚好加了|union的参数"不同,前者可以parameter和argument数目不一,后者不可以
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">announceSong</span><span style="color: #000000;">(</span><span style="color: #005e8b;">song</span>: <span style="color: #531ab6;">string</span>, <span style="color: #005e8b;">singer</span>: <span style="color: #531ab6;">string</span> | <span style="color: #0000b0;">undefined</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">`Song: </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">song</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #dd22dd;">)</span>;

  <span style="color: #531ab6;">if</span> <span style="color: #dd22dd;">(</span>singer<span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #3548cf;">`Singer: </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">singer</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #721045;">announceSong</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Greensleeves"</span>, <span style="color: #0000b0;">undefined</span><span style="color: #000000;">)</span>;
<span style="color: #721045;">announceSong</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Greensleeves"</span>, <span style="color: #3548cf;">"Sia"</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Song: Greensleeves</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Song: Greensleeves</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Singer: Sia</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:9:1 - error TS2554: Expected 2 arguments, but got 1.</span>

<span style="color: #7f0000;">///////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">announceSong("Greensleeves"); //</span>
<span style="color: #7f0000;">///////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
<li>optional parameter必须作为最后的参数,否则会报错
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:1:40 - error TS1016: A required parameter cannot follow an optional parameter.</span>

<span style="color: #7f0000;">/////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">function announceSong(</span><span style="color: #005e8b;">singer?</span><span style="color: #7f0000;">: string, </span><span style="color: #005e8b;">song</span><span style="color: #7f0000;">: string) {} //</span>
<span style="color: #7f0000;">/////////////////////////////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org404d473" class="outline-4">
<h4 id="org404d473"><span class="section-number-4">5.1.3.</span> Default Parameters</h4>
<div class="outline-text-4" id="text-5-1-3">
<ul class="org-ul">
<li>参数默认值是比optional parameter更好的一种选择,它可以让我们的parameter在没有argument的情况下给一个默认值
<ul class="org-ul">
<li><p>
typescript的default parameter示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">rateSong</span><span style="color: #000000;">(</span><span style="color: #005e8b;">song</span>: <span style="color: #531ab6;">string</span>, rating = 0<span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">`|typeof rating| =&gt; </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">typeof rating</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #dd22dd;">)</span>;
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">`</span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">song</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;"> gets </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">rating</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">/5 stars!`</span><span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>

<span style="color: #721045;">rateSong</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Photograph"</span><span style="color: #000000;">)</span>;
<span style="color: #721045;">rateSong</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Set Fire to the Rain"</span>, 5<span style="color: #000000;">)</span>;
<span style="color: #721045;">rateSong</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Set Fire to the Rain"</span>, <span style="color: #0000b0;">undefined</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|typeof rating| =&gt; number</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Photograph gets 0/5 stars!</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|typeof rating| =&gt; number</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Set Fire to the Rain gets 5/5 stars!</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|typeof rating| =&gt; number</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Set Fire to the Rain gets 0/5 stars!</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:14:22 - error TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.</span>

<span style="color: #7f0000;">//////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">rateSong("At Last!", "100"); //</span>
<span style="color: #7f0000;">//////////////////////////////////</span>
</pre>
</div></li>
<li>我们调用的时候,想要默认值起作用可以:
<ol class="org-ol">
<li>缺少这个参数(这个和其他语言行为一致),</li>
<li>使用undefind替代(这个是为了和javascript语言特性一致)</li>
</ol></li>
<li><p>
我们发现一旦有了default parameter,那么argument的类型就确定了,在上例中必定是number.而不是像optional
parameter一样的union类型(number | undefiend).
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">rateSong</span><span style="color: #000000;">(</span><span style="color: #005e8b;">song</span>: <span style="color: #531ab6;">string</span>, <span style="color: #005e8b;">rating?</span>: <span style="color: #531ab6;">number</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">`|typeof rating| =&gt; </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">typeof rating</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #dd22dd;">)</span>;
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">`</span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">song</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;"> gets </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">rating</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">/5 stars!`</span><span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>

<span style="color: #721045;">rateSong</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Photograph"</span><span style="color: #000000;">)</span>;
<span style="color: #721045;">rateSong</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Set Fire to the Rain"</span>, 5<span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|typeof rating| =&gt; undefined</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Photograph gets undefined/5 stars!</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|typeof rating| =&gt; number</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Set Fire to the Rain gets 5/5 stars!</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org7f2cf16" class="outline-4">
<h4 id="org7f2cf16"><span class="section-number-4">5.1.4.</span> Rest Parameters</h4>
<div class="outline-text-4" id="text-5-1-4">
<ul class="org-ul">
<li>rest parametr也叫不定参数,是只最后一个参数可以是0个或者多个的情况
<ul class="org-ul">
<li><p>
在typescript里面,rest  parameter的类型会多一个`[]`,示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">singAllTheSongs</span><span style="color: #000000;">(</span><span style="color: #005e8b;">singer</span>: <span style="color: #531ab6;">string</span>, ...songs: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">[]</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">for</span> <span style="color: #dd22dd;">(</span><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">song</span> <span style="color: #531ab6;">of</span> songs<span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #3548cf;">`</span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">song</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">, by </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">singer</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #721045;">singAllTheSongs</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Alicia Keys"</span><span style="color: #000000;">)</span>;
<span style="color: #721045;">singAllTheSongs</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Lady Gaga"</span>, <span style="color: #3548cf;">"Bad Romance"</span>, <span style="color: #3548cf;">"Just Dance"</span>, <span style="color: #3548cf;">"Poker Face"</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Bad Romance, by Lady Gaga</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Just Dance, by Lady Gaga</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Poker Face, by Lady Gaga</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:18:36 - error TS2345: Argument of type 'number' is not assignable to parameter of type 'string'.</span>

<span style="color: #7f0000;">///////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">singAllTheSongs("Ella Fitzgerald", 2000); //</span>
<span style="color: #7f0000;">///////////////////////////////////////////////</span>
</pre>
</div></li>
<li>由于rest parameter有类型要求,所以传入number类型会导致typescript报错</li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org62e394b" class="outline-3">
<h3 id="org62e394b"><span class="section-number-3">5.2.</span> Return Types</h3>
<div class="outline-text-3" id="text-5-2">
<ul class="org-ul">
<li>TypeScript可以理解一个函数的所有可能返回值,并且给与其类型(多种返回值类型就是union类型)
<ul class="org-ul">
<li><p>
下面这个例子中,singSong返回值类型就是number
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">singSong</span><span style="color: #000000;">(</span><span style="color: #005e8b;">songs</span>: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">[]</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> songs.length;
<span style="color: #000000;">}</span>
</pre>
</div></li>
<li><p>
下面这个例子中,getSongAt的返回值就是一个string | undefined了
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">getSongAt</span><span style="color: #000000;">(</span><span style="color: #005e8b;">songs</span>: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">[]</span>, <span style="color: #005e8b;">index</span>: <span style="color: #531ab6;">number</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> index &lt; <span style="color: #005f5f;">songs</span>.<span style="color: #005f5f;">length</span> ? <span style="color: #005f5f;">songs</span><span style="color: #dd22dd;">[</span><span style="color: #005f5f;">index</span><span style="color: #dd22dd;">]</span> : <span style="color: #005f5f;">undefined</span>;
<span style="color: #000000;">}</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
<div id="outline-container-orgbf1c6f3" class="outline-4">
<h4 id="orgbf1c6f3"><span class="section-number-4">5.2.1.</span> Explicit Return Types</h4>
<div class="outline-text-4" id="text-5-2-1">
<ul class="org-ul">
<li>虽然typescript最佳实践就是不要给function明确的标记返回值类型.但是有几种特殊的情况下还是建议把返回值
类型给标记起来,这些情况分别是:
<ul class="org-ul">
<li>有很多种可能的return value,但是你希望只返回一种类型</li>
<li>typescript拒绝判断返回类型</li>
<li>在非常大的项目里面,标记函数返回类型,能减轻typescript的工作,从而提升代码检查效率,缩短时间</li>
</ul></li>
<li>下面是函数返回类型annotaion的书写方式:
<ul class="org-ul">
<li><p>
对于普通函数来说,就是在`{`之前加上类型
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">singSongRecursive</span><span style="color: #000000;">(</span><span style="color: #005e8b;">songs</span>: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">[]</span>, <span style="color: #005e8b;">count</span> = 0<span style="color: #000000;">)</span>: <span style="color: #531ab6;">number</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> songs.length ? <span style="color: #721045;">singSongRecursive</span><span style="color: #dd22dd;">(</span>songs.<span style="color: #721045;">slice</span><span style="color: #008899;">(</span>1<span style="color: #008899;">)</span>, count + 1<span style="color: #dd22dd;">)</span> : count;
<span style="color: #000000;">}</span>
</pre>
</div></li>
<li><p>
对于arrow function来说,就是在`=&gt;`之前加上类型
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">singSongRecursive</span> = <span style="color: #000000;">(</span>songs: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">[]</span>, count = 0<span style="color: #000000;">)</span>: <span style="color: #531ab6;">number</span> <span style="color: #531ab6;">=&gt;</span>
  songs.length ? <span style="color: #721045;">singSongRecursive</span><span style="color: #000000;">(</span>songs.<span style="color: #721045;">slice</span><span style="color: #dd22dd;">(</span>1<span style="color: #dd22dd;">)</span>, count + 1<span style="color: #000000;">)</span> : count;
</pre>
</div></li>
</ul></li>
<li>一旦设置的function return type,那么typescript会去进行检查的
<ul class="org-ul">
<li><p>
示例代码如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">getSongRecordingDate</span><span style="color: #000000;">(</span><span style="color: #005e8b;">song</span>: <span style="color: #531ab6;">string</span><span style="color: #000000;">)</span>: <span style="color: #005f5f;">Date</span> | <span style="color: #0000b0;">undefined</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">switch</span> <span style="color: #dd22dd;">(</span>song<span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">case</span> <span style="color: #3548cf;">"Strange Fruit"</span>:
      <span style="color: #531ab6;">return</span> <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Date</span><span style="color: #008899;">(</span><span style="color: #3548cf;">"April 20, 1939"</span><span style="color: #008899;">)</span>;
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:6:7 - error TS2322: Type 'string' is not assignable to type 'Date'.</span>

    <span style="color: #7f0000;">//////////////////////////</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">case "Greensleeves": //</span>
    <span style="color: #7f0000;">//   </span><span style="color: #7f0000;">return "unknown";  //</span>
    <span style="color: #7f0000;">//////////////////////////</span>
    <span style="color: #000000; background-color: #fbf7f0;">default</span>:
      <span style="color: #531ab6;">return</span> <span style="color: #0000b0;">undefined</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org17b8376" class="outline-3">
<h3 id="org17b8376"><span class="section-number-3">5.3.</span> Function Types</h3>
<div class="outline-text-3" id="text-5-3">
<ul class="org-ul">
<li>Javascript的函数是一等公民,可以把function作为value到处传递,那么我们的function也必须要有自己的类型</li>
<li>Function type和arrow function的样子很像,只不过"=&gt;"之后是返回值的类型,而不是{}
<ul class="org-ul">
<li><p>
nothingInGivesString函数是一个没有形参,返回值为string类型的函数
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">nothingInGivesString</span>: <span style="color: #000000;">()</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #531ab6;">string</span>;
</pre>
</div></li>
<li><p>
inputAndOutput函数有一个必选参数string[]类型的songs,一个可选参数count?,返回值为number类型
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">inputAndOutput</span>: <span style="color: #000000;">(</span>songs: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">[]</span>, <span style="color: #005e8b;">count</span>?: <span style="color: #531ab6;">number</span><span style="color: #000000;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #531ab6;">number</span>;
</pre>
</div></li>
</ul></li>
<li>function type的最常用的地方是callback parameter(这种参数会被像function一样被调用)
<ul class="org-ul">
<li><p>
下面就是这样一个例子,runOnSong的唯一参数就是一个callback parameter
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">songs</span> = <span style="color: #000000;">[</span><span style="color: #3548cf;">"Juice"</span>, <span style="color: #3548cf;">"Shake It Off"</span>, <span style="color: #3548cf;">"What's Up"</span><span style="color: #000000;">]</span>;

<span style="color: #531ab6;">function</span> <span style="color: #721045;">runOnSongs</span><span style="color: #000000;">(</span><span style="color: #005e8b;">getSongAtP</span>: <span style="color: #dd22dd;">(</span><span style="color: #005e8b;">index</span>: <span style="color: #531ab6;">number</span><span style="color: #dd22dd;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #531ab6;">string</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">for</span> <span style="color: #dd22dd;">(</span><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">i</span> = 0; i &lt; <span style="color: #005f5f;">songs</span>.<span style="color: #005f5f;">length</span>; <span style="color: #005f5f;">i</span> += 1<span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #721045;">getSongAtP</span><span style="color: #972500;">(</span>i<span style="color: #972500;">)</span><span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">function</span> <span style="color: #721045;">getSongAt</span><span style="color: #000000;">(</span><span style="color: #005e8b;">index</span>: <span style="color: #531ab6;">number</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> <span style="color: #3548cf;">`</span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">songs[index]</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span>;
<span style="color: #000000;">}</span>

<span style="color: #721045;">runOnSongs</span><span style="color: #000000;">(</span>getSongAt<span style="color: #000000;">)</span>;

<span style="color: #531ab6;">function</span> <span style="color: #721045;">longSong</span><span style="color: #000000;">(</span><span style="color: #005e8b;">song</span>: <span style="color: #531ab6;">string</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> <span style="color: #3548cf;">`</span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">song</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span>;
<span style="color: #000000;">}</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Juice</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Shake It Off</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">What's Up</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:24:12 - error TS2345: Argument of type '(song: string) =&gt; string' is not assignable to parameter of type '(index: number) =&gt; string'.</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">Types of parameters 'song' and 'index' are incompatible.</span>
<span style="color: #7f0000;">//     </span><span style="color: #7f0000;">Type 'number' is not assignable to type 'string'.</span>

<span style="color: #7f0000;">///////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">runOnSongs(longSong); //</span>
<span style="color: #7f0000;">///////////////////////////</span>
</pre>
</div></li>
<li>callback pameter的类型是形参为number,返回值为string, getSongAt符合要求, logSong则不符合</li>
</ul></li>
</ul>
</div>
<div id="outline-container-orgaa48f49" class="outline-4">
<h4 id="orgaa48f49"><span class="section-number-4">5.3.1.</span> Function Type Parentheses</h4>
<div class="outline-text-4" id="text-5-3-1">
<ul class="org-ul">
<li>function type是一个比较复杂的称谓(这个称谓的中间还有空格),所以我们需要在有些情况下在function type外面加上括号</li>
<li>union type就是这样一种情况:
<ul class="org-ul">
<li><p>
如果不加括号,那么returnsStringOrUndefined的function type的类型为: function that returns a union: string | undefined
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">returnsStringOrUndefined</span>: <span style="color: #000000;">()</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #531ab6;">string</span> | <span style="color: #0000b0;">undefined</span>;
</pre>
</div></li>
<li><p>
加了括号,那么mybeReturnsString要么是一个function that returns a string, 要么是一个undefined
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">maybeReturnsString</span>: <span style="color: #000000;">(</span><span style="color: #dd22dd;">()</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #531ab6;">string</span><span style="color: #000000;">)</span> | <span style="color: #0000b0;">undefined</span>;
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org3ab6c0c" class="outline-4">
<h4 id="org3ab6c0c"><span class="section-number-4">5.3.2.</span> Parameter Type Inferences</h4>
<div class="outline-text-4" id="text-5-3-2">
<ul class="org-ul">
<li>typescript可以聪明的让我们在类型明确的情况下,少些后续的类型.
<ul class="org-ul">
<li><p>
比如下面的例子,我们已经声明了singer的类型了,那么在赋值的时候我们不需要再给song声明其为string了
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">singer</span>: <span style="color: #000000;">(</span>song: <span style="color: #531ab6;">string</span><span style="color: #000000;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #531ab6;">string</span>;

singer = <span style="color: #531ab6;">function</span> <span style="color: #000000;">(</span><span style="color: #005e8b;">song</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> <span style="color: #3548cf;">`Sing: </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">song.toUpperCase()</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">!`</span>;
<span style="color: #000000;">}</span>;

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span><span style="color: #721045;">singer</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">"Hello"</span><span style="color: #dd22dd;">)</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Sing: HELLO!</span>
</pre>
</div></li>
<li><p>
因为不是stirng压根赋值不会成功,如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">singer</span>: <span style="color: #000000;">(</span>song: <span style="color: #531ab6;">string</span><span style="color: #000000;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #531ab6;">string</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:3:1 - error TS2322: Type '(song: number) =&gt; string' is not assignable to type '(song: string) =&gt; string'.</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">Types of parameters 'song' and 'song' are incompatible.</span>
<span style="color: #7f0000;">//     </span><span style="color: #7f0000;">Type 'string' is not assignable to type 'number'.</span>

<span style="color: #7f0000;">////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">singer = function (</span><span style="color: #005e8b;">song</span><span style="color: #7f0000;">: number) { //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">return `Sing: Something!`;       //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">};                                 //</span>
<span style="color: #7f0000;">////////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
<li>既然"已声明对象赋值"的时候,可以被infer. 那么把"函数作为参数"传递给另外函数的时候,类型也是可以被infer
的,因为另外的函数肯定在其他地方已经声明过"函数参数"的类型了
<ul class="org-ul">
<li><p>
示例如下:
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">songs</span> = <span style="color: #000000;">[</span><span style="color: #3548cf;">"Call Me"</span>, <span style="color: #3548cf;">"Jolene"</span>, <span style="color: #3548cf;">"The Chain"</span><span style="color: #000000;">]</span>;

songs.<span style="color: #721045;">forEach</span><span style="color: #000000;">(</span><span style="color: #dd22dd;">(</span><span style="color: #005e8b;">song</span>, <span style="color: #005e8b;">index</span><span style="color: #dd22dd;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #dd22dd;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #3548cf;">`</span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">song</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;"> is at index </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">index</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #008899;">)</span>
<span style="color: #dd22dd;">}</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Call Me is at index 0</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Jolene is at index 1</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">The Chain is at index 2</span>
</pre>
</div></li>
<li>forEach的函数参数已经声明过类型了,其callbackFn参数第二个成员为number类型,这里的inde也就直接被infer
成number类型</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org983f9ef" class="outline-4">
<h4 id="org983f9ef"><span class="section-number-4">5.3.3.</span> Function Type Aliases</h4>
<div class="outline-text-4" id="text-5-3-3">
<ul class="org-ul">
<li>type aliases 本来是实现"一人千面"作用的. 但是同时也能将复杂的类型转换成一个"看起来简单的类型"</li>
<li>function type一般来说,其都是比较复杂的类型,能够转成一个"看起来简单的类型"非常重要.
<ul class="org-ul">
<li><p>
示例如下,我们把(input: string) =&gt; number这么复杂的类型,alias成StringToNumber这么一个"看起来简单
的类型",然后这个类型还能在之后使用
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">type</span> <span style="color: #005f5f;">StringToNumber</span> = <span style="color: #000000;">(</span>input: <span style="color: #531ab6;">string</span><span style="color: #000000;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #531ab6;">number</span>;

<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">stringToNumber</span>: <span style="color: #005f5f;">StringToNumber</span>;

stringToNumber = <span style="color: #000000;">(</span>input<span style="color: #000000;">)</span> <span style="color: #531ab6;">=&gt;</span> input.length; <span style="color: #7f0000;">// </span><span style="color: #7f0000;">ok</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:8:29 - error TS2322: Type 'string' is not assignable to type 'number'.</span>

<span style="color: #7f0000;">//////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">stringToNumber = (input) =&gt; input.</span><span style="color: #721045;">toUpperCase</span><span style="color: #7f0000;">(); //</span>
<span style="color: #7f0000;">//////////////////////////////////////////////////////</span>
</pre>
</div></li>
<li><p>
我们当然可以把这个"看起来简单的类型"放到函数声明里面,比起原来的复杂的函数声明,当前的函数声明看起
来简单好多(虽然看起来不像function type)
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">type</span> <span style="color: #005f5f;">NumberToString</span> = <span style="color: #000000;">(</span>input: <span style="color: #531ab6;">number</span><span style="color: #000000;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #531ab6;">string</span>;

<span style="color: #531ab6;">function</span> <span style="color: #721045;">userNumberToString</span><span style="color: #000000;">(</span><span style="color: #005e8b;">numberToString</span>: <span style="color: #005f5f;">NumberToString</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">`Ths string is : </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">numberToString(123)</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>

<span style="color: #721045;">userNumberToString</span><span style="color: #000000;">(</span><span style="color: #dd22dd;">(</span>input<span style="color: #dd22dd;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #3548cf;">`</span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">input</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">! Hooray`</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Ths string is : 123! Hooray</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:9:31 - error TS2322: Type 'number' is not assignable to type 'string'.</span>

<span style="color: #7f0000;">///////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">userNumberToString((input) =&gt; input * 2); //</span>
<span style="color: #7f0000;">///////////////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org680fb1e" class="outline-3">
<h3 id="org680fb1e"><span class="section-number-3">5.4.</span> More Return Types</h3>
<div class="outline-text-3" id="text-5-4">
</div>
<div id="outline-container-orgf709a06" class="outline-4">
<h4 id="orgf709a06"><span class="section-number-4">5.4.1.</span> Void Returns</h4>
<div class="outline-text-4" id="text-5-4-1">
<ul class="org-ul">
<li>void return是绝大多数typescript都有的特性,其主要处理如下两种情况:
<ul class="org-ul">
<li>函数体没有return关键字</li>
<li>函数体的return后面直接就是分号,没返回任何东西</li>
</ul></li>
<li>void return一旦声明了之后,是不允许返回任何值的
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">songLogger</span>: <span style="color: #000000;">(</span>song: <span style="color: #531ab6;">string</span><span style="color: #000000;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #531ab6;">void</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:5:3 - error TS2322: Type 'boolean' is not assignable to type 'void'.</span>

<span style="color: #7f0000;">////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">songLogger = (</span><span style="color: #005e8b;">song</span><span style="color: #7f0000;">): void =&gt; { //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">console.</span><span style="color: #721045;">log</span><span style="color: #7f0000;">(`${song}`);      //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">return true;                 //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">};                             //</span>
<span style="color: #7f0000;">////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
<li>void return在function type里面非常重要,因为"=&gt;"后面必须得有点东西
<ul class="org-ul">
<li><p>
示例如下,注意声明时候的void在"=&gt;"后面,调用的时候void在"=&gt;"前面
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">songLogger</span>: <span style="color: #000000;">(</span>song: <span style="color: #531ab6;">string</span><span style="color: #000000;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #531ab6;">void</span>;

songLogger = <span style="color: #000000;">(</span><span style="color: #005e8b;">song</span><span style="color: #000000;">)</span>: <span style="color: #531ab6;">void</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #000000;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">`</span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">song</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>;

<span style="color: #721045;">songLogger</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Heart of Glass"</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Heart of Glass</span>
</pre>
</div></li>
</ul></li>
<li>注意,void是typescript里面的一个type,其和undefined是不一样的,两者不可以相互赋值
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">returnsVoid</span><span style="color: #000000;">()</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">lazyValue</span>: <span style="color: #531ab6;">string</span> | <span style="color: #0000b0;">undefined</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:7:1 - error TS2322: Type 'void' is not assignable to type 'string | undefined'.</span>

<span style="color: #7f0000;">////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">lazyValue = returnsVoid(); //</span>
<span style="color: #7f0000;">////////////////////////////////</span>
</pre>
</div></li>
<li><p>
注意上面的例子中function returnsVoid()并没有明确的写出返回值类型,那么其实是可以返回任意类型的,只
不过代码里面return;让Typescript编译器直接给他确认了返回值类型是void.如果你的代码里面有其他逻辑,可
以返回不同类型,编译器甚至能判断出这些类型!
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">returnsVoid</span><span style="color: #000000;">()</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">if</span> <span style="color: #dd22dd;">(</span>Math.<span style="color: #721045;">random</span><span style="color: #008899;">()</span> &gt; 0.5<span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">return</span> 123;
  <span style="color: #dd22dd;">}</span> <span style="color: #531ab6;">else</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">return</span> <span style="color: #3548cf;">"123"</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">lazyValue</span>: <span style="color: #531ab6;">string</span> | <span style="color: #0000b0;">undefined</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:14:1 - error TS2322: Type '123 | "123"' is not assignable to type 'string | undefined'.</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">Type 'number' is not assignable to type 'string'.</span>

<span style="color: #7f0000;">////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">lazyValue = returnsVoid(); //</span>
<span style="color: #7f0000;">////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
<li>void返回值的定义会产生一个问题,比如forEach函数,其要求第一个参数callbackFn的返回值为void,这样可以警
告forEach,不要去使用这个callbackFn的返回值.
<ul class="org-ul">
<li><p>
如果真的严格要求,那么我们的forEach只能这样调用
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">records</span>: <span style="color: #531ab6;">string</span><span style="color: #000000;">[]</span> = <span style="color: #000000;">[]</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>records<span style="color: #000000;">)</span>;

<span style="color: #531ab6;">function</span> <span style="color: #721045;">saveRecords</span><span style="color: #000000;">(</span><span style="color: #005e8b;">newRecords</span>: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">[]</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  newRecords.<span style="color: #721045;">forEach</span><span style="color: #dd22dd;">(</span><span style="color: #008899;">(</span><span style="color: #005e8b;">record</span><span style="color: #008899;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #008899;">{</span>
    records.<span style="color: #721045;">push</span><span style="color: #972500;">(</span>record<span style="color: #972500;">)</span>;
  <span style="color: #008899;">}</span><span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>

<span style="color: #721045;">saveRecords</span><span style="color: #000000;">(</span><span style="color: #dd22dd;">[</span><span style="color: #3548cf;">"21"</span>, <span style="color: #3548cf;">"Come On Over"</span>, <span style="color: #3548cf;">"The Bodyguard"</span><span style="color: #dd22dd;">]</span><span style="color: #000000;">)</span>;

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>records<span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">[]</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">[ '21', 'Come On Over', 'The Bodyguard' ]</span>
</pre>
</div></li>
<li><p>
但实际上,我们可以不要这个括号也能调用,这算是Typescript为数不多的"委曲求全",默认了也能在void返回值
的时候返回非void,只是用void警告大家不要使用这个返回值就可以了.
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">records</span>: <span style="color: #531ab6;">string</span><span style="color: #000000;">[]</span> = <span style="color: #000000;">[]</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>records<span style="color: #000000;">)</span>;

<span style="color: #531ab6;">function</span> <span style="color: #721045;">saveRecords</span><span style="color: #000000;">(</span><span style="color: #005e8b;">newRecords</span>: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">[]</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  newRecords.<span style="color: #721045;">forEach</span><span style="color: #dd22dd;">(</span><span style="color: #008899;">(</span>record<span style="color: #008899;">)</span> <span style="color: #531ab6;">=&gt;</span> records.<span style="color: #721045;">push</span><span style="color: #008899;">(</span>record<span style="color: #008899;">)</span><span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>

<span style="color: #721045;">saveRecords</span><span style="color: #000000;">(</span><span style="color: #dd22dd;">[</span><span style="color: #3548cf;">"21"</span>, <span style="color: #3548cf;">"Come On Over"</span>, <span style="color: #3548cf;">"The Bodyguard"</span><span style="color: #dd22dd;">]</span><span style="color: #000000;">)</span>;

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>records<span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">[]</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">[ '21', 'Come On Over', 'The Bodyguard' ]</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org527e26b" class="outline-4">
<h4 id="org527e26b"><span class="section-number-4">5.4.2.</span> Never Returns</h4>
<div class="outline-text-4" id="text-5-4-2">
<ul class="org-ul">
<li>never return是处理如下两种情况:
<ul class="org-ul">
<li><p>
总数抛出异常,例子如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">fail</span><span style="color: #000000;">(</span><span style="color: #005e8b;">message</span>: <span style="color: #531ab6;">string</span><span style="color: #000000;">)</span>: <span style="color: #531ab6;">never</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">throw</span> <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Error</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">`Invariant failure: </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">message</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">.`</span><span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">function</span> <span style="color: #721045;">workWithUnsafeParam</span><span style="color: #000000;">(</span><span style="color: #005e8b;">param</span>: <span style="color: #531ab6;">unknown</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">if</span> <span style="color: #dd22dd;">(</span><span style="color: #531ab6;">typeof</span> param != <span style="color: #3548cf;">"string"</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #721045;">fail</span><span style="color: #008899;">(</span><span style="color: #3548cf;">`param should be a string, not </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">typeof param</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #008899;">)</span>
  <span style="color: #dd22dd;">}</span>

  param.<span style="color: #721045;">toUpperCase</span><span style="color: #dd22dd;">()</span>;
<span style="color: #000000;">}</span>
</pre>
</div></li>
<li>无限循环,但是不返回.这种不太常见.</li>
</ul></li>
<li>注意,never和void不一样:
<ul class="org-ul">
<li>never是一个函数永远都不返回值</li>
<li>void是函数返回的值nothing,提醒使用者不用使用这个nothing</li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orga05e21a" class="outline-3">
<h3 id="orga05e21a"><span class="section-number-3">5.5.</span> Function Overloads</h3>
<div class="outline-text-3" id="text-5-5">
<ul class="org-ul">
<li>函数重载是编程语言经典的特性.typescript自然也是支持的
<ul class="org-ul">
<li><p>
下面就是一个重载的例子.
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">createDate</span><span style="color: #000000;">(</span><span style="color: #005e8b;">timestamp</span>: <span style="color: #531ab6;">number</span><span style="color: #000000;">)</span>: <span style="color: #005f5f;">Date</span>;
<span style="color: #531ab6;">function</span> <span style="color: #721045;">createDate</span><span style="color: #000000;">(</span><span style="color: #005e8b;">month</span>: <span style="color: #531ab6;">number</span>, <span style="color: #005e8b;">day</span>: <span style="color: #531ab6;">number</span>, <span style="color: #005e8b;">year</span>: <span style="color: #531ab6;">number</span><span style="color: #000000;">)</span>: <span style="color: #005f5f;">Date</span>;

<span style="color: #531ab6;">function</span> <span style="color: #721045;">createDate</span><span style="color: #000000;">(</span><span style="color: #005e8b;">monthOrTimestamp</span>: <span style="color: #531ab6;">number</span>, <span style="color: #005e8b;">day?</span>: <span style="color: #531ab6;">number</span>, <span style="color: #005e8b;">year?</span>: <span style="color: #531ab6;">number</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> day === <span style="color: #0000b0;">undefined</span> || year === <span style="color: #0000b0;">undefined</span>
    ? <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Date</span><span style="color: #dd22dd;">(</span><span style="color: #005e8b;">monthOrTimestamp</span><span style="color: #dd22dd;">)</span>
    : <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Date</span><span style="color: #dd22dd;">(</span>year, monthOrTimestamp, day<span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>

<span style="color: #721045;">createDate</span><span style="color: #000000;">(</span>554356800<span style="color: #000000;">)</span>;
<span style="color: #721045;">createDate</span><span style="color: #000000;">(</span>7, 27, 1987<span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:13:1 - error TS2575: No overload expects 2 arguments, but overloads do exist that expect either 1 or 3 arguments.</span>

<span style="color: #7f0000;">///////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">createDate(3, 1); //</span>
<span style="color: #7f0000;">///////////////////////</span>
</pre>
</div></li>
<li>注意上面的前两个是函数声明,第三个是函数实现.第三个函数实现虽然是支持两个参数调用的,但是由于声明的
时候没有两个参数的版本,所以调用两个参数的版本会失败</li>
<li><p>
上面重载的例子,其实就是在转换为javascript之后,会把代码改变成如下javascript逻辑,可以看到,已经完全
没有重载的痕迹了.
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #531ab6;">function</span> <span style="color: #721045;">createDate</span><span style="color: #000000;">(</span><span style="color: #005e8b;">monthOrTimestamp</span>, <span style="color: #005e8b;">day</span>, <span style="color: #005e8b;">year</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> day === <span style="color: #0000b0;">undefined</span> || year === <span style="color: #0000b0;">undefined</span>
    ? <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Datre</span><span style="color: #dd22dd;">(</span>monthOrTimestamp<span style="color: #dd22dd;">)</span>
    : <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Datre</span><span style="color: #dd22dd;">(</span>year, monthOrTimestamp, day<span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
<div id="outline-container-org008d529" class="outline-4">
<h4 id="org008d529"><span class="section-number-4">5.5.1.</span> Call-Signature Compatibility</h4>
<div class="outline-text-4" id="text-5-5-1">
<ul class="org-ul">
<li>由于typescript的重载办法,是在编译成javascript的时候,依靠逻辑来重写代码.那么我们就要求参数必须能够
相互转换(对位assignable),比如上一节例子中的timestamp和month都是string
<ul class="org-ul">
<li><p>
下面的例子中,第三个函数就因为无法和第一个函数对位assign,所以重载失败了
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">format</span><span style="color: #000000;">(</span><span style="color: #005e8b;">data</span>: <span style="color: #531ab6;">string</span><span style="color: #000000;">)</span>: <span style="color: #531ab6;">string</span>;
<span style="color: #531ab6;">function</span> <span style="color: #721045;">format</span><span style="color: #000000;">(</span><span style="color: #005e8b;">data</span>: <span style="color: #531ab6;">string</span>, <span style="color: #005e8b;">needle</span>: <span style="color: #531ab6;">string</span>, <span style="color: #005e8b;">haystack</span>: <span style="color: #531ab6;">string</span><span style="color: #000000;">)</span>: <span style="color: #531ab6;">string</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:4:10 - error TS2394: This overload signature is not compatible with its implementation signature.</span>

<span style="color: #7f0000;">/////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">function format(</span><span style="color: #005e8b;">getData</span><span style="color: #7f0000;">: () =&gt; </span><span style="color: #005e8b;">string</span><span style="color: #7f0000;">): string; //</span>
<span style="color: #7f0000;">/////////////////////////////////////////////////////</span>

<span style="color: #531ab6;">function</span> <span style="color: #721045;">format</span><span style="color: #000000;">(</span><span style="color: #005e8b;">data</span>: <span style="color: #531ab6;">string</span>, <span style="color: #005e8b;">needle?</span>: <span style="color: #531ab6;">string</span>, <span style="color: #005e8b;">haystack?</span>: <span style="color: #531ab6;">string</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> needle &amp;&amp; haystack ? data.<span style="color: #721045;">replace</span><span style="color: #dd22dd;">(</span><span style="color: #005e8b;">needle</span>, <span style="color: #005e8b;">haystack</span><span style="color: #dd22dd;">)</span> : data;
<span style="color: #000000;">}</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org28ac7c3" class="outline-2">
<h2 id="org28ac7c3"><span class="section-number-2">6.</span> Chapter 6: Arrays</h2>
<div class="outline-text-2" id="text-6">
</div>
<div id="outline-container-orge722912" class="outline-3">
<h3 id="orge722912"><span class="section-number-3">6.1.</span> Array Types</h3>
<div class="outline-text-3" id="text-6-1">
<ul class="org-ul">
<li>变量一般声明的时候,都是没有value的.array也同样,所以我们必须为"空的array"创建一个声明样式
<ul class="org-ul">
<li><p>
typescript肯定是希望你一开始就把array里面放置什么类型给标记出来的,如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">arrayOfNumbbers</span>: <span style="color: #531ab6;">number</span><span style="color: #000000;">[]</span>;

arrayOfNumbbers = <span style="color: #000000;">[</span>1, 2, 3, 4, 5<span style="color: #000000;">]</span>;
</pre>
</div></li>
<li>我们甚至可以使用Array&lt;number&gt;来替代number[],但是这种写法不太受欢迎</li>
</ul></li>
</ul>
</div>
<div id="outline-container-orga763b26" class="outline-4">
<h4 id="orga763b26"><span class="section-number-4">6.1.1.</span> Array and Function Types</h4>
<div class="outline-text-4" id="text-6-1-1">
<ul class="org-ul">
<li>我们之前说过,本身function type由于其类型过长,就容易需要配合(). 如果function type再加上array,那么使
用括号的概率,就更高了
<ul class="org-ul">
<li><p>
第一个例子函数的类型是: function that returns an array of strings
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">createStrings</span>: <span style="color: #000000;">()</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #531ab6;">string</span><span style="color: #000000;">[]</span>;
</pre>
</div></li>
<li><p>
第二个例子函数的类型是: functions that each return a string
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">strignCreators</span>: <span style="color: #000000;">(</span><span style="color: #dd22dd;">()</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #531ab6;">string</span><span style="color: #000000;">)[]</span>;
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgd5c48bf" class="outline-4">
<h4 id="orgd5c48bf"><span class="section-number-4">6.1.2.</span> Union Type Arrays</h4>
<div class="outline-text-4" id="text-6-1-2">
<ul class="org-ul">
<li>array里面可以使用union type来明确array里面的成员可以是union中的一种.这种情况下,()的使用概率也很高:
<ul class="org-ul">
<li><p>
第一个例子变量的类型是: either a number or an array of strings
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">stringOrArrayOfNumbers</span>: <span style="color: #531ab6;">string</span> | <span style="color: #531ab6;">number</span><span style="color: #000000;">[]</span>;
</pre>
</div></li>
<li><p>
第二个例子变量的类型是: an array of elements that ar each either a number or a string
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">arrayOfStringOrNumbers</span>: <span style="color: #000000;">(</span><span style="color: #531ab6;">string</span> | <span style="color: #531ab6;">number</span><span style="color: #000000;">)[]</span>;
</pre>
</div></li>
</ul></li>
<li>如果一个typescript没有明确的declare它的类型,那么Typescript会自己infer这个数组的类型(通过数组中的数据)
<ul class="org-ul">
<li><p>
比如下面的例子中,我们可以通过错误提示来发现namesMaybe的类型
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">namesMaybe</span> = <span style="color: #000000;">[</span><span style="color: #3548cf;">"Aqualtune"</span>, <span style="color: #3548cf;">"Blenda"</span>, <span style="color: #0000b0;">undefined</span><span style="color: #000000;">]</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:3:5 - error TS2322: Type '(string | undefined)[]' is not assignable to type 'number'.</span>

<span style="color: #7f0000;">///////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">let tmp: number = namesMaybe; //</span>
<span style="color: #7f0000;">///////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orga917548" class="outline-4">
<h4 id="orga917548"><span class="section-number-4">6.1.3.</span> Evolving Any Arrays</h4>
<div class="outline-text-4" id="text-6-1-3">
<ul class="org-ul">
<li>如果声明数组的时候,没有写具体的类型,那么就相当于是any[]</li>
<li>any[]不是Typescript所希望的类型,因为这样配置失去了typescript的优势:类型. 所以typescript会随着any[]
数组里面增加不同类型的成员,而动态的改变自己的类型
<ul class="org-ul">
<li><p>
比如下面例子中,数组的类型从any[]到string[],再到(number | string)[]
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">values</span> = <span style="color: #000000;">[]</span>;                <span style="color: #7f0000;">// </span><span style="color: #7f0000;">Type: any[]</span>
values.<span style="color: #721045;">push</span><span style="color: #000000;">(</span><span style="color: #3548cf;">""</span><span style="color: #000000;">)</span>;                <span style="color: #7f0000;">// </span><span style="color: #005e8b;">Type</span><span style="color: #7f0000;">: string[]</span>
values<span style="color: #000000;">[</span>0<span style="color: #000000;">]</span> = 0;                  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">Type: (number | string)[]</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgc7a5f41" class="outline-4">
<h4 id="orgc7a5f41"><span class="section-number-4">6.1.4.</span> Multidimensional Arrays</h4>
<div class="outline-text-4" id="text-6-1-4">
<ul class="org-ul">
<li>作为2D数组,我们会有两个[]
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">arrayOfArraysOfNumbers</span>: <span style="color: #531ab6;">number</span><span style="color: #000000;">[][]</span>;

arrayOfArraysOfNumbers = <span style="color: #000000;">[</span>
  <span style="color: #dd22dd;">[</span>1, 2, 3<span style="color: #dd22dd;">]</span>,
  <span style="color: #dd22dd;">[</span>2, 4, 6<span style="color: #dd22dd;">]</span>,
  <span style="color: #dd22dd;">[</span>3, 6, 9<span style="color: #dd22dd;">]</span>,
<span style="color: #000000;">]</span>;

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>arrayOfArraysOfNumbers<span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">[ [ 1, 2, 3 ], [ 2, 4, 6 ], [ 3, 6, 9 ] ]</span>
</pre>
</div></li>
</ul></li>
<li>对于3D数组,那么就会有3个[], 4D数组,会有4个[],5D数组,会有5个[].依此类推</li>
<li>多维数组其实只是语法糖.如下两种情况其实是等价的:
<ul class="org-ul">
<li>number[][]</li>
<li>(number[])[]</li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org208109d" class="outline-3">
<h3 id="org208109d"><span class="section-number-3">6.2.</span> Array Members</h3>
<div class="outline-text-3" id="text-6-2">
<ul class="org-ul">
<li>typescript可以理解数组[index]得到的数据的类型:
<ul class="org-ul">
<li><p>
如果数组是string[],那么数组[index]类型是string,这个容易理解
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">defenders</span> = <span style="color: #000000;">[</span><span style="color: #3548cf;">"Clarenza"</span>, <span style="color: #3548cf;">"Dina"</span><span style="color: #000000;">]</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Type: string</span>
<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">defender</span> = defenders<span style="color: #000000;">[</span>0<span style="color: #000000;">]</span>;
</pre>
</div></li>
<li><p>
如果数组是(string | Date)[],那么数组[index]类型是 string | Date.这个有点反直觉,本以为Typescript能
够判断出具体类型的
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">soldersOrDates</span> = <span style="color: #000000;">[</span><span style="color: #3548cf;">"Deborah Sampson"</span>, <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Date</span><span style="color: #dd22dd;">(</span>1782, 6, 3<span style="color: #dd22dd;">)</span><span style="color: #000000;">]</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Type: Date | string</span>
<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">soldersOrDate</span> = soldersOrDates<span style="color: #000000;">[</span>0<span style="color: #000000;">]</span>;
</pre>
</div></li>
</ul></li>
</ul>
</div>
<div id="outline-container-org7fb6dd1" class="outline-4">
<h4 id="org7fb6dd1"><span class="section-number-4">6.2.1.</span> Caveat: Unsound Members</h4>
<div class="outline-text-4" id="text-6-2-1">
<ul class="org-ul">
<li>有个术语叫做unsound,意思就是说类型判断大多数情况下是准确的,但不是每次都是准确的. Typescript的type
system就是unsound的
<ul class="org-ul">
<li><p>
示例如下, typescript在compile time没有发现9001是一个错误的index
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #7f0000;">// </span><span style="color: #7f0000;">TypeError: Cannot read properties of undefined (reading 'length')</span>

<span style="color: #7f0000;">/////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">function withElements(</span><span style="color: #005e8b;">elements</span><span style="color: #7f0000;">: string[]) { //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">console.</span><span style="color: #721045;">log</span><span style="color: #7f0000;">(elements[9001].length);       //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">}                                           //</span>
<span style="color: #7f0000;">//                                             </span><span style="color: #7f0000;">//</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">withElements(["A", "AB", "ABC"])            //</span>
<span style="color: #7f0000;">/////////////////////////////////////////////////</span>
</pre>
</div></li>
<li>虽然也有报错,但是我们看到这个错误是一个runtime错误</li>
<li>如果我们设置&#x2013;noUncheckedIndexedAccess flag那么能够捕捉到这个错误,但是这个flag太严格了,几乎没有项
目使用这个flag</li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgf0cda23" class="outline-3">
<h3 id="orgf0cda23"><span class="section-number-3">6.3.</span> Spreads and Rests</h3>
<div class="outline-text-3" id="text-6-3">
<ul class="org-ul">
<li>前面我们用过"&#x2026;"这个操作符,其在typescript里面和javascript的左右是一样的.:
<ul class="org-ul">
<li><p>
array spreading
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">fruits</span> = <span style="color: #000000;">[</span><span style="color: #3548cf;">"apple"</span>, <span style="color: #3548cf;">"banana"</span>, <span style="color: #3548cf;">"orange"</span><span style="color: #000000;">]</span>;
<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">moreFruits</span> = <span style="color: #000000;">[</span><span style="color: #3548cf;">"grape"</span>, ...fruits, <span style="color: #3548cf;">"pineapple"</span><span style="color: #000000;">]</span>;

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>moreFruits<span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">[ 'grape', 'apple', 'banana', 'orange', 'pineapple' ]</span>
</pre>
</div></li>
<li><p>
rest parameter
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">sum</span><span style="color: #000000;">(</span>...<span style="color: #005e8b;">numbers</span>: <span style="color: #531ab6;">number</span><span style="color: #dd22dd;">[]</span><span style="color: #000000;">)</span>: <span style="color: #531ab6;">number</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> numbers.<span style="color: #721045;">reduce</span><span style="color: #dd22dd;">(</span><span style="color: #008899;">(</span>total, num<span style="color: #008899;">)</span> <span style="color: #531ab6;">=&gt;</span> total + num, 0<span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">totalSum</span> = <span style="color: #721045;">sum</span><span style="color: #000000;">(</span>1, 2, 3, 4, 5<span style="color: #000000;">)</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>totalSum<span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">15</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
<div id="outline-container-orgb1c7e12" class="outline-4">
<h4 id="orgb1c7e12"><span class="section-number-4">6.3.1.</span> Spreads</h4>
<div class="outline-text-4" id="text-6-3-1">
<ul class="org-ul">
<li>Typescript足够聪明,可以知道两个不同类型的数组spread在一块得到的新数组,其类型是两个类型的union
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">soldiers</span> = <span style="color: #000000;">[</span><span style="color: #3548cf;">"Harriet Tubman"</span>, <span style="color: #3548cf;">"Joan of Arc"</span>, <span style="color: #3548cf;">"Khutulun"</span><span style="color: #000000;">]</span>; <span style="color: #7f0000;">// </span><span style="color: #7f0000;">Type: string[]</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">soldierAges</span> = <span style="color: #000000;">[</span>90, 19, 45<span style="color: #000000;">]</span>; <span style="color: #7f0000;">// </span><span style="color: #7f0000;">Type: number[]</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">conjoined</span> = <span style="color: #000000;">[</span>...soldiers, ...soldier<span style="color: #000000;">]</span>; <span style="color: #7f0000;">// </span><span style="color: #7f0000;">Type: (string | number)[]</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgaf888e0" class="outline-4">
<h4 id="orgaf888e0"><span class="section-number-4">6.3.2.</span> Spreading Rest Parameters</h4>
<div class="outline-text-4" id="text-6-3-2">
<ul class="org-ul">
<li>如果"&#x2026;"作为rest parameters,那么我们的typescript就会进行严格检查了,不符合规定的实参传递不进去
<ul class="org-ul">
<li><p>
示例如下, string[]可以传入, number[]不能传入
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">logWarriers</span><span style="color: #000000;">(</span><span style="color: #005e8b;">greeting</span>: <span style="color: #531ab6;">string</span>, ...names: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">[]</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">for</span> <span style="color: #dd22dd;">(</span><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">name</span> <span style="color: #531ab6;">of</span> names<span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #3548cf;">`</span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">greeting</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">, </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">name</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">!`</span><span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">warriors</span> = <span style="color: #000000;">[</span><span style="color: #3548cf;">"Cathay Williams"</span>, <span style="color: #3548cf;">"Lozen"</span>, <span style="color: #3548cf;">"Nzinga"</span><span style="color: #000000;">]</span>;
<span style="color: #721045;">logWarriers</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Hello"</span>, ...warriors<span style="color: #000000;">)</span>;

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">brithYears</span> = <span style="color: #000000;">[</span>1844, 1840, 1583<span style="color: #000000;">]</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Hello, Cathay Williams!</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Hello, Lozen!</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Hello, Nzinga!</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:11:22 - error TS2345: Argument of type 'number' is not assignable to parameter of type 'string'.</span>

<span style="color: #7f0000;">//////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">logWarriers("Hello", ...brithYears); //</span>
<span style="color: #7f0000;">//////////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgb661dfe" class="outline-3">
<h3 id="orgb661dfe"><span class="section-number-3">6.4.</span> Tuples</h3>
<div class="outline-text-3" id="text-6-4">
<ul class="org-ul">
<li>所谓tuple,就是fixed size array. 在python中也有tuple这个概念,typescript是对这个概念的增强:因为typescript
自己有类型系统.所以typescript的tuple包含了如下两层含义:
<ul class="org-ul">
<li>fixed size</li>
<li>type for each index</li>
</ul></li>
<li>tuple需要为每个index都声明类型,这些类型组成的数组又标明了其fixed的长度
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">yearAndWarrier</span>: <span style="color: #000000;">[</span><span style="color: #531ab6;">number</span>, <span style="color: #531ab6;">string</span><span style="color: #000000;">]</span>;
yearAndWarrier = <span style="color: #000000;">[</span>530, <span style="color: #3548cf;">"Tomyris"</span><span style="color: #000000;">]</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:3:19 - error TS2322: Type 'boolean' is not assignable to type 'number'.</span>

<span style="color: #7f0000;">//////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">yearAndWarrier = [false, "Tomyris"]; //</span>
<span style="color: #7f0000;">//////////////////////////////////////////</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:11:1 - error TS2322: Type '[number]' is not assignable to type '[number, string]'.</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">Source has 1 element(s) but target requires 2.</span>

<span style="color: #7f0000;">/////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">yearAndWarrier = [530]; //</span>
<span style="color: #7f0000;">/////////////////////////////</span>
</pre>
</div></li>
</ul></li>
<li>tuple最常用的场景是array destructuring, 其作用是一次性assign多个value
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #000000;">[</span><span style="color: #005e8b;">year</span>, <span style="color: #005e8b;">warrier</span><span style="color: #000000;">]</span> =
  Math.<span style="color: #721045;">random</span><span style="color: #000000;">()</span> &gt; 0.5 ? <span style="color: #000000;">[</span>340, <span style="color: #3548cf;">"Archidamia"</span><span style="color: #000000;">]</span> : <span style="color: #000000;">[</span>1828, <span style="color: #3548cf;">"Rani of Jhansi"</span><span style="color: #000000;">]</span>;

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span><span style="color: #3548cf;">`|year| =&gt; </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">year</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #000000;">)</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span><span style="color: #3548cf;">`|warrier| =&gt; </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">warrier</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT1====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|year| =&gt; 1828</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|warrier| =&gt; Rani of Jhansi</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT2====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|year| =&gt; 340</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|warrier| =&gt; Archidamia</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
<div id="outline-container-org9706d80" class="outline-4">
<h4 id="org9706d80"><span class="section-number-4">6.4.1.</span> Tuple Assignability</h4>
<div class="outline-text-4" id="text-6-4-1">
<ul class="org-ul">
<li>由于tuple的类型信息里面包括了每个index的类型,所以tuple是比array更加specific的类型,那么我们很显然是
没办法把array赋值给tuple的
<ul class="org-ul">
<li><p>
下面就是这样一个例子,我们的pairLosse这个数组不是我们想象的[boolean, number],其类型其实是(boolean | number)[],
那么显然其无法赋值给类型我[boolean, number]的tuple
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">pairLosse</span> = <span style="color: #000000;">[</span><span style="color: #0000b0;">false</span>, 123<span style="color: #000000;">]</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:3:7 - error TS2322: Type '(number | boolean)[]' is not assignable to type '[boolean, number]'.</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">Target requires 2 element(s) but source may have fewer.</span>

<span style="color: #7f0000;">//////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">const pairTupleLoose: [boolean, number] = pairLosse; //</span>
<span style="color: #7f0000;">//////////////////////////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
<li>不同长度的tuple,显然是无法赋值的.这个很显然
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">tupleThree</span>: <span style="color: #000000;">[</span><span style="color: #531ab6;">boolean</span>, <span style="color: #531ab6;">number</span>, <span style="color: #531ab6;">string</span><span style="color: #000000;">]</span> = <span style="color: #000000;">[</span><span style="color: #0000b0;">false</span>, 1583, <span style="color: #3548cf;">"Nzinga"</span><span style="color: #000000;">]</span>;
<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">tupleTwoExact1</span>: <span style="color: #000000;">[</span><span style="color: #531ab6;">boolean</span>, <span style="color: #531ab6;">number</span><span style="color: #000000;">]</span> = <span style="color: #000000;">[</span>tupleThree<span style="color: #dd22dd;">[</span>0<span style="color: #dd22dd;">]</span>, tupleThree<span style="color: #dd22dd;">[</span>1<span style="color: #dd22dd;">]</span><span style="color: #000000;">]</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:3:7 - error TS2322: Type '[boolean, number, string]' is not assignable to type '[boolean, number]'.</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">Source has 3 element(s) but target allows only 2.</span>

<span style="color: #7f0000;">///////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">const tupleTwoExact2: [boolean, number] = tupleThree; //</span>
<span style="color: #7f0000;">///////////////////////////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
<li>由于tuple包含了fixed数组和每个index的类型信息,其非常适合作为rest parameter传递给函数
<ul class="org-ul">
<li><p>
示例如下,tuple可以赋值给函数,其类型在每个index上面是确定的
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">logPair</span><span style="color: #000000;">(</span><span style="color: #005e8b;">name</span>: <span style="color: #531ab6;">string</span>, <span style="color: #005e8b;">value</span>: <span style="color: #531ab6;">number</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">`</span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">name</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;"> has </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">value</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">pairTupleCorrect</span>: <span style="color: #000000;">[</span><span style="color: #531ab6;">string</span>, <span style="color: #531ab6;">number</span><span style="color: #000000;">]</span> = <span style="color: #000000;">[</span><span style="color: #3548cf;">"Amage"</span>, 1<span style="color: #000000;">]</span>;
<span style="color: #721045;">logPair</span><span style="color: #000000;">(</span>...pairTupleCorrect<span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Amage has 1</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">pairTupleIncorrect</span>: <span style="color: #000000;">[</span><span style="color: #531ab6;">number</span>, <span style="color: #531ab6;">string</span><span style="color: #000000;">]</span> = <span style="color: #000000;">[</span>1, <span style="color: #3548cf;">"Amage"</span><span style="color: #000000;">]</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:6:9 - error TS2345: Argument of type 'number' is not assignable to parameter of type 'string'.</span>

<span style="color: #7f0000;">/////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">logPair(...pairTupleIncorrect); //</span>
<span style="color: #7f0000;">/////////////////////////////////////</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">pairArray</span> = <span style="color: #000000;">[</span><span style="color: #3548cf;">"Amage"</span>, 1<span style="color: #000000;">]</span>;
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:6:9 - error TS2556: A spread argument must either have a tuple type or be passed to a rest parameter.</span>

<span style="color: #7f0000;">////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">logPair(...pairArray); //</span>
<span style="color: #7f0000;">////////////////////////////</span>
</pre>
</div></li>
<li>作为反例,index类型不正确的tuple是赋值不成功的</li>
<li>作为另一个反例,数组也不能赋值给函数,其类型是union()</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgfe2a701" class="outline-4">
<h4 id="orgfe2a701"><span class="section-number-4">6.4.2.</span> Tuple Inferences</h4>
<div class="outline-text-4" id="text-6-4-2">
<ul class="org-ul">
<li>Typescript总体上,如果不特殊配置,都是把"[]"的代码都解释为variable length array的,而不是tuple
<ul class="org-ul">
<li><p>
示例如下,下面的函数把其返回值给infer成(string | number)[]
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">firstCharAndSize</span><span style="color: #000000;">(</span><span style="color: #005e8b;">input</span>: <span style="color: #531ab6;">string</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> <span style="color: #dd22dd;">[</span>input<span style="color: #008899;">[</span>0<span style="color: #008899;">]</span>, input.length<span style="color: #dd22dd;">]</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #000000;">[</span><span style="color: #005e8b;">firstChar</span>, <span style="color: #005e8b;">size</span><span style="color: #000000;">]</span> = <span style="color: #721045;">firstCharAndSize</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Gudit"</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:7:7 - error TS2322: Type 'string | number' is not assignable to type 'strng</span>

<span style="color: #7f0000;">////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">const tmp: string = firstChar; //</span>
<span style="color: #7f0000;">////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
<li>Typescript如果经过如下两种"特殊配置",那么就可以把"[]"解析成tuple:
<ul class="org-ul">
<li>explicit tuple type</li>
<li>const assertion</li>
</ul></li>
</ul>
</div>
<ol class="org-ol">
<li><a id="orga979b9c"></a>Explicit tuple types<br />
<div class="outline-text-5" id="text-6-4-2-1">
<ul class="org-ul">
<li>如果一个函数的返回值明确的描述了自己要返回一个tuple type,并且代码里面使用了array literal(也就是"[]")
那么这种情况下,这个array literal会被infer成一个tuple,而不是数组
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">firstCharAndSizeExplicit</span><span style="color: #000000;">(</span><span style="color: #005e8b;">input</span>: <span style="color: #531ab6;">string</span><span style="color: #000000;">)</span>: <span style="color: #000000;">[</span><span style="color: #531ab6;">string</span>, <span style="color: #531ab6;">number</span><span style="color: #000000;">]</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> <span style="color: #dd22dd;">[</span>input<span style="color: #008899;">[</span>0<span style="color: #008899;">]</span>, input.length<span style="color: #dd22dd;">]</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #000000;">[</span><span style="color: #005e8b;">firstChar</span>, <span style="color: #005e8b;">size</span><span style="color: #000000;">]</span> = <span style="color: #721045;">firstCharAndSizeExplicit</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Cathay Williams"</span><span style="color: #000000;">)</span>;

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">typeStr</span>: <span style="color: #531ab6;">string</span> = firstChar;
<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">typeNum</span>: <span style="color: #531ab6;">number</span> = size;
</pre>
</div></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org1af8219"></a>Const asserted tuples<br />
<div class="outline-text-5" id="text-6-4-2-2">
<ul class="org-ul">
<li>如果每次都把类型明确的写出来,不仅非常的累,而且在更新代码的时候,还要同时更新这些类型,所以Typescript
也为我们提供了一种能够把array litral("[]")给直接解释成tuple的语法糖, as const
<ul class="org-ul">
<li><p>
示例如下,下面例子中的readonlyTuple就别infer成了tuple
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">unionArray</span> = <span style="color: #000000;">[</span>1157, <span style="color: #3548cf;">"Tomo"</span><span style="color: #000000;">]</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:3:7 - error TS2322: Type '(string | number)[]' is not assignable to type 'string'.</span>

<span style="color: #7f0000;">/////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">const typeStr: string = unionArray; //</span>
<span style="color: #7f0000;">/////////////////////////////////////////</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">readonlyTuple</span> = <span style="color: #000000;">[</span>1157, <span style="color: #3548cf;">"Tomoe"</span><span style="color: #000000;">]</span> <span style="color: #531ab6;">as</span> <span style="color: #531ab6;">const</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:12:7 - error TS2322: Type 'readonly [1157, "Tomoe"]' is not assignable to type 'string'.</span>

<span style="color: #7f0000;">////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">const typeStr: string = readonlyTuple; //</span>
<span style="color: #7f0000;">////////////////////////////////////////////</span>
</pre>
</div></li>
<li>从上面的例子中我们也可以看到使用as const返回的不仅仅是tuple,而是加了一个readonly的tuple,也就是readonly [1157, "Tomoe"]</li>
</ul></li>
<li>上面as const的副作用就是我们得到的tuple不仅仅是tuple,其是readonly的.这个readonly还不仅仅是对象不能重复被assign,而是每个成员都不能改动.
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">pairMutable</span>: <span style="color: #000000;">[</span><span style="color: #531ab6;">number</span>, <span style="color: #531ab6;">string</span><span style="color: #000000;">]</span> = <span style="color: #000000;">[</span>1157, <span style="color: #3548cf;">"Tomoe"</span><span style="color: #000000;">]</span>;
pairMutable<span style="color: #000000;">[</span>0<span style="color: #000000;">]</span> = 1247; <span style="color: #7f0000;">// </span><span style="color: #7f0000;">Ok</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">The type 'readonly [1157, "Tomoe"]' is 'readonly' and cannot be assigned to the mutable type '[number, string]'. (typescript-tide)</span>

<span style="color: #7f0000;">/////////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">const pairAlsoMutable: [number, string] = [1157, "Tomoe"] as const; //</span>
<span style="color: #7f0000;">/////////////////////////////////////////////////////////////////////////</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">pairConst</span> = <span style="color: #000000;">[</span>1157, <span style="color: #3548cf;">"Tomoe"</span><span style="color: #000000;">]</span> <span style="color: #531ab6;">as</span> <span style="color: #531ab6;">const</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:11:11 - error TS2540: Cannot assign to '0' because it is a read-only property.</span>

<span style="color: #7f0000;">//////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">pairConst[0] = 1247; //</span>
<span style="color: #7f0000;">//////////////////////////</span>
</pre>
</div></li>
</ul></li>
<li>在实践当中,read-only tuple最合适的使用场景是function return, 因为函数的返回值往往非常快的就被destructure
掉.用户只关心从function return里面取值,不关心其是否const
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">firstCharAndSizeAsConst</span><span style="color: #000000;">(</span><span style="color: #005e8b;">input</span>: <span style="color: #531ab6;">string</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> <span style="color: #dd22dd;">[</span>input<span style="color: #008899;">[</span>0<span style="color: #008899;">]</span>, input.length<span style="color: #dd22dd;">]</span> <span style="color: #531ab6;">as</span> <span style="color: #531ab6;">const</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #000000;">[</span><span style="color: #005e8b;">firstChar</span>, <span style="color: #005e8b;">size</span><span style="color: #000000;">]</span> = <span style="color: #721045;">firstCharAndSizeAsConst</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Ching Shih"</span><span style="color: #000000;">)</span>;

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span><span style="color: #3548cf;">`|firstChar| =&gt; </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">firstChar</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #000000;">)</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span><span style="color: #3548cf;">`|size| =&gt; </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">size</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|firstChar| =&gt; C</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|size| =&gt; 10</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-org1b779e7" class="outline-2">
<h2 id="org1b779e7"><span class="section-number-2">7.</span> Chapter 7: Interfaces</h2>
<div class="outline-text-2" id="text-7">
<ul class="org-ul">
<li>我们前面主要介绍了type,其主要功能是describe object shape</li>
<li>而本章介绍的interface,其主要功能也是describe shape,interface的功能和type基本一致,但是多数情况下,
interface更应该被Typescript开发者所选择,因为其:
<ul class="org-ul">
<li>错误信息更加友好</li>
<li>编译器能更加快速编译</li>
<li>和class更好的进行配合</li>
</ul></li>
</ul>
</div>
<div id="outline-container-orgd138a7b" class="outline-3">
<h3 id="orgd138a7b"><span class="section-number-3">7.1.</span> Type Aliases Versus Intrfaces</h3>
<div class="outline-text-3" id="text-7-1">
<ul class="org-ul">
<li>我们用下面的代码来对比下type和Interface
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">type</span> <span style="color: #005f5f;">Poet1</span> = <span style="color: #000000;">{</span>
  born: <span style="color: #531ab6;">number</span>;
  name: <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>;

<span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">Poet2</span> <span style="color: #000000;">{</span>
  born: <span style="color: #531ab6;">number</span>;
  name: <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>
</pre>
</div></li>
<li>我们可以看到,两者的syntax基本一致</li>
<li>但是type的最后有分号,而interface最后没有.这个可以从javascript的规范来推导:
<ol class="org-ol">
<li>javascript里面创建一个变量是加分号的</li>
<li>javascript里面创建一个class或者function是不加分号的</li>
</ol></li>
</ul></li>
<li>Type和interface有如下根本上的不同:
<ul class="org-ul">
<li>interface是可以把多个interface合成一个的</li>
<li>interface是可以type check class 声明的,但是type不行</li>
<li>interface的编译更快</li>
<li>interface被编译器认为是"named object", 而type被编译器认为是"alias for an unnamed object literal",
所以显然interface的错误信息更易读</li>
</ul></li>
<li><p>
上面虽然都是区别,但是很显然凸显出interface的优势.最佳实践中,我们会默认使用interface,直到你遇到必须
使用type的情况,比如union type(required)或者是function type(cleaner syntax)
</p>
<pre class="example" id="orga2e2978">
Use interfaces whenever possible, until you need features such as union types(required)
or function type (cleaner syntax)
</pre></li>
</ul>
</div>
</div>
<div id="outline-container-org0b95143" class="outline-3">
<h3 id="org0b95143"><span class="section-number-3">7.2.</span> Type of Proprties</h3>
<div class="outline-text-3" id="text-7-2">
<ul class="org-ul">
<li>真实世界的javascript object非常灵活(比如可选的property, setter和getter等), 为了能够适配这些灵活的情况,
typescript创建了一系列的type system tool</li>
<li>下面会介绍这些system tool,多说一句,这些tool竟然都能在type上面使用.可见type和interface有多相似.</li>
</ul>
</div>
<div id="outline-container-org60b6f22" class="outline-4">
<h4 id="org60b6f22"><span class="section-number-4">7.2.1.</span> Optional Properties</h4>
<div class="outline-text-4" id="text-7-2-1">
<ul class="org-ul">
<li>我们前面介绍object type的时候介绍过,某个object满足某个type可以有"可选的property",interface也同样拥有这个特性
<ul class="org-ul">
<li><p>
示例如下,任何object只需要pages存在,既可以被认为是Book interface
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">Book</span> <span style="color: #000000;">{</span>
  author?: <span style="color: #531ab6;">string</span>;
  pages: <span style="color: #531ab6;">number</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">ok</span>: <span style="color: #005f5f;">Book</span> = <span style="color: #000000;">{</span>
  author: <span style="color: #3548cf;">"Rita Dove"</span>,
  pages: 80,
<span style="color: #000000;">}</span>;

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">missing</span>: <span style="color: #005f5f;">Book</span> = <span style="color: #000000;">{</span>
  pages: 80,
<span style="color: #000000;">}</span>;
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgef24bd5" class="outline-4">
<h4 id="orgef24bd5"><span class="section-number-4">7.2.2.</span> Read-Only Properties</h4>
<div class="outline-text-4" id="text-7-2-2">
<ul class="org-ul">
<li>typescript的interface可以设置某些property为readonly,一旦设置,那么实现这个interface的object的相应
property不能在初始化之后再被赋值
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">Page</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">readonly</span> text: <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">function</span> <span style="color: #721045;">read</span><span style="color: #000000;">(</span><span style="color: #005e8b;">page</span>: <span style="color: #005f5f;">Page</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #dd22dd;">(</span>page.text<span style="color: #dd22dd;">)</span>;

  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:8:8 - error TS2540: Cannot assign to 'text' because it is a read-only property.</span>

  <span style="color: #7f0000;">///////////////////////</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">page.text += "!"; //</span>
  <span style="color: #7f0000;">///////////////////////</span>
<span style="color: #000000;">}</span>
</pre>
</div></li>
<li>需要注意的是,readonly这个标签,只有像上面例子一样,某个object"显式地"和某个interface发生映射关系的
时候才起作用. 下面例子中的page2 虽然也"隐式"的符合interface Page,但是在没有被read函数"显式"的指派
给Page interface之前,是可以随便改动text的</li>
</ul></li>
<li>需要理解的是,readonly这个特性是类型系统的typescript才有的,目的也是在编译阶段进行检查,最终编译成javascript
之后,就不存在这个特性了</li>
</ul>
</div>
</div>
<div id="outline-container-org10a17c6" class="outline-4">
<h4 id="org10a17c6"><span class="section-number-4">7.2.3.</span> Functions and Methods</h4>
<div class="outline-text-4" id="text-7-2-3">
<ul class="org-ul">
<li>在javascript里面function作为object的member是很正常的事情, 所以作为object的抽象interface,其也会允许
声明interface member的类型为function type</li>
<li>typescript提供了两种声明interface function memeber 的方式,其实是映射了两种javascript定义function的
方式(arrow和非arrow):
<ul class="org-ul">
<li>method syntax:对应常规函数,this会在调用时候动态绑定,适合class的instance使用</li>
<li>property syntax:对应箭头函数,this在创建时候就绑定,除了class的instance以外的情况都使用这个</li>
</ul></li>
<li>我们来看一个interface的例子,其中混合使用了两种function member的声明方式:
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">HasBothFunctionTypes</span> <span style="color: #000000;">{</span>
  property: <span style="color: #dd22dd;">()</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #531ab6;">string</span>;
  <span style="color: #721045;">method</span><span style="color: #dd22dd;">()</span>: <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">hasBoth</span>: <span style="color: #005f5f;">HasBothFunctionTypes</span> = <span style="color: #000000;">{</span>
  property: <span style="color: #dd22dd;">()</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #3548cf;">"property return"</span>,
  <span style="color: #721045;">method</span><span style="color: #dd22dd;">()</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">return</span> <span style="color: #3548cf;">"method return"</span>;
  <span style="color: #dd22dd;">}</span>,
<span style="color: #000000;">}</span>;

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>hasBoth.<span style="color: #721045;">property</span><span style="color: #dd22dd;">()</span><span style="color: #000000;">)</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>hasBoth.<span style="color: #721045;">method</span><span style="color: #dd22dd;">()</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">property return</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">method return</span>
</pre>
</div></li>
<li><p>
上面的每种形式也支持使用?来配置成optional参数
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">OptionalFunctions</span> <span style="color: #000000;">{</span>
  property?: <span style="color: #dd22dd;">()</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #531ab6;">string</span>;
  method?<span style="color: #dd22dd;">()</span>: <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>
</pre>
</div></li>
<li><p>
readonly只能在method 声明上面使用
</p>
<div class="org-src-container">
<pre class="src src-typescript">jinterface ReadonlyFunctions <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">readonly</span> property: <span style="color: #dd22dd;">()</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #531ab6;">string</span>;
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:3:3 - error TS1024: 'readonly' modifier can only appear on a property declaration or index signature.</span>

  <span style="color: #7f0000;">////////////////////////////////</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">readonly method(): string; //</span>
  <span style="color: #7f0000;">////////////////////////////////</span>
<span style="color: #000000;">}</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org1f8e184" class="outline-4">
<h4 id="org1f8e184"><span class="section-number-4">7.2.4.</span> Call Signatures</h4>
<div class="outline-text-4" id="text-7-2-4">
<ul class="org-ul">
<li>call signature是一个非常重要的特性,其用来描述一个value是如何能被像function一样调用的</li>
<li>上面这句定义非常难懂,其实也没有什么意义.我们通过例子来了解call signature在interface的三个主要使用
场景:
<ul class="org-ul">
<li><p>
interface通常描述一个类型,但是有时候interface描述的本身就是一个function(function也是一个类型)
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">StringToNumberConverter</span> <span style="color: #000000;">{</span>
  <span style="color: #dd22dd;">(</span>input: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">)</span>: <span style="color: #531ab6;">number</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">stringLength</span>: <span style="color: #005f5f;">StringToNumberConverter</span> = <span style="color: #000000;">(</span><span style="color: #005e8b;">input</span><span style="color: #000000;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> input.length;
<span style="color: #000000;">}</span>

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span><span style="color: #721045;">stringLength</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">"Hello"</span><span style="color: #dd22dd;">)</span><span style="color: #000000;">)</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">5</span>
</pre>
</div></li>
<li><p>
interface通常描述一个类型,很多的时候,这个类型是一个对象,那么这个对象里面就得有对应的函数才行.这个
时候call signature要有函数名
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">PriceCalculator</span> <span style="color: #000000;">{</span>
  calculatePrice: <span style="color: #dd22dd;">(</span>quantity: <span style="color: #531ab6;">number</span>, pricePerUnit: <span style="color: #531ab6;">number</span><span style="color: #dd22dd;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #531ab6;">number</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">calculator</span>: <span style="color: #005f5f;">PriceCalculator</span> = <span style="color: #000000;">{</span>
  calculatePrice: <span style="color: #dd22dd;">(</span><span style="color: #005e8b;">quantity</span>, <span style="color: #005e8b;">pricePreUnit</span><span style="color: #dd22dd;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">return</span> quantity * pricePreUnit;
  <span style="color: #dd22dd;">}</span>,
<span style="color: #000000;">}</span>;

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>calculator.<span style="color: #721045;">calculatePrice</span><span style="color: #dd22dd;">(</span>5, 10<span style="color: #dd22dd;">)</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">50</span>
</pre>
</div></li>
<li><p>
interface描述的本身就是一个function,然后这个function还有一些自己的变量.这属于第一种情况的扩展
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">Logger</span> <span style="color: #000000;">{</span>
  <span style="color: #dd22dd;">(</span>message: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">)</span>: <span style="color: #531ab6;">void</span>;
  logLevel: <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">myLogger</span>: <span style="color: #005f5f;">Logger</span> = <span style="color: #000000;">(</span><span style="color: #005e8b;">message</span>: <span style="color: #531ab6;">string</span><span style="color: #000000;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #000000;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">`[</span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">myLogger.logLevel</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">] </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">message</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>;
myLogger.logLevel = <span style="color: #3548cf;">"INFO"</span>;

<span style="color: #721045;">myLogger</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"This is a log message."</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">[INFO] This is a log message.</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgada1013" class="outline-4">
<h4 id="orgada1013"><span class="section-number-4">7.2.5.</span> Index Signatures</h4>
<div class="outline-text-4" id="text-7-2-5">
<ul class="org-ul">
<li>有时候,你无法提前知道某个类型所有属性的名字,但是你知道这些属性值的类型(属性通常是字符串或者能转换成
字符串的类型,比如字符串,symbol, 所以这里强调属性值的类型)</li>
<li>在这种情况下,你可以使用index signature(索引签名)去描述可能的key和value的类型
<ul class="org-ul">
<li><p>
示例如下,只有number类型的value可以赋值成功
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">WordCounts</span> <span style="color: #000000;">{</span>
  <span style="color: #dd22dd;">[</span>i: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">]</span>: <span style="color: #531ab6;">number</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">counts</span>: <span style="color: #005f5f;">WordCounts</span> = <span style="color: #000000;">{}</span>;
counts.apple = 0;
counts.banana = 1;

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>counts<span style="color: #dd22dd;">[</span><span style="color: #3548cf;">"apple"</span><span style="color: #dd22dd;">]</span><span style="color: #000000;">)</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>counts<span style="color: #dd22dd;">[</span><span style="color: #3548cf;">"banana"</span><span style="color: #dd22dd;">]</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">0</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">1</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:12:1 - error TS2322: Type 'boolean' is not assignable to type 'number'.</span>

<span style="color: #7f0000;">////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">counts.cherry = false; //</span>
<span style="color: #7f0000;">////////////////////////////</span>
</pre>
</div></li>
</ul></li>
<li><p>
Index signature的存在的意义是:一个对象必须返回一个value,不管对象触发的property是什么.所以index signature
的重点,在于"不管触发的property是什么",而不在于typesafe
</p>
<pre class="example" id="org6ef4ca4">
Index Signature indicates that an object should give back a value no matter
what proprty is being accessed
</pre></li>
<li>下面例子就是这样一种情况, publishDate的Beloved明明没设置,但是还是返回值了(undefined)
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">DatesByName</span> <span style="color: #000000;">{</span>
  <span style="color: #dd22dd;">[</span>i: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">]</span>: <span style="color: #005f5f;">Date</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">publishDates</span>: <span style="color: #005f5f;">DatesByName</span> = <span style="color: #000000;">{</span>
  Frankenstein: <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Date</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">"1 January 1818"</span><span style="color: #dd22dd;">)</span>,
<span style="color: #000000;">}</span>;

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>publishDates.Frankenstein<span style="color: #000000;">)</span>;

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>publishDates.Beloved<span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">1817-12-31T15:54:17.000Z</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">undefined</span>
</pre>
</div></li>
<li>上面这种情况下更应该的选择是Map</li>
</ul></li>
</ul>
</div>
<ol class="org-ol">
<li><a id="orgc771363"></a>Mixing properties and index signatures<br />
<div class="outline-text-5" id="text-7-2-5-1">
<ul class="org-ul">
<li><p>
interface 甚至可以把index signature和一个具体的named property并列的列出来. 但是需要注意的是:
</p>
<pre class="example" id="org7861a78">
这个named property的key和value,必须能够assign给index signature
</pre></li>
<li>换句话说,就是named property列出大的范围, named property是这个大的范围里面的一个特例.这个特例也要符
合大的范围,并且object是必须要有property满足这个特例的,其他的property满足大范围就可以了
<ul class="org-ul">
<li><p>
完全匹配的例子(完全匹配必然可以assign)如下. 注意这例子中的`i`是一个占位符,其可以随意更改,必须改成`key`,这里写成`i`是因为这里代表index signature
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">HistorialNovels</span> <span style="color: #000000;">{</span>
  Oroonoko: <span style="color: #531ab6;">number</span>;
  <span style="color: #dd22dd;">[</span>i: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">]</span>: <span style="color: #531ab6;">number</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">novels</span>: <span style="color: #005f5f;">HistorialNovels</span> = <span style="color: #000000;">{</span>
  Outlander: 1991,
  Oroonoko: 1688,
<span style="color: #000000;">}</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:11:7 - error TS2741: Property 'Oroonoko' is missing in type '{ Outlander: number; }' but required in type 'HistorialNovels'.</span>

<span style="color: #7f0000;">////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">const missingOroonoko: HistorialNovels = { //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">Outlander: 1991,                         //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">};                                         //</span>
<span style="color: #7f0000;">////////////////////////////////////////////////</span>
</pre>
</div></li>
<li><p>
不完全匹配,但是可以assign的例子如下(0作为primitive是可以assign给number的,类似的还有literal可以assign给string)
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">ChapterStarts</span> <span style="color: #000000;">{</span>
  preface: 0;
  <span style="color: #dd22dd;">[</span>i: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">]</span>: <span style="color: #531ab6;">number</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">correctPreface</span>: <span style="color: #005f5f;">ChapterStarts</span> = <span style="color: #000000;">{</span>
  preface: 0,
  night: 1,
  shopping: 5,
<span style="color: #000000;">}</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:13:3 - error TS2322: Type '1' is not assignable to type '0'.</span>

<span style="color: #7f0000;">///////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">const wrongPreface: ChapterStarts = { //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">preface: 1,                         //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">};                                    //</span>
<span style="color: #7f0000;">///////////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org7a6e01e"></a>Numeric index signatures<br />
<div class="outline-text-5" id="text-7-2-5-2">
<ul class="org-ul">
<li>虽然绝大部分情况下,我们使用string来作为object的key(因为javascript其实是隐式的将object key转换为string
的),但是也有时候,特别是在typescript里面,我们会以number来作为key.</li>
<li>不过这个number key其地位是类似named property,是一个特例,其还是要在string key限定的范围里面
<ul class="org-ul">
<li><p>
示例如下, [i:number]: string 是一个特例,类似上面的preface:0, 其value类型string必须能赋给catchall的string index
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">MoreNarrowNumbers</span> <span style="color: #000000;">{</span>
  <span style="color: #dd22dd;">[</span>i: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">]</span>: <span style="color: #531ab6;">string</span>;
  <span style="color: #dd22dd;">[</span>i: <span style="color: #531ab6;">number</span><span style="color: #dd22dd;">]</span>: <span style="color: #531ab6;">string</span> | <span style="color: #0000b0;">undefined</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">mixesNumberAndString</span>: <span style="color: #005f5f;">MoreNarrowNumbers</span> = <span style="color: #000000;">{</span>
  0: <span style="color: #3548cf;">""</span>,
  key1: <span style="color: #3548cf;">""</span>,
  key2: <span style="color: #0000b0;">undefined</span>,
<span style="color: #000000;">}</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:3:3 - error TS2413: 'number' index type 'string | undefined' is not assignable to 'string' index type 'string'.</span>

<span style="color: #7f0000;">////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">interface MoreNarrowStrings {      //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">[i: number]: string | undefined; //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">[i: string]: string;             //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">}                                  //</span>
<span style="color: #7f0000;">////////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</li>
</ol>
</div>
<div id="outline-container-orgb07e401" class="outline-4">
<h4 id="orgb07e401"><span class="section-number-4">7.2.6.</span> Nested Interfaces</h4>
<div class="outline-text-4" id="text-7-2-6">
<ul class="org-ul">
<li>就像object typeA可以nested成为 object typeB的property, interfaceA也能作为其他interface的property
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">Novel</span> <span style="color: #000000;">{</span>
  author: <span style="color: #dd22dd;">{</span>
    name: <span style="color: #531ab6;">string</span>;
  <span style="color: #dd22dd;">}</span>;
  setting: <span style="color: #005f5f;">Settings</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">Settings</span> <span style="color: #000000;">{</span>
  place: <span style="color: #531ab6;">string</span>;
  year: <span style="color: #531ab6;">number</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">myNovel</span>: <span style="color: #005f5f;">Novel</span>;

myNovel = <span style="color: #000000;">{</span>
  author: <span style="color: #dd22dd;">{</span>
    name: <span style="color: #3548cf;">"Jane Austen"</span>,
  <span style="color: #dd22dd;">}</span>,
  setting: <span style="color: #dd22dd;">{</span>
    place: <span style="color: #3548cf;">"England"</span>,
    year: 1812,
  <span style="color: #dd22dd;">}</span>,
<span style="color: #000000;">}</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:29:3 - error TS2741: Property 'year' is missing in type '{ place: string; }' but required in type 'Settings'.</span>

<span style="color: #7f0000;">//////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">myNovel = {                  //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">author: {                  //</span>
<span style="color: #7f0000;">//     </span><span style="color: #7f0000;">name: "Emilly Bronte",   //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">},                         //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">setting: {                 //</span>
<span style="color: #7f0000;">//     </span><span style="color: #7f0000;">place: "West Yorkshire", //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">},                         //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">};                           //</span>
<span style="color: #7f0000;">//////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org2cbfd29" class="outline-3">
<h3 id="org2cbfd29"><span class="section-number-3">7.3.</span> Interface Extensions</h3>
<div class="outline-text-3" id="text-7-3">
<ul class="org-ul">
<li>和java一样typescript的interface可以进行"继承",方法就是使用extends关键字
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">Writing</span> <span style="color: #000000;">{</span>
  title: <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">Novella</span> <span style="color: #531ab6;">extends</span> <span style="color: #005f5f;">Writing</span> <span style="color: #000000;">{</span>
  pages: <span style="color: #531ab6;">number</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">myNovella</span>: <span style="color: #005f5f;">Novella</span> = <span style="color: #000000;">{</span>
  pages: 195,
  title: <span style="color: #3548cf;">"Ethan Frome"</span>,
<span style="color: #000000;">}</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:14:5 - error TS2741: Property 'pages' is missing in type '{ title: string; }' but required in type 'Novella'.</span>

<span style="color: #7f0000;">///////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">let missingPages: Novella = { //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">title: "The Awakening",     //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">};                            //</span>
<span style="color: #7f0000;">///////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
<div id="outline-container-orga4b3c39" class="outline-4">
<h4 id="orga4b3c39"><span class="section-number-4">7.3.1.</span> Overridden Properties</h4>
<div class="outline-text-4" id="text-7-3-1">
<ul class="org-ul">
<li>derive interface 可以override base interface的property.这里的override和cpp里面的override是不一样的,
这里的override是说新的overridden property,比如能够assign 给base property:</li>
<li>assignable的方法一般有两种:
<ul class="org-ul">
<li><p>
使用subset of a typeo union
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#29238;&#25509;&#21475;</span>
<span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">Base</span> <span style="color: #000000;">{</span>
  status: <span style="color: #3548cf;">"active"</span> | <span style="color: #3548cf;">"inactive"</span> | <span style="color: #3548cf;">"archived"</span>; <span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#32852;&#21512;&#31867;&#22411;</span>
<span style="color: #000000;">}</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#27966;&#29983;&#25509;&#21475;</span>
<span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">Derived</span> <span style="color: #531ab6;">extends</span> <span style="color: #005f5f;">Base</span> <span style="color: #000000;">{</span>
  status: <span style="color: #3548cf;">"active"</span> | <span style="color: #3548cf;">"inactive"</span>; <span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#26356;&#20855;&#20307;&#30340;&#23376;&#38598;&#31867;&#22411;</span>
<span style="color: #000000;">}</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#31034;&#20363;&#20351;&#29992;</span>
<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">item1</span>: <span style="color: #005f5f;">Derived</span> = <span style="color: #000000;">{</span>
  status: <span style="color: #3548cf;">"active"</span>, <span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#21512;&#27861;</span>
<span style="color: #000000;">}</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:17:3 - error TS2322: Type '"archived"' is not assignable to type '"active" | "inactive"'.</span>

<span style="color: #7f0000;">//////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">const item2: Derived = { //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">status: "archived",    //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">};                       //</span>
<span style="color: #7f0000;">//////////////////////////////</span>
</pre>
</div></li>
<li><p>
使用从base interface type extend出来的type
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#29238;&#25509;&#21475;</span>
<span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">Base</span> <span style="color: #000000;">{</span>
  details: <span style="color: #dd22dd;">{</span>
    id: <span style="color: #531ab6;">number</span>;
  <span style="color: #dd22dd;">}</span>; <span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#22522;&#30784;&#31867;&#22411;</span>
<span style="color: #000000;">}</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#27966;&#29983;&#25509;&#21475;</span>
<span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">Derived</span> <span style="color: #531ab6;">extends</span> <span style="color: #005f5f;">Base</span> <span style="color: #000000;">{</span>
  details: <span style="color: #dd22dd;">{</span>
    id: <span style="color: #531ab6;">number</span>;
    name: <span style="color: #531ab6;">string</span>; <span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#26032;&#22686;&#23383;&#27573;</span>
  <span style="color: #dd22dd;">}</span>; <span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#25193;&#23637;&#31867;&#22411;</span>
<span style="color: #000000;">}</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#31034;&#20363;&#20351;&#29992;</span>
<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">item1</span>: <span style="color: #005f5f;">Derived</span> = <span style="color: #000000;">{</span>
  details: <span style="color: #dd22dd;">{</span>
    id: 1,
    name: <span style="color: #3548cf;">"Item 1"</span>, <span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#21512;&#27861;&#65292;&#22240;&#20026;&#27966;&#29983;&#25509;&#21475;&#25193;&#23637;&#20102;&#29238;&#25509;&#21475;&#30340;&#23646;&#24615;</span>
  <span style="color: #dd22dd;">}</span>,
<span style="color: #000000;">}</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:25:3 - error TS2741: Property 'name' is missing in type '{ id: number; }' but required in type '{ id: number; name: string; }'.</span>

<span style="color: #7f0000;">//////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">const item2: Derived = { //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">details: {             //</span>
<span style="color: #7f0000;">//     </span><span style="color: #7f0000;">id: 2,               //</span>
<span style="color: #7f0000;">//     </span><span style="color: #7f0000;">// name &#32570;&#22833;         //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">},                     //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">};                       //</span>
<span style="color: #7f0000;">//////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org677304c" class="outline-4">
<h4 id="org677304c"><span class="section-number-4">7.3.2.</span> Extending Multiple Interfaces</h4>
<div class="outline-text-4" id="text-7-3-2">
<ul class="org-ul">
<li>interface的extends可以extends多个不同的interface,用","隔开
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">GivesNumber</span> <span style="color: #000000;">{</span>
  <span style="color: #721045;">giveNumber</span><span style="color: #dd22dd;">()</span>: <span style="color: #531ab6;">number</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">GivesString</span> <span style="color: #000000;">{</span>
  <span style="color: #721045;">giveString</span><span style="color: #dd22dd;">()</span>: <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">GivesBothAndEither</span> <span style="color: #531ab6;">extends</span> <span style="color: #005f5f;">GivesNumber</span>, GivesString <span style="color: #000000;">{</span>
  <span style="color: #721045;">giveEither</span><span style="color: #dd22dd;">()</span>: <span style="color: #531ab6;">number</span> | <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">function</span> <span style="color: #721045;">useGivesBoth</span><span style="color: #000000;">(</span><span style="color: #005e8b;">instance</span>: <span style="color: #005f5f;">GivesBothAndEither</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  instance.<span style="color: #721045;">giveEither</span><span style="color: #dd22dd;">()</span>;
  instance.<span style="color: #721045;">giveNumber</span><span style="color: #dd22dd;">()</span>;
  instance.<span style="color: #721045;">giveString</span><span style="color: #dd22dd;">()</span>;
<span style="color: #000000;">}</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org5eaceef" class="outline-3">
<h3 id="org5eaceef"><span class="section-number-3">7.4.</span> Interface Merging</h3>
<div class="outline-text-3" id="text-7-4">
<ul class="org-ul">
<li>Interface Merging是typescript中非常特殊的特性,在其他语言中很少见.interface merging是说在同一个scope
定义的两个名字相同的interface,那么他们自动合并成一个更大的interface
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">Merged</span> <span style="color: #000000;">{</span>
  fromFirst: <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">Merged</span> <span style="color: #000000;">{</span>
  fromSecond: <span style="color: #531ab6;">number</span>;
<span style="color: #000000;">}</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Equivalent to</span>
<span style="color: #7f0000;">///////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">interface Merged {    //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">fromFirst: string;  //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">fromSecond: number; //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">}                     //</span>
<span style="color: #7f0000;">///////////////////////////</span>
</pre>
</div></li>
</ul></li>
<li>注意:Interface merging是一个让代码不容易被人理解的特性,普通程序不建议使用</li>
</ul>
</div>
<div id="outline-container-orgd253d84" class="outline-4">
<h4 id="orgd253d84"><span class="section-number-4">7.4.1.</span> Member Naming Conflicts</h4>
<div class="outline-text-4" id="text-7-4-1">
<ul class="org-ul">
<li>虽然我们不会太使用interface merging,但是我们这里还是介绍一下interface merging在property和method方
面的一个不同:
<ul class="org-ul">
<li><p>
在不同的merging interfaces里面是不能定义"名字相同,但是类型不同的"property的(arrow function)
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">MergedProperties</span> <span style="color: #000000;">{</span>
  same: <span style="color: #dd22dd;">(</span>input: <span style="color: #531ab6;">boolean</span><span style="color: #dd22dd;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #531ab6;">string</span>;
  different: <span style="color: #dd22dd;">(</span>input: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">MergedProperties</span> <span style="color: #000000;">{</span>
  same: <span style="color: #dd22dd;">(</span>input: <span style="color: #531ab6;">boolean</span><span style="color: #dd22dd;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #531ab6;">string</span>;

  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:8:3 - error TS2717: Subsequent property declarations must have the same type.  Property 'different' must be of type '(input: string) =&gt; string', but here has type '(input: number) =&gt; string'.</span>

  <span style="color: #7f0000;">///////////////////////////////////////////</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">different: (input: number) =&gt; string; //</span>
  <span style="color: #7f0000;">///////////////////////////////////////////</span>
<span style="color: #000000;">}</span>
</pre>
</div></li>
<li><p>
在不同的merging interfaces里面是可以定义"名字相同,但是类型不同的"method的(非arrow function)
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">MergedMethods</span> <span style="color: #000000;">{</span>
  <span style="color: #721045;">different</span><span style="color: #dd22dd;">(</span><span style="color: #005e8b;">input</span>: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">)</span>: <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">MergedMethods</span> <span style="color: #000000;">{</span>
  <span style="color: #721045;">different</span><span style="color: #dd22dd;">(</span><span style="color: #005e8b;">input</span>: <span style="color: #531ab6;">number</span><span style="color: #dd22dd;">)</span>: <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-orga1c387d" class="outline-2">
<h2 id="orga1c387d"><span class="section-number-2">8.</span> Chapter 8: Classes</h2>
<div class="outline-text-2" id="text-8">
</div>
<div id="outline-container-orgb93a484" class="outline-3">
<h3 id="orgb93a484"><span class="section-number-3">8.1.</span> Class Methods</h3>
<div class="outline-text-3" id="text-8-1">
<ul class="org-ul">
<li>在typescript看来,如下两个概念是没有区别的,都是需要些参数(没设置就是any类型), 返回值如果不是递归的,
就可以infer到:
<ul class="org-ul">
<li>class里面的method</li>
<li>普通的function</li>
</ul></li>
<li>下面就是一个简单的Greetr class(拥有greet class method)的例子
<ul class="org-ul">
<li><p>
普通class method示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">Greeter</span> <span style="color: #000000;">{</span>
  <span style="color: #721045;">greet</span><span style="color: #dd22dd;">(</span><span style="color: #005e8b;">name</span>: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #3548cf;">`</span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">name</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">, do your stuff !`</span><span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Greeter</span><span style="color: #000000;">()</span>.<span style="color: #721045;">greet</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Miss Frizzle"</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:9:15 - error TS2554: Expected 1 arguments, but got 0.</span>

<span style="color: #7f0000;">////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">new Greeter().</span><span style="color: #721045;">greet</span><span style="color: #7f0000;">(); //</span>
<span style="color: #7f0000;">////////////////////////////</span>
</pre>
</div></li>
<li><p>
constructor也被看做是普通个class method而已
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">Greeter</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">constructor</span><span style="color: #dd22dd;">(</span>message: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #3548cf;">`As I always say: </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">message</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">!`</span><span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Greeter</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"take chances, make mistaks, get messy"</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:9:1 - error TS2554: Expected 1 arguments, but got 0.</span>

<span style="color: #7f0000;">////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">new Greeter(); //</span>
<span style="color: #7f0000;">////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org63e022e" class="outline-3">
<h3 id="org63e022e"><span class="section-number-3">8.2.</span> Class Properties</h3>
<div class="outline-text-3" id="text-8-2">
<ul class="org-ul">
<li>如果一个typescript的class里面的property需要写入和读取,必须explicitly的在class内部声明,没有声明的property
不会被编译器所识别
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">FieldTrip</span> <span style="color: #000000;">{</span>
  destination: <span style="color: #531ab6;">string</span>;

  <span style="color: #531ab6;">constructor</span><span style="color: #dd22dd;">(</span>destitnation: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">this</span>.destination = destitnation;
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #3548cf;">`We're going to </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">this.destination</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #008899;">)</span>;

    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:8:10 - error TS2339: Property 'nonexistent' does not exist on type 'FieldTrip'.</span>

    <span style="color: #7f0000;">//////////////////////////////////////</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">this.nonexistent = destitnation; //</span>
    <span style="color: #7f0000;">//////////////////////////////////////</span>
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">trip</span> = <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">FieldTrip</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"planetarium"</span><span style="color: #000000;">)</span>;

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>trip.destination<span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:21:18 - error TS2339: Property 'nonexistent' does not exist on type 'FieldTrip'.</span>

<span style="color: #7f0000;">////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">console.</span><span style="color: #721045;">log</span><span style="color: #7f0000;">(trip.nonexistent); //</span>
<span style="color: #7f0000;">////////////////////////////////////</span>
</pre>
</div></li>
<li>一旦在class里面创建了property,那么使用的时候就知道哪些property可以使用了,没有声明过的nonexistent显然无法使用</li>
</ul></li>
</ul>
</div>
<div id="outline-container-org3af7103" class="outline-4">
<h4 id="org3af7103"><span class="section-number-4">8.2.1.</span> Function Properties</h4>
<div class="outline-text-4" id="text-8-2-1">
<ul class="org-ul">
<li>我们回顾下javascript的method scoping和syntax fundamentals,以便更好的理解typescript的特性:javascript
在class里面可以声明两种member的callable function:
<ul class="org-ul">
<li>method: 第一种是直接定义一个method,这是最传统的做法</li>
<li>property: 第二种是定义一个property,只是这个property的类型刚好是function</li>
</ul></li>
<li>这两种方法在typescript上面当然也必须有相应的映射:</li>
</ul>
</div>
<ol class="org-ol">
<li><a id="org5844bc9"></a>使用方法(method)<br />
<div class="outline-text-5" id="text-8-2-1-1">
<ul class="org-ul">
<li>这是最常见的的一种方式,方法是直接定义在类上掉函数
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">CallableClass</span> <span style="color: #000000;">{</span>
  <span style="color: #721045;">callableMethod</span><span style="color: #dd22dd;">()</span>: <span style="color: #531ab6;">void</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #3548cf;">"This is a callable method!"</span><span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">instance</span> = <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">CallableClass</span><span style="color: #000000;">()</span>;
instance.<span style="color: #721045;">callableMethod</span><span style="color: #000000;">()</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>
  <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">CallableClass</span><span style="color: #dd22dd;">()</span>.callableMethod === <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">CallableClass</span><span style="color: #dd22dd;">()</span>.callableMethod,
<span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">This is a callable method!</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">true</span>
</pre>
</div></li>
</ul></li>
<li>这种定义有如下特点:
<ul class="org-ul">
<li>定义的方法会存储在类的prototype上,因此对于多个实例来说,它们共享一个函数,不会占用额外的内存</li>
<li><p>
this是动态绑定的
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">Example</span> <span style="color: #000000;">{</span>
  <span style="color: #721045;">regularFunction</span><span style="color: #dd22dd;">()</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #0000b0;">this</span><span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">obj</span> = <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Example</span><span style="color: #000000;">()</span>;
obj.<span style="color: #721045;">regularFunction</span><span style="color: #000000;">()</span>;

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">detachedFunction</span> = obj.regularFunction;
<span style="color: #721045;">detachedFunction</span><span style="color: #000000;">()</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Example {}</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">undefined</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org998b6c4"></a>使用属性赋值为函数(Property as Function)<br />
<div class="outline-text-5" id="text-8-2-1-2">
<ul class="org-ul">
<li>这种方式是通过类的属性值直接赋值为一个函数
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">CallableClass</span> <span style="color: #000000;">{</span>
  callbleProperty = <span style="color: #dd22dd;">()</span>: <span style="color: #531ab6;">void</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #3548cf;">"This is a callable property !"</span><span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">instance</span> = <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">CallableClass</span><span style="color: #000000;">()</span>;
instance.<span style="color: #721045;">callbleProperty</span><span style="color: #000000;">()</span>;

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>
  <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">CallableClass</span><span style="color: #dd22dd;">()</span>.callbleProperty === <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">CallableClass</span><span style="color: #dd22dd;">()</span>.callbleProperty,
<span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">This is a callable property !</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">false</span>
</pre>
</div></li>
</ul></li>
<li>这种定义有如下特点:
<ul class="org-ul">
<li>函数是直接绑定在实例上的,而不是类的prototype上,因此每个实例都会有一份独立的函数</li>
<li><p>
this是自动绑定定义时的上下文的
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">Example</span> <span style="color: #000000;">{</span>
  arrowFunction = <span style="color: #dd22dd;">()</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #0000b0;">this</span><span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">obj</span> = <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Example</span><span style="color: #000000;">()</span>;
obj.<span style="color: #721045;">arrowFunction</span><span style="color: #000000;">()</span>;

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">detachedFunction</span> = obj.arrowFunction;
<span style="color: #721045;">detachedFunction</span><span style="color: #000000;">()</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Example { arrowFunction: [Function (anonymous)] }</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Example { arrowFunction: [Function (anonymous)] }</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</li>
</ol>
</div>
<div id="outline-container-org6b51ac7" class="outline-4">
<h4 id="org6b51ac7"><span class="section-number-4">8.2.2.</span> Initialization Checking</h4>
<div class="outline-text-4" id="text-8-2-2">
<ul class="org-ul">
<li>如果设置了strict compiler setting enable,那么typescript会check每个被设置为undefined的property
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">WithValue</span> <span style="color: #000000;">{</span>
  immediate = 0;
  later: <span style="color: #531ab6;">number</span>;
  mayBeUndefined: <span style="color: #531ab6;">number</span> | <span style="color: #0000b0;">undefined</span>;

  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:6:3 - error TS2564: Property 'unused' has no initializer and is not definitely assigned in the constructor.</span>

  unused: <span style="color: #531ab6;">number</span>;

  <span style="color: #531ab6;">constructor</span><span style="color: #dd22dd;">()</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">this</span>.later = 1;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>
</pre>
</div></li>
<li>注意如果strict compiler setting没有设置的话,上面的例子是可以编译通过的</li>
</ul></li>
<li>在极端情况下,我们甚至可以通过在property后面加一个 `!` 来disable check.这通常发生在我们很确信在使用
之前我们会通过一个非constructor的方法来初始化这个property
<ul class="org-ul">
<li><p>
示例如下, 我们通过initialize()函数来初始化了pending
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">ActivitiesQueue</span> <span style="color: #000000;">{</span>
  pending!: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">[]</span>;
  <span style="color: #721045;">initialize</span><span style="color: #dd22dd;">(</span><span style="color: #005e8b;">pending</span>: <span style="color: #531ab6;">string</span><span style="color: #008899;">[]</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">this</span>.pending = pending;
  <span style="color: #dd22dd;">}</span>
  <span style="color: #721045;">next</span><span style="color: #dd22dd;">()</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">return</span> <span style="color: #531ab6;">this</span>.pending.<span style="color: #721045;">pop</span><span style="color: #008899;">()</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">activities</span> = <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">ActivitiesQueue</span><span style="color: #000000;">()</span>;

activities.<span style="color: #721045;">initialize</span><span style="color: #000000;">(</span><span style="color: #dd22dd;">[</span><span style="color: #3548cf;">"eat"</span>, <span style="color: #3548cf;">"sleep"</span>, <span style="color: #3548cf;">"learn"</span><span style="color: #dd22dd;">]</span><span style="color: #000000;">)</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>activities.<span style="color: #721045;">next</span><span style="color: #dd22dd;">()</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">learn</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org4674311" class="outline-4">
<h4 id="org4674311"><span class="section-number-4">8.2.3.</span> Optional Properties</h4>
<div class="outline-text-4" id="text-8-2-3">
<ul class="org-ul">
<li>和interface一样,class的property也可以设置为optional的.
<ul class="org-ul">
<li><p>
示例如下,一旦设置为property,那么即便不在constructor里面配置,编译器也不会抱怨
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">MissingInitializer</span> <span style="color: #000000;">{</span>
  proprty?: <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span><span style="color: #531ab6;">new</span> <span style="color: #005f5f;">MissingInitializer</span><span style="color: #dd22dd;">()</span>.proprty?.length<span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">undefined</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:6:13 - error TS2532: Object is possibly 'undefined'.</span>

<span style="color: #7f0000;">///////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">console.</span><span style="color: #721045;">log</span><span style="color: #7f0000;">(new MissingInitializer().proprty.length); //</span>
<span style="color: #7f0000;">///////////////////////////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orga540090" class="outline-4">
<h4 id="orga540090"><span class="section-number-4">8.2.4.</span> Read-Only Properties</h4>
<div class="outline-text-4" id="text-8-2-4">
<ul class="org-ul">
<li>就和interface一样, class里面也能设置某些property为readonly
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">Quote</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">readonly</span> text: <span style="color: #531ab6;">string</span>;

  <span style="color: #531ab6;">constructor</span><span style="color: #dd22dd;">(</span>text: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">this</span>.text = text;
  <span style="color: #dd22dd;">}</span>

  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:9:10 - error TS2540: Cannot assign to 'text' because it is a read-only property.</span>

  <span style="color: #7f0000;">/////////////////////////</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">emphasize() {       //</span>
  <span style="color: #7f0000;">//   </span><span style="color: #7f0000;">this.text += "!"; //</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">}                   //</span>
  <span style="color: #7f0000;">/////////////////////////</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">quote</span> = <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Quote</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Hello"</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:21:7 - error TS2540: Cannot assign to 'text' because it is a read-only property.</span>

<span style="color: #7f0000;">////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">quote.text = 'Ha!" //</span>
<span style="color: #7f0000;">////////////////////////</span>
</pre>
</div></li>
</ul></li>
<li>readonly property只能在如下两个地方初始化:
<ul class="org-ul">
<li>要么是在declare的时候</li>
<li>要么是在constructor里面</li>
</ul></li>
<li>定义为readonly的类型有一个特别特别细节的优化:它们在被typescript infer类型的时候,会尽可能的"严格"
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript">jclass RandomQuote <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">readonly</span> explicit: <span style="color: #531ab6;">string</span> = <span style="color: #3548cf;">"Explicit Original"</span>;
  <span style="color: #531ab6;">readonly</span> implicit = <span style="color: #3548cf;">"Implicit Original"</span>;

  <span style="color: #531ab6;">constructor</span><span style="color: #dd22dd;">()</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">if</span> <span style="color: #008899;">(</span>Math.<span style="color: #721045;">random</span><span style="color: #972500;">()</span> &gt; 0.5<span style="color: #008899;">)</span> <span style="color: #008899;">{</span>
      <span style="color: #531ab6;">this</span>.explicit = <span style="color: #3548cf;">"Explicit New"</span>;
      <span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
      <span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:8:7 - error TS2322: Type '"Implicit New"' is not assignable to type '"Implicit Original"'.</span>

      <span style="color: #7f0000;">////////////////////////////////////</span>
      <span style="color: #7f0000;">// </span><span style="color: #7f0000;">this.implicit = "Implicit New" //</span>
      <span style="color: #7f0000;">////////////////////////////////////</span>
    <span style="color: #008899;">}</span>
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>
</pre>
</div></li>

<li>我们可以看到,如果不加string, implicit直接被infer成了更严格的literal type,也就是"Implicit Original"</li>
<li>只有加了string的explicit才真正获得了string的类型</li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgd995bc4" class="outline-3">
<h3 id="orgd995bc4"><span class="section-number-3">8.3.</span> Classes as Types</h3>
<div class="outline-text-3" id="text-8-3">
<ul class="org-ul">
<li>Class在类型系统里面是比较特殊的,因为一个class declaration会创建两个东西:
<ul class="org-ul">
<li><p>
运行时的值-也就是类本身,可以被实例化(其实本质是一个函数),甚至是直接使用. 比如类的静态属性就是类
本身的值,不需要实例化就可以使用,如下例
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">MathUtils</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">static</span> pi = 3.14159;
  <span style="color: #531ab6;">static</span> <span style="color: #721045;">calculateArea</span><span style="color: #dd22dd;">(</span><span style="color: #005e8b;">radius</span>: <span style="color: #531ab6;">number</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">return</span> MathUtils.pi * radius * radius;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>MathUtils.pi<span style="color: #000000;">)</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>MathUtils.<span style="color: #721045;">calculateArea</span><span style="color: #dd22dd;">(</span>10<span style="color: #dd22dd;">)</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">3.14159</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">314.159</span>
</pre>
</div></li>
<li><p>
同时还是类型系统中的一个类型
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">MathUtils</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">static</span> pi = 3.14159;
  <span style="color: #531ab6;">static</span> <span style="color: #721045;">calculateArea</span><span style="color: #dd22dd;">(</span><span style="color: #005e8b;">radius</span>: <span style="color: #531ab6;">number</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">return</span> MathUtils.pi * radius * radius;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">mathUtils</span>: <span style="color: #005f5f;">MathUtils</span> = <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">MathUtils</span><span style="color: #000000;">()</span>;

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>mathUtils<span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">MathUtils {}</span>
</pre>
</div></li>
</ul></li>
<li>还有一个有意思(但是非常少发生的情况),就是我们如果一个参数是一个class,由于class也可以作为一个type,
那么我们竟然可以传递把一个符合这个type的object(不需要实例化自class).
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">SchoolBus</span> <span style="color: #000000;">{</span>
  <span style="color: #721045;">getAbilities</span><span style="color: #dd22dd;">()</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">return</span> <span style="color: #008899;">[</span><span style="color: #3548cf;">"magic"</span>, <span style="color: #3548cf;">"shapeshifting"</span><span style="color: #008899;">]</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">function</span> <span style="color: #721045;">withSchoolBus</span><span style="color: #000000;">(</span><span style="color: #005e8b;">bus</span>: <span style="color: #005f5f;">SchoolBus</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #dd22dd;">(</span>bus.<span style="color: #721045;">getAbilities</span><span style="color: #008899;">()</span><span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>

<span style="color: #721045;">withSchoolBus</span><span style="color: #000000;">(</span><span style="color: #531ab6;">new</span> <span style="color: #005f5f;">SchoolBus</span><span style="color: #dd22dd;">()</span><span style="color: #000000;">)</span>;

<span style="color: #721045;">withSchoolBus</span><span style="color: #000000;">(</span><span style="color: #dd22dd;">{</span>
  getAbilities: <span style="color: #008899;">()</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #008899;">[</span><span style="color: #3548cf;">"transmogrification"</span><span style="color: #008899;">]</span>,
<span style="color: #dd22dd;">}</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">[ 'magic', 'shapeshifting' ]</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">[ 'transmogrification' ]</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:19:23 - error TS2322: Type 'number' is not assignable to type 'string[]'.</span>

<span style="color: #7f0000;">////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">withSchoolBus({            //</span>
<span style="color: #7f0000;">//                            </span><span style="color: #7f0000;">//</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">getAbilities: () =&gt; 123; //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">});                        //</span>
<span style="color: #7f0000;">////////////////////////////////</span>
</pre>
</div></li>
<li>这么做看起来是把class当做了interface,所以多数情况下是应该使用interface,而不是class</li>
<li>这么做能成功的深层次原因是typescript是"隐式"类型判断(只要你符合shape of object就可以),不需要显式的体现</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org62d7750" class="outline-3">
<h3 id="org62d7750"><span class="section-number-3">8.4.</span> Classes and Interfaces</h3>
<div class="outline-text-3" id="text-8-4">
<ul class="org-ul">
<li><p>
typescript里面当然也支持class和interface最原始的"编程语言定义": 那就是让class implements某个interface,
在编译器通过的情况下,class的instance都可以放在interface声明的位置
</p>
<pre class="example" id="org9e77b38">
Class can implements interfaces, doing so indicates to TypeScript that
instance of the class should be assignable to each of those interfaces
</pre></li>
<li>我们前面说过,interface有两种定义callable function成员的方法: member function和property.如果你想要
class来implements你的interface,那么推荐使用ember function的声明方法,因为class里面的实例化的样子和
interface里面声明的样子是相同的.这样写起来更让人容易理解
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">Learner</span> <span style="color: #000000;">{</span>
  name: <span style="color: #531ab6;">string</span>;
  <span style="color: #721045;">study</span><span style="color: #dd22dd;">(</span><span style="color: #005e8b;">hours</span>: <span style="color: #531ab6;">number</span><span style="color: #dd22dd;">)</span>: <span style="color: #531ab6;">void</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">class</span> <span style="color: #005f5f;">Student</span> <span style="color: #531ab6;">implements</span> <span style="color: #005f5f;">Learner</span> <span style="color: #000000;">{</span>
  name: <span style="color: #531ab6;">string</span>;
  <span style="color: #531ab6;">constructor</span><span style="color: #dd22dd;">(</span>name: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">this</span>.name = name;
  <span style="color: #dd22dd;">}</span>

  <span style="color: #721045;">study</span><span style="color: #dd22dd;">(</span><span style="color: #005e8b;">hours</span>: <span style="color: #531ab6;">number</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">for</span> <span style="color: #008899;">(</span><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">i</span> = 0; i &lt; <span style="color: #005f5f;">hours</span>; <span style="color: #005f5f;">i</span> += 1<span style="color: #008899;">)</span> <span style="color: #008899;">{</span>
      <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #972500;">(</span><span style="color: #3548cf;">"...studying..."</span><span style="color: #972500;">)</span>;
    <span style="color: #008899;">}</span>
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:19:7 - error TS2420: Class 'Slacker' incorrectly implements interface 'Learner'.</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">Property 'study' is missing in type 'Slacker' but required in type 'Learner'.</span>

<span style="color: #7f0000;">////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">class Slacker implements Learner { //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">name = "Rocky";                  //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">}                                  //</span>
<span style="color: #7f0000;">////////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
<li>需要注意的是,class implements interface的情况下, typescript主要是对class内部的成员进行check而已,
并不会自动帮class里面的类型进行infer(特别是从any infer到符合interface的类型).这是由Typescript的立场
决定的: 它主要做类型检查!
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">Learner</span> <span style="color: #000000;">{</span>
  name: <span style="color: #531ab6;">string</span>;
  <span style="color: #721045;">study</span><span style="color: #dd22dd;">(</span><span style="color: #005e8b;">hours</span>: <span style="color: #531ab6;">number</span><span style="color: #dd22dd;">)</span>: <span style="color: #531ab6;">void</span>;
<span style="color: #000000;">}</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:8:9 - error TS7006: Parameter 'hours' implicitly has an 'any' type.</span>

<span style="color: #7f0000;">////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">class Slacker implements Learner { //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">name = "Rocky";                  //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">study(</span><span style="color: #005e8b;">hours</span><span style="color: #7f0000;">) {}                  //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">}                                  //</span>
<span style="color: #7f0000;">////////////////////////////////////////</span>
</pre>
</div></li>
<li>上例中的hours还是any类型,不不会因为implements了Learner而被infer成number类型</li>
</ul></li>
</ul>
</div>
<div id="outline-container-org3c94283" class="outline-4">
<h4 id="org3c94283"><span class="section-number-4">8.4.1.</span> Implementing Multiple Interfaces</h4>
<div class="outline-text-4" id="text-8-4-1">
<ul class="org-ul">
<li><p>
和其他语言一样,TypeScript也允许一个class implements多个interface, 示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">Graded</span> <span style="color: #000000;">{</span>
  grades: <span style="color: #531ab6;">number</span><span style="color: #dd22dd;">[]</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">Reporter</span> <span style="color: #000000;">{</span>
  report: <span style="color: #dd22dd;">()</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">class</span> <span style="color: #005f5f;">ReportCard</span> <span style="color: #531ab6;">implements</span> <span style="color: #005f5f;">Graded</span>, <span style="color: #005f5f;">Reporter</span> <span style="color: #000000;">{</span>
  grades: <span style="color: #531ab6;">number</span><span style="color: #dd22dd;">[]</span>;

  <span style="color: #531ab6;">constructor</span><span style="color: #dd22dd;">(</span>grades: <span style="color: #531ab6;">number</span><span style="color: #008899;">[]</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">this</span>.grades = grades;
  <span style="color: #dd22dd;">}</span>

  <span style="color: #721045;">report</span><span style="color: #dd22dd;">()</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">return</span> <span style="color: #531ab6;">this</span>.grades.<span style="color: #721045;">join</span><span style="color: #008899;">(</span><span style="color: #3548cf;">", "</span><span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:21:7 - error TS2420: Class 'Empty' incorrectly implements interface 'Graded'.</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">Property 'grades' is missing in type 'Empty' but required in type 'Graded'.</span>

<span style="color: #7f0000;">////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">class Empty implements Graded, Reporter {} //</span>
<span style="color: #7f0000;">////////////////////////////////////////////////</span>
</pre>
</div></li>
<li>当然这几个interface要相互"容忍"对方,如果不同interface里面的成员定义相抵触,那么显然同时实现这些interface是不合理的
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">AgeIsANumber</span> <span style="color: #000000;">{</span>
  age: <span style="color: #531ab6;">number</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">AgeIsNotANumber</span> <span style="color: #000000;">{</span>
  age: <span style="color: #dd22dd;">()</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:10:3 - error TS2416: Property 'age' in type 'AsNumber' is not assignable to the same property in base type 'AgeIsNotANumber'.</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">Type 'number' is not assignable to type '() =&gt; string'.</span>

<span style="color: #7f0000;">///////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">class AsNumber implements AgeIsANumber, AgeIsNotANumber { //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">age = 0;                                                //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">}                                                         //</span>
<span style="color: #7f0000;">///////////////////////////////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org1694aaf" class="outline-3">
<h3 id="org1694aaf"><span class="section-number-3">8.5.</span> Extending a Class</h3>
<div class="outline-text-3" id="text-8-5">
<ul class="org-ul">
<li>和其他编程语言一样, class之间可以相互继承.
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">Teacher</span> <span style="color: #000000;">{</span>
  <span style="color: #721045;">teach</span><span style="color: #dd22dd;">()</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #3548cf;">"The surest test of discipline is its absense."</span><span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">class</span> <span style="color: #005f5f;">StudentTeacher</span> <span style="color: #531ab6;">extends</span> <span style="color: #005f5f;">Teacher</span> <span style="color: #000000;">{</span>
  <span style="color: #721045;">learn</span><span style="color: #dd22dd;">()</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #3548cf;">"I cannot afford the luxury of a closed mind."</span><span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">teacher</span> = <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">StudentTeacher</span><span style="color: #000000;">()</span>;
teacher.<span style="color: #721045;">teach</span><span style="color: #000000;">()</span>;
teacher.<span style="color: #721045;">learn</span><span style="color: #000000;">()</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">The surest test of discipline is its absense.</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">I cannot afford the luxury of a closed mind.</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
<div id="outline-container-orga181959" class="outline-4">
<h4 id="orga181959"><span class="section-number-4">8.5.1.</span> Extension Assignability</h4>
<div class="outline-text-4" id="text-8-5-1">
<ul class="org-ul">
<li>subclass extends 一个base class类似于class implements一个interface.那么:
<ul class="org-ul">
<li>由于interface声明的地方,都可以使用implements它的class</li>
<li><p>
那么base class声明的地方,必然可以使用subclass,示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">Lesson</span> <span style="color: #000000;">{</span>
  subject: <span style="color: #531ab6;">string</span>;

  <span style="color: #531ab6;">constructor</span><span style="color: #dd22dd;">(</span>subject: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">this</span>.subject = subject;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">class</span> <span style="color: #005f5f;">OnlineLesson</span> <span style="color: #531ab6;">extends</span> <span style="color: #005f5f;">Lesson</span> <span style="color: #000000;">{</span>
  url: <span style="color: #531ab6;">string</span>;

  <span style="color: #531ab6;">constructor</span><span style="color: #dd22dd;">(</span>subject: <span style="color: #531ab6;">string</span>, url: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">super</span><span style="color: #008899;">(</span>subject<span style="color: #008899;">)</span>;
    <span style="color: #531ab6;">this</span>.url = url;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">lesson</span>: <span style="color: #005f5f;">Lesson</span>;

lesson = <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Lesson</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"coding"</span><span style="color: #000000;">)</span>;
lesson = <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">OnlineLesson</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"coding"</span>, <span style="color: #3548cf;">"oreilly.com"</span><span style="color: #000000;">)</span>;

<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">online</span>: <span style="color: #005f5f;">OnlineLesson</span>;
online = <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">OnlineLesson</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"coding"</span>, <span style="color: #3548cf;">"oreilly.com"</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:26:1 - error TS2741: Property 'url' is missing in type 'Lesson' but required in type 'OnlineLesson'.</span>

<span style="color: #7f0000;">////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">online = new Lesson("coding"); //</span>
<span style="color: #7f0000;">////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
<li>同时,拜Typescript的structural checking(也就是隐式类型检查)所赐,如果subclass没有引入新的memeber(换句
话说,subclass和base的函数和property都一样),那么subclass声明的地方也能放置base class
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">PastGrades</span> <span style="color: #000000;">{</span>
  grades: <span style="color: #531ab6;">number</span><span style="color: #dd22dd;">[]</span> = <span style="color: #dd22dd;">[]</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">class</span> <span style="color: #005f5f;">LabeledPastGrades</span> <span style="color: #531ab6;">extends</span> <span style="color: #005f5f;">PastGrades</span> <span style="color: #000000;">{</span>
  label?: <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">subClass</span>: <span style="color: #005f5f;">LabeledPastGrades</span>;

subClass = <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">LabeledPastGrades</span><span style="color: #000000;">()</span>;
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">this can work because of TypeScript's structural typing!</span>
subClass = <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">PastGrades</span><span style="color: #000000;">()</span>;
</pre>
</div></li>
<li>由于subclass LabeledPastGrades只增加了一个optional property,所以base class竟然可以subclass声明的
地方.</li>
<li>注意!这个例子更多的是介绍Typescript的structural checking带来的副作用,常规代码中,subclass总会带来
"确定性"的不同,不会让base class能否在subclass放置的地方起作用</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org8787823" class="outline-4">
<h4 id="org8787823"><span class="section-number-4">8.5.2.</span> Overriddeng Constructors</h4>
<div class="outline-text-4" id="text-8-5-2">
<ul class="org-ul">
<li>继承其实是需要调用base class的constructor的. TypeScript会帮我们进行这方面的检查,比如:
<ul class="org-ul">
<li><p>
强制要求调用base class的constructor,如果不调用就报错
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">GradeAnnouncer</span> <span style="color: #000000;">{</span>
  message: <span style="color: #531ab6;">string</span>;
  <span style="color: #531ab6;">constructor</span><span style="color: #dd22dd;">(</span>grade: <span style="color: #531ab6;">number</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">this</span>.message = grade &gt;= 65 ? <span style="color: #3548cf;">"You Pass"</span> : <span style="color: #3548cf;">"Maybe next time"</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">class</span> <span style="color: #005f5f;">PassingAnnouncer</span> <span style="color: #531ab6;">extends</span> <span style="color: #005f5f;">GradeAnnouncer</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">constructor</span><span style="color: #dd22dd;">()</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">super</span><span style="color: #008899;">(</span>100<span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:15:3 - error TS2377: Constructors for derived classes must contain a 'super' call.</span>

<span style="color: #7f0000;">//////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">class FaillingAnnouncer extends GradeAnnouncer { //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">constructor() {}                               //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">}                                                //</span>
<span style="color: #7f0000;">//////////////////////////////////////////////////////</span>
</pre>
</div></li>
<li><p>
subclass 如果调用constructor(下面的例子中不调用constructor就没事)需要调用base class的constructor
(通过super)之后,才能使用this,如果顺序不对,就报错
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">GradesTally</span> <span style="color: #000000;">{</span>
  grades: <span style="color: #531ab6;">number</span><span style="color: #dd22dd;">[]</span> = <span style="color: #dd22dd;">[]</span>;
  <span style="color: #721045;">addGrades</span><span style="color: #dd22dd;">(</span>...<span style="color: #005e8b;">grades</span>: <span style="color: #531ab6;">number</span><span style="color: #008899;">[]</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">this</span>.grades.<span style="color: #721045;">push</span><span style="color: #008899;">(</span>...grades<span style="color: #008899;">)</span>;
    <span style="color: #531ab6;">return</span> <span style="color: #531ab6;">this</span>.grades.length;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">class</span> <span style="color: #005f5f;">ContinueGradesTally</span> <span style="color: #531ab6;">extends</span> <span style="color: #005f5f;">GradesTally</span> <span style="color: #000000;">{</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:11:5 - error TS17009: 'super' must be called before accessing 'this' in the constructor of a derived class.</span>
  <span style="color: #7f0000;">////////////////////////////////////////////////////////////////</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">constructor(</span><span style="color: #005e8b;">previousGrades</span><span style="color: #7f0000;">: number[]) {                    //</span>
  <span style="color: #7f0000;">//   </span><span style="color: #7f0000;">this.grades = [...previousGrades];                       //</span>
  <span style="color: #7f0000;">//   </span><span style="color: #7f0000;">super();                                                 //</span>
  <span style="color: #7f0000;">//   </span><span style="color: #7f0000;">console.</span><span style="color: #721045;">log</span><span style="color: #7f0000;">("Starting with length", this.grades.length); //</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">}                                                          //</span>
  <span style="color: #7f0000;">////////////////////////////////////////////////////////////////</span>
<span style="color: #000000;">}</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org0eeb311" class="outline-4">
<h4 id="org0eeb311"><span class="section-number-4">8.5.3.</span> Overridden Methods</h4>
<div class="outline-text-4" id="text-8-5-3">
<ul class="org-ul">
<li>subclass可以redeclare base class的同名函数,只要新的类型是assignable给老类型的(所谓assignable我们之
前在函数重载部分讲到过,大意就是对应类型可以不存在,但是有必须类型相同).
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">GradeCounter</span> <span style="color: #000000;">{</span>
  <span style="color: #721045;">countGrades</span><span style="color: #dd22dd;">(</span><span style="color: #005e8b;">grades</span>: <span style="color: #531ab6;">string</span><span style="color: #008899;">[]</span>, <span style="color: #005e8b;">letter</span>: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">return</span> grades.<span style="color: #721045;">filter</span><span style="color: #008899;">(</span><span style="color: #972500;">(</span>grade<span style="color: #972500;">)</span> <span style="color: #531ab6;">=&gt;</span> grade === letter<span style="color: #008899;">)</span>.length;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">class</span> <span style="color: #005f5f;">FailureCounter</span> <span style="color: #531ab6;">extends</span> <span style="color: #005f5f;">GradeCounter</span> <span style="color: #000000;">{</span>
  <span style="color: #721045;">countGrades</span><span style="color: #dd22dd;">(</span><span style="color: #005e8b;">grades</span>: <span style="color: #531ab6;">string</span><span style="color: #008899;">[]</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">return</span> <span style="color: #531ab6;">super</span>.<span style="color: #721045;">countGrades</span><span style="color: #008899;">(</span>grades, <span style="color: #3548cf;">"F"</span><span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:14:3 - error TS2416: Property 'countGrades' in type 'AnyFailureChecker' is not assignable to the same property in base type 'GradeCounter'.</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">Type '(grades: string[]) =&gt; boolean' is not assignable to type '(grades: string[], letter: string) =&gt; number'.</span>
<span style="color: #7f0000;">//     </span><span style="color: #7f0000;">Type 'boolean' is not assignable to type 'number'.</span>

<span style="color: #7f0000;">//////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">class AnyFailureChecker extends GradeCounter {   //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">countGrades(</span><span style="color: #005e8b;">grades</span><span style="color: #7f0000;">: string[]) {                //</span>
<span style="color: #7f0000;">//     </span><span style="color: #7f0000;">return super.</span><span style="color: #721045;">countGrades</span><span style="color: #7f0000;">(grades, "F") !== 0; //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">}                                              //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">}                                                //</span>
<span style="color: #7f0000;">//////////////////////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgac8d716" class="outline-4">
<h4 id="orgac8d716"><span class="section-number-4">8.5.4.</span> Overridden Properties</h4>
<div class="outline-text-4" id="text-8-5-4">
<ul class="org-ul">
<li>既然能够重载method,那么重载property也是非常正常的.</li>
<li>重载property类型一定能够assignable, 对于property来说,assiable一般意味着更加specific的类型,比如union
type中少一些类型
<ul class="org-ul">
<li><p>
示例如下, 类型从头string | undefined, 变成了string,更specific
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">Assignment</span> <span style="color: #000000;">{</span>
  grade?: <span style="color: #531ab6;">number</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">class</span> <span style="color: #005f5f;">GradeAssignment</span> <span style="color: #531ab6;">extends</span> <span style="color: #005f5f;">Assignment</span> <span style="color: #000000;">{</span>
  grade: <span style="color: #531ab6;">number</span>;

  <span style="color: #531ab6;">constructor</span><span style="color: #dd22dd;">(</span>grade: <span style="color: #531ab6;">number</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">super</span><span style="color: #008899;">()</span>;
    <span style="color: #531ab6;">this</span>.grade = grade;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>
</pre>
</div></li>
</ul></li>
<li>相反,如果我们在继承的时候,expand了我们property的union type,那么是会报错的,原因很简单,我们没办法把一
个可能性更广的subclass值给base class,因为代码是根据base class来写的,根本没考虑到新增的类型.
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">NumericGrade</span> <span style="color: #000000;">{</span>
  value = 0;
<span style="color: #000000;">}</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:6:3 - error TS2416: Property 'value' in type 'VagueGrade' is not assignable to the same property in base type 'NumericGrade'.</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">Type 'string | number' is not assignable to type 'number'.</span>
<span style="color: #7f0000;">//     </span><span style="color: #7f0000;">Type 'string' is not assignable to type 'number'.</span>

<span style="color: #7f0000;">////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">class VagueGrade extends NumericGrade {    //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">value = Math.</span><span style="color: #721045;">random</span><span style="color: #7f0000;">() &gt; 0.5 ? 1 : "..."; //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">}                                          //</span>
<span style="color: #7f0000;">////////////////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgd00e261" class="outline-3">
<h3 id="orgd00e261"><span class="section-number-3">8.6.</span> Abstract Classes</h3>
<div class="outline-text-3" id="text-8-6">
<ul class="org-ul">
<li>有时候我们希望创建一个base class,它的部分method是没有implementation的(换言之,其他部分都提供了实现),
而是希望subclass来实现这部分method
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">abstract</span> <span style="color: #531ab6;">class</span> <span style="color: #005f5f;">School</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">readonly</span> name: <span style="color: #531ab6;">string</span>;
  <span style="color: #531ab6;">constructor</span><span style="color: #dd22dd;">(</span>name: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">this</span>.name = name;
  <span style="color: #dd22dd;">}</span>

  <span style="color: #531ab6;">abstract</span> <span style="color: #721045;">getStudentTypes</span><span style="color: #dd22dd;">()</span>: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">[]</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">class</span> <span style="color: #005f5f;">Preschool</span> <span style="color: #531ab6;">extends</span> <span style="color: #005f5f;">School</span> <span style="color: #000000;">{</span>
  <span style="color: #721045;">getStudentTypes</span><span style="color: #dd22dd;">()</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">return</span> <span style="color: #008899;">[</span><span style="color: #3548cf;">"preschooler"</span><span style="color: #008899;">]</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:16:7 - error TS18052: Non-abstract class 'Absence' does not implement all abstract members of 'School'</span>

<span style="color: #7f0000;">/////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">class Absence extends School {} //</span>
<span style="color: #7f0000;">/////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
<li>由于abstract class缺少某些method的实现,所以abstract class是不能初始化的.
<ul class="org-ul">
<li><p>
试图初始化一个abstrct class会报错
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">abstract</span> <span style="color: #531ab6;">class</span> <span style="color: #005f5f;">School</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">readonly</span> name: <span style="color: #531ab6;">string</span>;
  <span style="color: #531ab6;">constructor</span><span style="color: #dd22dd;">(</span>name: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">this</span>.name = name;
  <span style="color: #dd22dd;">}</span>

  <span style="color: #531ab6;">abstract</span> <span style="color: #721045;">getStudentTypes</span><span style="color: #dd22dd;">()</span>: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">[]</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">class</span> <span style="color: #005f5f;">Preschool</span> <span style="color: #531ab6;">extends</span> <span style="color: #005f5f;">School</span> <span style="color: #000000;">{</span>
  <span style="color: #721045;">getStudentTypes</span><span style="color: #dd22dd;">()</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">return</span> <span style="color: #008899;">[</span><span style="color: #3548cf;">"preschooler"</span><span style="color: #008899;">]</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">school</span>: <span style="color: #005f5f;">School</span>;
school = <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Preschool</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Sunnyside Daycare"</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:19:10 - error TS2511: Cannot create an instance of an abstract class.</span>

<span style="color: #7f0000;">////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">school = new School("somewhere else"); //</span>
<span style="color: #7f0000;">////////////////////////////////////////////</span>
</pre>
</div></li>

<li>abstract class通常应用于framework: 实现了部分细节,但是留给用户来实现剩下的细节.同时我还能使用abstract
class来在需要的地方只用abstract class类型的变量站位(比如上面例子中的school: School)</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org0e8b002" class="outline-3">
<h3 id="org0e8b002"><span class="section-number-3">8.7.</span> Member Visibility</h3>
<div class="outline-text-3" id="text-8-7">
<ul class="org-ul">
<li>JavaScript引入了`#`关键字来表示某个class的member是private的
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #531ab6;">class</span> Person <span style="color: #000000;">{</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#31169;&#26377;&#23383;&#27573;</span>
  #name;

  constructor<span style="color: #dd22dd;">(</span>name<span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #0000b0;">this</span>.#name = name; <span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#21482;&#33021;&#22312;&#31867;&#20869;&#37096;&#35775;&#38382;</span>
  <span style="color: #dd22dd;">}</span>

  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#20844;&#20849;&#26041;&#27861;&#65292;&#29992;&#20110;&#35775;&#38382;&#31169;&#26377;&#23383;&#27573;</span>
  getName<span style="color: #dd22dd;">()</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">return</span> <span style="color: #0000b0;">this</span>.#name;
  <span style="color: #dd22dd;">}</span>

  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#20844;&#20849;&#26041;&#27861;&#65292;&#29992;&#20110;&#20462;&#25913;&#31169;&#26377;&#23383;&#27573;</span>
  setName<span style="color: #dd22dd;">(</span>newName<span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #0000b0;">this</span>.#name = newName;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">person</span> = <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Person</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Alice"</span><span style="color: #000000;">)</span>;

console.log<span style="color: #000000;">(</span>person.getName<span style="color: #dd22dd;">()</span><span style="color: #000000;">)</span>; <span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#36755;&#20986;: Alice</span>
person.setName<span style="color: #000000;">(</span><span style="color: #3548cf;">"Bob"</span><span style="color: #000000;">)</span>;
console.log<span style="color: #000000;">(</span>person.getName<span style="color: #dd22dd;">()</span><span style="color: #000000;">)</span>; <span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#36755;&#20986;: Bob</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Alice</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Bob</span>


<span style="color: #7f0000;">// </span><span style="color: #7f0000;">SyntaxError: Private field '#name' must be declared in an enclosing class</span>
<span style="color: #7f0000;">////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">console.log(person.#name); //</span>
<span style="color: #7f0000;">////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
<li>Typescript当然支持`#`关键字,但是它同时引入了和其他编程语言类似的三级visibility系统,关键字分别是:
<ul class="org-ul">
<li>public (default): 允许任何人访问</li>
<li>protected: 只有class和其他subclas可以访问</li>
<li>private: 只有class自己可以访问</li>
</ul></li>
<li>注意,这些关键字只是在type system里面起作用,转换为javascript的时候,就被去掉了
<ul class="org-ul">
<li><p>
我们来看一个包括这些关键字的例子
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">Base</span> <span style="color: #000000;">{</span>
  isPublicImplicit = 0;
  <span style="color: #531ab6;">public</span> isPublicExplicit = 1;
  <span style="color: #531ab6;">protected</span> isProtected = 2;
  <span style="color: #531ab6;">private</span> isPrivate = 3;
  #truePrivate = 4;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">class</span> <span style="color: #005f5f;">Subclass</span> <span style="color: #531ab6;">extends</span> <span style="color: #005f5f;">Base</span> <span style="color: #000000;">{</span>
  <span style="color: #721045;">examples</span><span style="color: #dd22dd;">()</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #531ab6;">this</span>.isPublicImplicit<span style="color: #008899;">)</span>;
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #531ab6;">this</span>.isPublicExplicit<span style="color: #008899;">)</span>;
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #531ab6;">this</span>.isProtected<span style="color: #008899;">)</span>;

    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:15:10 - error TS2341: Property 'isPrivate' is private and only accessible within class 'Base'.</span>

    <span style="color: #7f0000;">/////////////////////</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">this.isPrivate; //</span>
    <span style="color: #7f0000;">/////////////////////</span>

    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:21:10 - error TS18013: Property '#truePrivate' is not accessible outside class 'Base' because it has a private identifier.</span>

    <span style="color: #7f0000;">////////////////////////</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">this.#truePrivate; //</span>
    <span style="color: #7f0000;">////////////////////////</span>
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Subclass</span><span style="color: #000000;">()</span>.isPublicImplicit;
<span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Subclass</span><span style="color: #000000;">()</span>.isPublicExplicit;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:33:16 - error TS2445: Property 'isProtected' is protected and only accessible within class 'Base' and its subclasses.</span>

<span style="color: #7f0000;">/////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">new Subclass().isProtected; //</span>
<span style="color: #7f0000;">/////////////////////////////////</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:41:16 - error TS2341: Property 'isPrivate' is private and only accessible within class 'Base'.</span>

<span style="color: #7f0000;">///////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">new Subclass().isPrivate; //</span>
<span style="color: #7f0000;">///////////////////////////////</span>

<span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Subclass</span><span style="color: #000000;">()</span>.<span style="color: #721045;">examples</span><span style="color: #000000;">()</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">0</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">1</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">2</span>
</pre>
</div></li>
</ul></li>

<li>visibility modifier 可以和readonly一起使用, visibility modifier在前, readonly在后
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">TwoKeywords</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">private</span> <span style="color: #531ab6;">readonly</span> name: <span style="color: #531ab6;">string</span>;

  <span style="color: #531ab6;">constructor</span><span style="color: #dd22dd;">()</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">this</span>.name = <span style="color: #3548cf;">"Anne Sullivan"</span>;
  <span style="color: #dd22dd;">}</span>

  <span style="color: #721045;">log</span><span style="color: #dd22dd;">()</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #531ab6;">this</span>.name<span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">two</span> = <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">TwoKeywords</span><span style="color: #000000;">()</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:15:5 - error TS2341: Property 'name' is private and only accessible within class 'TwoKeywords'.</span>

<span style="color: #7f0000;">////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">two.name = "Savitribai Phule"; //</span>
<span style="color: #7f0000;">////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
<div id="outline-container-org3f48ca1" class="outline-4">
<h4 id="org3f48ca1"><span class="section-number-4">8.7.1.</span> Static Field Modifiers</h4>
<div class="outline-text-4" id="text-8-7-1">
<ul class="org-ul">
<li>javascript的static关键字用来表示某个member是class的,而不是instance的</li>
<li>TypeScript是支持这个关键字的,而且支持这个关键字和readonly一起使用.
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">Question</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">protected</span> <span style="color: #531ab6;">static</span> <span style="color: #531ab6;">readonly</span> answer: <span style="color: #3548cf;">"bash"</span>;
  <span style="color: #531ab6;">protected</span> <span style="color: #531ab6;">static</span> <span style="color: #531ab6;">readonly</span> prompt =
    <span style="color: #3548cf;">"What's an ogre's favorite programming language?"</span>;

  <span style="color: #721045;">guess</span><span style="color: #dd22dd;">(</span><span style="color: #005e8b;">getAnswer</span>: <span style="color: #008899;">(</span><span style="color: #005e8b;">prompt</span>: <span style="color: #531ab6;">string</span><span style="color: #008899;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">const</span> <span style="color: #005e8b;">answer</span> = <span style="color: #721045;">getAnswer</span><span style="color: #008899;">(</span>Question.prompt<span style="color: #008899;">)</span>;

    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">Ok</span>
    <span style="color: #531ab6;">if</span> <span style="color: #008899;">(</span>answer === Question.answer<span style="color: #008899;">)</span> <span style="color: #008899;">{</span>
      <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #972500;">(</span><span style="color: #3548cf;">"You got it!"</span><span style="color: #972500;">)</span>;
    <span style="color: #008899;">}</span> <span style="color: #531ab6;">else</span> <span style="color: #008899;">{</span>
      <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #972500;">(</span><span style="color: #3548cf;">"Try again..."</span><span style="color: #972500;">)</span>;
    <span style="color: #008899;">}</span>
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:19:22 - error TS2445: Property 'answer' is protected and only accessible within class 'Question' and its subclasses.</span>

<span style="color: #7f0000;">//////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">console.</span><span style="color: #721045;">log</span><span style="color: #7f0000;">(Question.answer) //</span>
<span style="color: #7f0000;">//////////////////////////////////</span>
</pre>
</div></li>
<li>从上面的例子来看,不同关键字放置的顺序是:
<ol class="org-ol">
<li>visibility modifier</li>
<li>static</li>
<li>readonly</li>
</ol></li>
</ul></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-orge68ed46" class="outline-2">
<h2 id="orge68ed46"><span class="section-number-2">9.</span> Chapter 9: Type Modifiers</h2>
<div class="outline-text-2" id="text-9">
</div>
<div id="outline-container-org597d9a5" class="outline-3">
<h3 id="org597d9a5"><span class="section-number-3">9.1.</span> Top Types</h3>
<div class="outline-text-3" id="text-9-1">
</div>
<div id="outline-container-org6a83986" class="outline-4">
<h4 id="org6a83986"><span class="section-number-4">9.1.1.</span> any, Again</h4>
<div class="outline-text-4" id="text-9-1-1">
<ul class="org-ul">
<li>any类型可以作为top type,所谓top type是指提供一个location来放置任意类型</li>
<li>any一般放置的位置是那些所有类型都可以放置的位置,比如console.log</li>
<li>any的问题是,它其实是告诉TypeScript不要再做类型检查了,这样做降低了TypeScript的作用
<ul class="org-ul">
<li><p>
示例如下,下面的代码,在把一个对象赋值给string的时候,TypeScript本来可以报错的,但是由于name定义成了
any类型,所以TypeScript也就不进行检查了
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">greetComedian</span><span style="color: #000000;">(</span><span style="color: #005e8b;">name</span>: <span style="color: #531ab6;">any</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">`Announcing </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">name.toUpperCase()</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>

<span style="color: #721045;">greetComedian</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Bea Arthur"</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Announcing BEA ARTHUR</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TypeError: name.toUpperCase is not a function</span>

<span style="color: #7f0000;">////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">greetComedian({ name: "Bea Arthur" }); //</span>
<span style="color: #7f0000;">////////////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org7f7915a" class="outline-4">
<h4 id="org7f7915a"><span class="section-number-4">9.1.2.</span> unknown</h4>
<div class="outline-text-4" id="text-9-1-2">
<ul class="org-ul">
<li><p>
any的危害我们已经看到了,其实TypeScript真正希望你使用的top type是unknown,而不是any
</p>
<pre class="example" id="org02d719f">
You should generally prefer using unknown instead of any when possible
</pre></li>
<li>unknown初看起来非常的严格:
<ul class="org-ul">
<li><p>
不允许直接访问unknown(经过value narrow后就可以了哈,否则没法使用了)
</p>
<div class="org-src-container">
<pre class="src src-typescript"> <span style="color: #531ab6;">function</span> <span style="color: #721045;">greetComedian</span><span style="color: #000000;">(</span><span style="color: #005e8b;">name</span>: <span style="color: #531ab6;">unknown</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:2:29 - error TS18046: 'name' is of type 'unknown'.</span>
  <span style="color: #7f0000;">/////////////////////////////////////////////////////////</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">console.</span><span style="color: #721045;">log</span><span style="color: #7f0000;">(`Announcing ${name.</span><span style="color: #721045;">toUpperCase</span><span style="color: #7f0000;">()} !`);  //</span>
  <span style="color: #7f0000;">/////////////////////////////////////////////////////////</span>
<span style="color: #000000;">}</span>
</pre>
</div></li>
<li>unknown只允许被赋值为top type(any或者unknown)</li>
</ul></li>
<li>我们只有通过typeof或者instanceof进行了type narrow之后,我们就可以使用unknown了
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">greetComedianSafety</span><span style="color: #000000;">(</span><span style="color: #005e8b;">name</span>: <span style="color: #531ab6;">unknown</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">if</span> <span style="color: #dd22dd;">(</span><span style="color: #531ab6;">typeof</span> name === <span style="color: #3548cf;">"string"</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #3548cf;">`Announcing </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">name.toUpperCase()</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;"> !`</span><span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span> <span style="color: #531ab6;">else</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #3548cf;">"Well, I'm off."</span><span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #721045;">greetComedianSafety</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Betty White"</span><span style="color: #000000;">)</span>;
<span style="color: #721045;">greetComedianSafety</span><span style="color: #000000;">(</span><span style="color: #dd22dd;">{}</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Announcing BETTY WHITE !</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Well, I'm off.</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org038ec38" class="outline-3">
<h3 id="org038ec38"><span class="section-number-3">9.2.</span> Type Prddicates</h3>
<div class="outline-text-3" id="text-9-2">
<ul class="org-ul">
<li>前面我们知道了,如果使用了unknown,那么必须和typeof和instanceof来确定真实的类型,然后进行操作
<ul class="org-ul">
<li><p>
下面就是这样一个例子.
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">isNumberOrString</span><span style="color: #000000;">(</span><span style="color: #005e8b;">value</span>: <span style="color: #531ab6;">unknown</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> <span style="color: #dd22dd;">[</span><span style="color: #3548cf;">"number"</span>, <span style="color: #3548cf;">"string"</span><span style="color: #dd22dd;">]</span>.<span style="color: #721045;">includes</span><span style="color: #dd22dd;">(</span><span style="color: #531ab6;">typeof</span> value<span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">function</span> <span style="color: #721045;">logValueIfExists</span><span style="color: #000000;">(</span><span style="color: #005e8b;">value</span>: <span style="color: #531ab6;">number</span> | <span style="color: #531ab6;">string</span> | <span style="color: #0000b0;">null</span> | <span style="color: #0000b0;">undefined</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">if</span> <span style="color: #dd22dd;">(</span><span style="color: #721045;">isNumberOrString</span><span style="color: #008899;">(</span>value<span style="color: #008899;">)</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:7:5 - error TS18049: 'value' is possibly 'null' or 'undefined'.</span>

    <span style="color: #7f0000;">///////////////////////</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">value.</span><span style="color: #721045;">toString</span><span style="color: #7f0000;">(); //</span>
    <span style="color: #7f0000;">///////////////////////</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #3548cf;">"string"</span><span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span> <span style="color: #531ab6;">else</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #3548cf;">"value does not exist"</span><span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>
</pre>
</div></li>
<li>这个例子中的isNumberOrString只是返回了boolean,但是Typescript编译器并不知道value的类型是什么,所以无法调用toString</li>
</ul></li>
<li>那么有没有那么一种特性,能在返回boolean的同时,还能给Typescript编译器捎句话,告诉他参数是什么类型呢?
(unkown是非常合适的场景,因为用户创建的时候压根没写,也没法infer)
<ul class="org-ul">
<li><p>
答案是有的,就是所谓的type predicates,其原型如下
</p>
<pre class="example" id="org4565a2d">
function typePredicate(input: WideType): input is NarrowType;
</pre></li>
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">isNumberOrString</span><span style="color: #000000;">(</span><span style="color: #005e8b;">value</span>: <span style="color: #531ab6;">unknown</span><span style="color: #000000;">)</span>: value is <span style="color: #531ab6;">number</span> | <span style="color: #531ab6;">string</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> <span style="color: #dd22dd;">[</span><span style="color: #3548cf;">"number"</span>, <span style="color: #3548cf;">"string"</span><span style="color: #dd22dd;">]</span>.<span style="color: #721045;">includes</span><span style="color: #dd22dd;">(</span><span style="color: #531ab6;">typeof</span> value<span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">function</span> <span style="color: #721045;">logValueIfExists</span><span style="color: #000000;">(</span><span style="color: #005e8b;">value</span>: <span style="color: #531ab6;">number</span> | <span style="color: #531ab6;">string</span> | <span style="color: #0000b0;">null</span> | <span style="color: #0000b0;">undefined</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">if</span> <span style="color: #dd22dd;">(</span><span style="color: #721045;">isNumberOrString</span><span style="color: #008899;">(</span>value<span style="color: #008899;">)</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #3548cf;">`toString(): </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">value.toString()</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span> <span style="color: #531ab6;">else</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #3548cf;">"value does not exist:"</span>, value<span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #721045;">logValueIfExists</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"abc"</span><span style="color: #000000;">)</span>;
<span style="color: #721045;">logValueIfExists</span><span style="color: #000000;">(</span>123<span style="color: #000000;">)</span>;
<span style="color: #721045;">logValueIfExists</span><span style="color: #000000;">(</span><span style="color: #0000b0;">undefined</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">toString(): abc</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">toString(): 123</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">value does not exist: undefined</span>
</pre>
</div></li>
<li>上例会告诉Typescript:在返回为true的情况下, value的类型是number | string</li>
</ul></li>
<li>除了unknown以外,还有一个type predicate应用的场景是把interface给narrow成更加specific的interface
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">Comedian</span> <span style="color: #000000;">{</span>
  funny: <span style="color: #531ab6;">boolean</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">StandupComedian</span> <span style="color: #531ab6;">extends</span> <span style="color: #005f5f;">Comedian</span> <span style="color: #000000;">{</span>
  routine: <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">function</span> <span style="color: #721045;">isStandupComedian</span><span style="color: #000000;">(</span><span style="color: #005e8b;">value</span>: <span style="color: #005f5f;">Comedian</span><span style="color: #000000;">)</span>: <span style="color: #005e8b;">value</span> <span style="color: #531ab6;">is</span> <span style="color: #005f5f;">StandupComedian</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> <span style="color: #3548cf;">"routine"</span> <span style="color: #531ab6;">in</span> value;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">function</span> <span style="color: #721045;">workWithComedian</span><span style="color: #000000;">(</span><span style="color: #005e8b;">value</span>: <span style="color: #005f5f;">Comedian</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">if</span> <span style="color: #dd22dd;">(</span><span style="color: #721045;">isStandupComedian</span><span style="color: #008899;">(</span>value<span style="color: #008899;">)</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span>value.routine<span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span>

  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:18:21 - error TS2339: Property 'routine' does not exist on type 'Comedian'.</span>

  <span style="color: #7f0000;">/////////////////////////////////</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">console.</span><span style="color: #721045;">log</span><span style="color: #7f0000;">(value.routine); //</span>
  <span style="color: #7f0000;">/////////////////////////////////</span>
<span style="color: #000000;">}</span>
</pre>
</div></li>
<li>我们可以看到,在isStandupComedian返回true的情况下,Typescript就知道value是更加specifi的StandupComedian,
所以可以调用其routine成员</li>
</ul></li>
<li>Typescript如此精密,其不仅仅在type predicate的true case里面知道类型为更specific值,还会再false case里
面自动判断出"原始类型-specific类型"剩下的类型
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">isLongString</span><span style="color: #000000;">(</span><span style="color: #005e8b;">input</span>: <span style="color: #531ab6;">string</span> | <span style="color: #0000b0;">undefined</span><span style="color: #000000;">)</span>: input is <span style="color: #531ab6;">string</span> <span style="color: #000000;">{</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">!! &#26159;&#19968;&#20010;&#21452;&#21542;&#23450;&#25805;&#20316;&#31526;&#65292;&#23427;&#23558;&#34920;&#36798;&#24335;&#36716;&#25442;&#20026;&#24067;&#23572;&#20540;&#12290;&#36890;&#24120;&#29992;&#20110;&#30830;&#20445;&#36820;&#22238;&#30340;&#26159; true &#25110; false</span>
  <span style="color: #531ab6;">return</span> !!<span style="color: #dd22dd;">(</span>input &amp;&amp; input.length &gt;= 7<span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">function</span> <span style="color: #721045;">workWithText</span><span style="color: #000000;">(</span><span style="color: #005e8b;">text</span>: <span style="color: #531ab6;">string</span> | <span style="color: #0000b0;">undefined</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">if</span> <span style="color: #dd22dd;">(</span><span style="color: #721045;">isLongString</span><span style="color: #008899;">(</span>text<span style="color: #008899;">)</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #3548cf;">"Long Text: "</span>, text.length<span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span> <span style="color: #531ab6;">else</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:10:32 - error TS18048: 'text' is possibly 'undefined'.</span>
    <span style="color: #7f0000;">//////////////////////////////////////////////</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">console.</span><span style="color: #721045;">log</span><span style="color: #7f0000;">("Short Text:", text.length); //</span>
    <span style="color: #7f0000;">//////////////////////////////////////////////</span>
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>
</pre>
</div></li>

<li><p>
上例中的false case中,Typescript知道如果为true case是string,那么false case就是undefined了,因为
</p>
<pre class="example" id="org379ad07">
string | undefined - string = undefined
</pre></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org6227ac7" class="outline-3">
<h3 id="org6227ac7"><span class="section-number-3">9.3.</span> Type Operators</h3>
<div class="outline-text-3" id="text-9-3">
</div>
<div id="outline-container-org32b9631" class="outline-4">
<h4 id="org32b9631"><span class="section-number-4">9.3.1.</span> keyof</h4>
<div class="outline-text-4" id="text-9-3-1">
<ul class="org-ul">
<li>Javascript object的访问,可以在`[]`里面传入一个字符串(通常来说是字符串,但是也可以是其他类型,比如数组就是传入整型number)
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">obj</span> = <span style="color: #000000;">{</span>
  hello: <span style="color: #3548cf;">"world"</span>,
<span style="color: #000000;">}</span>;
console.log<span style="color: #000000;">(</span>obj<span style="color: #dd22dd;">[</span><span style="color: #3548cf;">"hello"</span><span style="color: #dd22dd;">]</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">world</span>
</pre>
</div></li>
</ul></li>
<li>Typescript里面,如果想传入object的这个key,那么最先想到的是把key声明为stirng类型,但是我们会看到,这样
口子开太大了,不存在的字符串也可以传递进来. 所以编译不成功
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">Ratings</span> <span style="color: #000000;">{</span>
  audience: <span style="color: #531ab6;">number</span>;
  critics: <span style="color: #531ab6;">number</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">function</span> <span style="color: #721045;">getRating</span><span style="color: #000000;">(</span><span style="color: #005e8b;">ratings</span>: <span style="color: #005f5f;">Ratings</span>, <span style="color: #005e8b;">key</span>: <span style="color: #531ab6;">string</span><span style="color: #000000;">)</span>: <span style="color: #531ab6;">number</span> <span style="color: #000000;">{</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:7:10 - error TS7053: Element implicitly has an 'any' type because expression of type 'string' can't be used to index type 'Ratings'.</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">No index signature with a parameter of type 'string' was found on type 'Ratings'.</span>

  <span style="color: #7f0000;">//////////////////////////</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">return ratings[key]; //</span>
  <span style="color: #7f0000;">//////////////////////////</span>
  <span style="color: #531ab6;">return</span> 1;
<span style="color: #000000;">}</span>
</pre>
</div></li>
<li><p>
从编译报错来看,我们最容易的改动方法,就是使用union of literal (使用那些允许的key)
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">Ratings</span> <span style="color: #000000;">{</span>
  audience: <span style="color: #531ab6;">number</span>;
  critics: <span style="color: #531ab6;">number</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">function</span> <span style="color: #721045;">getRating</span><span style="color: #000000;">(</span><span style="color: #005e8b;">ratings</span>: <span style="color: #005f5f;">Ratings</span>, <span style="color: #005e8b;">key</span>: <span style="color: #3548cf;">"audience"</span> | <span style="color: #3548cf;">"critics"</span><span style="color: #000000;">)</span>: <span style="color: #531ab6;">number</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> ratings<span style="color: #dd22dd;">[</span>key<span style="color: #dd22dd;">]</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">ratings</span>: <span style="color: #005f5f;">Ratings</span> = <span style="color: #000000;">{</span> audience: 66, critics: 86 <span style="color: #000000;">}</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span><span style="color: #721045;">getRating</span><span style="color: #dd22dd;">(</span>ratings, <span style="color: #3548cf;">"audience"</span><span style="color: #dd22dd;">)</span><span style="color: #000000;">)</span>;


<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:13:32 - error TS2345: Argument of type '"not valid"' is not assignable to parameter of type '"audience" | "critics"'.</span>

<span style="color: #7f0000;">///////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">console.</span><span style="color: #721045;">log</span><span style="color: #7f0000;">(getRating(ratings, "not valid")); //</span>
<span style="color: #7f0000;">///////////////////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
<li>union of literal的问题,是如果合理的literal有成千上万个,那么我们就不可能一一列出来,所以Typescript发明了一个语法糖来返回union of all the keys allowed on the type
<ul class="org-ul">
<li><p>
示例代码如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">Ratings</span> <span style="color: #000000;">{</span>
  audience: <span style="color: #531ab6;">number</span>;
  critics: <span style="color: #531ab6;">number</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">function</span> <span style="color: #721045;">getRating</span><span style="color: #000000;">(</span><span style="color: #005e8b;">ratings</span>: <span style="color: #005f5f;">Ratings</span>, <span style="color: #005e8b;">key</span>: <span style="color: #531ab6;">keyof</span> Ratings<span style="color: #000000;">)</span>: <span style="color: #531ab6;">number</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> ratings<span style="color: #dd22dd;">[</span>key<span style="color: #dd22dd;">]</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">ratings</span>: <span style="color: #005f5f;">Ratings</span> = <span style="color: #000000;">{</span> audience: 66, critics: 86 <span style="color: #000000;">}</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span><span style="color: #721045;">getRating</span><span style="color: #dd22dd;">(</span>ratings, <span style="color: #3548cf;">"audience"</span><span style="color: #dd22dd;">)</span><span style="color: #000000;">)</span>;


<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:13:32 - error TS2345: Argument of type '"not valid"' is not assignable to parameter of type '"audience" | "critics"'.</span>

<span style="color: #7f0000;">///////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">console.</span><span style="color: #721045;">log</span><span style="color: #7f0000;">(getRating(ratings, "not valid")); //</span>
<span style="color: #7f0000;">///////////////////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org85df7dc" class="outline-4">
<h4 id="org85df7dc"><span class="section-number-4">9.3.2.</span> typeof</h4>
<div class="outline-text-4" id="text-9-3-2">
<ul class="org-ul">
<li>有些情况下,某些value的type是非常难以书写的(或者手写很难写对),Typescript提供了一个语法糖来直接获得某个value的type
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">original</span> = <span style="color: #000000;">{</span>
  medium: <span style="color: #3548cf;">"movie"</span>,
  title: <span style="color: #3548cf;">"Mean Girls"</span>,
<span style="color: #000000;">}</span>;

<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">adaptation</span>: <span style="color: #531ab6;">typeof</span> original;

<span style="color: #531ab6;">if</span> <span style="color: #000000;">(</span>Math.<span style="color: #721045;">random</span><span style="color: #dd22dd;">()</span> &gt; 0.5<span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  adaptation = <span style="color: #dd22dd;">{</span> ...original, medium: <span style="color: #3548cf;">"play"</span> <span style="color: #dd22dd;">}</span>;
<span style="color: #000000;">}</span> <span style="color: #531ab6;">else</span> <span style="color: #000000;">{</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:11:31 - error TS2322: Type 'number' is not assignable to type 'string'.</span>
  <span style="color: #7f0000;">//////////////////////////////////////////////</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">adaptation = { ...original, medium: 2 }; //</span>
  <span style="color: #7f0000;">//////////////////////////////////////////////</span>
<span style="color: #000000;">}</span>
</pre>
</div></li>
</ul></li>

<li>注意!typeof在Typescript和Javascript里面的区别:
<ul class="org-ul">
<li>TypeScript里面的typeof是一个compile time的概念, Typescript的typeof只在type里面有效,编译成javascript
后就消失</li>
<li><p>
Javascript里面的typeof是一个runtime的概念,其在runtime返回一个字符串
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span><span style="color: #531ab6;">typeof</span> 32<span style="color: #000000;">)</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span><span style="color: #531ab6;">typeof</span> <span style="color: #0000b0;">true</span><span style="color: #000000;">)</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span><span style="color: #531ab6;">typeof</span> <span style="color: #3548cf;">"hello"</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">number</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">boolean</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">string</span>
</pre>
</div></li>
</ul></li>
<li>keyof和typeof还可以联合起来使用,对于没有明确interface type的value来说,这能节省大量的书写工作.而且
能跟着value内容改变而改变,无需手动更新.
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">ratings</span> = <span style="color: #000000;">{</span>
  imdb: 8.8,
  metacritic: 82,
<span style="color: #000000;">}</span>;

<span style="color: #531ab6;">function</span> <span style="color: #721045;">logRating</span><span style="color: #000000;">(</span><span style="color: #005e8b;">key</span>: <span style="color: #531ab6;">keyof</span> <span style="color: #531ab6;">typeof</span> ratings<span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #dd22dd;">(</span>ratings<span style="color: #008899;">[</span>key<span style="color: #008899;">]</span><span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>

<span style="color: #721045;">logRating</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"imdb"</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">8.8</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:11:11 - error TS2345: Argument of type '"invalid"' is not assignable to parameter of type '"imdb" | "metacritic"'.</span>

<span style="color: #7f0000;">///////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">logRating("invalid"); //</span>
<span style="color: #7f0000;">///////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org447f46b" class="outline-3">
<h3 id="org447f46b"><span class="section-number-3">9.4.</span> Type Assertions</h3>
<div class="outline-text-3" id="text-9-4">
<ul class="org-ul">
<li>有些情况下,代码开发者比编译器更加了解类型的时候(比如JSON.parse就只能将类型全部设置为any),可以强制"断言"类型,也就是type assertion</li>
<li>type assertion有两种形式:
<ul class="org-ul">
<li><p>
尖括号语法(因为可能与jsx相冲突,已经不推荐使用)
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">someValue</span>: <span style="color: #531ab6;">any</span> = <span style="color: #3548cf;">"this is a string"</span>;
<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">strLength</span>: <span style="color: #531ab6;">number</span> = <span style="color: #000000;">(</span>&lt;<span style="color: #531ab6;">string</span>&gt;someValue<span style="color: #000000;">)</span>.length;
</pre>
</div></li>
<li><p>
as语法
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">someValue</span>: <span style="color: #531ab6;">any</span> = <span style="color: #3548cf;">"this is a string"</span>;
<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">strLength</span>: <span style="color: #531ab6;">number</span> = <span style="color: #000000;">(</span>someValue <span style="color: #531ab6;">as</span> <span style="color: #531ab6;">string</span><span style="color: #000000;">)</span>.length;
</pre>
</div></li>
</ul></li>
<li>Typescript的最佳实践就是:能不用type assertion就不要用type assertion,尽量fully type,从而让Typescript来全盘理解类型</li>
</ul>
</div>
<div id="outline-container-org45bf2ad" class="outline-4">
<h4 id="org45bf2ad"><span class="section-number-4">9.4.1.</span> Asserting Caught Error Types</h4>
<div class="outline-text-4" id="text-9-4-1">
<ul class="org-ul">
<li>error handling是可能用到type assertion的地方
<ul class="org-ul">
<li><p>
比如你很确信,只会抛出Error类型的错误,那么你可以这么写
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">try</span> <span style="color: #000000;">{</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">(code that may throw an error)</span>
<span style="color: #000000;">}</span> <span style="color: #531ab6;">catch</span> <span style="color: #000000;">(</span>error<span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">warn</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">"Oh no !"</span>, <span style="color: #008899;">(</span>error <span style="color: #531ab6;">as</span> Error<span style="color: #008899;">)</span>.message<span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>
</pre>
</div></li>
<li><p>
但是其实还有更好的办法,就是使用instanceof来判断类型,进而调用Error的message
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">try</span> <span style="color: #000000;">{</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">(code that may throw an error)</span>
<span style="color: #000000;">}</span> <span style="color: #531ab6;">catch</span> <span style="color: #000000;">(</span>error<span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">warn</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">"Oh no !"</span>, error <span style="color: #531ab6;">instanceof</span> <span style="color: #005f5f;">Error</span> ? error.message : error<span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org4b13142" class="outline-4">
<h4 id="org4b13142"><span class="section-number-4">9.4.2.</span> Non-Null Assertions</h4>
<div class="outline-text-4" id="text-9-4-2">
<ul class="org-ul">
<li>另外一种可能用到type assertion的情况,是我们要把一个variable里面的null(undefined)去掉. 这种通常null
(and/or undefined)只在理论上存在,实际业务逻辑上不可能存在,所以我们就要去掉
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">maybeDate</span> = Math.<span style="color: #721045;">random</span><span style="color: #000000;">()</span> &gt; 0.5 ? <span style="color: #005e8b;">undefined</span> : <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Date</span><span style="color: #000000;">()</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Asserted type: Date</span>
maybeDate <span style="color: #531ab6;">as</span> Date;
</pre>
</div></li>
<li><p>
由于去掉null and /or undefined如此的常用,Typescript增加了一个"后缀!"语法糖 (也就是Non-null assertion)
来专门去掉null和undefind,下面代码和上面的代码等价
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">maybeDate</span> = Math.<span style="color: #721045;">random</span><span style="color: #000000;">()</span> &gt; 0.5 ? <span style="color: #005e8b;">undefined</span> : <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Date</span><span style="color: #000000;">()</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">same with: maybeDate as Date;</span>
maybeDate!;
</pre>
</div></li>
</ul></li>
<li>Non-null assertion对于Map.get来说非常有用,因为Map.get在key存在的时候返回value,不存在的时候返回undefined,
所以其返回类型是包含undefined的union
<ul class="org-ul">
<li><p>
使用non-null assertion就会让Map.get使用起来非常容易
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">seasonCounts</span> = <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Map</span><span style="color: #000000;">(</span><span style="color: #dd22dd;">[</span>
  <span style="color: #008899;">[</span><span style="color: #3548cf;">"I Love Lucy"</span>, <span style="color: #3548cf;">"abc"</span><span style="color: #008899;">]</span>,
  <span style="color: #008899;">[</span><span style="color: #3548cf;">"The Golden Girls"</span>, <span style="color: #3548cf;">"def"</span><span style="color: #008899;">]</span>,
<span style="color: #dd22dd;">]</span><span style="color: #000000;">)</span>;

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">maybeValue</span> = seasonCounts.<span style="color: #721045;">get</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"I Love Lucy"</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:12:13 - error TS18048: 'maybeValue' is possibly 'undefined'.</span>

<span style="color: #7f0000;">/////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">console.</span><span style="color: #721045;">log</span><span style="color: #7f0000;">(maybeValue.</span><span style="color: #721045;">toUpperCase</span><span style="color: #7f0000;">());  //</span>
<span style="color: #7f0000;">/////////////////////////////////////////////</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">knownValue</span> = seasonCounts.<span style="color: #721045;">get</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"I Love Lucy"</span><span style="color: #000000;">)</span>!;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>knownValue.<span style="color: #721045;">toUpperCase</span><span style="color: #dd22dd;">()</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">ABC</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org4827b39" class="outline-4">
<h4 id="org4827b39"><span class="section-number-4">9.4.3.</span> Type Assertin Caveats</h4>
<div class="outline-text-4" id="text-9-4-3">
<ul class="org-ul">
<li>和any一样,type assertion是Typescript的"逃生舱",换句话说,我们应该尽可能的避免使用他们,除非迫不得已</li>
<li>很多时候,我们的type assertion都是错误的:
<ul class="org-ul">
<li>要么在你写代码的时候已经错了</li>
<li>要么在后续漫长的代码维护过程中由于业务逻辑改变,之前正确的assertion也会变成错的了.</li>
</ul></li>
<li>Typescript只运行type assertion发生在这样两个type之间:"一个type可以assign给另一个type的",否则会报错
<ul class="org-ul">
<li><p>
示例如下, 在两个primitive直接assertion是不被允许的
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:1:15 - error TS2352: Conversion of type 'string' to type 'number' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first.</span>

<span style="color: #7f0000;">////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">let myValue = "Stella!" as number; //</span>
<span style="color: #7f0000;">////////////////////////////////////////</span>
</pre>
</div></li>
<li><p>
上面例子中提示我们,可以用先把myValue as成unknown,再as成number.虽然可以成功,但是这只是能编译成功而已,这是应该完全避免的写法
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">myValueDouble</span> = <span style="color: #3548cf;">"1337"</span> <span style="color: #531ab6;">as</span> <span style="color: #531ab6;">unknown</span> <span style="color: #531ab6;">as</span> <span style="color: #531ab6;">number</span>;
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org5ac8eb5" class="outline-3">
<h3 id="org5ac8eb5"><span class="section-number-3">9.5.</span> Const Assertions</h3>
<div class="outline-text-3" id="text-9-5">
<ul class="org-ul">
<li>虽然as不太推荐使用,但是as const却非常推荐使用,其作用总体上来说是让一个类型变成constant, immutable version
的它们自己,具体来说就是:
<ul class="org-ul">
<li><p>
array会被看成是reaonly tuple,而不再是mutable array
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#19968;&#20010;&#25968;&#32452;</span>
<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">colors</span> = <span style="color: #000000;">[</span><span style="color: #3548cf;">"red"</span>, <span style="color: #3548cf;">"green"</span>, <span style="color: #3548cf;">"blue"</span><span style="color: #000000;">]</span>;
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#40664;&#35748;&#24773;&#20917;&#19979;&#65292;TypeScript &#20250;&#25512;&#26029;&#20026; string[] &#31867;&#22411;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">colors &#30340;&#31867;&#22411;&#26159; (string[])</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#20351;&#29992; as const</span>
<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">colorsConst</span> = <span style="color: #000000;">[</span><span style="color: #3548cf;">"red"</span>, <span style="color: #3548cf;">"green"</span>, <span style="color: #3548cf;">"blue"</span><span style="color: #000000;">]</span> <span style="color: #531ab6;">as</span> <span style="color: #531ab6;">const</span>;
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#20351;&#29992; as const &#21518;&#65292;colorsConst &#30340;&#31867;&#22411;&#26159; readonly ["red", "green", "blue"]</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#31867;&#22411;&#21464;&#25104;&#20102;&#19968;&#20010;&#21482;&#35835;&#30340;&#20803;&#32452;&#65292;&#24182;&#19988;&#27599;&#20010;&#20803;&#32032;&#37117;&#20855;&#26377;&#20855;&#20307;&#30340;&#23383;&#38754;&#37327;&#31867;&#22411; "red", "green", "blue"</span>
</pre>
</div></li>
<li>literal会被认为是literal类型,而不是更加general的primitive类型(比如字符串"abc"会被认为是abc类型,
而不是string,这样能保证其只能被"abc"赋值,也就是readonly啦)</li>
<li>object的property变成了readonly</li>
</ul></li>
</ul>
</div>
<div id="outline-container-orgf82b50b" class="outline-4">
<h4 id="orgf82b50b"><span class="section-number-4">9.5.1.</span> Literals to Primitives</h4>
<div class="outline-text-4" id="text-9-5-1">
<ul class="org-ul">
<li>在Typescript中,literal通常会被推断为其对应的原始类型,比如"hello"会被推断为string,而不是literal类型
"hello",但是加了as const之后,就会被推断成"hello"类型了
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#19981;&#20351;&#29992; as const</span>
<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">greeting</span> = <span style="color: #3548cf;">"hello"</span>;
<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">example</span>: <span style="color: #531ab6;">typeof</span> greeting;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#25512;&#26029;&#31867;&#22411;&#20026; string&#65292;&#32780;&#19981;&#26159;&#20855;&#20307;&#30340; "hello"</span>
example = <span style="color: #3548cf;">"hello"</span>;              <span style="color: #7f0000;">// </span><span style="color: #7f0000;">ok</span>
example = <span style="color: #3548cf;">"world"</span>;              <span style="color: #7f0000;">// </span><span style="color: #7f0000;">ok</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#20351;&#29992; as const</span>
<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">greetingConst</span> = <span style="color: #3548cf;">"hello"</span> <span style="color: #531ab6;">as</span> <span style="color: #531ab6;">const</span>;
<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">exampleConst</span>: <span style="color: #531ab6;">typeof</span> greetingConst;

exampleConst = <span style="color: #3548cf;">"hello"</span>;
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:7:1 - error TS2322: Type '"world"' is not assignable to type '"hello"'.</span>

<span style="color: #7f0000;">/////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">exampleConst = "world"; //</span>
<span style="color: #7f0000;">/////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org5b8077d" class="outline-4">
<h4 id="org5b8077d"><span class="section-number-4">9.5.2.</span> Read-Only Objects</h4>
<div class="outline-text-4" id="text-9-5-2">
<ul class="org-ul">
<li>我们一旦在object定义的时候加上as const,那么相当于给object的所有成员都加上as const
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">describePreference</span><span style="color: #000000;">(</span><span style="color: #005e8b;">preference</span>: <span style="color: #3548cf;">"maybe"</span> | <span style="color: #3548cf;">"no"</span> | <span style="color: #3548cf;">"yes"</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">switch</span> <span style="color: #dd22dd;">(</span>preference<span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">case</span> <span style="color: #3548cf;">"maybe"</span>:
      <span style="color: #531ab6;">return</span> <span style="color: #3548cf;">"I suppose..."</span>;
    <span style="color: #531ab6;">case</span> <span style="color: #3548cf;">"no"</span>:
      <span style="color: #531ab6;">return</span> <span style="color: #3548cf;">"No thanks."</span>;
    <span style="color: #531ab6;">case</span> <span style="color: #3548cf;">"yes"</span>:
      <span style="color: #531ab6;">return</span> <span style="color: #3548cf;">"Yes please !"</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">preferencesMutable</span> = <span style="color: #000000;">{</span>
  movie: <span style="color: #3548cf;">"maybe"</span>,
  standup: <span style="color: #3548cf;">"yes"</span>,
<span style="color: #000000;">}</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:18:20 - error TS2345: Argument of type 'string' is not assignable to parameter of type '"maybe" | "no" | "yes"'.</span>

<span style="color: #7f0000;">///////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">describePreference(preferencesMutable.movie); //</span>
<span style="color: #7f0000;">///////////////////////////////////////////////////</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">preferencesReadonly</span> = <span style="color: #000000;">{</span>
  movie: <span style="color: #3548cf;">"maybe"</span>,
  standup: <span style="color: #3548cf;">"yes"</span>,
<span style="color: #000000;">}</span> <span style="color: #531ab6;">as</span> <span style="color: #531ab6;">const</span>;

<span style="color: #721045;">describePreference</span><span style="color: #000000;">(</span>preferencesReadonly.movie<span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:30:21 - error TS2540: Cannot assign to 'movie' because it is a read-only property.</span>

<span style="color: #7f0000;">//////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">preferencesReadonly.movie = "new value"; //</span>
<span style="color: #7f0000;">//////////////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: harrifeng@outlook.com</p>
<p class="date">Created: 2025-04-01 Tue 17:20</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
