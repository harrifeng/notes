<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2025-04-22 Tue 12:15 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>lts</title>
<meta name="author" content="harrifeng@outlook.com" />
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="src/readtheorg_theme/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="src/readtheorg_theme/css/readtheorg.css"/>
<script type="text/javascript" src="src/lib/js/jquery.min.js"></script>
<script type="text/javascript" src="src/lib/js/bootstrap.min.js"></script>
<script type="text/javascript" src="src/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="src/readtheorg_theme/js/readtheorg.js"></script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">lts</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org23e6ab6">1. Chapter 1: From JavaScript to TypeScript</a>
<ul>
<li><a href="#org460ead0">1.1. History of JavaScript</a></li>
<li><a href="#orgf74b5a1">1.2. Vanilla JavaScript's Pitfalls</a>
<ul>
<li><a href="#orgbd8d380">1.2.1. Costly Freedom</a></li>
<li><a href="#org321905d">1.2.2. Losse Documentation</a></li>
<li><a href="#org0483224">1.2.3. Weaker Developer Tooling</a></li>
</ul>
</li>
<li><a href="#org24fa0db">1.3. Typescript!</a></li>
<li><a href="#org02d5a96">1.4. Getting Started in the TypeScript Playground</a>
<ul>
<li><a href="#orga9f3fac">1.4.1. TypeScript in Action</a></li>
<li><a href="#orgc02ce5e">1.4.2. Freedom Through Restriction</a></li>
<li><a href="#org932d526">1.4.3. Precise Documentation</a></li>
<li><a href="#orgbc3d61e">1.4.4. Stronger Developer Tooling</a></li>
<li><a href="#orgfbb46f5">1.4.5. Compiling Syntax</a></li>
</ul>
</li>
<li><a href="#org1558f04">1.5. Getting Started Locally</a>
<ul>
<li><a href="#orgaa5e067">1.5.1. Running Locally</a></li>
<li><a href="#org3c2d79d">1.5.2. Editor Features</a></li>
</ul>
</li>
<li><a href="#org6548670">1.6. What TypeScript is Not</a>
<ul>
<li><a href="#org24b876b">1.6.1. A Remedy for Bad Code</a></li>
<li><a href="#orga0ca578">1.6.2. Extensions to JavaScript(Mostly)</a></li>
<li><a href="#orgd82b5c3">1.6.3. SLower Than JavaScript</a></li>
<li><a href="#org042476e">1.6.4. Finished Evolving</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org4c801c4">2. Chapter 2: The Type System</a>
<ul>
<li><a href="#org9bdfef1">2.1. What's in a Type?</a>
<ul>
<li><a href="#org60c3a23">2.1.1. Type Systems</a></li>
<li><a href="#orgeae9c5e">2.1.2. Kinds of Errors</a></li>
</ul>
</li>
<li><a href="#org3f6b714">2.2. Assignability</a>
<ul>
<li><a href="#orgfd9d357">2.2.1. Understanding Assignability Errors</a></li>
</ul>
</li>
<li><a href="#org2fae039">2.3. Type Annotations</a>
<ul>
<li><a href="#orgaf733bc">2.3.1. Unnecessary Type Annotaions</a></li>
</ul>
</li>
<li><a href="#org00f0621">2.4. Type Shapes</a>
<ul>
<li><a href="#org1fd881f">2.4.1. Modules</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org70a5cd7">3. Chapter 3: Unions and Literals</a>
<ul>
<li><a href="#orgba58751">3.1. Union Types</a>
<ul>
<li><a href="#orgc3c5261">3.1.1. Declaring Union Types</a></li>
<li><a href="#orgac1c1dc">3.1.2. Union Preperties</a></li>
</ul>
</li>
<li><a href="#orga09eda6">3.2. Narrowing</a>
<ul>
<li><a href="#org1c0a448">3.2.1. Assignment Narrowing</a></li>
<li><a href="#orge222bed">3.2.2. Conditional Checks</a></li>
<li><a href="#org1236e0d">3.2.3. Typeof Checks</a></li>
</ul>
</li>
<li><a href="#orgc832dd3">3.3. Literal Types</a>
<ul>
<li><a href="#org623d894">3.3.1. Literal Assignability</a></li>
</ul>
</li>
<li><a href="#org386ef53">3.4. Strict Null Checking</a>
<ul>
<li><a href="#org977e08f">3.4.1. The Billion-Dollar Mistake</a></li>
<li><a href="#orgc626d42">3.4.2. Truthiness Narrowing</a></li>
<li><a href="#org573ec14">3.4.3. Variables Without Initial Values</a></li>
</ul>
</li>
<li><a href="#org5a462c7">3.5. Type Aliases</a>
<ul>
<li><a href="#org7ef6b1e">3.5.1. Type Aliases Are Not JavaScript</a></li>
<li><a href="#org9976b5b">3.5.2. Combining Type Aliases</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org22ff6f6">4. Chapter 4: Objects</a>
<ul>
<li><a href="#org4b2033a">4.1. Object Types</a>
<ul>
<li><a href="#org7b8c3fd">4.1.1. Declaring Object Types</a></li>
<li><a href="#org1a10a9a">4.1.2. Aliased Object Types</a></li>
</ul>
</li>
<li><a href="#org85244ee">4.2. Structural Typing</a>
<ul>
<li><a href="#org04b01f5">4.2.1. Usage Checking</a></li>
<li><a href="#org7d0aef3">4.2.2. Excess Property Checking</a></li>
<li><a href="#org5512bb2">4.2.3. Nested Object Types</a></li>
<li><a href="#orgf051efd">4.2.4. Optional Properties</a></li>
</ul>
</li>
<li><a href="#org5416994">4.3. Unions of Object Types</a>
<ul>
<li><a href="#org130c882">4.3.1. Inferred Object-Type Unions</a></li>
<li><a href="#org474033b">4.3.2. Explicit Object-Type Unions</a></li>
<li><a href="#orgc8f1a5b">4.3.3. Narrowing Object Types</a></li>
<li><a href="#org29e335d">4.3.4. Discriminated Unions</a></li>
</ul>
</li>
<li><a href="#org354f210">4.4. Intersection Types</a>
<ul>
<li><a href="#orgb0cd320">4.4.1. Dangers of Intersection Types</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org7145187">5. Chapter 5: Functions</a>
<ul>
<li><a href="#orgf7e4d5f">5.1. Function Parameters</a>
<ul>
<li><a href="#orgc538e60">5.1.1. Required Parameters</a></li>
<li><a href="#org134604b">5.1.2. Optional Parameters</a></li>
<li><a href="#org262ce68">5.1.3. Default Parameters</a></li>
<li><a href="#org6e08202">5.1.4. Rest Parameters</a></li>
</ul>
</li>
<li><a href="#org882e35f">5.2. Return Types</a>
<ul>
<li><a href="#orgd287926">5.2.1. Explicit Return Types</a></li>
</ul>
</li>
<li><a href="#org3e56543">5.3. Function Types</a>
<ul>
<li><a href="#orgf95fb60">5.3.1. Function Type Parentheses</a></li>
<li><a href="#org9710193">5.3.2. Parameter Type Inferences</a></li>
<li><a href="#org8577a3f">5.3.3. Function Type Aliases</a></li>
</ul>
</li>
<li><a href="#org8f4fae2">5.4. More Return Types</a>
<ul>
<li><a href="#org8706af9">5.4.1. Void Returns</a></li>
<li><a href="#orgd7a9389">5.4.2. Never Returns</a></li>
</ul>
</li>
<li><a href="#org753cd2b">5.5. Function Overloads</a>
<ul>
<li><a href="#orgbe4b973">5.5.1. Call-Signature Compatibility</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org74cad20">6. Chapter 6: Arrays</a>
<ul>
<li><a href="#org19081fb">6.1. Array Types</a>
<ul>
<li><a href="#orgbf877c6">6.1.1. Array and Function Types</a></li>
<li><a href="#org8d9dfe8">6.1.2. Union Type Arrays</a></li>
<li><a href="#org97f1506">6.1.3. Evolving Any Arrays</a></li>
<li><a href="#org277db04">6.1.4. Multidimensional Arrays</a></li>
</ul>
</li>
<li><a href="#org0c45b7c">6.2. Array Members</a>
<ul>
<li><a href="#orgb29b2a7">6.2.1. Caveat: Unsound Members</a></li>
</ul>
</li>
<li><a href="#org3082492">6.3. Spreads and Rests</a>
<ul>
<li><a href="#orga28634e">6.3.1. Spreads</a></li>
<li><a href="#org3d0ffcd">6.3.2. Spreading Rest Parameters</a></li>
</ul>
</li>
<li><a href="#org6912ba1">6.4. Tuples</a>
<ul>
<li><a href="#org2410da3">6.4.1. Tuple Assignability</a></li>
<li><a href="#orgaf67b28">6.4.2. Tuple Inferences</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orge4ae9b9">7. Chapter 7: Interfaces</a>
<ul>
<li><a href="#org123bc5c">7.1. Type Aliases Versus Intrfaces</a></li>
<li><a href="#orgf463798">7.2. Type of Proprties</a>
<ul>
<li><a href="#org5039285">7.2.1. Optional Properties</a></li>
<li><a href="#orgea4809f">7.2.2. Read-Only Properties</a></li>
<li><a href="#org40746ea">7.2.3. Functions and Methods</a></li>
<li><a href="#org0b3a894">7.2.4. Call Signatures</a></li>
<li><a href="#org023a55b">7.2.5. Index Signatures</a></li>
<li><a href="#orgd669ee2">7.2.6. Nested Interfaces</a></li>
</ul>
</li>
<li><a href="#orge26ff24">7.3. Interface Extensions</a>
<ul>
<li><a href="#org1a13c62">7.3.1. Overridden Properties</a></li>
<li><a href="#org5f34f37">7.3.2. Extending Multiple Interfaces</a></li>
</ul>
</li>
<li><a href="#org9f8b0ec">7.4. Interface Merging</a>
<ul>
<li><a href="#org5a9ef23">7.4.1. Member Naming Conflicts</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgf021dd7">8. Chapter 8: Classes</a>
<ul>
<li><a href="#orgd1b3cb0">8.1. Class Methods</a></li>
<li><a href="#orgf479dfd">8.2. Class Properties</a>
<ul>
<li><a href="#org0f6c7e0">8.2.1. Function Properties</a></li>
<li><a href="#org3c9bee3">8.2.2. Initialization Checking</a></li>
<li><a href="#orgdf33816">8.2.3. Optional Properties</a></li>
<li><a href="#orge951e5c">8.2.4. Read-Only Properties</a></li>
</ul>
</li>
<li><a href="#org74ea0c0">8.3. Classes as Types</a></li>
<li><a href="#orga7343ab">8.4. Classes and Interfaces</a>
<ul>
<li><a href="#orgefcfceb">8.4.1. Implementing Multiple Interfaces</a></li>
</ul>
</li>
<li><a href="#orge778d5e">8.5. Extending a Class</a>
<ul>
<li><a href="#orgef6b3f1">8.5.1. Extension Assignability</a></li>
<li><a href="#orgc2a4d91">8.5.2. Overriddeng Constructors</a></li>
<li><a href="#orge83c050">8.5.3. Overridden Methods</a></li>
<li><a href="#orgfc834b2">8.5.4. Overridden Properties</a></li>
</ul>
</li>
<li><a href="#org3b31213">8.6. Abstract Classes</a></li>
<li><a href="#org3c526d1">8.7. Member Visibility</a>
<ul>
<li><a href="#org2896a6a">8.7.1. Static Field Modifiers</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgda13b0d">9. Chapter 9: Type Modifiers</a>
<ul>
<li><a href="#orge8a9a10">9.1. Top Types</a>
<ul>
<li><a href="#orgd90420e">9.1.1. any, Again</a></li>
<li><a href="#org15759e6">9.1.2. unknown</a></li>
</ul>
</li>
<li><a href="#org1052232">9.2. Type Prddicates</a></li>
<li><a href="#org24035b7">9.3. Type Operators</a>
<ul>
<li><a href="#org5b7ae08">9.3.1. keyof</a></li>
<li><a href="#org099e6d8">9.3.2. typeof</a></li>
</ul>
</li>
<li><a href="#org37bf263">9.4. Type Assertions</a>
<ul>
<li><a href="#org1a76f38">9.4.1. Asserting Caught Error Types</a></li>
<li><a href="#org6494811">9.4.2. Non-Null Assertions</a></li>
<li><a href="#org4708c09">9.4.3. Type Assertin Caveats</a></li>
</ul>
</li>
<li><a href="#org2d0e065">9.5. Const Assertions</a>
<ul>
<li><a href="#orgf889ea7">9.5.1. Literals to Primitives</a></li>
<li><a href="#org6086610">9.5.2. Read-Only Objects</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org20b168e">10. Chapter 10: Generics</a>
<ul>
<li><a href="#orgb359b20">10.1. Generic Functions</a>
<ul>
<li><a href="#org2955dce">10.1.1. Explicit Generic Call Types</a></li>
<li><a href="#org534000d">10.1.2. Multiple Function Type Parameters</a></li>
</ul>
</li>
<li><a href="#orgf92a3e8">10.2. Generic Interface</a>
<ul>
<li><a href="#orge57ec89">10.2.1. Inferred Generic Interface Types</a></li>
</ul>
</li>
<li><a href="#org0f14810">10.3. Generic Classes</a>
<ul>
<li><a href="#org7b51570">10.3.1. Explicit Generic Class Types</a></li>
<li><a href="#org3fc59b2">10.3.2. Extending Generic Classes</a></li>
<li><a href="#orgd284236">10.3.3. Implementing Generic Interfaces</a></li>
<li><a href="#orgcb8c03b">10.3.4. Method Generics</a></li>
<li><a href="#org671840b">10.3.5. Static Class Generics</a></li>
</ul>
</li>
<li><a href="#orgc6245fd">10.4. Generic Type Aliases</a>
<ul>
<li><a href="#orgf3fe606">10.4.1. Generic Discriminated Unions</a></li>
</ul>
</li>
<li><a href="#org7d8a1a2">10.5. Generic Modifiers</a>
<ul>
<li><a href="#orgb3b267b">10.5.1. Generic Defaults</a></li>
</ul>
</li>
<li><a href="#org39204f0">10.6. Constrained Generic Types</a>
<ul>
<li><a href="#orgfddc350">10.6.1. keyof and Constrained Type Parameters</a></li>
</ul>
</li>
<li><a href="#org1bbd748">10.7. Promises</a>
<ul>
<li><a href="#orgd62137a">10.7.1. Creating Promises</a></li>
<li><a href="#org9632ffb">10.7.2. Async Functions</a></li>
</ul>
</li>
<li><a href="#org581a26a">10.8. Using Generics Right</a>
<ul>
<li><a href="#org42ad22a">10.8.1. The Golden Rule of Generics</a></li>
<li><a href="#orgb85b5cc">10.8.2. Generic Naming Conventions</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org10371e5">11. Chapter 11: Declaration Files</a>
<ul>
<li><a href="#orgf64e535">11.1. Declaration Files</a></li>
<li><a href="#org403229d">11.2. Declaring Runtime Values</a>
<ul>
<li><a href="#orgc9b1aa0">11.2.1. Global Values</a></li>
<li><a href="#orgc08452d">11.2.2. Global Interface Merging</a></li>
<li><a href="#org381d418">11.2.3. Global Augmentations</a></li>
</ul>
</li>
<li><a href="#orgb781da5">11.3. Built-in Declarations</a>
<ul>
<li><a href="#org48c4dd5">11.3.1. Library Declarations</a></li>
<li><a href="#org76cc8e4">11.3.2. DOM Declarations</a></li>
</ul>
</li>
<li><a href="#org754d035">11.4. Module Declarations</a>
<ul>
<li><a href="#org0378ab4">11.4.1. Wildcard Module Declarations</a></li>
</ul>
</li>
<li><a href="#org1a72e6d">11.5. Package Types</a>
<ul>
<li><a href="#org0204f61">11.5.1. declaration</a></li>
<li><a href="#org99d5830">11.5.2. Dependency Package Types</a></li>
<li><a href="#org02c0115">11.5.3. Exposing Package Types</a></li>
</ul>
</li>
<li><a href="#orgaf50596">11.6. Definitely Typed</a>
<ul>
<li><a href="#org20bccf9">11.6.1. Type Availability</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org10583e9">12. Chapter 12: Using IDE Features</a>
<ul>
<li><a href="#org12dda2a">12.1. Navigating Code</a>
<ul>
<li><a href="#org0cac4db">12.1.1. Finding Definitions</a></li>
<li><a href="#orgccdb54f">12.1.2. Finding References</a></li>
<li><a href="#org4ddf0b9">12.1.3. Finding Implementations</a></li>
</ul>
</li>
<li><a href="#org9953ece">12.2. Writing Code</a>
<ul>
<li><a href="#orgf66ee67">12.2.1. Completing Names</a></li>
<li><a href="#orgaebd732">12.2.2. Automatic Import Updates</a></li>
<li><a href="#orgfec7b97">12.2.3. Code Actions</a></li>
</ul>
</li>
<li><a href="#orgf495460">12.3. Working Effectively with Errors</a>
<ul>
<li><a href="#org2449cc1">12.3.1. Language Service Errors</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orga44f5a8">13. Chapter 13: Configuration Options</a>
<ul>
<li><a href="#orgce57f6b">13.1. tsc Options</a>
<ul>
<li><a href="#orgf0d58b3">13.1.1. Pretty Mode</a></li>
<li><a href="#org8a83384">13.1.2. Watch Mode</a></li>
</ul>
</li>
<li><a href="#org8113af1">13.2. TSConfig Files</a>
<ul>
<li><a href="#org7f78b30">13.2.1. tsc &#x2013;init</a></li>
<li><a href="#orgdf81186">13.2.2. CLI Versus Configuration</a></li>
</ul>
</li>
<li><a href="#orgf7f52ae">13.3. File Inclusions</a>
<ul>
<li><a href="#orgecf1ac0">13.3.1. include</a></li>
<li><a href="#org6ae1e2b">13.3.2. exclude</a></li>
</ul>
</li>
<li><a href="#org025f22c">13.4. Alternative Extensions</a>
<ul>
<li><a href="#org3fc4abd">13.4.1. JSX Syntax</a></li>
<li><a href="#org22f9820">13.4.2. resolveJsonModule</a></li>
</ul>
</li>
<li><a href="#org2268280">13.5. Emit</a>
<ul>
<li><a href="#org44796a6">13.5.1. outDir</a></li>
<li><a href="#orgd1541e5">13.5.2. target</a></li>
<li><a href="#org6558f62">13.5.3. Emitting Declarations</a></li>
<li><a href="#orgf87df88">13.5.4. Source Maps</a></li>
<li><a href="#org0fc0cfd">13.5.5. noEmit</a></li>
</ul>
</li>
<li><a href="#org2dfc6db">13.6. Type Checking</a>
<ul>
<li><a href="#org249d944">13.6.1. lib</a></li>
<li><a href="#org8ff7625">13.6.2. skipLibCheck</a></li>
<li><a href="#orga04b46c">13.6.3. Strict Mode</a></li>
</ul>
</li>
<li><a href="#org14f5adf">13.7. Modules</a>
<ul>
<li><a href="#org32d524b">13.7.1. module</a></li>
<li><a href="#orgf8d5a34">13.7.2. moduleResolution</a></li>
<li><a href="#orgb300d32">13.7.3. interoperability with CommonJS</a></li>
<li><a href="#orga686f98">13.7.4. isolatedModules</a></li>
</ul>
</li>
<li><a href="#org56c9893">13.8. JavaScript</a>
<ul>
<li><a href="#orga70c574">13.8.1. allowJs</a></li>
<li><a href="#org719c4bf">13.8.2. checkJs</a></li>
<li><a href="#org1d8acec">13.8.3. JSDoc Support</a></li>
</ul>
</li>
<li><a href="#orga9e2fd5">13.9. Configuration Extensions</a>
<ul>
<li><a href="#org584611c">13.9.1. extends</a></li>
<li><a href="#orgf0abf72">13.9.2. Configuration Bases</a></li>
</ul>
</li>
<li><a href="#orgfe22e90">13.10. Project References</a>
<ul>
<li><a href="#org944d2ac">13.10.1. composite</a></li>
<li><a href="#orgfbc5496">13.10.2. references</a></li>
<li><a href="#org8ea7482">13.10.3. Build Mode</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-org23e6ab6" class="outline-2">
<h2 id="org23e6ab6"><span class="section-number-2">1.</span> Chapter 1: From JavaScript to TypeScript</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org460ead0" class="outline-3">
<h3 id="org460ead0"><span class="section-number-3">1.1.</span> History of JavaScript</h3>
<div class="outline-text-3" id="text-1-1">
<ul class="org-ul">
<li>javascript是Brendan Eich在1995年用十天时间发明的语言,由于时间仓促,javascript有很多奇怪的地方</li>
<li>从2015年开始,javascript的规范化组织ECMAScript(因为javascript是火狐浏览器的商标),就每年发布新版本,并
且保证向前兼容</li>
</ul>
</div>
</div>
<div id="outline-container-orgf74b5a1" class="outline-3">
<h3 id="orgf74b5a1"><span class="section-number-3">1.2.</span> Vanilla JavaScript's Pitfalls</h3>
<div class="outline-text-3" id="text-1-2">
<ul class="org-ul">
<li>开发者把没有使用任何框架的javascript叫做vanilla(因为香草味是最常见的味道)</li>
<li>实际上很少有项目使用vanilla javascript,因为原生javascript的陷阱实在是太多了,这也是为什么Typescript会诞生的原因</li>
</ul>
</div>
<div id="outline-container-orgbd8d380" class="outline-4">
<h4 id="orgbd8d380"><span class="section-number-4">1.2.1.</span> Costly Freedom</h4>
<div class="outline-text-4" id="text-1-2-1">
<ul class="org-ul">
<li>javascript太过于自由了,导致有很多的问题.
<ul class="org-ul">
<li><p>
比如下面的代码:
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #531ab6;">function</span> <span style="color: #721045;">paintPainting</span><span style="color: #000000;">(</span><span style="color: #005e8b;">painter</span>, <span style="color: #005e8b;">painting</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> painter
    .prepare<span style="color: #dd22dd;">()</span>
    .paint<span style="color: #dd22dd;">(</span>painting, painter.ownMaterials<span style="color: #dd22dd;">)</span>
    .finish<span style="color: #dd22dd;">()</span>;
<span style="color: #000000;">}</span>
</pre>
</div></li>
<li>由于不经过编译器确认,那么一旦paint()函数改名字了,那么代码毫无感觉,直到代码运行到这个地方</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org321905d" class="outline-4">
<h4 id="org321905d"><span class="section-number-4">1.2.2.</span> Losse Documentation</h4>
<div class="outline-text-4" id="text-1-2-2">
<ul class="org-ul">
<li>由于是动态语言,所以维持js代码的文档是非常困难的,因为:
<ul class="org-ul">
<li>很有可能JSDoc是错误的,因为它和代码是分离的</li>
<li>即便我们JSDoc是正确的,但是随着代码的重构,我们要经常性的去更改那些now-invalid JSDoc,这个是非常困难
也复杂的</li>
<li>描述复杂的对象会非常的复杂</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org0483224" class="outline-4">
<h4 id="org0483224"><span class="section-number-4">1.2.3.</span> Weaker Developer Tooling</h4>
<div class="outline-text-4" id="text-1-2-3">
<ul class="org-ul">
<li>Js作为动态语言,天然的没有太多开发者支持工具,比如重命名成员和跳转到定义等</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org24fa0db" class="outline-3">
<h3 id="org24fa0db"><span class="section-number-3">1.3.</span> Typescript!</h3>
<div class="outline-text-3" id="text-1-3">
<ul class="org-ul">
<li>Typescript由C#,Pascal语言的作者 Anders Hejlsberg在2010年发明,并在2012年开源</li>
<li>我们可以把Typescript看成是如下四个东西:
<ul class="org-ul">
<li>programming language: 一个包含所有Js的syntax的语言,外加新的TypeScript-specific syntax用来定义和使用type</li>
<li>Type checker: 还可以把ts看成是一个程序,用来检查输入的js和ts代码是否正确</li>
<li>Compiler: 还可以把ts卡成是一个编译器,用来把ts代码编译成js代码</li>
<li>Language service: 还可以把ts看成是一个服务,提供给编辑器(比如vs code)来帮助开发者开发代码</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org02d5a96" class="outline-3">
<h3 id="org02d5a96"><span class="section-number-3">1.4.</span> Getting Started in the TypeScript Playground</h3>
<div class="outline-text-3" id="text-1-4">
<ul class="org-ul">
<li>TypeScript主页包含了一个在线的编辑器,叫TypeScript Playground,地址如下 <a href="https://www.typescriptlang.org/play">https://www.typescriptlang.org/play</a></li>
</ul>
</div>
<div id="outline-container-orga9f3fac" class="outline-4">
<h4 id="orga9f3fac"><span class="section-number-4">1.4.1.</span> TypeScript in Action</h4>
<div class="outline-text-4" id="text-1-4-1">
<ul class="org-ul">
<li><p>
我们先来看看一个代码片段
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">firstName</span> = <span style="color: #3548cf;">"Georgia"</span>;
<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">nameLangth</span> = firstName.length<span style="color: #000000;">()</span>;
</pre>
</div></li>
<li>这段如果是js代码的话,在运行时会爆出问题,因为字符串没有length()函数</li>
<li><p>
我们把这段代码贴到Typescript Playground,我们会发现,ts作为language service会帮我们分析到
</p>
<pre class="example" id="org852ec92">
This expression is not callable.
  Type 'Number' has no call signatures. ts(2349)
</pre></li>
<li>在代码书写阶段就得到警告,好过运行的时候整个程序崩溃</li>
</ul>
</div>
</div>
<div id="outline-container-orgc02ce5e" class="outline-4">
<h4 id="orgc02ce5e"><span class="section-number-4">1.4.2.</span> Freedom Through Restriction</h4>
<div class="outline-text-4" id="text-1-4-2">
<ul class="org-ul">
<li>ts允许我们选定参数和变量能够使用的类型</li>
<li>ts还允许我们在函数的定义改变的时候,做出告警</li>
</ul>
</div>
</div>
<div id="outline-container-org932d526" class="outline-4">
<h4 id="org932d526"><span class="section-number-4">1.4.3.</span> Precise Documentation</h4>
<div class="outline-text-4" id="text-1-4-3">
<ul class="org-ul">
<li><p>
我们来看看ts版本的paintPainting,即便我们还没引入ts的内容,但是你也可以看出这就是代码本身就是documentation的范本
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">Painter</span> <span style="color: #000000;">{</span>
  <span style="color: #721045;">finish</span><span style="color: #dd22dd;">()</span>: <span style="color: #531ab6;">boolean</span>;
  ownMaterials: <span style="color: #005f5f;">Material</span><span style="color: #dd22dd;">[]</span>;
  <span style="color: #721045;">paint</span><span style="color: #dd22dd;">(</span><span style="color: #005e8b;">painting</span>: <span style="color: #531ab6;">string</span>, <span style="color: #005e8b;">materials</span>: <span style="color: #005f5f;">Material</span><span style="color: #008899;">[]</span><span style="color: #dd22dd;">)</span>: <span style="color: #531ab6;">boolean</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">function</span> <span style="color: #721045;">paintPainting</span><span style="color: #000000;">(</span><span style="color: #005e8b;">painter</span>: <span style="color: #005f5f;">Painter</span>, <span style="color: #005e8b;">painting</span>: <span style="color: #531ab6;">string</span><span style="color: #000000;">)</span>: <span style="color: #531ab6;">boolean</span><span style="color: #000000;">{</span><span style="color: #7f0000;">/* </span><span style="color: #7f0000;">... */</span><span style="color: #000000;">}</span>
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-orgbc3d61e" class="outline-4">
<h4 id="orgbc3d61e"><span class="section-number-4">1.4.4.</span> Stronger Developer Tooling</h4>
<div class="outline-text-4" id="text-1-4-4">
<ul class="org-ul">
<li>Typescript 自己就能为vs code 提供自动补全等功能</li>
</ul>
</div>
</div>
<div id="outline-container-orgfbb46f5" class="outline-4">
<h4 id="orgfbb46f5"><span class="section-number-4">1.4.5.</span> Compiling Syntax</h4>
<div class="outline-text-4" id="text-1-4-5">
<ul class="org-ul">
<li>Typescript不仅能把ts编译成js,还能把新版本的js编译成老版本的js</li>
<li>我们可以在Typescript playground页面的右侧看到编译好的js代码</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org1558f04" class="outline-3">
<h3 id="org1558f04"><span class="section-number-3">1.5.</span> Getting Started Locally</h3>
<div class="outline-text-3" id="text-1-5">
<ul class="org-ul">
<li><p>
typescript是作为nodejs的一个module被安装的,如果要本地使用,记得全局安装
</p>
<div class="org-src-container">
<pre class="src src-shell">npm i -g typescript
</pre>
</div></li>
<li><p>
一旦全局安装typescript module成功之后,会有一个tsc的命令放在path
</p>
<div class="org-src-container">
<pre class="src src-shell">$ tsc --version
Version 5.0.4
</pre>
</div></li>
</ul>
</div>
<div id="outline-container-orgaa5e067" class="outline-4">
<h4 id="orgaa5e067"><span class="section-number-4">1.5.1.</span> Running Locally</h4>
<div class="outline-text-4" id="text-1-5-1">
<ul class="org-ul">
<li><p>
在一个空白的文件夹下面运行如下命令,就能在root目录创建一个新的tsconfig.json配置文件
</p>
<div class="org-src-container">
<pre class="src src-shell">$ tsc --init

Created a new tsconfig.json with:
                                                                                                              TS
  target: es2016
  module: commonjs
  strict: true
  esModuleInterop: true
  skipLibCheck: true
  forceConsistentCasingInFileNames: true


You can learn more at https://aka.ms/tsconfig
$ ls -al .
total 24
drwxr-xr-x   3 fenghaoran  staff     96 May  8 17:58 .
drwxr-xr-x  23 fenghaoran  staff    736 May  8 17:58 ..
-rw-r--r--   1 fenghaoran  staff  12288 May  8 17:58 tsconfig.json
</pre>
</div></li>
<li><p>
我们在这个文件夹里面创建一个文件index.ts并且添加如下文本
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #005f5f;">console</span>.<span style="color: #721045;">blub</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Nothing is worth more than laughter."</span><span style="color: #000000;">)</span>;
</pre>
</div></li>
<li><p>
我们如果使用tsc编译的话,会出现如下错误
</p>
<div class="org-src-container">
<pre class="src src-shell">$ tsc index.ts
index.ts:1:9 - error TS2339: Property <span style="color: #3548cf;">'blub'</span> does not exist on type <span style="color: #3548cf;">'Console'</span>.

1 console.blub<span style="color: #000000;">(</span><span style="color: #3548cf;">"Nothing is worth more than laughter."</span><span style="color: #000000;">)</span>;
          ~~~~


Found 1 error<span style="color: #531ab6;"> in</span> index.ts:1
</pre>
</div></li>
<li><p>
虽然你的写法tsc认为有问题,但是它还是给你创建了一个新的index.js文件
</p>
<div class="org-src-container">
<pre class="src src-shell">$ cat index.js
<span style="color: #721045;">console.blub</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Nothing is worth more than laughter."</span><span style="color: #000000;">)</span>;
</pre>
</div></li>
<li>从这里看tsc的编译和我们之前理解的gcc等还是有差别的.</li>
<li><p>
我们更改错误之后,编译就不会有问题了,而且会产生新的正确的js代码
</p>
<div class="org-src-container">
<pre class="src src-shell">$ cat index.ts
<span style="color: #721045;">console.log</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Nothing is worth more than laughter."</span><span style="color: #000000;">)</span>;
$ tsc index.ts
$ cat index.js
<span style="color: #721045;">console.log</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Nothing is worth more than laughter."</span><span style="color: #000000;">)</span>;
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-org3c2d79d" class="outline-4">
<h4 id="org3c2d79d"><span class="section-number-4">1.5.2.</span> Editor Features</h4>
<div class="outline-text-4" id="text-1-5-2">
<ul class="org-ul">
<li>tsconfig.json配置文件的巨大作用,在于让vs code(或者其他编辑器,IDE)能够识别出ts project root folder</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org6548670" class="outline-3">
<h3 id="org6548670"><span class="section-number-3">1.6.</span> What TypeScript is Not</h3>
<div class="outline-text-3" id="text-1-6">
<ul class="org-ul">
<li>每个工具都有其优点,也有其局限性. ts的局限性总计起来就是</li>
</ul>
</div>
<div id="outline-container-org24b876b" class="outline-4">
<h4 id="org24b876b"><span class="section-number-4">1.6.1.</span> A Remedy for Bad Code</h4>
<div class="outline-text-4" id="text-1-6-1">
<ul class="org-ul">
<li>ts只会enforce type safety,它不会强制你使用任何的structure(比如class等)</li>
</ul>
</div>
</div>
<div id="outline-container-orga0ca578" class="outline-4">
<h4 id="orga0ca578"><span class="section-number-4">1.6.2.</span> Extensions to JavaScript(Mostly)</h4>
<div class="outline-text-4" id="text-1-6-2">
<ul class="org-ul">
<li>ts的设计目标说,it should:
<ul class="org-ul">
<li>遵守当前的,以及未来的ECMAScript proposal</li>
<li>能够适配所有js的runtime(比如老版本的IE11)</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgd82b5c3" class="outline-4">
<h4 id="orgd82b5c3"><span class="section-number-4">1.6.3.</span> SLower Than JavaScript</h4>
<div class="outline-text-4" id="text-1-6-3">
<ul class="org-ul">
<li>关于ts比js慢的观点,是不准确,而且有诱导性的,因为ts慢是因为它首先要转成js,而且编译的时候有类型检查</li>
</ul>
</div>
</div>
<div id="outline-container-org042476e" class="outline-4">
<h4 id="org042476e"><span class="section-number-4">1.6.4.</span> Finished Evolving</h4>
<div class="outline-text-4" id="text-1-6-4">
<ul class="org-ul">
<li>随着web的继续发展,ts也会不断演进</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org4c801c4" class="outline-2">
<h2 id="org4c801c4"><span class="section-number-2">2.</span> Chapter 2: The Type System</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-org9bdfef1" class="outline-3">
<h3 id="org9bdfef1"><span class="section-number-3">2.1.</span> What's in a Type?</h3>
<div class="outline-text-3" id="text-2-1">
<ul class="org-ul">
<li>所谓的shape,是指有哪些property和method在一个value上,也可以理解为内置的typeof操作符对这个value的解释</li>
<li><p>
比如下面的js代码,如果给ts来理解,它肯定能知道singer是一个string type的变量
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">singer</span> = <span style="color: #3548cf;">"Aretha"</span>
</pre>
</div></li>
<li>js中有如下七中原生类型,ts也同样视他们为原生类型:
<ul class="org-ul">
<li>null</li>
<li>undefined</li>
<li>boolean</li>
<li>string</li>
<li>number</li>
<li>bigint</li>
<li>symbol</li>
</ul></li>
</ul>
</div>
<div id="outline-container-org60c3a23" class="outline-4">
<h4 id="org60c3a23"><span class="section-number-4">2.1.1.</span> Type Systems</h4>
<div class="outline-text-4" id="text-2-1-1">
<ul class="org-ul">
<li>TypeScript的type system总体上是安装如下流程工作的:
<ul class="org-ul">
<li>读取你的代码,理解代码中所有的type,和所有的value</li>
<li>对每个value,试着从其初始化的地方理解其可能有的类型</li>
<li>对每个value,看看在后续代码里面其使用的方式(有没有超过其类型所限)</li>
<li>如果value采用了不符合其类型的操作,反馈给用户</li>
</ul></li>
<li>我们以一个例子来介绍下上面的几步都是什么意思:
<ul class="org-ul">
<li><p>
代码如下
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">firstName</span> = <span style="color: #3548cf;">"Whiteney"</span>;
firstName.length<span style="color: #000000;">()</span>;
<span style="color: #7f0000;">//        </span><span style="color: #7f0000;">~~~~~~</span>
<span style="color: #7f0000;">//  </span><span style="color: #7f0000;">This expression is not callable.</span>
<span style="color: #7f0000;">//    </span><span style="color: #7f0000;">Type 'Number' has no call signatures</span>
</pre>
</div></li>
<li>ts能够得到上面的报警,是依次通过如下步骤获得的:
<ol class="org-ol">
<li>读取代码,并且理解了代码里面有个变量叫做firstName</li>
<li>总结出来firstName是string类型的,因为它的初始化值为"Whitney"</li>
<li>发现代码会去让firstName去调用.length这个method</li>
<li>终于得到机会进行警告: .length是一个member,而不是一个函数</li>
</ol></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgeae9c5e" class="outline-4">
<h4 id="orgeae9c5e"><span class="section-number-4">2.1.2.</span> Kinds of Errors</h4>
<div class="outline-text-4" id="text-2-1-2">
<ul class="org-ul">
<li>在ts里面一般会遇到两种错误:
<ul class="org-ul">
<li>syntax error: 可以认为是严重错误,导致ts无法转换成js代码(虽然也会产生js代码,但是肯定是错误的,无法运行的)</li>
<li><p>
type error: 可以认为是普通告警,syntax error不存在的情况下(所以ts成功转换成了js代码),但是ts 编译器
认为你的代码可能出错.注意type error是说,从type类型的角度上讲,你是错误的.但是从动态语言的角度讲,
不一定是错误的.比如下面的代码,一个变量开始是字符类型,后来被赋值了true,在ts看来就是type error,但是js
看来,这是再正常不过的代码
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">lastName</span> = <span style="color: #3548cf;">"King"</span>;
lastName = <span style="color: #0000b0;">true</span>;
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org3f6b714" class="outline-3">
<h3 id="org3f6b714"><span class="section-number-3">2.2.</span> Assignability</h3>
<div class="outline-text-3" id="text-2-2">
<ul class="org-ul">
<li><p>
ts会读取变量的初始化值来判断其类型,如果后面赋值的时候类型一样还好,如果类型不一样,那么报警是跑不了
的了,而且报的就是Type error
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">lastName</span> = <span style="color: #3548cf;">"King"</span>;
lastName = <span style="color: #0000b0;">true</span>;
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Error: Type 'boolean' is not assignable to type 'string'.</span>
</pre>
</div></li>
</ul>
</div>
<div id="outline-container-orgfd9d357" class="outline-4">
<h4 id="orgfd9d357"><span class="section-number-4">2.2.1.</span> Understanding Assignability Errors</h4>
<div class="outline-text-4" id="text-2-2-1">
<ul class="org-ul">
<li>我们要试着理解Type Error报警:
<ul class="org-ul">
<li>比如 Type 'A' is not assignable to type 'B'</li>
<li>意思就是类型A无法赋值给类型B, 类型B是接受者(变量), 类型A是赋值者(新的类型)</li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org2fae039" class="outline-3">
<h3 id="org2fae039"><span class="section-number-3">2.3.</span> Type Annotations</h3>
<div class="outline-text-3" id="text-2-3">
<ul class="org-ul">
<li>如果一个变量没有设置初始化的值,那么ts显然不能assume它的类型,这种情况下,ts认为这个变量的类型是any</li>
<li>any类型很奇怪:
<ul class="org-ul">
<li><p>
一个any类型的变量可以先后被赋值任何类型的数值.如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">rocker</span>;                     <span style="color: #7f0000;">// </span><span style="color: #7f0000;">Type: any</span>
rocker.<span style="color: #721045;">toUpperCase</span><span style="color: #000000;">()</span>;

rocker = 19.58;
rocker.<span style="color: #721045;">toPrecision</span><span style="color: #000000;">(</span>1<span style="color: #000000;">)</span>;
</pre>
</div></li>
<li><p>
但是每次赋值相当于让当前变量处于某个类型,不过不能调用其他类型的method,如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">rocker</span>;                     <span style="color: #7f0000;">// </span><span style="color: #7f0000;">Type: any</span>
rocker.<span style="color: #721045;">toUpperCase</span><span style="color: #000000;">()</span>;

rocker = 19.58;
rocker.<span style="color: #721045;">toPrecision</span><span style="color: #000000;">(</span>1<span style="color: #000000;">)</span>;

rocker.<span style="color: #721045;">toUpperCase</span><span style="color: #000000;">()</span>;           <span style="color: #7f0000;">// </span><span style="color: #7f0000;">error    2339   Property 'toUpperCase' does not exist on type 'number'. (typescript-</span><span style="color: #005e8b;">tide</span><span style="color: #7f0000;">)</span>

</pre>
</div></li>
</ul></li>
<li>使用any类型是不推荐的,因为它本质上是一种妥协,一旦设置了any, ts的很多类型检查就不再起作用了</li>
<li>如果没有初始化值,但是还想要设置类型怎么办? ts给出的解决方案是type annotation:
<ul class="org-ul">
<li><p>
type annotation的代码如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">rocker</span>: <span style="color: #531ab6;">string</span>;
rocker = <span style="color: #3548cf;">"Joan Jett"</span>;
</pre>
</div></li>
<li><p>
type annotation是ts的特有syntax, js无法理解. tsc会把上面的ts代码编译成如下的js代码
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #531ab6;">var</span> <span style="color: #005e8b;">rocker</span>;
rocker = <span style="color: #3548cf;">"Joan Jett"</span>;
</pre>
</div></li>
</ul></li>
</ul>
</div>
<div id="outline-container-orgaf733bc" class="outline-4">
<h4 id="orgaf733bc"><span class="section-number-4">2.3.1.</span> Unnecessary Type Annotaions</h4>
<div class="outline-text-4" id="text-2-3-1">
<ul class="org-ul">
<li>只有在没有初始化值的情况下才需要type annotation,否则:
<ul class="org-ul">
<li>如果类型和初始化值一样,那么type annotation是多此一举</li>
<li>如果类型和初始化值不一样,那么还会报错</li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org00f0621" class="outline-3">
<h3 id="org00f0621"><span class="section-number-3">2.4.</span> Type Shapes</h3>
<div class="outline-text-3" id="text-2-4">
<ul class="org-ul">
<li>typescript不仅仅能检查赋值的时候类型是否匹配,还会理解object的shape</li>
<li>所谓object的shape,就是object能够拥有哪些:
<ul class="org-ul">
<li>property</li>
<li>method</li>
</ul></li>
</ul>
</div>
<div id="outline-container-org1fd881f" class="outline-4">
<h4 id="org1fd881f"><span class="section-number-4">2.4.1.</span> Modules</h4>
<div class="outline-text-4" id="text-2-4-1">
<ul class="org-ul">
<li>js自己是没有包版本管理系统的,直到2015年ECMAScript添加了ECMAScript modules(ESM),标准化了如下两个命令:
<ul class="org-ul">
<li><p>
import: 用来从其他文件读取value
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #531ab6;">import</span> <span style="color: #000000;">{</span> value <span style="color: #000000;">}</span> from <span style="color: #3548cf;">"./values"</span>;
</pre>
</div></li>
<li><p>
export: 用来把value导出到其他文件
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #531ab6;">export</span> <span style="color: #531ab6;">const</span> <span style="color: #005e8b;">doubled</span> = value * 2;
</pre>
</div></li>
</ul></li>
<li>本书为了和ECAMScript规范相一致,会严格区分如下两个概念:
<ul class="org-ul">
<li>Module: 包含export或者import的文件</li>
<li>Script: 不是module的文件,都是script</li>
</ul></li>
<li>ts自然是能和Module以及Script都处理好关系的,这是最低要求</li>
<li>moduleA里面如果定义了一个变量, 并不会和moduleB里面定义的其他同名变量相conflict(例外情况是你非要从
moduleB里面import那肯定不行,比如下面的例子),这也是module的魅力
<ul class="org-ul">
<li><p>
两个module里面相同名字,没问题
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #7f0000;">// </span><span style="color: #7f0000;">a.ts</span>
<span style="color: #531ab6;">export</span> <span style="color: #531ab6;">const</span> <span style="color: #005e8b;">shared</span> = <span style="color: #3548cf;">"Cher"</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">b.ts</span>
<span style="color: #531ab6;">export</span> <span style="color: #531ab6;">const</span> <span style="color: #005e8b;">shared</span> = <span style="color: #3548cf;">"Cher"</span>;
</pre>
</div></li>
<li><p>
两个module里面相同名字,但是你要从另外一个module import,那么就会declaration conflicts啦
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #7f0000;">// </span><span style="color: #7f0000;">a.ts</span>
<span style="color: #531ab6;">export</span> <span style="color: #531ab6;">const</span> <span style="color: #005e8b;">shared</span> = <span style="color: #3548cf;">"Cher"</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">c.ts</span>
<span style="color: #531ab6;">import</span> <span style="color: #000000;">{</span> shared <span style="color: #000000;">}</span> <span style="color: #531ab6;">from</span> <span style="color: #3548cf;">"./a"</span>;
<span style="color: #7f0000;">//       </span><span style="color: #7f0000;">~~~~~~</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Error: Import declaration conflicts with local declaration of 'shared'.</span>

<span style="color: #531ab6;">export</span> <span style="color: #531ab6;">const</span> <span style="color: #005e8b;">shared</span> = <span style="color: #3548cf;">"Cher"</span>;
<span style="color: #7f0000;">//           </span><span style="color: #7f0000;">~~~~~~</span>
<span style="color: #7f0000;">//  </span><span style="color: #7f0000;">Error: Individual declarations in merged declaration</span>
<span style="color: #7f0000;">//  </span><span style="color: #7f0000;">'shared' must b all exported or all local</span>
</pre>
</div></li>
</ul></li>
<li>在script里面,可以就不一样了,scriptA里面定义了一个变量,那么ts就认为他是全局的,同一个project下面的另
外一个scriptB文件就完全不能再定义同一个名字的变量了.
<ul class="org-ul">
<li><p>
例子如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #7f0000;">// </span><span style="color: #7f0000;">a.ts</span>
<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">shared</span> = <span style="color: #3548cf;">"Cher"</span>;
<span style="color: #7f0000;">//    </span><span style="color: #7f0000;">~~~~~~</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Cannot redeclare block-scoped variable 'shared'.</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">b.ts</span>
<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">shared</span> = <span style="color: #3548cf;">"Cher"</span>;
<span style="color: #7f0000;">//    </span><span style="color: #7f0000;">~~~~~~</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Cannot redeclare block-scoped variable 'shared'.</span>
</pre>
</div></li>
<li>上面的俩个文件虽然是.ts文件,但是由于没有import也没有export,那么就认为是普通script(不是module),于
是两个文件里面连同名变量都不能有</li>
<li>以后一旦看到"Cannot redeclare &#x2026;",那么看看是不是你的文件可能是script,避免这个错误的办法可以是转
换script成module</li>
<li><p>
如果实在不需要export和import,还想让你的script成为module,那么可以使用一个export {}.如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #7f0000;">// </span><span style="color: #7f0000;">a.ts and b.ts</span>
<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">shared</span> = <span style="color: #3548cf;">"Cher"</span>           <span style="color: #7f0000;">// </span><span style="color: #7f0000;">ok</span>
<span style="color: #531ab6;">export</span> <span style="color: #000000;">{}</span>;
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org70a5cd7" class="outline-2">
<h2 id="org70a5cd7"><span class="section-number-2">3.</span> Chapter 3: Unions and Literals</h2>
<div class="outline-text-2" id="text-3">
<ul class="org-ul">
<li>本章主要介绍如下两个特性:
<ul class="org-ul">
<li>Unions: 可以让一个value承载两种或者多种类型</li>
<li>Narrowing: 可以让一个value承载除了某几种类型以外的类型</li>
</ul></li>
</ul>
</div>
<div id="outline-container-orgba58751" class="outline-3">
<h3 id="orgba58751"><span class="section-number-3">3.1.</span> Union Types</h3>
<div class="outline-text-3" id="text-3-1">
<ul class="org-ul">
<li>有种情况,某个类型可能是多种类型
<ul class="org-ul">
<li><p>
代码如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">mathematician</span> = Math.<span style="color: #721045;">random</span><span style="color: #000000;">()</span> &gt; 0.5
  ? <span style="color: #0000b0;">undefined</span>
  : <span style="color: #3548cf;">"Mark Goldberg"</span>;
</pre>
</div></li>
<li>mathematician是一个either undefined or string的变量.这种"either or"类型在ts
里面就叫做union</li>
<li><p>
Typescript的编译器会分析出来,并且给出mathematician的类型判断如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">mathematician</span>: <span style="color: #531ab6;">string</span> | <span style="color: #0000b0;">undefined</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
<div id="outline-container-orgc3c5261" class="outline-4">
<h4 id="orgc3c5261"><span class="section-number-4">3.1.1.</span> Declaring Union Types</h4>
<div class="outline-text-4" id="text-3-1-1">
<ul class="org-ul">
<li><p>
union type的定义例子如下: 虽然thinker已经有了初始化值null,但是因为它有可能后面变成string,所以还是
给它一个string的定义
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">thinker</span>: <span style="color: #531ab6;">string</span> | <span style="color: #0000b0;">null</span> = <span style="color: #0000b0;">null</span>;

<span style="color: #531ab6;">if</span> <span style="color: #000000;">(</span>Math.<span style="color: #721045;">random</span><span style="color: #dd22dd;">()</span> &gt; 0.5<span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  thinker = <span style="color: #3548cf;">"Susanne Langer"</span>;   <span style="color: #7f0000;">// </span><span style="color: #7f0000;">ok</span>
<span style="color: #000000;">}</span>
</pre>
</div></li>
<li>union里面的多个类型的先后顺序是不重要的</li>
</ul>
</div>
</div>
<div id="outline-container-orgac1c1dc" class="outline-4">
<h4 id="orgac1c1dc"><span class="section-number-4">3.1.2.</span> Union Preperties</h4>
<div class="outline-text-4" id="text-3-1-2">
<ul class="org-ul">
<li><p>
如果一个类型是union的,那么ts只允许你访问union内部所有类型都有的member property. 访问只有部分类型有
的member property是会报type-checking error的,例子如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">physicist</span> = Math.<span style="color: #721045;">random</span><span style="color: #000000;">()</span> &gt; 0.5
  ? <span style="color: #3548cf;">"Marie Curie"</span>
  : 84;

physicist.<span style="color: #721045;">toString</span><span style="color: #000000;">()</span>;


<span style="color: #7f0000;">////////////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">error TS2339: Property 'toUpperCase' does not exist on type 'string | number'. //</span>
<span style="color: #7f0000;">////////////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">physicist.</span><span style="color: #721045;">toUpperCase</span><span style="color: #7f0000;">();</span>


<span style="color: #7f0000;">////////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">error TS2339: Property 'toFixed' does not exist on type 'string | number'. //</span>
<span style="color: #7f0000;">////////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">physicist.</span><span style="color: #721045;">toFixed</span><span style="color: #7f0000;">();</span>
</pre>
</div></li>
<li>为了能够使用只有某一种类型上才有的property, 代码需要告诉ts,在某处的code是one of those more specific
type:这个过程叫做narrowing</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orga09eda6" class="outline-3">
<h3 id="orga09eda6"><span class="section-number-3">3.2.</span> Narrowing</h3>
<div class="outline-text-3" id="text-3-2">
<ul class="org-ul">
<li>narrowing的方法有两种:
<ul class="org-ul">
<li>一种通过assignment</li>
<li>另外一种通过check</li>
</ul></li>
</ul>
</div>
<div id="outline-container-org1c0a448" class="outline-4">
<h4 id="org1c0a448"><span class="section-number-4">3.2.1.</span> Assignment Narrowing</h4>
<div class="outline-text-4" id="text-3-2-1">
<ul class="org-ul">
<li>assignment narrowing又有两种情况:
<ul class="org-ul">
<li><p>
初始化为其中一个类型
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">physicist</span>: <span style="color: #531ab6;">number</span> | <span style="color: #531ab6;">string</span> = 83;

physicist.<span style="color: #721045;">toString</span><span style="color: #000000;">()</span>;

<span style="color: #7f0000;">////////////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">error TS2339: Property 'toUpperCase' does not exist on type 'string | number'. //</span>
<span style="color: #7f0000;">////////////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">physicist.</span><span style="color: #721045;">toUpperCase</span><span style="color: #7f0000;">();</span>

physicist.<span style="color: #721045;">toFixed</span><span style="color: #000000;">()</span>;
</pre>
</div></li>
<li><p>
赋值为其中一个类型
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">physicist</span> = Math.<span style="color: #721045;">random</span><span style="color: #000000;">()</span> &gt; 0.5 ? <span style="color: #3548cf;">"Marie Curie"</span> : 84;

physicist.<span style="color: #721045;">toString</span><span style="color: #000000;">()</span>;

physicist = <span style="color: #3548cf;">"Hedy Lamarr"</span>;
physicist.<span style="color: #721045;">toUpperCase</span><span style="color: #000000;">()</span>;

<span style="color: #7f0000;">////////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">error TS2339: Property 'toFixed' does not exist on type 'string | number'. //</span>
<span style="color: #7f0000;">////////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">physicist.</span><span style="color: #721045;">toFixed</span><span style="color: #7f0000;">();</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orge222bed" class="outline-4">
<h4 id="orge222bed"><span class="section-number-4">3.2.2.</span> Conditional Checks</h4>
<div class="outline-text-4" id="text-3-2-2">
<ul class="org-ul">
<li><p>
ts非常聪明,能够判定if statement里面的变量当前是什么类型.下面的例子中在if里面scientist是字符串类型,
但是出了循环scientist就不再单单是字符串类型了
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">scientist</span> = Math.<span style="color: #721045;">random</span><span style="color: #000000;">()</span> &gt; 0.5 ? <span style="color: #3548cf;">"Rosalind Franklin"</span> : 51;

<span style="color: #531ab6;">if</span> <span style="color: #000000;">(</span>scientist === <span style="color: #3548cf;">"Rosalind Franklin"</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">Type of scientist: string</span>
  scientist.<span style="color: #721045;">toUpperCase</span><span style="color: #dd22dd;">()</span>; <span style="color: #7f0000;">// </span><span style="color: #005e8b;">ok</span>
<span style="color: #000000;">}</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">error TS2339: Property 'toUpperCase' does not exist on type 'string | number'.</span>
<span style="color: #7f0000;">//////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">scientist.</span><span style="color: #721045;">toUpperCase</span><span style="color: #7f0000;">(); //</span>
<span style="color: #7f0000;">//////////////////////////////</span>
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-org1236e0d" class="outline-4">
<h4 id="org1236e0d"><span class="section-number-4">3.2.3.</span> Typeof Checks</h4>
<div class="outline-text-4" id="text-3-2-3">
<ul class="org-ul">
<li>除了用直接的等于(<code>=</code>)判断,typescript还支持typeof的结果</li>
<li><p>
typeof首先可以判断true的情况
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">researcher</span> = Math.<span style="color: #721045;">random</span><span style="color: #000000;">()</span> &gt; 0.5 ? <span style="color: #3548cf;">"Rosalind Franklin"</span> : 51;

<span style="color: #531ab6;">if</span> <span style="color: #000000;">(</span><span style="color: #531ab6;">typeof</span> researcher === <span style="color: #3548cf;">"string"</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  researcher.<span style="color: #721045;">toUpperCase</span><span style="color: #dd22dd;">()</span>; <span style="color: #7f0000;">// </span><span style="color: #005e8b;">ok</span>
<span style="color: #000000;">}</span>
</pre>
</div></li>
<li><p>
typeof也可以判断false的情况
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">researcher</span> = Math.<span style="color: #721045;">random</span><span style="color: #000000;">()</span> &gt; 0.5 ? <span style="color: #3548cf;">"Rosalind Franklin"</span> : 51;

<span style="color: #531ab6;">if</span> <span style="color: #000000;">(</span>!<span style="color: #dd22dd;">(</span><span style="color: #531ab6;">typeof</span> researcher === <span style="color: #3548cf;">"string"</span><span style="color: #dd22dd;">)</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  researcher.<span style="color: #721045;">toFixed</span><span style="color: #dd22dd;">()</span>; <span style="color: #7f0000;">// </span><span style="color: #005e8b;">ok</span>
<span style="color: #000000;">}</span> <span style="color: #531ab6;">else</span> <span style="color: #000000;">{</span>
  researcher.<span style="color: #721045;">toUpperCase</span><span style="color: #dd22dd;">()</span>; <span style="color: #7f0000;">// </span><span style="color: #005e8b;">ok</span>
<span style="color: #000000;">}</span>
</pre>
</div></li>
<li><p>
我们还可以把typeof写成三元表达式的情况
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">researcher</span> = Math.<span style="color: #721045;">random</span><span style="color: #000000;">()</span> &gt; 0.5 ? <span style="color: #3548cf;">"Rosalind Franklin"</span> : 51;

<span style="color: #531ab6;">typeof</span> researcher === <span style="color: #3548cf;">"string"</span>
  ? researcher.<span style="color: #721045;">toUpperCase</span><span style="color: #000000;">()</span> <span style="color: #7f0000;">// </span><span style="color: #005e8b;">ok</span>
  : researcher.<span style="color: #721045;">toFixed</span><span style="color: #000000;">()</span>; <span style="color: #7f0000;">// </span><span style="color: #005e8b;">ok</span>
</pre>
</div></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgc832dd3" class="outline-3">
<h3 id="orgc832dd3"><span class="section-number-3">3.3.</span> Literal Types</h3>
<div class="outline-text-3" id="text-3-3">
<ul class="org-ul">
<li>先来看个例子
<ul class="org-ul">
<li><p>
例子如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">philosopher</span> = <span style="color: #3548cf;">"Hypatia"</span>;
</pre>
</div></li>
<li>这个例子中的philosopher是一个string类型,这也是我们之前学到的内容</li>
<li>我们这里要学到的是,philosopher不仅仅是string类型,它还是一个更具体的类型,叫做"specific Hypatia"类型</li>
<li><p>
这种"更具体的类型",就是literal type,具体点说就是
</p>
<pre class="example" id="orgb4ffde7">
The type of a value that is known to be a specific value of a primitive,
rather than any of those primitive's value at all
</pre></li>
</ul></li>
<li>我们来看看"string类型"和"Hypatia类型"的区别:
<ul class="org-ul">
<li>primitive type string代表了所有可能的字符串</li>
<li>literal type Hypatia只能代表一种字符串</li>
</ul></li>
<li><p>
如果你创建了变量,并且给它设置为const,那么ts就直接给这个变量设置为literal type,比如下面的例子中,
mathematician的类型就是 "Mark Goldberg"
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">mathematician</span> = <span style="color: #3548cf;">"Mark Goldberg"</span>;
</pre>
</div></li>
<li><p>
你可以把每个primitive type都看成是所有可能的literal value的union
</p>
<pre class="example" id="org2946694">
You can think of each primitive type as a union of every possible matching literal value
</pre></li>
<li><p>
union type annotation可以混合literal和primitive,比如下面的例子
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">lifespan</span>: <span style="color: #531ab6;">number</span> | <span style="color: #3548cf;">"ongoing"</span> | <span style="color: #3548cf;">"uncertain"</span>;

lifespan = 89;                   <span style="color: #7f0000;">// </span><span style="color: #7f0000;">ok</span>
lifespan = <span style="color: #3548cf;">"ongoing"</span>;            <span style="color: #7f0000;">// </span><span style="color: #7f0000;">ok</span>

<span style="color: #7f0000;">/////////////////////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">error TS2322: Type 'true' is not assignable to type 'number | "ongoing" | "uncertain"'. //</span>
<span style="color: #7f0000;">/////////////////////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">//</span><span style="color: #7f0000;">lifespan = true;</span>
</pre>
</div></li>
</ul>
</div>
<div id="outline-container-org623d894" class="outline-4">
<h4 id="org623d894"><span class="section-number-4">3.3.1.</span> Literal Assignability</h4>
<div class="outline-text-4" id="text-3-3-1">
<ul class="org-ul">
<li>literal type可不是简单说说一下,它真的是一个类型:
<ul class="org-ul">
<li>我们知道,不通的primitive 类型相互之间不能赋值:比如number和string不能相互赋值</li>
<li>不同的literal type之间也不能相互赋值(虽然他们属于同一种primitive type)</li>
</ul></li>
<li>我们可以从下面的例子证明这一点:
<ul class="org-ul">
<li><p>
例子如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">specificallyAda</span>: <span style="color: #3548cf;">"Ada"</span>;
specificallyAda = <span style="color: #3548cf;">"Ada"</span>;         <span style="color: #7f0000;">// </span><span style="color: #7f0000;">ok</span>

<span style="color: #7f0000;">/////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">error TS2322: Type '"Byron"' is not assignable to type '"Ada"'. //</span>
<span style="color: #7f0000;">/////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">specificallyAda = "Byron";</span>

<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">someStirng</span> = <span style="color: #3548cf;">""</span>;            <span style="color: #7f0000;">// </span><span style="color: #7f0000;">Type: string</span>

<span style="color: #7f0000;">////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">error TS2322: Type 'string' is not assignable to type '"Ada"'. //</span>
<span style="color: #7f0000;">////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">specificallyAda = someStirng</span>
</pre>
</div></li>
<li><p>
注意,创建一个literal type除了使用const,还可以把literal 类型像其他类型一样写在':'后面,但是注意,虽
然specificallyAda的值只能是"Ada"(因为他是"Ada"类型的),但是初始化之后没有赋值,还是不能访问的,否则
会报错.例子如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">specificallyAda</span>: <span style="color: #3548cf;">"Ada"</span>;

<span style="color: #7f0000;">/////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">error TS2454: Variable 'specificallyAda' is used before being assigned. //</span>
<span style="color: #7f0000;">/////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">console.</span><span style="color: #721045;">log</span><span style="color: #7f0000;">(specificallyAda)</span>

specificallyAda = <span style="color: #3548cf;">"Ada"</span>;         <span style="color: #7f0000;">// </span><span style="color: #7f0000;">ok</span>
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>specificallyAda<span style="color: #000000;">)</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Ada</span>
</pre>
</div></li>
</ul></li>
<li>literal type相互之间不可用赋值,但是literal type却可以"向上"赋值给自己所在的primitive type,这也是
literal type作为比primitive低一个级别类型的特点."向上"赋值随时可见,只是我们没有想到.比如下面这两个
都是向上赋值:
<ul class="org-ul">
<li><p>
比较"严谨"的向上赋值
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">smile</span> : <span style="color: #3548cf;">":)"</span>;
smile = <span style="color: #3548cf;">":)"</span>;
<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">something</span> = <span style="color: #3548cf;">""</span>;

something = smile
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>something<span style="color: #000000;">)</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">:)</span>
</pre>
</div></li>
<li><p>
比较"常见"的向上赋值,其实是上面"严谨"版本的简化版
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">someString</span> = <span style="color: #3548cf;">":)"</span>;
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org386ef53" class="outline-3">
<h3 id="org386ef53"><span class="section-number-3">3.4.</span> Strict Null Checking</h3>
<div class="outline-text-3" id="text-3-4">
<ul class="org-ul">
<li>narrowed union在加上literal能够让ts非常从容的处理strict null checking</li>
</ul>
</div>
<div id="outline-container-org977e08f" class="outline-4">
<h4 id="org977e08f"><span class="section-number-4">3.4.1.</span> The Billion-Dollar Mistake</h4>
<div class="outline-text-4" id="text-3-4-1">
<ul class="org-ul">
<li>所谓的billion-dollar mistake是指, null value的发明者认为这不是一个好的发明,把null value引入编程语言
导致了几十亿美元的损失.</li>
<li>ts的编译器包含了很多option,允许我们配置编译器,最著名的一个选项就是strictNullChecks:
<ul class="org-ul">
<li><p>
如果enable,那么null(undefined)不能赋值给其他类型变量,默认的配置就是这样的
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">someString</span> = <span style="color: #3548cf;">"abc"</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>someString<span style="color: #000000;">)</span>

<span style="color: #7f0000;">///////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">error TS2322: Type 'null' is not assignable to type 'string'. //</span>
<span style="color: #7f0000;">///////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">someString = null;</span>
</pre>
</div></li>
<li><p>
如果disable,那么显然就是null(undefined)可以赋值给其他变量.其实质上的原理,就是给每个类型添加如下
代码
</p>
<div class="org-src-container">
<pre class="src src-typescript">| <span style="color: #0000b0;">null</span> | <span style="color: #0000b0;">undefined</span>
</pre>
</div></li>
</ul></li>
<li>ts的最佳实践就是开启strictNullCheck,否则无法规避某些null和undefined对代码的破坏</li>
</ul>
</div>
</div>
<div id="outline-container-orgc626d42" class="outline-4">
<h4 id="orgc626d42"><span class="section-number-4">3.4.2.</span> Truthiness Narrowing</h4>
<div class="outline-text-4" id="text-3-4-2">
<ul class="org-ul">
<li>在js里面,判断一个变量是否为true原理如下:变量只要不是如下值,那么它们就是true:
<ul class="org-ul">
<li>false</li>
<li>0</li>
<li>-0</li>
<li>0n</li>
<li>""</li>
<li>null</li>
<li>undefined</li>
<li>NaN</li>
</ul></li>
<li>基于js的这些设置,那么ts可以在某些if为true的case里面,narrowing类型成功(到一种)
<ul class="org-ul">
<li><p>
例子如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">geneticist</span> = Math.<span style="color: #721045;">random</span><span style="color: #000000;">()</span> &gt; 0.5
  ? <span style="color: #3548cf;">"Barbara McClintock"</span>
  : <span style="color: #0000b0;">undefined</span>;

<span style="color: #531ab6;">if</span> <span style="color: #000000;">(</span>geneticist<span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  geneticist.<span style="color: #721045;">toUpperCase</span><span style="color: #dd22dd;">()</span>;      <span style="color: #7f0000;">// </span><span style="color: #005e8b;">ok</span><span style="color: #7f0000;">: </span><span style="color: #005e8b;">string</span>
<span style="color: #000000;">}</span>

<span style="color: #7f0000;">//////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">error TS18048: 'geneticist' is possibly 'undefined'. //</span>
<span style="color: #7f0000;">//////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">geneticist.</span><span style="color: #721045;">toUpperCase</span><span style="color: #7f0000;">();</span>
</pre>
</div></li>
<li>上面例子中,由于undefined是不可能为true的,那么if 里面是必然是string类型的</li>
<li>在if之外,就不能narrowing了,强制调用toUpperCase()会失败</li>
</ul></li>
<li>注意,这种narrowing只能在true case里面起作用,无法在false case里面起作用,因为空字符串("")和undefined
都被认为是false</li>
</ul>
</div>
</div>
<div id="outline-container-org573ec14" class="outline-4">
<h4 id="org573ec14"><span class="section-number-4">3.4.3.</span> Variables Without Initial Values</h4>
<div class="outline-text-4" id="text-3-4-3">
<ul class="org-ul">
<li>在js里面,如果一个变量声明之后,没有给初始化值,那么这个变量就会初始化成undefined</li>
<li>在ts中如果试图使用一个值为undefined的变量(声明之后没有赋值的变量),ts会报一个特定的错误,
<ul class="org-ul">
<li><p>
代码如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">mathematician</span>: <span style="color: #531ab6;">string</span>;
<span style="color: #7f0000;">///////////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">error TS2454: Variable 'mathematician' is used before being assigned. //</span>
<span style="color: #7f0000;">///////////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">mathematician?.length;</span>

mathematician = <span style="color: #3548cf;">"Mark Goldberg"</span>;
mathematician.length;
</pre>
</div></li>
<li><p>
上面例子中出现了 `?`, 这是ts里面特有的安全链式调用,详细解释如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#36825;&#37324; Error&#23545;&#35937;&#23450;&#20041;&#30340;stack&#26159;&#21487;&#36873;&#21442;&#25968;&#65292;&#22914;&#26524;&#36825;&#26679;&#20889;&#30340;&#35805;&#32534;&#35793;&#22120;&#20250;&#25552;&#31034;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#20986;&#38169; TS2532: Object is possibly 'undefined'.</span>
<span style="color: #531ab6;">return</span> <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Error</span><span style="color: #000000;">()</span>.stack.<span style="color: #721045;">split</span><span style="color: #000000;">(</span><span style="color: #3548cf;">'\n'</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#25105;&#20204;&#21487;&#20197;&#28155;&#21152;?&#25805;&#20316;&#31526;&#65292;&#24403;stack&#23646;&#24615;&#23384;&#22312;&#26102;&#65292;&#35843;&#29992; stack.split&#12290;&#33509;stack&#19981;&#23384;&#22312;&#65292;&#21017;&#36820;&#22238;&#31354;</span>
<span style="color: #531ab6;">return</span> <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Error</span><span style="color: #000000;">()</span>.stack?.<span style="color: #721045;">split</span><span style="color: #000000;">(</span><span style="color: #3548cf;">'\n'</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#20197;&#19978;&#20195;&#30721;&#31561;&#21516;&#20197;&#19979;&#20195;&#30721;</span>
<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">err</span> = <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Error</span><span style="color: #000000;">()</span>;
<span style="color: #531ab6;">return</span> err.stack &amp;&amp; err.stack.<span style="color: #721045;">split</span><span style="color: #000000;">(</span><span style="color: #3548cf;">'\n'</span><span style="color: #000000;">)</span>;
</pre>
</div></li>
<li><p>
注意,如果类型里面union了undefined,那么上面的错误不会发生
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">mathematician</span>: <span style="color: #531ab6;">string</span> | <span style="color: #0000b0;">undefined</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>mathematician?.length<span style="color: #000000;">)</span>;

mathematician = <span style="color: #3548cf;">"Mark Goldberg"</span>;
mathematician.length;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">undefined</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org5a462c7" class="outline-3">
<h3 id="org5a462c7"><span class="section-number-3">3.5.</span> Type Aliases</h3>
<div class="outline-text-3" id="text-3-5">
<ul class="org-ul">
<li><p>
绝大多数情况下,union只有两三个成员,但是也有出现很多成员的情况,如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">rawDataFirst</span>: <span style="color: #531ab6;">boolean</span> | <span style="color: #531ab6;">number</span> | <span style="color: #531ab6;">string</span> | <span style="color: #0000b0;">null</span> | <span style="color: #0000b0;">undefined</span>
<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">rawDataSecond</span>: <span style="color: #531ab6;">boolean</span> | <span style="color: #531ab6;">number</span> | <span style="color: #531ab6;">string</span> | <span style="color: #0000b0;">null</span> | <span style="color: #0000b0;">undefined</span>
<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">rawDataThird</span>: <span style="color: #531ab6;">boolean</span> | <span style="color: #531ab6;">number</span> | <span style="color: #531ab6;">string</span> | <span style="color: #0000b0;">null</span> | <span style="color: #0000b0;">undefined</span>
</pre>
</div></li>
<li><p>
上述例子中的 `boolean | number | string | null | undefined` 被使用了多次,为了保证DRY原则,ts又设计了
重用type列表的type alias,上面的例子就可以改写成如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">type</span> <span style="color: #005f5f;">RawData</span> = <span style="color: #531ab6;">boolean</span> | <span style="color: #531ab6;">number</span> | <span style="color: #531ab6;">string</span> | <span style="color: #0000b0;">null</span> | <span style="color: #0000b0;">undefined</span>

<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">rawDataFirst</span>: <span style="color: #005f5f;">RawData</span>
<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">rawDataSecond</span>: <span style="color: #005f5f;">RawData</span>
<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">rawDataThird</span>: <span style="color: #005f5f;">RawData</span>
</pre>
</div></li>
</ul>
</div>
<div id="outline-container-org7ef6b1e" class="outline-4">
<h4 id="org7ef6b1e"><span class="section-number-4">3.5.1.</span> Type Aliases Are Not JavaScript</h4>
<div class="outline-text-4" id="text-3-5-1">
<ul class="org-ul">
<li>type alias不会编译成javascript,它只存在于typescript里面</li>
<li><p>
既然不会被编译成js,那么你在运行时想access这个变量就是违法的,ts会报警
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">type</span> <span style="color: #005f5f;">SomeType</span> = <span style="color: #531ab6;">string</span> | <span style="color: #0000b0;">undefined</span>;

<span style="color: #7f0000;">////////////////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">error TS2693: 'SomeType' only refers to a type, but is being used as a value here. //</span>
<span style="color: #7f0000;">////////////////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">console.</span><span style="color: #721045;">log</span><span style="color: #7f0000;">(SomeType)</span>
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-org9976b5b" class="outline-4">
<h4 id="org9976b5b"><span class="section-number-4">3.5.2.</span> Combining Type Aliases</h4>
<div class="outline-text-4" id="text-3-5-2">
<ul class="org-ul">
<li><p>
type alias还可以互相引用
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">type</span> <span style="color: #005f5f;">Id</span> = <span style="color: #531ab6;">number</span> | <span style="color: #531ab6;">string</span>

<span style="color: #531ab6;">type</span> <span style="color: #005f5f;">IdMaybe</span> = Id | <span style="color: #0000b0;">undefined</span> | <span style="color: #0000b0;">null</span>; <span style="color: #7f0000;">// </span><span style="color: #7f0000;">Equivalent to: number | string | undefind | null</span>
</pre>
</div></li>
<li><p>
互相引用的时候,不必要又顺序,ts编译器会全局考虑,所以使用未定义的type alias也是允许的
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">type</span> <span style="color: #005f5f;">IdMaybe</span> = Id | <span style="color: #0000b0;">undefined</span> | <span style="color: #0000b0;">null</span>; <span style="color: #7f0000;">// </span><span style="color: #7f0000;">Equivalent to: number | string | undefind | null</span>
<span style="color: #531ab6;">type</span> <span style="color: #005f5f;">Id</span> = <span style="color: #531ab6;">number</span> | <span style="color: #531ab6;">string</span>
</pre>
</div></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org22ff6f6" class="outline-2">
<h2 id="org22ff6f6"><span class="section-number-2">4.</span> Chapter 4: Objects</h2>
<div class="outline-text-2" id="text-4">
</div>
<div id="outline-container-org4b2033a" class="outline-3">
<h3 id="org4b2033a"><span class="section-number-3">4.1.</span> Object Types</h3>
<div class="outline-text-3" id="text-4-1">
<ul class="org-ul">
<li>在ts/js里面,有种创建object的方法叫做object literal
<ul class="org-ul">
<li><p>
样子如下
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">person</span> = <span style="color: #000000;">{</span>
  name: <span style="color: #3548cf;">"adam"</span>,
  age: 23,
<span style="color: #000000;">}</span>;
console.log<span style="color: #000000;">(</span>person<span style="color: #000000;">)</span>
console.log<span style="color: #000000;">(</span><span style="color: #531ab6;">typeof</span><span style="color: #dd22dd;">(</span>person<span style="color: #dd22dd;">)</span><span style="color: #000000;">)</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">{ name: 'adam', age: 23 }</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">object</span>
</pre>
</div></li>
<li>在js的语境中person的类型就是object</li>
</ul></li>
<li>ts中当然也承认这种用法,并且ts还做了js没有做的事情,给新的object person一个更加具体的类型
<ul class="org-ul">
<li>类型名字叫'{name: string; age: number;}'</li>
<li><p>
这个类型我们可以通过typescript playground可以看到,也可以通过如下的"错误"代码看到
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">person</span> = <span style="color: #000000;">{</span>
  name: <span style="color: #3548cf;">"adam"</span>,
  age: 23,
<span style="color: #000000;">}</span>;

<span style="color: #7f0000;">/////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Property 'foo' does not exist on type '{ name: string; age: number; }'. //</span>
<span style="color: #7f0000;">/////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">person.</span><span style="color: #721045;">foo</span><span style="color: #7f0000;">()</span>
</pre>
</div></li>
</ul></li>
<li>在js和ts中,我们都可以使用如下两种方式访问object value的成员:
<ul class="org-ul">
<li>object_value.mameber</li>
<li>object_value['member']</li>
</ul></li>
<li><p>
如果访问不存在的member,那么会报警
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">const</span>  <span style="color: #005e8b;">poet</span> = <span style="color: #000000;">{</span>
  born: 1935,
  name: <span style="color: #3548cf;">"Mary Oliver"</span>,
<span style="color: #000000;">}</span>;

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>poet<span style="color: #dd22dd;">[</span><span style="color: #3548cf;">'born'</span><span style="color: #dd22dd;">]</span><span style="color: #000000;">)</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>poet.name<span style="color: #000000;">)</span>;

<span style="color: #7f0000;">////////////////////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">error TS2339: Property 'end' does not exist on type '{ born: number; name: string; }'. //</span>
<span style="color: #7f0000;">////////////////////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">poet.end;</span>
</pre>
</div></li>
</ul>
</div>
<div id="outline-container-org7b8c3fd" class="outline-4">
<h4 id="org7b8c3fd"><span class="section-number-4">4.1.1.</span> Declaring Object Types</h4>
<div class="outline-text-4" id="text-4-1-1">
<ul class="org-ul">
<li>ts作为一个静态的类型系统语言,当然会提供"显式"定义object type的功能
<ul class="org-ul">
<li><p>
代码如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">poetLater</span>: <span style="color: #000000;">{</span>
  born: <span style="color: #531ab6;">number</span>;
  name: <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">ok</span>
poetLater = <span style="color: #000000;">{</span>
  born: 1935,
  name: <span style="color: #3548cf;">"Mary Oliver"</span>,
<span style="color: #000000;">}</span>;

<span style="color: #7f0000;">//////////////////////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">error TS2322: Type 'string' is not assignable to type '{ born: number; name: string; }'. //</span>
<span style="color: #7f0000;">//////////////////////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">poetLater = "Sappho";</span>
</pre>
</div></li>
<li>注意这里的类型就是type '{ born: number; name: string; }'</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org1a10a9a" class="outline-4">
<h4 id="org1a10a9a"><span class="section-number-4">4.1.2.</span> Aliased Object Types</h4>
<div class="outline-text-4" id="text-4-1-2">
<ul class="org-ul">
<li>我们发现上一节讲到的ts的类型名字都是这样的type '{ born: number; name: string; }', 这种名字是类似"匿名"
的这么一种方式(只有类型的属性,没有名字)</li>
<li><p>
如果我们想给不同的变量赋予类型,显然还是"非匿名"的方式更好,也就是给object type一个名字.这样一来,我们
的error message也会更加易读
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">type</span> <span style="color: #005f5f;">Poet</span> = <span style="color: #000000;">{</span>
  born: <span style="color: #531ab6;">number</span>;
  name: <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>;

<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">poetLater</span>: <span style="color: #005f5f;">Poet</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">ok</span>
poetLater = <span style="color: #000000;">{</span>
  born: 1935,
  name: <span style="color: #3548cf;">"Sara Teasdale"</span>,
<span style="color: #000000;">}</span>;

<span style="color: #7f0000;">///////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">error TS2322: Type 'string' is not assignable to type 'Poet'. //</span>
<span style="color: #7f0000;">///////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">poetLater = "Emily Dickinson"</span>
</pre>
</div></li>
<li>理解ts如何解析object literal对于我们理解ts的type system非常重要,本节内容对后面理解也非常重要</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org85244ee" class="outline-3">
<h3 id="org85244ee"><span class="section-number-3">4.2.</span> Structural Typing</h3>
<div class="outline-text-3" id="text-4-2">
<ul class="org-ul">
<li><p>
TypeScript的类型系统叫做structurally typed: 所谓structurally type,是说一个value"刚好"能满足一个类型,
那么就可以作为这个类型的value. 换句话说就是golang的所谓类型推断(Type inference),不需要显式的类型声明
</p>
<pre class="example" id="orgbbd08ab">
Structurally typing means: any value that happens to satisfy a type is a allowed to be used
as a value of that type.
</pre></li>
<li>下面就是一个structural typing的例子:
<ul class="org-ul">
<li><p>
如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">type</span> <span style="color: #005f5f;">WithFirstName</span> = <span style="color: #000000;">{</span>
  firstName: <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>;

<span style="color: #531ab6;">type</span> <span style="color: #005f5f;">WithLastName</span> = <span style="color: #000000;">{</span>
  lastName: <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>;

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">hasBoth</span> = <span style="color: #000000;">{</span>
  firstName: <span style="color: #3548cf;">"Lucille"</span>,
  lastName: <span style="color: #3548cf;">"Clifton"</span>,
<span style="color: #000000;">}</span>;

<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">withFirstName</span>: <span style="color: #005f5f;">WithFirstName</span> = hasBoth;
<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">withLastName</span>: <span style="color: #005f5f;">WithLastName</span> = hasBoth;

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>withFirstName<span style="color: #000000;">)</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>withLastName<span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">{ firstName: 'Lucille', lastName: 'Clifton' }</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">{ firstName: 'Lucille', lastName: 'Clifton' }</span>
</pre>
</div></li>
<li>这个例子中我们有两个类型WithFirstName和WithLastName,每个类型都只有一个成员.</li>
<li>而hasBoth刚好这两个成员都有,那么即便我们没有"显式"的声明hashBoth属于这两个类型,但是hasBoth确实同
时符合这两个类型,那么一旦有这两个类型的变量需要value,我们的hashBoth就可以提供了.</li>
</ul></li>
<li>需要注意的是Structural typing和duck typing是两个概念:
<ul class="org-ul">
<li>structural tying是有staic system check的,在typescript这里就是type checker</li>
<li>duck typing是没有static system check的,它是在runtime遇到某个属性方法的时候,才去做check. Javascript
就是duck typing的编程语言</li>
</ul></li>
</ul>
</div>
<div id="outline-container-org04b01f5" class="outline-4">
<h4 id="org04b01f5"><span class="section-number-4">4.2.1.</span> Usage Checking</h4>
<div class="outline-text-4" id="text-4-2-1">
<ul class="org-ul">
<li>当我们在为一个value标记object type的时候,typescript会去check这个value是否满足了目标标记的type所需要
的所有成员. 如果缺少成员,那么就会报type error(多了其实也不行,后面会看到. 赋值的时候多了可以,声明的
时候多了不行)</li>
<li>下面就是一个缺少成员而报错的例子
<ul class="org-ul">
<li><p>
代码如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">type</span> <span style="color: #005f5f;">FirstAndLastNames</span> = <span style="color: #000000;">{</span>
  first: <span style="color: #531ab6;">string</span>;
  last: <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">ok</span>
<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">hasBoth</span>: <span style="color: #005f5f;">FirstAndLastNames</span> = <span style="color: #000000;">{</span>
  first: <span style="color: #3548cf;">"Sarojini"</span>,
  last: <span style="color: #3548cf;">"Naidu"</span>,
<span style="color: #000000;">}</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:12:7 - error TS2741: Property 'last' is missing in type '{ first: string; }' but required in type 'FirstAndLastNames'.</span>

<span style="color: #7f0000;">/////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">const hasOnlyOne: FirstAndLastNames = { //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">first: "Sappho",                      //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">};                                      //</span>
<span style="color: #7f0000;">/////////////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
<li>如果数量对上了,但是具体的类型没有满足,也是会报错的.
<ul class="org-ul">
<li><p>
如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">type</span> <span style="color: #005f5f;">TimeRange</span> = <span style="color: #000000;">{</span>
  start: <span style="color: #005f5f;">Date</span>;
<span style="color: #000000;">}</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:6:3 - error TS2322: Type 'string' is not assignable to type 'Date'.</span>

<span style="color: #7f0000;">/////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">const hasStartString: TimeRange = { //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">start: "1979-02-13",              //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">};                                  //</span>
<span style="color: #7f0000;">/////////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org7d0aef3" class="outline-4">
<h4 id="org7d0aef3"><span class="section-number-4">4.2.2.</span> Excess Property Checking</h4>
<div class="outline-text-4" id="text-4-2-2">
<ul class="org-ul">
<li>我们对Typescript的structural typing印象深刻,一来是不需要声明,二来是成员满足即可,成员多了也能赋值成功</li>
<li>如果初始化变量的时候,我们声明了(同时标记了类型),那么成员就必须一模一样,不能少,也不能多了
<ul class="org-ul">
<li><p>
下面的例子中,就是我们在声明的时候,标记了类型,多一个成员activity就会报错
</p>
<div class="org-src-container">
<pre class="src src-js">type Poet = <span style="color: #000000;">{</span>
  born: number;
  name: string;
<span style="color: #000000;">}</span>;

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">poetMatch</span>: Poet = <span style="color: #000000;">{</span>
  born: 1928,
  name: <span style="color: #3548cf;">"Maya Angelou"</span>,
<span style="color: #000000;">}</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:12:3 - error TS2353: Object literal may only specify known properties, and 'activity' does not exist in type 'Poet'.</span>

<span style="color: #7f0000;">///////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">const extraProperty: Poet = { //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">activity: "walking",        //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">born: 1935,                 //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">name: "Mary Oliver",        //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">};                            //</span>
<span style="color: #7f0000;">///////////////////////////////////</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">existingObject</span> = <span style="color: #000000;">{</span>
  activity: <span style="color: #3548cf;">"walking"</span>,
  born: 1935,
  name: <span style="color: #3548cf;">"Mary Oliver"</span>,
<span style="color: #000000;">}</span>;

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">extraProperty</span>: Poet = existingObject; <span style="color: #7f0000;">// </span><span style="color: #7f0000;">Ok</span>
</pre>
</div></li>
<li>我们可以看到,初始化的时候多了是会有问题的(因为这时候往往是mistype), 但是用一个其他value赋值的时候多了是没问题的</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org5512bb2" class="outline-4">
<h4 id="org5512bb2"><span class="section-number-4">4.2.3.</span> Nested Object Types</h4>
<div class="outline-text-4" id="text-4-2-3">
<ul class="org-ul">
<li>由于Javascript object可以nest很多其他的object, typescript也就必须能够表达nested object.</li>
<li>我们在type定义的类型,在使用object literal(而不是value)初始化的时候,必须完全一致
<ul class="org-ul">
<li><p>
下面代码中poemMismatch缺少author成员,所以初始化报错
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">type</span> <span style="color: #005f5f;">Poem</span> = <span style="color: #000000;">{</span>
  author: <span style="color: #dd22dd;">{</span>
    firstName: <span style="color: #531ab6;">string</span>;
    lastName: <span style="color: #531ab6;">string</span>;
  <span style="color: #dd22dd;">}</span>;
  name: <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">ok</span>
<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">poemMatch</span>: <span style="color: #005f5f;">Poem</span> = <span style="color: #000000;">{</span>
  author: <span style="color: #dd22dd;">{</span>
    firstName: <span style="color: #3548cf;">"Sylvia"</span>,
    lastName: <span style="color: #3548cf;">"Plath"</span>,
  <span style="color: #dd22dd;">}</span>,
  name: <span style="color: #3548cf;">"Lady Lazarus"</span>,
<span style="color: #000000;">}</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:20:5 - error TS2353: Object literal may only specify known properties, and 'name' does not exist in type '{ firstName: string; lastName: string; }'.</span>

<span style="color: #7f0000;">//////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">const poemMismatch: Poem = { //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">author: {                  //</span>
<span style="color: #7f0000;">//     </span><span style="color: #7f0000;">name: "Sylvia Plath",    //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">},                         //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">name: "Tuplips",           //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">};                           //</span>
<span style="color: #7f0000;">//////////////////////////////////</span>
</pre>
</div></li>
<li>上面的代码报错比较不容易理解,因为我们的author成员没有文字类型,只能用'{ firstName: string; lastName: string; }'来替代.</li>
<li><p>
一个更好的办法是把nested 类型给拆出来,给与一个名字,比如Author,那么代码更清晰,报错也更易读
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">type</span> <span style="color: #005f5f;">Author</span> = <span style="color: #000000;">{</span>
  firstName: <span style="color: #531ab6;">string</span>;
  lastName: <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>;

<span style="color: #531ab6;">type</span> <span style="color: #005f5f;">Poem</span> = <span style="color: #000000;">{</span>
  author: <span style="color: #005f5f;">Author</span>;
  name: <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:16:5 - error TS2353: Object literal may only specify known properties, and 'name' does not exist in type 'Author'.</span>

<span style="color: #7f0000;">//////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">const poemMismatch: Poem = { //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">author: {                  //</span>
<span style="color: #7f0000;">//     </span><span style="color: #7f0000;">name: "Sylvia Plath",    //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">},                         //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">name: "Tuplips",           //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">};                           //</span>
<span style="color: #7f0000;">//////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgf051efd" class="outline-4">
<h4 id="orgf051efd"><span class="section-number-4">4.2.4.</span> Optional Properties</h4>
<div class="outline-text-4" id="text-4-2-4">
<ul class="org-ul">
<li>Object type可以包含一些"可选"成员,这些成员可以不出现,使用`?`标记
<ul class="org-ul">
<li><p>
比如下面的author成员可以不出现
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">type</span> <span style="color: #005f5f;">Book</span> = <span style="color: #000000;">{</span>
  author?: <span style="color: #531ab6;">string</span>;
  pages: <span style="color: #531ab6;">number</span>;
<span style="color: #000000;">}</span>;

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">ok</span>: <span style="color: #005f5f;">Book</span> = <span style="color: #000000;">{</span>
  author: <span style="color: #3548cf;">"Rita Dove"</span>,
  pages: 80,
<span style="color: #000000;">}</span>;

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">ok2</span>: <span style="color: #005f5f;">Book</span> = <span style="color: #000000;">{</span>
  pages: 90,
<span style="color: #000000;">}</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:15:7 - error TS2741: Property 'pages' is missing in type '{ author: string; }' but required in type 'Book'.</span>

<span style="color: #7f0000;">/////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">const missing: Book = { //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">author: "Rita Dove",  //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">};                      //</span>
<span style="color: #7f0000;">/////////////////////////////</span>
</pre>
</div></li>
<li>但是注意pages是必须出现的,不出现就会报错</li>
</ul></li>
<li>optional参数是可以不存在的,这个和类型为undefined(或者union包含undefined)不一样,后者即便是undefined也要存在
<ul class="org-ul">
<li><p>
例子如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">type</span> <span style="color: #005f5f;">Writers</span> = <span style="color: #000000;">{</span>
  author: <span style="color: #531ab6;">string</span> | <span style="color: #0000b0;">undefined</span>;
  editor?: <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">ok</span>
<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">hasRequired</span>: <span style="color: #005f5f;">Writers</span> = <span style="color: #000000;">{</span>
  author: <span style="color: #0000b0;">undefined</span>,
<span style="color: #000000;">}</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:11:7 - error TS2741: Property 'author' is missing in type '{}' but required in type 'Writers'.</span>

<span style="color: #7f0000;">//////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">const missingRequired: Writers = {}; //</span>
<span style="color: #7f0000;">//////////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org5416994" class="outline-3">
<h3 id="org5416994"><span class="section-number-3">4.3.</span> Unions of Object Types</h3>
<div class="outline-text-3" id="text-4-3">
<ul class="org-ul">
<li>既然普通类型有union,那么object类型的union需求也是合理的</li>
</ul>
</div>
<div id="outline-container-org130c882" class="outline-4">
<h4 id="org130c882"><span class="section-number-4">4.3.1.</span> Inferred Object-Type Unions</h4>
<div class="outline-text-4" id="text-4-3-1">
<ul class="org-ul">
<li>如果我们不明确的"声明"类型,而是直接赋值(通过?:),那么Typescript会自动的为我们创建union type
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">poem</span> =
  Math.<span style="color: #721045;">random</span><span style="color: #000000;">()</span> &gt; 0.5
    ? <span style="color: #000000;">{</span> name: <span style="color: #3548cf;">"The Double Image"</span>, pages: 7 <span style="color: #000000;">}</span>
    : <span style="color: #000000;">{</span> name: <span style="color: #3548cf;">"Her Kind"</span>, rhymes: <span style="color: #0000b0;">true</span> <span style="color: #000000;">}</span>;

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span><span style="color: #3548cf;">`|poem.name| =&gt; </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">poem.name</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #000000;">)</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span><span style="color: #3548cf;">`|poem.pages| =&gt; </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">poem.pages</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #000000;">)</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span><span style="color: #3548cf;">`|poem.rhymes| =&gt; </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">poem.rhymes</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT1====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|poem.name| =&gt; The Double Image</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|poem.pages| =&gt; 7</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|poem.rhymes| =&gt; undefined</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT2====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|poem.name| =&gt; Her Kind</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|poem.pages| =&gt; undefined</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|poem.rhymes| =&gt; true</span>
</pre>
</div></li>
<li>注意,这种Typescript内部帮我们创建的union type和真正的写出来的union type的不同:
<ol class="org-ol">
<li>真正的union type在没有narrow的情况下,只能使用"交集"的成员,比如name</li>
<li>这里的union type在没有narrow的情况下,还能使用"并集"的成员,比如pages, rhymes</li>
</ol></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org474033b" class="outline-4">
<h4 id="org474033b"><span class="section-number-4">4.3.2.</span> Explicit Object-Type Unions</h4>
<div class="outline-text-4" id="text-4-3-2">
<ul class="org-ul">
<li>explicit的把类型列出来做union,而不是让Typescript帮我们创建union是最高的选择,代码清晰,逻辑自然
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">type</span> <span style="color: #005f5f;">PoemWithPages</span> = <span style="color: #000000;">{</span>
  name: <span style="color: #531ab6;">string</span>;
  pages: <span style="color: #531ab6;">number</span>;
<span style="color: #000000;">}</span>;

<span style="color: #531ab6;">type</span> <span style="color: #005f5f;">PoemWithRhymes</span> = <span style="color: #000000;">{</span>
  name: <span style="color: #531ab6;">string</span>;
  rhymes: <span style="color: #531ab6;">boolean</span>;
<span style="color: #000000;">}</span>;

<span style="color: #531ab6;">type</span> <span style="color: #005f5f;">Poem</span> = PoemWithPages | PoemWithRhymes;

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">poem</span>: <span style="color: #005f5f;">Poem</span> =
  Math.<span style="color: #721045;">random</span><span style="color: #000000;">()</span> &gt; 0.5
    ? <span style="color: #000000;">{</span> name: <span style="color: #3548cf;">"The Double Image"</span>, pages: 7 <span style="color: #000000;">}</span>
    : <span style="color: #000000;">{</span> name: <span style="color: #3548cf;">"Her Kind"</span>, rhymes: <span style="color: #0000b0;">true</span> <span style="color: #000000;">}</span>;

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span><span style="color: #3548cf;">`|poem.name| =&gt; </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">poem.name</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT1====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|poem.name| =&gt; The Double Image</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT2====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|poem.name| =&gt; Her Kind</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:27:6 - error TS2339: Property 'pages' does not exist on type 'Poem'.</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">Property 'pages' does not exist on type 'PoemWithRhymes'.</span>

<span style="color: #7f0000;">/////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">poem.pages; //</span>
<span style="color: #7f0000;">/////////////////</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:35:6 - error TS2339: Property 'rhymes' does not exist on type 'Poem'.</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">Property 'rhymes' does not exist on type 'PoemWithPages'.</span>

<span style="color: #7f0000;">//////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">poem.rhymes; //</span>
<span style="color: #7f0000;">//////////////////</span>
</pre>
</div></li>
<li>注意,这里因为是列出来的union,所以只有"交集"name可以在没有narrow的情况下访问</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgc8f1a5b" class="outline-4">
<h4 id="orgc8f1a5b"><span class="section-number-4">4.3.3.</span> Narrowing Object Types</h4>
<div class="outline-text-4" id="text-4-3-3">
<ul class="org-ul">
<li>有union,那么很显然也会有narrow,只不过object narrow的方法有所不同
<ul class="org-ul">
<li><p>
比如下面的例子,我们使用"page" in poem来进行narrow是可以的
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">type</span> <span style="color: #005f5f;">PoemWithPages</span> = <span style="color: #000000;">{</span>
  name: <span style="color: #531ab6;">string</span>;
  pages: <span style="color: #531ab6;">number</span>;
<span style="color: #000000;">}</span>;

<span style="color: #531ab6;">type</span> <span style="color: #005f5f;">PoemWithRhymes</span> = <span style="color: #000000;">{</span>
  name: <span style="color: #531ab6;">string</span>;
  rhymes: <span style="color: #531ab6;">boolean</span>;
<span style="color: #000000;">}</span>;

<span style="color: #531ab6;">type</span> <span style="color: #005f5f;">Poem</span> = PoemWithPages | PoemWithRhymes;

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">poem</span>: <span style="color: #005f5f;">Poem</span> =
  Math.<span style="color: #721045;">random</span><span style="color: #000000;">()</span> &gt; 0.5
    ? <span style="color: #000000;">{</span> name: <span style="color: #3548cf;">"The Double Image"</span>, pages: 7 <span style="color: #000000;">}</span>
    : <span style="color: #000000;">{</span> name: <span style="color: #3548cf;">"Her Kind"</span>, rhymes: <span style="color: #0000b0;">true</span> <span style="color: #000000;">}</span>;

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span><span style="color: #3548cf;">`|poem.name| =&gt; </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">poem.name</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #000000;">)</span>;

<span style="color: #531ab6;">if</span> <span style="color: #000000;">(</span><span style="color: #3548cf;">"pages"</span> <span style="color: #531ab6;">in</span> poem<span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">`|poem.pages| =&gt; </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">poem.pages</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span> <span style="color: #531ab6;">else</span> <span style="color: #000000;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">`|poem.rhymes| =&gt; </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">poem.rhymes</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT1====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|poem.name| =&gt; The Double Image</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|poem.pages| =&gt; 7</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT2====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|poem.name| =&gt; Her Kind</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|poem.rhymes| =&gt; true</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:34:10 - error TS2339: Property 'pages' does not exist on type 'Poem'.</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">Property 'pages' does not exist on type 'PoemWithRhymes'.</span>

<span style="color: #7f0000;">///////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">if (poem.</span><span style="color: #005e8b;">pages</span><span style="color: #7f0000;">) { //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">}                 //</span>
<span style="color: #7f0000;">///////////////////////</span>
</pre>
</div></li>
<li>但是不可以使用if (poem.pages), 因为试图访问一个不存在的property是会触发type error的</li>
<li>typescript足够聪明,判断出俩poem不是PoemWithPages的时候,它能够确定poem必然是PoemWithRhymes,所以else
里面的的poem.rhymes也能够触发而不报错</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org29e335d" class="outline-4">
<h4 id="org29e335d"><span class="section-number-4">4.3.4.</span> Discriminated Unions</h4>
<div class="outline-text-4" id="text-4-3-4">
<ul class="org-ul">
<li>discriminated union是一个在Javascript和Typescript里面都适用的概念,就是专门加一个property(通常是string)
用来indicate object的真实type</li>
<li>这个专门的用来indicate object的type就叫做discriminant, 而Typescript的narrow过程,如果有discriminant
的参与的话,就会事半功倍.
<ul class="org-ul">
<li><p>
示例如下, 下面例子中的poem.type就是discriminant
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">type</span> <span style="color: #005f5f;">PoemWithPages</span> = <span style="color: #000000;">{</span>
  name: <span style="color: #531ab6;">string</span>;
  pages: <span style="color: #531ab6;">number</span>;
  <span style="color: #000000; background-color: #fbf7f0;">type</span>: <span style="color: #3548cf;">"pages"</span>;
<span style="color: #000000;">}</span>;

<span style="color: #531ab6;">type</span> <span style="color: #005f5f;">PoemWithRhymes</span> = <span style="color: #000000;">{</span>
  name: <span style="color: #531ab6;">string</span>;
  rhymes: <span style="color: #531ab6;">boolean</span>;
  <span style="color: #000000; background-color: #fbf7f0;">type</span>: <span style="color: #3548cf;">"rhymes"</span>;
<span style="color: #000000;">}</span>;

<span style="color: #531ab6;">type</span> <span style="color: #005f5f;">Poem</span> = PoemWithPages | PoemWithRhymes;

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">poem</span>: <span style="color: #005f5f;">Poem</span> =
  Math.<span style="color: #721045;">random</span><span style="color: #000000;">()</span> &gt; 0.5
    ? <span style="color: #000000;">{</span> name: <span style="color: #3548cf;">"The Double Image"</span>, pages: 7, <span style="color: #000000; background-color: #fbf7f0;">type</span>: <span style="color: #3548cf;">"pages"</span> <span style="color: #000000;">}</span>
    : <span style="color: #000000;">{</span> name: <span style="color: #3548cf;">"Her Kind"</span>, rhymes: <span style="color: #0000b0;">true</span>, <span style="color: #000000; background-color: #fbf7f0;">type</span>: <span style="color: #3548cf;">"rhymes"</span> <span style="color: #000000;">}</span>;

<span style="color: #531ab6;">if</span> <span style="color: #000000;">(</span>poem.<span style="color: #531ab6;">type</span> === <span style="color: #3548cf;">"pages"</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">`|poem.pages| =&gt; </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">poem.pages</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span> <span style="color: #531ab6;">else</span> <span style="color: #000000;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">`|poem.rhymes| =&gt; </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">poem.rhymes</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span><span style="color: #3548cf;">`|poem.type| =&gt; </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">poem.type</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT1====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|poem.pages| =&gt; 7</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|poem.type| =&gt; pages</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">// &lt;====================OUTPUT2====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|poem.rhymes| =&gt; true</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|poem.type| =&gt; rhymes</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:36:6 - error TS2339: Property 'pages' does not exist on type 'Poem'.</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">Property 'pages' does not exist on type 'PoemWithRhymes'.</span>

<span style="color: #7f0000;">/////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">poem.pages; //</span>
<span style="color: #7f0000;">/////////////////</span>
</pre>
</div></li>
<li>poem.type在if判断后,可以选择书写poem.pages(或者poem.rhymes),否则还是会报错</li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org354f210" class="outline-3">
<h3 id="org354f210"><span class="section-number-3">4.4.</span> Intersection Types</h3>
<div class="outline-text-3" id="text-4-4">
<ul class="org-ul">
<li>在集合里面中:
<ul class="org-ul">
<li>| 代表 union</li>
<li>&amp; 代表 intersection</li>
</ul></li>
<li>既然已经有了使用`|`的union type,会整活的typescript也没有放弃`&amp;`,创建了intersection type
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">type</span> <span style="color: #005f5f;">Artwork</span> = <span style="color: #000000;">{</span>
  genre: <span style="color: #531ab6;">string</span>;
  name: <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>;

<span style="color: #531ab6;">type</span> <span style="color: #005f5f;">Writing</span> = <span style="color: #000000;">{</span>
  pages: <span style="color: #531ab6;">number</span>;
  name: <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>;

<span style="color: #531ab6;">type</span> <span style="color: #005f5f;">WrittenArt</span> = Artwork &amp; Writing;

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">example</span>: <span style="color: #005f5f;">WrittenArt</span> = <span style="color: #000000;">{</span>
  genre: <span style="color: #3548cf;">"Fiction"</span>,
  name: <span style="color: #3548cf;">"The Great Novel"</span>,
  pages: 300,
<span style="color: #000000;">}</span>;

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>example<span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">{ genre: 'Fiction', name: 'The Great Novel', pages: 300 }</span>
</pre>
</div></li>
<li><p>
上面的WrittenArt其实就相当于如下的类型
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">type</span> <span style="color: #005f5f;">WrittenArt</span> = <span style="color: #000000;">{</span>
  genre: <span style="color: #531ab6;">string</span>;
  name: <span style="color: #531ab6;">string</span>;
  pages: <span style="color: #531ab6;">number</span>;
<span style="color: #000000;">}</span>;
</pre>
</div></li>
</ul></li>
<li>集合中的union和intersection可以混用,以提高编程语言的解释力
<ul class="org-ul">
<li><p>
示例如下: 在创建discriminated union的时候,共同类型可以通过,`&amp;`来间接的引入而不需要重复写一遍
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">type</span> <span style="color: #005f5f;">ShortPoem</span> = <span style="color: #000000;">{</span> author: <span style="color: #531ab6;">string</span> <span style="color: #000000;">}</span> &amp; <span style="color: #000000;">(</span>
  | <span style="color: #dd22dd;">{</span> kigo: <span style="color: #531ab6;">string</span>; <span style="color: #000000; background-color: #fbf7f0;">type</span>: <span style="color: #3548cf;">"haiku"</span> <span style="color: #dd22dd;">}</span>
  | <span style="color: #dd22dd;">{</span> meter: <span style="color: #531ab6;">number</span>; <span style="color: #000000; background-color: #fbf7f0;">type</span>: <span style="color: #3548cf;">"villanelle"</span> <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">)</span>;

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">morningGlory</span>: <span style="color: #005f5f;">ShortPoem</span> = <span style="color: #000000;">{</span>
  author: <span style="color: #3548cf;">"Fukuda Chiyo-ni"</span>,
  kigo: <span style="color: #3548cf;">"Morning Glory"</span>,
  <span style="color: #000000; background-color: #fbf7f0;">type</span>: <span style="color: #3548cf;">"haiku"</span>,
<span style="color: #000000;">}</span>;

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span><span style="color: #3548cf;">`|morningGlory| =&gt; </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">morningGlory</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|morningGlory| =&gt; [object Object]</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:17:7 - error TS2322: Type '{ author: string; </span><span style="color: #000000; background-color: #fbf7f0;">type</span><span style="color: #7f0000;">: "villanelle"; }' is not assignable to type 'ShortPoem'.</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">Type '{ author: string; </span><span style="color: #000000; background-color: #fbf7f0;">type</span><span style="color: #7f0000;">: "villanelle"; }' is not assignable to type '{ author: string; } &amp; { meter: number; </span><span style="color: #000000; background-color: #fbf7f0;">type</span><span style="color: #7f0000;">: "villanelle"; }'.</span>
<span style="color: #7f0000;">//     </span><span style="color: #7f0000;">Property 'meter' is missing in type '{ author: string; </span><span style="color: #000000; background-color: #fbf7f0;">type</span><span style="color: #7f0000;">: "villanelle"; }' but required in type '{ meter: number; </span><span style="color: #000000; background-color: #fbf7f0;">type</span><span style="color: #7f0000;">: "villanelle"; }'.</span>

<span style="color: #7f0000;">///////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">const oneArt: ShortPoem = {   //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">author: "Elizabeth Bishop", //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">type: "villanelle",         //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">};                            //</span>
<span style="color: #7f0000;">///////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
<div id="outline-container-orgb0cd320" class="outline-4">
<h4 id="orgb0cd320"><span class="section-number-4">4.4.1.</span> Dangers of Intersection Types</h4>
<div class="outline-text-4" id="text-4-4-1">
<ul class="org-ul">
<li>intersection type会让作者和编译器都困惑,我们最好不要使用这个特性</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org7145187" class="outline-2">
<h2 id="org7145187"><span class="section-number-2">5.</span> Chapter 5: Functions</h2>
<div class="outline-text-2" id="text-5">
</div>
<div id="outline-container-orgf7e4d5f" class="outline-3">
<h3 id="orgf7e4d5f"><span class="section-number-3">5.1.</span> Function Parameters</h3>
<div class="outline-text-3" id="text-5-1">
<ul class="org-ul">
<li>对于typescript来说,函数参数也必须声明类型,否则会报错
<ul class="org-ul">
<li><p>
例子如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">sing</span><span style="color: #000000;">(</span><span style="color: #005e8b;">song</span>: <span style="color: #531ab6;">string</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">`Singing: </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">song</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">!`</span><span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>

<span style="color: #721045;">sing</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"hello world"</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:1:15 - error TS7006: Parameter 'song' implicitly has an 'any' type.</span>

<span style="color: #7f0000;">/////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">function sing(</span><span style="color: #005e8b;">song</span><span style="color: #7f0000;">) {               //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">console.</span><span style="color: #721045;">log</span><span style="color: #7f0000;">(`Singing: ${song}!`); //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">}                                   //</span>
<span style="color: #7f0000;">/////////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
<div id="outline-container-orgc538e60" class="outline-4">
<h4 id="orgc538e60"><span class="section-number-4">5.1.1.</span> Required Parameters</h4>
<div class="outline-text-4" id="text-5-1-1">
<ul class="org-ul">
<li>javascript的function并没有参数检查,你可以使用任意数目的参数来调用函数.即便这个数目和你声明的不一样
<ul class="org-ul">
<li><p>
示例如下,下面例子中我们的javascript函数声明了一个参数,但是可以分别使用0,1,2个参数成功调用
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #531ab6;">function</span> <span style="color: #721045;">greet</span><span style="color: #000000;">(</span><span style="color: #005e8b;">name</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  console.log<span style="color: #dd22dd;">(</span><span style="color: #3548cf;">"Hello, "</span> + name + <span style="color: #3548cf;">"!"</span><span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>

greet<span style="color: #000000;">(</span><span style="color: #3548cf;">"Alice"</span><span style="color: #000000;">)</span>; <span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#35843;&#29992;&#26102;&#20256;&#36882;&#19968;&#20010;&#21442;&#25968;&#65292;&#36755;&#20986;: Hello, Alice!</span>
greet<span style="color: #000000;">()</span>; <span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#35843;&#29992;&#26102;&#27809;&#26377;&#20256;&#36882;&#21442;&#25968;&#65292;&#36755;&#20986;: Hello, undefined!</span>
greet<span style="color: #000000;">(</span><span style="color: #3548cf;">"Alice"</span>, <span style="color: #3548cf;">"Bob"</span><span style="color: #000000;">)</span>; <span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#35843;&#29992;&#26102;&#20256;&#36882;&#20004;&#20010;&#21442;&#25968;&#65292;&#36755;&#20986;: Hello, Alice!</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Hello, Alice!</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Hello, undefined!</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Hello, Alice!</span>
</pre>
</div></li>
</ul></li>
<li>TypeScript则不可能延续这个策略,它会严格的进行测试,确保声明的函数参数和调用的函数参数数目一致
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">singTwo</span><span style="color: #000000;">(</span><span style="color: #005e8b;">first</span>: <span style="color: #531ab6;">string</span>, <span style="color: #005e8b;">second</span>: <span style="color: #531ab6;">string</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">`</span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">first</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;"> / </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">second</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>

<span style="color: #721045;">singTwo</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"hello"</span>, <span style="color: #3548cf;">"world"</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">hello / world</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:10:1 - error TS2554: Expected 2 arguments, but got 1.</span>

<span style="color: #7f0000;">///////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">singTwo("hello"); //</span>
<span style="color: #7f0000;">///////////////////////</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:18:27 - error TS2554: Expected 2 arguments, but got 3.</span>

<span style="color: #7f0000;">/////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">singTwo("hello", "world", "again"); //</span>
<span style="color: #7f0000;">/////////////////////////////////////////</span>
</pre>
</div>
<ul class="org-ul">
<li>用上面的例子区分两个概念:
<ol class="org-ol">
<li>parameter是函数声明时候希望接受的,上面例子的first, second就是pamameter</li>
<li>argument是函数调用时候赋予的,上面例子的"hello", "world"就是argument</li>
</ol></li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org134604b" class="outline-4">
<h4 id="org134604b"><span class="section-number-4">5.1.2.</span> Optional Parameters</h4>
<div class="outline-text-4" id="text-5-1-2">
<ul class="org-ul">
<li>在javascript里面,如果一个function parameter没有被提供,那么在使用的时候,其argument就是undefined</li>
<li>typescript作为类型安全的语言,为了能够满足parameter和argument数目不一致的场景,设计了特性:optional parameter
<ul class="org-ul">
<li><p>
示例如下,我们使用`?`来标记为optional parameter,所有的这些加`?`的参数类型默认加union为`| undefined`
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">announceSong</span><span style="color: #000000;">(</span><span style="color: #005e8b;">song</span>: <span style="color: #531ab6;">string</span>, <span style="color: #005e8b;">singer?</span>: <span style="color: #531ab6;">string</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">`Song: </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">song</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #dd22dd;">)</span>;

  <span style="color: #531ab6;">if</span> <span style="color: #dd22dd;">(</span>singer<span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #3548cf;">`Singer: </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">singer</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #721045;">announceSong</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Greensleeves"</span><span style="color: #000000;">)</span>;
<span style="color: #721045;">announceSong</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Greensleeves"</span>, <span style="color: #0000b0;">undefined</span><span style="color: #000000;">)</span>;
<span style="color: #721045;">announceSong</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Greensleeves"</span>, <span style="color: #3548cf;">"Sia"</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Song: Greensleeves</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Song: Greensleeves</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Song: Greensleeves</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Singer: Sia</span>
</pre>
</div></li>
<li><p>
注意,optional和"刚好加了|union的参数"不同,前者可以parameter和argument数目不一,后者不可以
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">announceSong</span><span style="color: #000000;">(</span><span style="color: #005e8b;">song</span>: <span style="color: #531ab6;">string</span>, <span style="color: #005e8b;">singer</span>: <span style="color: #531ab6;">string</span> | <span style="color: #0000b0;">undefined</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">`Song: </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">song</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #dd22dd;">)</span>;

  <span style="color: #531ab6;">if</span> <span style="color: #dd22dd;">(</span>singer<span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #3548cf;">`Singer: </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">singer</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #721045;">announceSong</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Greensleeves"</span>, <span style="color: #0000b0;">undefined</span><span style="color: #000000;">)</span>;
<span style="color: #721045;">announceSong</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Greensleeves"</span>, <span style="color: #3548cf;">"Sia"</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Song: Greensleeves</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Song: Greensleeves</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Singer: Sia</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:9:1 - error TS2554: Expected 2 arguments, but got 1.</span>

<span style="color: #7f0000;">///////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">announceSong("Greensleeves"); //</span>
<span style="color: #7f0000;">///////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
<li>optional parameter必须作为最后的参数,否则会报错
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:1:40 - error TS1016: A required parameter cannot follow an optional parameter.</span>

<span style="color: #7f0000;">/////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">function announceSong(</span><span style="color: #005e8b;">singer?</span><span style="color: #7f0000;">: string, </span><span style="color: #005e8b;">song</span><span style="color: #7f0000;">: string) {} //</span>
<span style="color: #7f0000;">/////////////////////////////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org262ce68" class="outline-4">
<h4 id="org262ce68"><span class="section-number-4">5.1.3.</span> Default Parameters</h4>
<div class="outline-text-4" id="text-5-1-3">
<ul class="org-ul">
<li>参数默认值是比optional parameter更好的一种选择,它可以让我们的parameter在没有argument的情况下给一个默认值
<ul class="org-ul">
<li><p>
typescript的default parameter示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">rateSong</span><span style="color: #000000;">(</span><span style="color: #005e8b;">song</span>: <span style="color: #531ab6;">string</span>, rating = 0<span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">`|typeof rating| =&gt; </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">typeof rating</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #dd22dd;">)</span>;
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">`</span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">song</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;"> gets </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">rating</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">/5 stars!`</span><span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>

<span style="color: #721045;">rateSong</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Photograph"</span><span style="color: #000000;">)</span>;
<span style="color: #721045;">rateSong</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Set Fire to the Rain"</span>, 5<span style="color: #000000;">)</span>;
<span style="color: #721045;">rateSong</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Set Fire to the Rain"</span>, <span style="color: #0000b0;">undefined</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|typeof rating| =&gt; number</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Photograph gets 0/5 stars!</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|typeof rating| =&gt; number</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Set Fire to the Rain gets 5/5 stars!</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|typeof rating| =&gt; number</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Set Fire to the Rain gets 0/5 stars!</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:14:22 - error TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.</span>

<span style="color: #7f0000;">//////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">rateSong("At Last!", "100"); //</span>
<span style="color: #7f0000;">//////////////////////////////////</span>
</pre>
</div></li>
<li>我们调用的时候,想要默认值起作用可以:
<ol class="org-ol">
<li>缺少这个参数(这个和其他语言行为一致),</li>
<li>使用undefind替代(这个是为了和javascript语言特性一致)</li>
</ol></li>
<li><p>
我们发现一旦有了default parameter,那么argument的类型就确定了,在上例中必定是number.而不是像optional
parameter一样的union类型(number | undefiend).
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">rateSong</span><span style="color: #000000;">(</span><span style="color: #005e8b;">song</span>: <span style="color: #531ab6;">string</span>, <span style="color: #005e8b;">rating?</span>: <span style="color: #531ab6;">number</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">`|typeof rating| =&gt; </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">typeof rating</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #dd22dd;">)</span>;
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">`</span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">song</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;"> gets </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">rating</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">/5 stars!`</span><span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>

<span style="color: #721045;">rateSong</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Photograph"</span><span style="color: #000000;">)</span>;
<span style="color: #721045;">rateSong</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Set Fire to the Rain"</span>, 5<span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|typeof rating| =&gt; undefined</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Photograph gets undefined/5 stars!</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|typeof rating| =&gt; number</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Set Fire to the Rain gets 5/5 stars!</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org6e08202" class="outline-4">
<h4 id="org6e08202"><span class="section-number-4">5.1.4.</span> Rest Parameters</h4>
<div class="outline-text-4" id="text-5-1-4">
<ul class="org-ul">
<li>rest parametr也叫不定参数,是只最后一个参数可以是0个或者多个的情况
<ul class="org-ul">
<li><p>
在typescript里面,rest  parameter的类型会多一个`[]`,示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">singAllTheSongs</span><span style="color: #000000;">(</span><span style="color: #005e8b;">singer</span>: <span style="color: #531ab6;">string</span>, ...songs: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">[]</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">for</span> <span style="color: #dd22dd;">(</span><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">song</span> <span style="color: #531ab6;">of</span> songs<span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #3548cf;">`</span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">song</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">, by </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">singer</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #721045;">singAllTheSongs</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Alicia Keys"</span><span style="color: #000000;">)</span>;
<span style="color: #721045;">singAllTheSongs</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Lady Gaga"</span>, <span style="color: #3548cf;">"Bad Romance"</span>, <span style="color: #3548cf;">"Just Dance"</span>, <span style="color: #3548cf;">"Poker Face"</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Bad Romance, by Lady Gaga</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Just Dance, by Lady Gaga</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Poker Face, by Lady Gaga</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:18:36 - error TS2345: Argument of type 'number' is not assignable to parameter of type 'string'.</span>

<span style="color: #7f0000;">///////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">singAllTheSongs("Ella Fitzgerald", 2000); //</span>
<span style="color: #7f0000;">///////////////////////////////////////////////</span>
</pre>
</div></li>
<li>由于rest parameter有类型要求,所以传入number类型会导致typescript报错</li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org882e35f" class="outline-3">
<h3 id="org882e35f"><span class="section-number-3">5.2.</span> Return Types</h3>
<div class="outline-text-3" id="text-5-2">
<ul class="org-ul">
<li>TypeScript可以理解一个函数的所有可能返回值,并且给与其类型(多种返回值类型就是union类型)
<ul class="org-ul">
<li><p>
下面这个例子中,singSong返回值类型就是number
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">singSong</span><span style="color: #000000;">(</span><span style="color: #005e8b;">songs</span>: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">[]</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> songs.length;
<span style="color: #000000;">}</span>
</pre>
</div></li>
<li><p>
下面这个例子中,getSongAt的返回值就是一个string | undefined了
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">getSongAt</span><span style="color: #000000;">(</span><span style="color: #005e8b;">songs</span>: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">[]</span>, <span style="color: #005e8b;">index</span>: <span style="color: #531ab6;">number</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> index &lt; <span style="color: #005f5f;">songs</span>.<span style="color: #005f5f;">length</span> ? <span style="color: #005f5f;">songs</span><span style="color: #dd22dd;">[</span><span style="color: #005f5f;">index</span><span style="color: #dd22dd;">]</span> : <span style="color: #005f5f;">undefined</span>;
<span style="color: #000000;">}</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
<div id="outline-container-orgd287926" class="outline-4">
<h4 id="orgd287926"><span class="section-number-4">5.2.1.</span> Explicit Return Types</h4>
<div class="outline-text-4" id="text-5-2-1">
<ul class="org-ul">
<li>虽然typescript最佳实践就是不要给function明确的标记返回值类型.但是有几种特殊的情况下还是建议把返回值
类型给标记起来,这些情况分别是:
<ul class="org-ul">
<li>有很多种可能的return value,但是你希望只返回一种类型</li>
<li>typescript拒绝判断返回类型</li>
<li>在非常大的项目里面,标记函数返回类型,能减轻typescript的工作,从而提升代码检查效率,缩短时间</li>
</ul></li>
<li>下面是函数返回类型annotaion的书写方式:
<ul class="org-ul">
<li><p>
对于普通函数来说,就是在`{`之前加上类型
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">singSongRecursive</span><span style="color: #000000;">(</span><span style="color: #005e8b;">songs</span>: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">[]</span>, <span style="color: #005e8b;">count</span> = 0<span style="color: #000000;">)</span>: <span style="color: #531ab6;">number</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> songs.length ? <span style="color: #721045;">singSongRecursive</span><span style="color: #dd22dd;">(</span>songs.<span style="color: #721045;">slice</span><span style="color: #008899;">(</span>1<span style="color: #008899;">)</span>, count + 1<span style="color: #dd22dd;">)</span> : count;
<span style="color: #000000;">}</span>
</pre>
</div></li>
<li><p>
对于arrow function来说,就是在`=&gt;`之前加上类型
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">singSongRecursive</span> = <span style="color: #000000;">(</span>songs: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">[]</span>, count = 0<span style="color: #000000;">)</span>: <span style="color: #531ab6;">number</span> <span style="color: #531ab6;">=&gt;</span>
  songs.length ? <span style="color: #721045;">singSongRecursive</span><span style="color: #000000;">(</span>songs.<span style="color: #721045;">slice</span><span style="color: #dd22dd;">(</span>1<span style="color: #dd22dd;">)</span>, count + 1<span style="color: #000000;">)</span> : count;
</pre>
</div></li>
</ul></li>
<li>一旦设置的function return type,那么typescript会去进行检查的
<ul class="org-ul">
<li><p>
示例代码如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">getSongRecordingDate</span><span style="color: #000000;">(</span><span style="color: #005e8b;">song</span>: <span style="color: #531ab6;">string</span><span style="color: #000000;">)</span>: <span style="color: #005f5f;">Date</span> | <span style="color: #0000b0;">undefined</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">switch</span> <span style="color: #dd22dd;">(</span>song<span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">case</span> <span style="color: #3548cf;">"Strange Fruit"</span>:
      <span style="color: #531ab6;">return</span> <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Date</span><span style="color: #008899;">(</span><span style="color: #3548cf;">"April 20, 1939"</span><span style="color: #008899;">)</span>;
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:6:7 - error TS2322: Type 'string' is not assignable to type 'Date'.</span>

    <span style="color: #7f0000;">//////////////////////////</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">case "Greensleeves": //</span>
    <span style="color: #7f0000;">//   </span><span style="color: #7f0000;">return "unknown";  //</span>
    <span style="color: #7f0000;">//////////////////////////</span>
    <span style="color: #000000; background-color: #fbf7f0;">default</span>:
      <span style="color: #531ab6;">return</span> <span style="color: #0000b0;">undefined</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org3e56543" class="outline-3">
<h3 id="org3e56543"><span class="section-number-3">5.3.</span> Function Types</h3>
<div class="outline-text-3" id="text-5-3">
<ul class="org-ul">
<li>Javascript的函数是一等公民,可以把function作为value到处传递,那么我们的function也必须要有自己的类型</li>
<li>Function type和arrow function的样子很像,只不过"=&gt;"之后是返回值的类型,而不是{}
<ul class="org-ul">
<li><p>
nothingInGivesString函数是一个没有形参,返回值为string类型的函数
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">nothingInGivesString</span>: <span style="color: #000000;">()</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #531ab6;">string</span>;
</pre>
</div></li>
<li><p>
inputAndOutput函数有一个必选参数string[]类型的songs,一个可选参数count?,返回值为number类型
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">inputAndOutput</span>: <span style="color: #000000;">(</span>songs: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">[]</span>, <span style="color: #005e8b;">count</span>?: <span style="color: #531ab6;">number</span><span style="color: #000000;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #531ab6;">number</span>;
</pre>
</div></li>
</ul></li>
<li>function type的最常用的地方是callback parameter(这种参数会被像function一样被调用)
<ul class="org-ul">
<li><p>
下面就是这样一个例子,runOnSong的唯一参数就是一个callback parameter
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">songs</span> = <span style="color: #000000;">[</span><span style="color: #3548cf;">"Juice"</span>, <span style="color: #3548cf;">"Shake It Off"</span>, <span style="color: #3548cf;">"What's Up"</span><span style="color: #000000;">]</span>;

<span style="color: #531ab6;">function</span> <span style="color: #721045;">runOnSongs</span><span style="color: #000000;">(</span><span style="color: #005e8b;">getSongAtP</span>: <span style="color: #dd22dd;">(</span><span style="color: #005e8b;">index</span>: <span style="color: #531ab6;">number</span><span style="color: #dd22dd;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #531ab6;">string</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">for</span> <span style="color: #dd22dd;">(</span><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">i</span> = 0; i &lt; <span style="color: #005f5f;">songs</span>.<span style="color: #005f5f;">length</span>; <span style="color: #005f5f;">i</span> += 1<span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #721045;">getSongAtP</span><span style="color: #972500;">(</span>i<span style="color: #972500;">)</span><span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">function</span> <span style="color: #721045;">getSongAt</span><span style="color: #000000;">(</span><span style="color: #005e8b;">index</span>: <span style="color: #531ab6;">number</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> <span style="color: #3548cf;">`</span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">songs[index]</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span>;
<span style="color: #000000;">}</span>

<span style="color: #721045;">runOnSongs</span><span style="color: #000000;">(</span>getSongAt<span style="color: #000000;">)</span>;

<span style="color: #531ab6;">function</span> <span style="color: #721045;">longSong</span><span style="color: #000000;">(</span><span style="color: #005e8b;">song</span>: <span style="color: #531ab6;">string</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> <span style="color: #3548cf;">`</span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">song</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span>;
<span style="color: #000000;">}</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Juice</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Shake It Off</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">What's Up</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:24:12 - error TS2345: Argument of type '(song: string) =&gt; string' is not assignable to parameter of type '(index: number) =&gt; string'.</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">Types of parameters 'song' and 'index' are incompatible.</span>
<span style="color: #7f0000;">//     </span><span style="color: #7f0000;">Type 'number' is not assignable to type 'string'.</span>

<span style="color: #7f0000;">///////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">runOnSongs(longSong); //</span>
<span style="color: #7f0000;">///////////////////////////</span>
</pre>
</div></li>
<li>callback pameter的类型是形参为number,返回值为string, getSongAt符合要求, logSong则不符合</li>
</ul></li>
</ul>
</div>
<div id="outline-container-orgf95fb60" class="outline-4">
<h4 id="orgf95fb60"><span class="section-number-4">5.3.1.</span> Function Type Parentheses</h4>
<div class="outline-text-4" id="text-5-3-1">
<ul class="org-ul">
<li>function type是一个比较复杂的称谓(这个称谓的中间还有空格),所以我们需要在有些情况下在function type外面加上括号</li>
<li>union type就是这样一种情况:
<ul class="org-ul">
<li><p>
如果不加括号,那么returnsStringOrUndefined的function type的类型为: function that returns a union: string | undefined
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">returnsStringOrUndefined</span>: <span style="color: #000000;">()</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #531ab6;">string</span> | <span style="color: #0000b0;">undefined</span>;
</pre>
</div></li>
<li><p>
加了括号,那么mybeReturnsString要么是一个function that returns a string, 要么是一个undefined
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">maybeReturnsString</span>: <span style="color: #000000;">(</span><span style="color: #dd22dd;">()</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #531ab6;">string</span><span style="color: #000000;">)</span> | <span style="color: #0000b0;">undefined</span>;
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org9710193" class="outline-4">
<h4 id="org9710193"><span class="section-number-4">5.3.2.</span> Parameter Type Inferences</h4>
<div class="outline-text-4" id="text-5-3-2">
<ul class="org-ul">
<li>typescript可以聪明的让我们在类型明确的情况下,少些后续的类型.
<ul class="org-ul">
<li><p>
比如下面的例子,我们已经声明了singer的类型了,那么在赋值的时候我们不需要再给song声明其为string了
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">singer</span>: <span style="color: #000000;">(</span>song: <span style="color: #531ab6;">string</span><span style="color: #000000;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #531ab6;">string</span>;

singer = <span style="color: #531ab6;">function</span> <span style="color: #000000;">(</span><span style="color: #005e8b;">song</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> <span style="color: #3548cf;">`Sing: </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">song.toUpperCase()</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">!`</span>;
<span style="color: #000000;">}</span>;

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span><span style="color: #721045;">singer</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">"Hello"</span><span style="color: #dd22dd;">)</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Sing: HELLO!</span>
</pre>
</div></li>
<li><p>
因为不是stirng压根赋值不会成功,如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">singer</span>: <span style="color: #000000;">(</span>song: <span style="color: #531ab6;">string</span><span style="color: #000000;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #531ab6;">string</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:3:1 - error TS2322: Type '(song: number) =&gt; string' is not assignable to type '(song: string) =&gt; string'.</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">Types of parameters 'song' and 'song' are incompatible.</span>
<span style="color: #7f0000;">//     </span><span style="color: #7f0000;">Type 'string' is not assignable to type 'number'.</span>

<span style="color: #7f0000;">////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">singer = function (</span><span style="color: #005e8b;">song</span><span style="color: #7f0000;">: number) { //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">return `Sing: Something!`;       //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">};                                 //</span>
<span style="color: #7f0000;">////////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
<li>既然"已声明对象赋值"的时候,可以被infer. 那么把"函数作为参数"传递给另外函数的时候,类型也是可以被infer
的,因为另外的函数肯定在其他地方已经声明过"函数参数"的类型了
<ul class="org-ul">
<li><p>
示例如下:
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">songs</span> = <span style="color: #000000;">[</span><span style="color: #3548cf;">"Call Me"</span>, <span style="color: #3548cf;">"Jolene"</span>, <span style="color: #3548cf;">"The Chain"</span><span style="color: #000000;">]</span>;

songs.<span style="color: #721045;">forEach</span><span style="color: #000000;">(</span><span style="color: #dd22dd;">(</span><span style="color: #005e8b;">song</span>, <span style="color: #005e8b;">index</span><span style="color: #dd22dd;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #dd22dd;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #3548cf;">`</span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">song</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;"> is at index </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">index</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #008899;">)</span>
<span style="color: #dd22dd;">}</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Call Me is at index 0</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Jolene is at index 1</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">The Chain is at index 2</span>
</pre>
</div></li>
<li>forEach的函数参数已经声明过类型了,其callbackFn参数第二个成员为number类型,这里的inde也就直接被infer
成number类型</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org8577a3f" class="outline-4">
<h4 id="org8577a3f"><span class="section-number-4">5.3.3.</span> Function Type Aliases</h4>
<div class="outline-text-4" id="text-5-3-3">
<ul class="org-ul">
<li>type aliases 本来是实现"一人千面"作用的. 但是同时也能将复杂的类型转换成一个"看起来简单的类型"</li>
<li>function type一般来说,其都是比较复杂的类型,能够转成一个"看起来简单的类型"非常重要.
<ul class="org-ul">
<li><p>
示例如下,我们把(input: string) =&gt; number这么复杂的类型,alias成StringToNumber这么一个"看起来简单
的类型",然后这个类型还能在之后使用
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">type</span> <span style="color: #005f5f;">StringToNumber</span> = <span style="color: #000000;">(</span>input: <span style="color: #531ab6;">string</span><span style="color: #000000;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #531ab6;">number</span>;

<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">stringToNumber</span>: <span style="color: #005f5f;">StringToNumber</span>;

stringToNumber = <span style="color: #000000;">(</span>input<span style="color: #000000;">)</span> <span style="color: #531ab6;">=&gt;</span> input.length; <span style="color: #7f0000;">// </span><span style="color: #7f0000;">ok</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:8:29 - error TS2322: Type 'string' is not assignable to type 'number'.</span>

<span style="color: #7f0000;">//////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">stringToNumber = (input) =&gt; input.</span><span style="color: #721045;">toUpperCase</span><span style="color: #7f0000;">(); //</span>
<span style="color: #7f0000;">//////////////////////////////////////////////////////</span>
</pre>
</div></li>
<li><p>
我们当然可以把这个"看起来简单的类型"放到函数声明里面,比起原来的复杂的函数声明,当前的函数声明看起
来简单好多(虽然看起来不像function type)
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">type</span> <span style="color: #005f5f;">NumberToString</span> = <span style="color: #000000;">(</span>input: <span style="color: #531ab6;">number</span><span style="color: #000000;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #531ab6;">string</span>;

<span style="color: #531ab6;">function</span> <span style="color: #721045;">userNumberToString</span><span style="color: #000000;">(</span><span style="color: #005e8b;">numberToString</span>: <span style="color: #005f5f;">NumberToString</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">`Ths string is : </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">numberToString(123)</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>

<span style="color: #721045;">userNumberToString</span><span style="color: #000000;">(</span><span style="color: #dd22dd;">(</span>input<span style="color: #dd22dd;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #3548cf;">`</span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">input</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">! Hooray`</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Ths string is : 123! Hooray</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:9:31 - error TS2322: Type 'number' is not assignable to type 'string'.</span>

<span style="color: #7f0000;">///////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">userNumberToString((input) =&gt; input * 2); //</span>
<span style="color: #7f0000;">///////////////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org8f4fae2" class="outline-3">
<h3 id="org8f4fae2"><span class="section-number-3">5.4.</span> More Return Types</h3>
<div class="outline-text-3" id="text-5-4">
</div>
<div id="outline-container-org8706af9" class="outline-4">
<h4 id="org8706af9"><span class="section-number-4">5.4.1.</span> Void Returns</h4>
<div class="outline-text-4" id="text-5-4-1">
<ul class="org-ul">
<li>void return是绝大多数typescript都有的特性,其主要处理如下两种情况:
<ul class="org-ul">
<li>函数体没有return关键字</li>
<li>函数体的return后面直接就是分号,没返回任何东西</li>
</ul></li>
<li>void return一旦声明了之后,是不允许返回任何值的
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">songLogger</span>: <span style="color: #000000;">(</span>song: <span style="color: #531ab6;">string</span><span style="color: #000000;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #531ab6;">void</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:5:3 - error TS2322: Type 'boolean' is not assignable to type 'void'.</span>

<span style="color: #7f0000;">////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">songLogger = (</span><span style="color: #005e8b;">song</span><span style="color: #7f0000;">): void =&gt; { //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">console.</span><span style="color: #721045;">log</span><span style="color: #7f0000;">(`${song}`);      //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">return true;                 //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">};                             //</span>
<span style="color: #7f0000;">////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
<li>void return在function type里面非常重要,因为"=&gt;"后面必须得有点东西
<ul class="org-ul">
<li><p>
示例如下,注意声明时候的void在"=&gt;"后面,调用的时候void在"=&gt;"前面
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">songLogger</span>: <span style="color: #000000;">(</span>song: <span style="color: #531ab6;">string</span><span style="color: #000000;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #531ab6;">void</span>;

songLogger = <span style="color: #000000;">(</span><span style="color: #005e8b;">song</span><span style="color: #000000;">)</span>: <span style="color: #531ab6;">void</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #000000;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">`</span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">song</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>;

<span style="color: #721045;">songLogger</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Heart of Glass"</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Heart of Glass</span>
</pre>
</div></li>
</ul></li>
<li>注意,void是typescript里面的一个type,其和undefined是不一样的,两者不可以相互赋值
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">returnsVoid</span><span style="color: #000000;">()</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">lazyValue</span>: <span style="color: #531ab6;">string</span> | <span style="color: #0000b0;">undefined</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:7:1 - error TS2322: Type 'void' is not assignable to type 'string | undefined'.</span>

<span style="color: #7f0000;">////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">lazyValue = returnsVoid(); //</span>
<span style="color: #7f0000;">////////////////////////////////</span>
</pre>
</div></li>
<li><p>
注意上面的例子中function returnsVoid()并没有明确的写出返回值类型,那么其实是可以返回任意类型的,只
不过代码里面return;让Typescript编译器直接给他确认了返回值类型是void.如果你的代码里面有其他逻辑,可
以返回不同类型,编译器甚至能判断出这些类型!
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">returnsVoid</span><span style="color: #000000;">()</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">if</span> <span style="color: #dd22dd;">(</span>Math.<span style="color: #721045;">random</span><span style="color: #008899;">()</span> &gt; 0.5<span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">return</span> 123;
  <span style="color: #dd22dd;">}</span> <span style="color: #531ab6;">else</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">return</span> <span style="color: #3548cf;">"123"</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">lazyValue</span>: <span style="color: #531ab6;">string</span> | <span style="color: #0000b0;">undefined</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:14:1 - error TS2322: Type '123 | "123"' is not assignable to type 'string | undefined'.</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">Type 'number' is not assignable to type 'string'.</span>

<span style="color: #7f0000;">////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">lazyValue = returnsVoid(); //</span>
<span style="color: #7f0000;">////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
<li>void返回值的定义会产生一个问题,比如forEach函数,其要求第一个参数callbackFn的返回值为void,这样可以警
告forEach,不要去使用这个callbackFn的返回值.
<ul class="org-ul">
<li><p>
如果真的严格要求,那么我们的forEach只能这样调用
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">records</span>: <span style="color: #531ab6;">string</span><span style="color: #000000;">[]</span> = <span style="color: #000000;">[]</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>records<span style="color: #000000;">)</span>;

<span style="color: #531ab6;">function</span> <span style="color: #721045;">saveRecords</span><span style="color: #000000;">(</span><span style="color: #005e8b;">newRecords</span>: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">[]</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  newRecords.<span style="color: #721045;">forEach</span><span style="color: #dd22dd;">(</span><span style="color: #008899;">(</span><span style="color: #005e8b;">record</span><span style="color: #008899;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #008899;">{</span>
    records.<span style="color: #721045;">push</span><span style="color: #972500;">(</span>record<span style="color: #972500;">)</span>;
  <span style="color: #008899;">}</span><span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>

<span style="color: #721045;">saveRecords</span><span style="color: #000000;">(</span><span style="color: #dd22dd;">[</span><span style="color: #3548cf;">"21"</span>, <span style="color: #3548cf;">"Come On Over"</span>, <span style="color: #3548cf;">"The Bodyguard"</span><span style="color: #dd22dd;">]</span><span style="color: #000000;">)</span>;

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>records<span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">[]</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">[ '21', 'Come On Over', 'The Bodyguard' ]</span>
</pre>
</div></li>
<li><p>
但实际上,我们可以不要这个括号也能调用,这算是Typescript为数不多的"委曲求全",默认了也能在void返回值
的时候返回非void,只是用void警告大家不要使用这个返回值就可以了.
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">records</span>: <span style="color: #531ab6;">string</span><span style="color: #000000;">[]</span> = <span style="color: #000000;">[]</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>records<span style="color: #000000;">)</span>;

<span style="color: #531ab6;">function</span> <span style="color: #721045;">saveRecords</span><span style="color: #000000;">(</span><span style="color: #005e8b;">newRecords</span>: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">[]</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  newRecords.<span style="color: #721045;">forEach</span><span style="color: #dd22dd;">(</span><span style="color: #008899;">(</span>record<span style="color: #008899;">)</span> <span style="color: #531ab6;">=&gt;</span> records.<span style="color: #721045;">push</span><span style="color: #008899;">(</span>record<span style="color: #008899;">)</span><span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>

<span style="color: #721045;">saveRecords</span><span style="color: #000000;">(</span><span style="color: #dd22dd;">[</span><span style="color: #3548cf;">"21"</span>, <span style="color: #3548cf;">"Come On Over"</span>, <span style="color: #3548cf;">"The Bodyguard"</span><span style="color: #dd22dd;">]</span><span style="color: #000000;">)</span>;

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>records<span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">[]</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">[ '21', 'Come On Over', 'The Bodyguard' ]</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgd7a9389" class="outline-4">
<h4 id="orgd7a9389"><span class="section-number-4">5.4.2.</span> Never Returns</h4>
<div class="outline-text-4" id="text-5-4-2">
<ul class="org-ul">
<li>never return是处理如下两种情况:
<ul class="org-ul">
<li><p>
总数抛出异常,例子如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">fail</span><span style="color: #000000;">(</span><span style="color: #005e8b;">message</span>: <span style="color: #531ab6;">string</span><span style="color: #000000;">)</span>: <span style="color: #531ab6;">never</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">throw</span> <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Error</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">`Invariant failure: </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">message</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">.`</span><span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">function</span> <span style="color: #721045;">workWithUnsafeParam</span><span style="color: #000000;">(</span><span style="color: #005e8b;">param</span>: <span style="color: #531ab6;">unknown</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">if</span> <span style="color: #dd22dd;">(</span><span style="color: #531ab6;">typeof</span> param != <span style="color: #3548cf;">"string"</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #721045;">fail</span><span style="color: #008899;">(</span><span style="color: #3548cf;">`param should be a string, not </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">typeof param</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #008899;">)</span>
  <span style="color: #dd22dd;">}</span>

  param.<span style="color: #721045;">toUpperCase</span><span style="color: #dd22dd;">()</span>;
<span style="color: #000000;">}</span>
</pre>
</div></li>
<li>无限循环,但是不返回.这种不太常见.</li>
</ul></li>
<li>注意,never和void不一样:
<ul class="org-ul">
<li>never是一个函数永远都不返回值</li>
<li>void是函数返回的值nothing,提醒使用者不用使用这个nothing</li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org753cd2b" class="outline-3">
<h3 id="org753cd2b"><span class="section-number-3">5.5.</span> Function Overloads</h3>
<div class="outline-text-3" id="text-5-5">
<ul class="org-ul">
<li>函数重载是编程语言经典的特性.typescript自然也是支持的
<ul class="org-ul">
<li><p>
下面就是一个重载的例子.
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">createDate</span><span style="color: #000000;">(</span><span style="color: #005e8b;">timestamp</span>: <span style="color: #531ab6;">number</span><span style="color: #000000;">)</span>: <span style="color: #005f5f;">Date</span>;
<span style="color: #531ab6;">function</span> <span style="color: #721045;">createDate</span><span style="color: #000000;">(</span><span style="color: #005e8b;">month</span>: <span style="color: #531ab6;">number</span>, <span style="color: #005e8b;">day</span>: <span style="color: #531ab6;">number</span>, <span style="color: #005e8b;">year</span>: <span style="color: #531ab6;">number</span><span style="color: #000000;">)</span>: <span style="color: #005f5f;">Date</span>;

<span style="color: #531ab6;">function</span> <span style="color: #721045;">createDate</span><span style="color: #000000;">(</span><span style="color: #005e8b;">monthOrTimestamp</span>: <span style="color: #531ab6;">number</span>, <span style="color: #005e8b;">day?</span>: <span style="color: #531ab6;">number</span>, <span style="color: #005e8b;">year?</span>: <span style="color: #531ab6;">number</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> day === <span style="color: #0000b0;">undefined</span> || year === <span style="color: #0000b0;">undefined</span>
    ? <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Date</span><span style="color: #dd22dd;">(</span><span style="color: #005e8b;">monthOrTimestamp</span><span style="color: #dd22dd;">)</span>
    : <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Date</span><span style="color: #dd22dd;">(</span>year, monthOrTimestamp, day<span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>

<span style="color: #721045;">createDate</span><span style="color: #000000;">(</span>554356800<span style="color: #000000;">)</span>;
<span style="color: #721045;">createDate</span><span style="color: #000000;">(</span>7, 27, 1987<span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:13:1 - error TS2575: No overload expects 2 arguments, but overloads do exist that expect either 1 or 3 arguments.</span>

<span style="color: #7f0000;">///////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">createDate(3, 1); //</span>
<span style="color: #7f0000;">///////////////////////</span>
</pre>
</div></li>
<li>注意上面的前两个是函数声明,第三个是函数实现.第三个函数实现虽然是支持两个参数调用的,但是由于声明的
时候没有两个参数的版本,所以调用两个参数的版本会失败</li>
<li><p>
上面重载的例子,其实就是在转换为javascript之后,会把代码改变成如下javascript逻辑,可以看到,已经完全
没有重载的痕迹了.
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #531ab6;">function</span> <span style="color: #721045;">createDate</span><span style="color: #000000;">(</span><span style="color: #005e8b;">monthOrTimestamp</span>, <span style="color: #005e8b;">day</span>, <span style="color: #005e8b;">year</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> day === <span style="color: #0000b0;">undefined</span> || year === <span style="color: #0000b0;">undefined</span>
    ? <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Datre</span><span style="color: #dd22dd;">(</span>monthOrTimestamp<span style="color: #dd22dd;">)</span>
    : <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Datre</span><span style="color: #dd22dd;">(</span>year, monthOrTimestamp, day<span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
<div id="outline-container-orgbe4b973" class="outline-4">
<h4 id="orgbe4b973"><span class="section-number-4">5.5.1.</span> Call-Signature Compatibility</h4>
<div class="outline-text-4" id="text-5-5-1">
<ul class="org-ul">
<li>由于typescript的重载办法,是在编译成javascript的时候,依靠逻辑来重写代码.那么我们就要求参数必须能够
相互转换(对位assignable),比如上一节例子中的timestamp和month都是string
<ul class="org-ul">
<li><p>
下面的例子中,第三个函数就因为无法和第一个函数对位assign,所以重载失败了
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">format</span><span style="color: #000000;">(</span><span style="color: #005e8b;">data</span>: <span style="color: #531ab6;">string</span><span style="color: #000000;">)</span>: <span style="color: #531ab6;">string</span>;
<span style="color: #531ab6;">function</span> <span style="color: #721045;">format</span><span style="color: #000000;">(</span><span style="color: #005e8b;">data</span>: <span style="color: #531ab6;">string</span>, <span style="color: #005e8b;">needle</span>: <span style="color: #531ab6;">string</span>, <span style="color: #005e8b;">haystack</span>: <span style="color: #531ab6;">string</span><span style="color: #000000;">)</span>: <span style="color: #531ab6;">string</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:4:10 - error TS2394: This overload signature is not compatible with its implementation signature.</span>

<span style="color: #7f0000;">/////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">function format(</span><span style="color: #005e8b;">getData</span><span style="color: #7f0000;">: () =&gt; </span><span style="color: #005e8b;">string</span><span style="color: #7f0000;">): string; //</span>
<span style="color: #7f0000;">/////////////////////////////////////////////////////</span>

<span style="color: #531ab6;">function</span> <span style="color: #721045;">format</span><span style="color: #000000;">(</span><span style="color: #005e8b;">data</span>: <span style="color: #531ab6;">string</span>, <span style="color: #005e8b;">needle?</span>: <span style="color: #531ab6;">string</span>, <span style="color: #005e8b;">haystack?</span>: <span style="color: #531ab6;">string</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> needle &amp;&amp; haystack ? data.<span style="color: #721045;">replace</span><span style="color: #dd22dd;">(</span><span style="color: #005e8b;">needle</span>, <span style="color: #005e8b;">haystack</span><span style="color: #dd22dd;">)</span> : data;
<span style="color: #000000;">}</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org74cad20" class="outline-2">
<h2 id="org74cad20"><span class="section-number-2">6.</span> Chapter 6: Arrays</h2>
<div class="outline-text-2" id="text-6">
</div>
<div id="outline-container-org19081fb" class="outline-3">
<h3 id="org19081fb"><span class="section-number-3">6.1.</span> Array Types</h3>
<div class="outline-text-3" id="text-6-1">
<ul class="org-ul">
<li>变量一般声明的时候,都是没有value的.array也同样,所以我们必须为"空的array"创建一个声明样式
<ul class="org-ul">
<li><p>
typescript肯定是希望你一开始就把array里面放置什么类型给标记出来的,如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">arrayOfNumbbers</span>: <span style="color: #531ab6;">number</span><span style="color: #000000;">[]</span>;

arrayOfNumbbers = <span style="color: #000000;">[</span>1, 2, 3, 4, 5<span style="color: #000000;">]</span>;
</pre>
</div></li>
<li>我们甚至可以使用Array&lt;number&gt;来替代number[],但是这种写法不太受欢迎</li>
</ul></li>
</ul>
</div>
<div id="outline-container-orgbf877c6" class="outline-4">
<h4 id="orgbf877c6"><span class="section-number-4">6.1.1.</span> Array and Function Types</h4>
<div class="outline-text-4" id="text-6-1-1">
<ul class="org-ul">
<li>我们之前说过,本身function type由于其类型过长,就容易需要配合(). 如果function type再加上array,那么使
用括号的概率,就更高了
<ul class="org-ul">
<li><p>
第一个例子函数的类型是: function that returns an array of strings
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">createStrings</span>: <span style="color: #000000;">()</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #531ab6;">string</span><span style="color: #000000;">[]</span>;
</pre>
</div></li>
<li><p>
第二个例子函数的类型是: functions that each return a string
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">strignCreators</span>: <span style="color: #000000;">(</span><span style="color: #dd22dd;">()</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #531ab6;">string</span><span style="color: #000000;">)[]</span>;
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org8d9dfe8" class="outline-4">
<h4 id="org8d9dfe8"><span class="section-number-4">6.1.2.</span> Union Type Arrays</h4>
<div class="outline-text-4" id="text-6-1-2">
<ul class="org-ul">
<li>array里面可以使用union type来明确array里面的成员可以是union中的一种.这种情况下,()的使用概率也很高:
<ul class="org-ul">
<li><p>
第一个例子变量的类型是: either a number or an array of strings
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">stringOrArrayOfNumbers</span>: <span style="color: #531ab6;">string</span> | <span style="color: #531ab6;">number</span><span style="color: #000000;">[]</span>;
</pre>
</div></li>
<li><p>
第二个例子变量的类型是: an array of elements that ar each either a number or a string
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">arrayOfStringOrNumbers</span>: <span style="color: #000000;">(</span><span style="color: #531ab6;">string</span> | <span style="color: #531ab6;">number</span><span style="color: #000000;">)[]</span>;
</pre>
</div></li>
</ul></li>
<li>如果一个typescript没有明确的declare它的类型,那么Typescript会自己infer这个数组的类型(通过数组中的数据)
<ul class="org-ul">
<li><p>
比如下面的例子中,我们可以通过错误提示来发现namesMaybe的类型
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">namesMaybe</span> = <span style="color: #000000;">[</span><span style="color: #3548cf;">"Aqualtune"</span>, <span style="color: #3548cf;">"Blenda"</span>, <span style="color: #0000b0;">undefined</span><span style="color: #000000;">]</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:3:5 - error TS2322: Type '(string | undefined)[]' is not assignable to type 'number'.</span>

<span style="color: #7f0000;">///////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">let tmp: number = namesMaybe; //</span>
<span style="color: #7f0000;">///////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org97f1506" class="outline-4">
<h4 id="org97f1506"><span class="section-number-4">6.1.3.</span> Evolving Any Arrays</h4>
<div class="outline-text-4" id="text-6-1-3">
<ul class="org-ul">
<li>如果声明数组的时候,没有写具体的类型,那么就相当于是any[]</li>
<li>any[]不是Typescript所希望的类型,因为这样配置失去了typescript的优势:类型. 所以typescript会随着any[]
数组里面增加不同类型的成员,而动态的改变自己的类型
<ul class="org-ul">
<li><p>
比如下面例子中,数组的类型从any[]到string[],再到(number | string)[]
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">values</span> = <span style="color: #000000;">[]</span>;                <span style="color: #7f0000;">// </span><span style="color: #7f0000;">Type: any[]</span>
values.<span style="color: #721045;">push</span><span style="color: #000000;">(</span><span style="color: #3548cf;">""</span><span style="color: #000000;">)</span>;                <span style="color: #7f0000;">// </span><span style="color: #005e8b;">Type</span><span style="color: #7f0000;">: string[]</span>
values<span style="color: #000000;">[</span>0<span style="color: #000000;">]</span> = 0;                  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">Type: (number | string)[]</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org277db04" class="outline-4">
<h4 id="org277db04"><span class="section-number-4">6.1.4.</span> Multidimensional Arrays</h4>
<div class="outline-text-4" id="text-6-1-4">
<ul class="org-ul">
<li>作为2D数组,我们会有两个[]
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">arrayOfArraysOfNumbers</span>: <span style="color: #531ab6;">number</span><span style="color: #000000;">[][]</span>;

arrayOfArraysOfNumbers = <span style="color: #000000;">[</span>
  <span style="color: #dd22dd;">[</span>1, 2, 3<span style="color: #dd22dd;">]</span>,
  <span style="color: #dd22dd;">[</span>2, 4, 6<span style="color: #dd22dd;">]</span>,
  <span style="color: #dd22dd;">[</span>3, 6, 9<span style="color: #dd22dd;">]</span>,
<span style="color: #000000;">]</span>;

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>arrayOfArraysOfNumbers<span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">[ [ 1, 2, 3 ], [ 2, 4, 6 ], [ 3, 6, 9 ] ]</span>
</pre>
</div></li>
</ul></li>
<li>对于3D数组,那么就会有3个[], 4D数组,会有4个[],5D数组,会有5个[].依此类推</li>
<li>多维数组其实只是语法糖.如下两种情况其实是等价的:
<ul class="org-ul">
<li>number[][]</li>
<li>(number[])[]</li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org0c45b7c" class="outline-3">
<h3 id="org0c45b7c"><span class="section-number-3">6.2.</span> Array Members</h3>
<div class="outline-text-3" id="text-6-2">
<ul class="org-ul">
<li>typescript可以理解数组[index]得到的数据的类型:
<ul class="org-ul">
<li><p>
如果数组是string[],那么数组[index]类型是string,这个容易理解
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">defenders</span> = <span style="color: #000000;">[</span><span style="color: #3548cf;">"Clarenza"</span>, <span style="color: #3548cf;">"Dina"</span><span style="color: #000000;">]</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Type: string</span>
<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">defender</span> = defenders<span style="color: #000000;">[</span>0<span style="color: #000000;">]</span>;
</pre>
</div></li>
<li><p>
如果数组是(string | Date)[],那么数组[index]类型是 string | Date.这个有点反直觉,本以为Typescript能
够判断出具体类型的
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">soldersOrDates</span> = <span style="color: #000000;">[</span><span style="color: #3548cf;">"Deborah Sampson"</span>, <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Date</span><span style="color: #dd22dd;">(</span>1782, 6, 3<span style="color: #dd22dd;">)</span><span style="color: #000000;">]</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Type: Date | string</span>
<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">soldersOrDate</span> = soldersOrDates<span style="color: #000000;">[</span>0<span style="color: #000000;">]</span>;
</pre>
</div></li>
</ul></li>
</ul>
</div>
<div id="outline-container-orgb29b2a7" class="outline-4">
<h4 id="orgb29b2a7"><span class="section-number-4">6.2.1.</span> Caveat: Unsound Members</h4>
<div class="outline-text-4" id="text-6-2-1">
<ul class="org-ul">
<li>有个术语叫做unsound,意思就是说类型判断大多数情况下是准确的,但不是每次都是准确的. Typescript的type
system就是unsound的
<ul class="org-ul">
<li><p>
示例如下, typescript在compile time没有发现9001是一个错误的index
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #7f0000;">// </span><span style="color: #7f0000;">TypeError: Cannot read properties of undefined (reading 'length')</span>

<span style="color: #7f0000;">/////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">function withElements(</span><span style="color: #005e8b;">elements</span><span style="color: #7f0000;">: string[]) { //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">console.</span><span style="color: #721045;">log</span><span style="color: #7f0000;">(elements[9001].length);       //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">}                                           //</span>
<span style="color: #7f0000;">//                                             </span><span style="color: #7f0000;">//</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">withElements(["A", "AB", "ABC"])            //</span>
<span style="color: #7f0000;">/////////////////////////////////////////////////</span>
</pre>
</div></li>
<li>虽然也有报错,但是我们看到这个错误是一个runtime错误</li>
<li>如果我们设置&#x2013;noUncheckedIndexedAccess flag那么能够捕捉到这个错误,但是这个flag太严格了,几乎没有项
目使用这个flag</li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org3082492" class="outline-3">
<h3 id="org3082492"><span class="section-number-3">6.3.</span> Spreads and Rests</h3>
<div class="outline-text-3" id="text-6-3">
<ul class="org-ul">
<li>前面我们用过"&#x2026;"这个操作符,其在typescript里面和javascript的左右是一样的.:
<ul class="org-ul">
<li><p>
array spreading
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">fruits</span> = <span style="color: #000000;">[</span><span style="color: #3548cf;">"apple"</span>, <span style="color: #3548cf;">"banana"</span>, <span style="color: #3548cf;">"orange"</span><span style="color: #000000;">]</span>;
<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">moreFruits</span> = <span style="color: #000000;">[</span><span style="color: #3548cf;">"grape"</span>, ...fruits, <span style="color: #3548cf;">"pineapple"</span><span style="color: #000000;">]</span>;

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>moreFruits<span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">[ 'grape', 'apple', 'banana', 'orange', 'pineapple' ]</span>
</pre>
</div></li>
<li><p>
rest parameter
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">sum</span><span style="color: #000000;">(</span>...<span style="color: #005e8b;">numbers</span>: <span style="color: #531ab6;">number</span><span style="color: #dd22dd;">[]</span><span style="color: #000000;">)</span>: <span style="color: #531ab6;">number</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> numbers.<span style="color: #721045;">reduce</span><span style="color: #dd22dd;">(</span><span style="color: #008899;">(</span>total, num<span style="color: #008899;">)</span> <span style="color: #531ab6;">=&gt;</span> total + num, 0<span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">totalSum</span> = <span style="color: #721045;">sum</span><span style="color: #000000;">(</span>1, 2, 3, 4, 5<span style="color: #000000;">)</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>totalSum<span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">15</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
<div id="outline-container-orga28634e" class="outline-4">
<h4 id="orga28634e"><span class="section-number-4">6.3.1.</span> Spreads</h4>
<div class="outline-text-4" id="text-6-3-1">
<ul class="org-ul">
<li>Typescript足够聪明,可以知道两个不同类型的数组spread在一块得到的新数组,其类型是两个类型的union
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">soldiers</span> = <span style="color: #000000;">[</span><span style="color: #3548cf;">"Harriet Tubman"</span>, <span style="color: #3548cf;">"Joan of Arc"</span>, <span style="color: #3548cf;">"Khutulun"</span><span style="color: #000000;">]</span>; <span style="color: #7f0000;">// </span><span style="color: #7f0000;">Type: string[]</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">soldierAges</span> = <span style="color: #000000;">[</span>90, 19, 45<span style="color: #000000;">]</span>; <span style="color: #7f0000;">// </span><span style="color: #7f0000;">Type: number[]</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">conjoined</span> = <span style="color: #000000;">[</span>...soldiers, ...soldier<span style="color: #000000;">]</span>; <span style="color: #7f0000;">// </span><span style="color: #7f0000;">Type: (string | number)[]</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org3d0ffcd" class="outline-4">
<h4 id="org3d0ffcd"><span class="section-number-4">6.3.2.</span> Spreading Rest Parameters</h4>
<div class="outline-text-4" id="text-6-3-2">
<ul class="org-ul">
<li>如果"&#x2026;"作为rest parameters,那么我们的typescript就会进行严格检查了,不符合规定的实参传递不进去
<ul class="org-ul">
<li><p>
示例如下, string[]可以传入, number[]不能传入
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">logWarriers</span><span style="color: #000000;">(</span><span style="color: #005e8b;">greeting</span>: <span style="color: #531ab6;">string</span>, ...names: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">[]</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">for</span> <span style="color: #dd22dd;">(</span><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">name</span> <span style="color: #531ab6;">of</span> names<span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #3548cf;">`</span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">greeting</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">, </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">name</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">!`</span><span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">warriors</span> = <span style="color: #000000;">[</span><span style="color: #3548cf;">"Cathay Williams"</span>, <span style="color: #3548cf;">"Lozen"</span>, <span style="color: #3548cf;">"Nzinga"</span><span style="color: #000000;">]</span>;
<span style="color: #721045;">logWarriers</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Hello"</span>, ...warriors<span style="color: #000000;">)</span>;

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">brithYears</span> = <span style="color: #000000;">[</span>1844, 1840, 1583<span style="color: #000000;">]</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Hello, Cathay Williams!</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Hello, Lozen!</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Hello, Nzinga!</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:11:22 - error TS2345: Argument of type 'number' is not assignable to parameter of type 'string'.</span>

<span style="color: #7f0000;">//////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">logWarriers("Hello", ...brithYears); //</span>
<span style="color: #7f0000;">//////////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org6912ba1" class="outline-3">
<h3 id="org6912ba1"><span class="section-number-3">6.4.</span> Tuples</h3>
<div class="outline-text-3" id="text-6-4">
<ul class="org-ul">
<li>所谓tuple,就是fixed size array. 在python中也有tuple这个概念,typescript是对这个概念的增强:因为typescript
自己有类型系统.所以typescript的tuple包含了如下两层含义:
<ul class="org-ul">
<li>fixed size</li>
<li>type for each index</li>
</ul></li>
<li>tuple需要为每个index都声明类型,这些类型组成的数组又标明了其fixed的长度
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">yearAndWarrier</span>: <span style="color: #000000;">[</span><span style="color: #531ab6;">number</span>, <span style="color: #531ab6;">string</span><span style="color: #000000;">]</span>;
yearAndWarrier = <span style="color: #000000;">[</span>530, <span style="color: #3548cf;">"Tomyris"</span><span style="color: #000000;">]</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:3:19 - error TS2322: Type 'boolean' is not assignable to type 'number'.</span>

<span style="color: #7f0000;">//////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">yearAndWarrier = [false, "Tomyris"]; //</span>
<span style="color: #7f0000;">//////////////////////////////////////////</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:11:1 - error TS2322: Type '[number]' is not assignable to type '[number, string]'.</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">Source has 1 element(s) but target requires 2.</span>

<span style="color: #7f0000;">/////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">yearAndWarrier = [530]; //</span>
<span style="color: #7f0000;">/////////////////////////////</span>
</pre>
</div></li>
</ul></li>
<li>tuple最常用的场景是array destructuring, 其作用是一次性assign多个value
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #000000;">[</span><span style="color: #005e8b;">year</span>, <span style="color: #005e8b;">warrier</span><span style="color: #000000;">]</span> =
  Math.<span style="color: #721045;">random</span><span style="color: #000000;">()</span> &gt; 0.5 ? <span style="color: #000000;">[</span>340, <span style="color: #3548cf;">"Archidamia"</span><span style="color: #000000;">]</span> : <span style="color: #000000;">[</span>1828, <span style="color: #3548cf;">"Rani of Jhansi"</span><span style="color: #000000;">]</span>;

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span><span style="color: #3548cf;">`|year| =&gt; </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">year</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #000000;">)</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span><span style="color: #3548cf;">`|warrier| =&gt; </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">warrier</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT1====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|year| =&gt; 1828</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|warrier| =&gt; Rani of Jhansi</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT2====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|year| =&gt; 340</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|warrier| =&gt; Archidamia</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
<div id="outline-container-org2410da3" class="outline-4">
<h4 id="org2410da3"><span class="section-number-4">6.4.1.</span> Tuple Assignability</h4>
<div class="outline-text-4" id="text-6-4-1">
<ul class="org-ul">
<li>由于tuple的类型信息里面包括了每个index的类型,所以tuple是比array更加specific的类型,那么我们很显然是
没办法把array赋值给tuple的
<ul class="org-ul">
<li><p>
下面就是这样一个例子,我们的pairLosse这个数组不是我们想象的[boolean, number],其类型其实是(boolean | number)[],
那么显然其无法赋值给类型我[boolean, number]的tuple
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">pairLosse</span> = <span style="color: #000000;">[</span><span style="color: #0000b0;">false</span>, 123<span style="color: #000000;">]</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:3:7 - error TS2322: Type '(number | boolean)[]' is not assignable to type '[boolean, number]'.</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">Target requires 2 element(s) but source may have fewer.</span>

<span style="color: #7f0000;">//////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">const pairTupleLoose: [boolean, number] = pairLosse; //</span>
<span style="color: #7f0000;">//////////////////////////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
<li>不同长度的tuple,显然是无法赋值的.这个很显然
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">tupleThree</span>: <span style="color: #000000;">[</span><span style="color: #531ab6;">boolean</span>, <span style="color: #531ab6;">number</span>, <span style="color: #531ab6;">string</span><span style="color: #000000;">]</span> = <span style="color: #000000;">[</span><span style="color: #0000b0;">false</span>, 1583, <span style="color: #3548cf;">"Nzinga"</span><span style="color: #000000;">]</span>;
<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">tupleTwoExact1</span>: <span style="color: #000000;">[</span><span style="color: #531ab6;">boolean</span>, <span style="color: #531ab6;">number</span><span style="color: #000000;">]</span> = <span style="color: #000000;">[</span>tupleThree<span style="color: #dd22dd;">[</span>0<span style="color: #dd22dd;">]</span>, tupleThree<span style="color: #dd22dd;">[</span>1<span style="color: #dd22dd;">]</span><span style="color: #000000;">]</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:3:7 - error TS2322: Type '[boolean, number, string]' is not assignable to type '[boolean, number]'.</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">Source has 3 element(s) but target allows only 2.</span>

<span style="color: #7f0000;">///////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">const tupleTwoExact2: [boolean, number] = tupleThree; //</span>
<span style="color: #7f0000;">///////////////////////////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
<li>由于tuple包含了fixed数组和每个index的类型信息,其非常适合作为rest parameter传递给函数
<ul class="org-ul">
<li><p>
示例如下,tuple可以赋值给函数,其类型在每个index上面是确定的
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">logPair</span><span style="color: #000000;">(</span><span style="color: #005e8b;">name</span>: <span style="color: #531ab6;">string</span>, <span style="color: #005e8b;">value</span>: <span style="color: #531ab6;">number</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">`</span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">name</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;"> has </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">value</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">pairTupleCorrect</span>: <span style="color: #000000;">[</span><span style="color: #531ab6;">string</span>, <span style="color: #531ab6;">number</span><span style="color: #000000;">]</span> = <span style="color: #000000;">[</span><span style="color: #3548cf;">"Amage"</span>, 1<span style="color: #000000;">]</span>;
<span style="color: #721045;">logPair</span><span style="color: #000000;">(</span>...pairTupleCorrect<span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Amage has 1</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">pairTupleIncorrect</span>: <span style="color: #000000;">[</span><span style="color: #531ab6;">number</span>, <span style="color: #531ab6;">string</span><span style="color: #000000;">]</span> = <span style="color: #000000;">[</span>1, <span style="color: #3548cf;">"Amage"</span><span style="color: #000000;">]</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:6:9 - error TS2345: Argument of type 'number' is not assignable to parameter of type 'string'.</span>

<span style="color: #7f0000;">/////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">logPair(...pairTupleIncorrect); //</span>
<span style="color: #7f0000;">/////////////////////////////////////</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">pairArray</span> = <span style="color: #000000;">[</span><span style="color: #3548cf;">"Amage"</span>, 1<span style="color: #000000;">]</span>;
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:6:9 - error TS2556: A spread argument must either have a tuple type or be passed to a rest parameter.</span>

<span style="color: #7f0000;">////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">logPair(...pairArray); //</span>
<span style="color: #7f0000;">////////////////////////////</span>
</pre>
</div></li>
<li>作为反例,index类型不正确的tuple是赋值不成功的</li>
<li>作为另一个反例,数组也不能赋值给函数,其类型是union()</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgaf67b28" class="outline-4">
<h4 id="orgaf67b28"><span class="section-number-4">6.4.2.</span> Tuple Inferences</h4>
<div class="outline-text-4" id="text-6-4-2">
<ul class="org-ul">
<li>Typescript总体上,如果不特殊配置,都是把"[]"的代码都解释为variable length array的,而不是tuple
<ul class="org-ul">
<li><p>
示例如下,下面的函数把其返回值给infer成(string | number)[]
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">firstCharAndSize</span><span style="color: #000000;">(</span><span style="color: #005e8b;">input</span>: <span style="color: #531ab6;">string</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> <span style="color: #dd22dd;">[</span>input<span style="color: #008899;">[</span>0<span style="color: #008899;">]</span>, input.length<span style="color: #dd22dd;">]</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #000000;">[</span><span style="color: #005e8b;">firstChar</span>, <span style="color: #005e8b;">size</span><span style="color: #000000;">]</span> = <span style="color: #721045;">firstCharAndSize</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Gudit"</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:7:7 - error TS2322: Type 'string | number' is not assignable to type 'strng</span>

<span style="color: #7f0000;">////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">const tmp: string = firstChar; //</span>
<span style="color: #7f0000;">////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
<li>Typescript如果经过如下两种"特殊配置",那么就可以把"[]"解析成tuple:
<ul class="org-ul">
<li>explicit tuple type</li>
<li>const assertion</li>
</ul></li>
</ul>
</div>
<ol class="org-ol">
<li><a id="org6df672d"></a>Explicit tuple types<br />
<div class="outline-text-5" id="text-6-4-2-1">
<ul class="org-ul">
<li>如果一个函数的返回值明确的描述了自己要返回一个tuple type,并且代码里面使用了array literal(也就是"[]")
那么这种情况下,这个array literal会被infer成一个tuple,而不是数组
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">firstCharAndSizeExplicit</span><span style="color: #000000;">(</span><span style="color: #005e8b;">input</span>: <span style="color: #531ab6;">string</span><span style="color: #000000;">)</span>: <span style="color: #000000;">[</span><span style="color: #531ab6;">string</span>, <span style="color: #531ab6;">number</span><span style="color: #000000;">]</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> <span style="color: #dd22dd;">[</span>input<span style="color: #008899;">[</span>0<span style="color: #008899;">]</span>, input.length<span style="color: #dd22dd;">]</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #000000;">[</span><span style="color: #005e8b;">firstChar</span>, <span style="color: #005e8b;">size</span><span style="color: #000000;">]</span> = <span style="color: #721045;">firstCharAndSizeExplicit</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Cathay Williams"</span><span style="color: #000000;">)</span>;

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">typeStr</span>: <span style="color: #531ab6;">string</span> = firstChar;
<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">typeNum</span>: <span style="color: #531ab6;">number</span> = size;
</pre>
</div></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="orgbdd75c3"></a>Const asserted tuples<br />
<div class="outline-text-5" id="text-6-4-2-2">
<ul class="org-ul">
<li>如果每次都把类型明确的写出来,不仅非常的累,而且在更新代码的时候,还要同时更新这些类型,所以Typescript
也为我们提供了一种能够把array litral("[]")给直接解释成tuple的语法糖, as const
<ul class="org-ul">
<li><p>
示例如下,下面例子中的readonlyTuple就别infer成了tuple
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">unionArray</span> = <span style="color: #000000;">[</span>1157, <span style="color: #3548cf;">"Tomo"</span><span style="color: #000000;">]</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:3:7 - error TS2322: Type '(string | number)[]' is not assignable to type 'string'.</span>

<span style="color: #7f0000;">/////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">const typeStr: string = unionArray; //</span>
<span style="color: #7f0000;">/////////////////////////////////////////</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">readonlyTuple</span> = <span style="color: #000000;">[</span>1157, <span style="color: #3548cf;">"Tomoe"</span><span style="color: #000000;">]</span> <span style="color: #531ab6;">as</span> <span style="color: #531ab6;">const</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:12:7 - error TS2322: Type 'readonly [1157, "Tomoe"]' is not assignable to type 'string'.</span>

<span style="color: #7f0000;">////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">const typeStr: string = readonlyTuple; //</span>
<span style="color: #7f0000;">////////////////////////////////////////////</span>
</pre>
</div></li>
<li>从上面的例子中我们也可以看到使用as const返回的不仅仅是tuple,而是加了一个readonly的tuple,也就是readonly [1157, "Tomoe"]</li>
</ul></li>
<li>上面as const的副作用就是我们得到的tuple不仅仅是tuple,其是readonly的.这个readonly还不仅仅是对象不能重复被assign,而是每个成员都不能改动.
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">pairMutable</span>: <span style="color: #000000;">[</span><span style="color: #531ab6;">number</span>, <span style="color: #531ab6;">string</span><span style="color: #000000;">]</span> = <span style="color: #000000;">[</span>1157, <span style="color: #3548cf;">"Tomoe"</span><span style="color: #000000;">]</span>;
pairMutable<span style="color: #000000;">[</span>0<span style="color: #000000;">]</span> = 1247; <span style="color: #7f0000;">// </span><span style="color: #7f0000;">Ok</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">The type 'readonly [1157, "Tomoe"]' is 'readonly' and cannot be assigned to the mutable type '[number, string]'. (typescript-tide)</span>

<span style="color: #7f0000;">/////////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">const pairAlsoMutable: [number, string] = [1157, "Tomoe"] as const; //</span>
<span style="color: #7f0000;">/////////////////////////////////////////////////////////////////////////</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">pairConst</span> = <span style="color: #000000;">[</span>1157, <span style="color: #3548cf;">"Tomoe"</span><span style="color: #000000;">]</span> <span style="color: #531ab6;">as</span> <span style="color: #531ab6;">const</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:11:11 - error TS2540: Cannot assign to '0' because it is a read-only property.</span>

<span style="color: #7f0000;">//////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">pairConst[0] = 1247; //</span>
<span style="color: #7f0000;">//////////////////////////</span>
</pre>
</div></li>
</ul></li>
<li>在实践当中,read-only tuple最合适的使用场景是function return, 因为函数的返回值往往非常快的就被destructure
掉.用户只关心从function return里面取值,不关心其是否const
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">firstCharAndSizeAsConst</span><span style="color: #000000;">(</span><span style="color: #005e8b;">input</span>: <span style="color: #531ab6;">string</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> <span style="color: #dd22dd;">[</span>input<span style="color: #008899;">[</span>0<span style="color: #008899;">]</span>, input.length<span style="color: #dd22dd;">]</span> <span style="color: #531ab6;">as</span> <span style="color: #531ab6;">const</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #000000;">[</span><span style="color: #005e8b;">firstChar</span>, <span style="color: #005e8b;">size</span><span style="color: #000000;">]</span> = <span style="color: #721045;">firstCharAndSizeAsConst</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Ching Shih"</span><span style="color: #000000;">)</span>;

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span><span style="color: #3548cf;">`|firstChar| =&gt; </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">firstChar</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #000000;">)</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span><span style="color: #3548cf;">`|size| =&gt; </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">size</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|firstChar| =&gt; C</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">|size| =&gt; 10</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-orge4ae9b9" class="outline-2">
<h2 id="orge4ae9b9"><span class="section-number-2">7.</span> Chapter 7: Interfaces</h2>
<div class="outline-text-2" id="text-7">
<ul class="org-ul">
<li>我们前面主要介绍了type,其主要功能是describe object shape</li>
<li>而本章介绍的interface,其主要功能也是describe shape,interface的功能和type基本一致,但是多数情况下,
interface更应该被Typescript开发者所选择,因为其:
<ul class="org-ul">
<li>错误信息更加友好</li>
<li>编译器能更加快速编译</li>
<li>和class更好的进行配合</li>
</ul></li>
</ul>
</div>
<div id="outline-container-org123bc5c" class="outline-3">
<h3 id="org123bc5c"><span class="section-number-3">7.1.</span> Type Aliases Versus Intrfaces</h3>
<div class="outline-text-3" id="text-7-1">
<ul class="org-ul">
<li>我们用下面的代码来对比下type和Interface
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">type</span> <span style="color: #005f5f;">Poet1</span> = <span style="color: #000000;">{</span>
  born: <span style="color: #531ab6;">number</span>;
  name: <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>;

<span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">Poet2</span> <span style="color: #000000;">{</span>
  born: <span style="color: #531ab6;">number</span>;
  name: <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>
</pre>
</div></li>
<li>我们可以看到,两者的syntax基本一致</li>
<li>但是type的最后有分号,而interface最后没有.这个可以从javascript的规范来推导:
<ol class="org-ol">
<li>javascript里面创建一个变量是加分号的</li>
<li>javascript里面创建一个class或者function是不加分号的</li>
</ol></li>
</ul></li>
<li>Type和interface有如下根本上的不同:
<ul class="org-ul">
<li>interface是可以把多个interface合成一个的</li>
<li>interface是可以type check class 声明的,但是type不行</li>
<li>interface的编译更快</li>
<li>interface被编译器认为是"named object", 而type被编译器认为是"alias for an unnamed object literal",
所以显然interface的错误信息更易读</li>
</ul></li>
<li><p>
上面虽然都是区别,但是很显然凸显出interface的优势.最佳实践中,我们会默认使用interface,直到你遇到必须
使用type的情况,比如union type(required)或者是function type(cleaner syntax)
</p>
<pre class="example" id="org8261fba">
Use interfaces whenever possible, until you need features such as union types(required)
or function type (cleaner syntax)
</pre></li>
</ul>
</div>
</div>
<div id="outline-container-orgf463798" class="outline-3">
<h3 id="orgf463798"><span class="section-number-3">7.2.</span> Type of Proprties</h3>
<div class="outline-text-3" id="text-7-2">
<ul class="org-ul">
<li>真实世界的javascript object非常灵活(比如可选的property, setter和getter等), 为了能够适配这些灵活的情况,
typescript创建了一系列的type system tool</li>
<li>下面会介绍这些system tool,多说一句,这些tool竟然都能在type上面使用.可见type和interface有多相似.</li>
</ul>
</div>
<div id="outline-container-org5039285" class="outline-4">
<h4 id="org5039285"><span class="section-number-4">7.2.1.</span> Optional Properties</h4>
<div class="outline-text-4" id="text-7-2-1">
<ul class="org-ul">
<li>我们前面介绍object type的时候介绍过,某个object满足某个type可以有"可选的property",interface也同样拥有这个特性
<ul class="org-ul">
<li><p>
示例如下,任何object只需要pages存在,既可以被认为是Book interface
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">Book</span> <span style="color: #000000;">{</span>
  author?: <span style="color: #531ab6;">string</span>;
  pages: <span style="color: #531ab6;">number</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">ok</span>: <span style="color: #005f5f;">Book</span> = <span style="color: #000000;">{</span>
  author: <span style="color: #3548cf;">"Rita Dove"</span>,
  pages: 80,
<span style="color: #000000;">}</span>;

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">missing</span>: <span style="color: #005f5f;">Book</span> = <span style="color: #000000;">{</span>
  pages: 80,
<span style="color: #000000;">}</span>;
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgea4809f" class="outline-4">
<h4 id="orgea4809f"><span class="section-number-4">7.2.2.</span> Read-Only Properties</h4>
<div class="outline-text-4" id="text-7-2-2">
<ul class="org-ul">
<li>typescript的interface可以设置某些property为readonly,一旦设置,那么实现这个interface的object的相应
property不能在初始化之后再被赋值
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">Page</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">readonly</span> text: <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">function</span> <span style="color: #721045;">read</span><span style="color: #000000;">(</span><span style="color: #005e8b;">page</span>: <span style="color: #005f5f;">Page</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #dd22dd;">(</span>page.text<span style="color: #dd22dd;">)</span>;

  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:8:8 - error TS2540: Cannot assign to 'text' because it is a read-only property.</span>

  <span style="color: #7f0000;">///////////////////////</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">page.text += "!"; //</span>
  <span style="color: #7f0000;">///////////////////////</span>
<span style="color: #000000;">}</span>
</pre>
</div></li>
<li>需要注意的是,readonly这个标签,只有像上面例子一样,某个object"显式地"和某个interface发生映射关系的
时候才起作用. 下面例子中的page2 虽然也"隐式"的符合interface Page,但是在没有被read函数"显式"的指派
给Page interface之前,是可以随便改动text的</li>
</ul></li>
<li>需要理解的是,readonly这个特性是类型系统的typescript才有的,目的也是在编译阶段进行检查,最终编译成javascript
之后,就不存在这个特性了</li>
</ul>
</div>
</div>
<div id="outline-container-org40746ea" class="outline-4">
<h4 id="org40746ea"><span class="section-number-4">7.2.3.</span> Functions and Methods</h4>
<div class="outline-text-4" id="text-7-2-3">
<ul class="org-ul">
<li>在javascript里面function作为object的member是很正常的事情, 所以作为object的抽象interface,其也会允许
声明interface member的类型为function type</li>
<li>typescript提供了两种声明interface function memeber 的方式,其实是映射了两种javascript定义function的
方式(arrow和非arrow):
<ul class="org-ul">
<li>method syntax:对应常规函数,this会在调用时候动态绑定,适合class的instance使用</li>
<li>property syntax:对应箭头函数,this在创建时候就绑定,除了class的instance以外的情况都使用这个</li>
</ul></li>
<li>我们来看一个interface的例子,其中混合使用了两种function member的声明方式:
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">HasBothFunctionTypes</span> <span style="color: #000000;">{</span>
  property: <span style="color: #dd22dd;">()</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #531ab6;">string</span>;
  <span style="color: #721045;">method</span><span style="color: #dd22dd;">()</span>: <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">hasBoth</span>: <span style="color: #005f5f;">HasBothFunctionTypes</span> = <span style="color: #000000;">{</span>
  property: <span style="color: #dd22dd;">()</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #3548cf;">"property return"</span>,
  <span style="color: #721045;">method</span><span style="color: #dd22dd;">()</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">return</span> <span style="color: #3548cf;">"method return"</span>;
  <span style="color: #dd22dd;">}</span>,
<span style="color: #000000;">}</span>;

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>hasBoth.<span style="color: #721045;">property</span><span style="color: #dd22dd;">()</span><span style="color: #000000;">)</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>hasBoth.<span style="color: #721045;">method</span><span style="color: #dd22dd;">()</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">property return</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">method return</span>
</pre>
</div></li>
<li><p>
上面的每种形式也支持使用?来配置成optional参数
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">OptionalFunctions</span> <span style="color: #000000;">{</span>
  property?: <span style="color: #dd22dd;">()</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #531ab6;">string</span>;
  method?<span style="color: #dd22dd;">()</span>: <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>
</pre>
</div></li>
<li><p>
readonly只能在method 声明上面使用
</p>
<div class="org-src-container">
<pre class="src src-typescript">jinterface ReadonlyFunctions <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">readonly</span> property: <span style="color: #dd22dd;">()</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #531ab6;">string</span>;
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:3:3 - error TS1024: 'readonly' modifier can only appear on a property declaration or index signature.</span>

  <span style="color: #7f0000;">////////////////////////////////</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">readonly method(): string; //</span>
  <span style="color: #7f0000;">////////////////////////////////</span>
<span style="color: #000000;">}</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org0b3a894" class="outline-4">
<h4 id="org0b3a894"><span class="section-number-4">7.2.4.</span> Call Signatures</h4>
<div class="outline-text-4" id="text-7-2-4">
<ul class="org-ul">
<li>call signature是一个非常重要的特性,其用来描述一个value是如何能被像function一样调用的</li>
<li>上面这句定义非常难懂,其实也没有什么意义.我们通过例子来了解call signature在interface的三个主要使用
场景:
<ul class="org-ul">
<li><p>
interface通常描述一个类型,但是有时候interface描述的本身就是一个function(function也是一个类型)
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">StringToNumberConverter</span> <span style="color: #000000;">{</span>
  <span style="color: #dd22dd;">(</span>input: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">)</span>: <span style="color: #531ab6;">number</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">stringLength</span>: <span style="color: #005f5f;">StringToNumberConverter</span> = <span style="color: #000000;">(</span><span style="color: #005e8b;">input</span><span style="color: #000000;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> input.length;
<span style="color: #000000;">}</span>

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span><span style="color: #721045;">stringLength</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">"Hello"</span><span style="color: #dd22dd;">)</span><span style="color: #000000;">)</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">5</span>
</pre>
</div></li>
<li><p>
interface通常描述一个类型,很多的时候,这个类型是一个对象,那么这个对象里面就得有对应的函数才行.这个
时候call signature要有函数名
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">PriceCalculator</span> <span style="color: #000000;">{</span>
  calculatePrice: <span style="color: #dd22dd;">(</span>quantity: <span style="color: #531ab6;">number</span>, pricePerUnit: <span style="color: #531ab6;">number</span><span style="color: #dd22dd;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #531ab6;">number</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">calculator</span>: <span style="color: #005f5f;">PriceCalculator</span> = <span style="color: #000000;">{</span>
  calculatePrice: <span style="color: #dd22dd;">(</span><span style="color: #005e8b;">quantity</span>, <span style="color: #005e8b;">pricePreUnit</span><span style="color: #dd22dd;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">return</span> quantity * pricePreUnit;
  <span style="color: #dd22dd;">}</span>,
<span style="color: #000000;">}</span>;

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>calculator.<span style="color: #721045;">calculatePrice</span><span style="color: #dd22dd;">(</span>5, 10<span style="color: #dd22dd;">)</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">50</span>
</pre>
</div></li>
<li><p>
interface描述的本身就是一个function,然后这个function还有一些自己的变量.这属于第一种情况的扩展
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">Logger</span> <span style="color: #000000;">{</span>
  <span style="color: #dd22dd;">(</span>message: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">)</span>: <span style="color: #531ab6;">void</span>;
  logLevel: <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">myLogger</span>: <span style="color: #005f5f;">Logger</span> = <span style="color: #000000;">(</span><span style="color: #005e8b;">message</span>: <span style="color: #531ab6;">string</span><span style="color: #000000;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #000000;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">`[</span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">myLogger.logLevel</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">] </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">message</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>;
myLogger.logLevel = <span style="color: #3548cf;">"INFO"</span>;

<span style="color: #721045;">myLogger</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"This is a log message."</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">[INFO] This is a log message.</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org023a55b" class="outline-4">
<h4 id="org023a55b"><span class="section-number-4">7.2.5.</span> Index Signatures</h4>
<div class="outline-text-4" id="text-7-2-5">
<ul class="org-ul">
<li>有时候,你无法提前知道某个类型所有属性的名字,但是你知道这些属性值的类型(属性通常是字符串或者能转换成
字符串的类型,比如字符串,symbol, 所以这里强调属性值的类型)</li>
<li>在这种情况下,你可以使用index signature(索引签名)去描述可能的key和value的类型
<ul class="org-ul">
<li><p>
示例如下,只有number类型的value可以赋值成功
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">WordCounts</span> <span style="color: #000000;">{</span>
  <span style="color: #dd22dd;">[</span>i: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">]</span>: <span style="color: #531ab6;">number</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">counts</span>: <span style="color: #005f5f;">WordCounts</span> = <span style="color: #000000;">{}</span>;
counts.apple = 0;
counts.banana = 1;

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>counts<span style="color: #dd22dd;">[</span><span style="color: #3548cf;">"apple"</span><span style="color: #dd22dd;">]</span><span style="color: #000000;">)</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>counts<span style="color: #dd22dd;">[</span><span style="color: #3548cf;">"banana"</span><span style="color: #dd22dd;">]</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">0</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">1</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:12:1 - error TS2322: Type 'boolean' is not assignable to type 'number'.</span>

<span style="color: #7f0000;">////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">counts.cherry = false; //</span>
<span style="color: #7f0000;">////////////////////////////</span>
</pre>
</div></li>
</ul></li>
<li><p>
Index signature的存在的意义是:一个对象必须返回一个value,不管对象触发的property是什么.所以index signature
的重点,在于"不管触发的property是什么",而不在于typesafe
</p>
<pre class="example" id="orge8e19a5">
Index Signature indicates that an object should give back a value no matter
what proprty is being accessed
</pre></li>
<li>下面例子就是这样一种情况, publishDate的Beloved明明没设置,但是还是返回值了(undefined)
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">DatesByName</span> <span style="color: #000000;">{</span>
  <span style="color: #dd22dd;">[</span>i: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">]</span>: <span style="color: #005f5f;">Date</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">publishDates</span>: <span style="color: #005f5f;">DatesByName</span> = <span style="color: #000000;">{</span>
  Frankenstein: <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Date</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">"1 January 1818"</span><span style="color: #dd22dd;">)</span>,
<span style="color: #000000;">}</span>;

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>publishDates.Frankenstein<span style="color: #000000;">)</span>;

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>publishDates.Beloved<span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">1817-12-31T15:54:17.000Z</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">undefined</span>
</pre>
</div></li>
<li>上面这种情况下更应该的选择是Map</li>
</ul></li>
</ul>
</div>
<ol class="org-ol">
<li><a id="orgd1bb01c"></a>Mixing properties and index signatures<br />
<div class="outline-text-5" id="text-7-2-5-1">
<ul class="org-ul">
<li><p>
interface 甚至可以把index signature和一个具体的named property并列的列出来. 但是需要注意的是:
</p>
<pre class="example" id="org3c64709">
这个named property的key和value,必须能够assign给index signature
</pre></li>
<li>换句话说,就是named property列出大的范围, named property是这个大的范围里面的一个特例.这个特例也要符
合大的范围,并且object是必须要有property满足这个特例的,其他的property满足大范围就可以了
<ul class="org-ul">
<li><p>
完全匹配的例子(完全匹配必然可以assign)如下. 注意这例子中的`i`是一个占位符,其可以随意更改,必须改成`key`,这里写成`i`是因为这里代表index signature
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">HistorialNovels</span> <span style="color: #000000;">{</span>
  Oroonoko: <span style="color: #531ab6;">number</span>;
  <span style="color: #dd22dd;">[</span>i: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">]</span>: <span style="color: #531ab6;">number</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">novels</span>: <span style="color: #005f5f;">HistorialNovels</span> = <span style="color: #000000;">{</span>
  Outlander: 1991,
  Oroonoko: 1688,
<span style="color: #000000;">}</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:11:7 - error TS2741: Property 'Oroonoko' is missing in type '{ Outlander: number; }' but required in type 'HistorialNovels'.</span>

<span style="color: #7f0000;">////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">const missingOroonoko: HistorialNovels = { //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">Outlander: 1991,                         //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">};                                         //</span>
<span style="color: #7f0000;">////////////////////////////////////////////////</span>
</pre>
</div></li>
<li><p>
不完全匹配,但是可以assign的例子如下(0作为primitive是可以assign给number的,类似的还有literal可以assign给string)
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">ChapterStarts</span> <span style="color: #000000;">{</span>
  preface: 0;
  <span style="color: #dd22dd;">[</span>i: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">]</span>: <span style="color: #531ab6;">number</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">correctPreface</span>: <span style="color: #005f5f;">ChapterStarts</span> = <span style="color: #000000;">{</span>
  preface: 0,
  night: 1,
  shopping: 5,
<span style="color: #000000;">}</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:13:3 - error TS2322: Type '1' is not assignable to type '0'.</span>

<span style="color: #7f0000;">///////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">const wrongPreface: ChapterStarts = { //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">preface: 1,                         //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">};                                    //</span>
<span style="color: #7f0000;">///////////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="orge57f9f1"></a>Numeric index signatures<br />
<div class="outline-text-5" id="text-7-2-5-2">
<ul class="org-ul">
<li>虽然绝大部分情况下,我们使用string来作为object的key(因为javascript其实是隐式的将object key转换为string
的),但是也有时候,特别是在typescript里面,我们会以number来作为key.</li>
<li>不过这个number key其地位是类似named property,是一个特例,其还是要在string key限定的范围里面
<ul class="org-ul">
<li><p>
示例如下, [i:number]: string 是一个特例,类似上面的preface:0, 其value类型string必须能赋给catchall的string index
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">MoreNarrowNumbers</span> <span style="color: #000000;">{</span>
  <span style="color: #dd22dd;">[</span>i: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">]</span>: <span style="color: #531ab6;">string</span>;
  <span style="color: #dd22dd;">[</span>i: <span style="color: #531ab6;">number</span><span style="color: #dd22dd;">]</span>: <span style="color: #531ab6;">string</span> | <span style="color: #0000b0;">undefined</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">mixesNumberAndString</span>: <span style="color: #005f5f;">MoreNarrowNumbers</span> = <span style="color: #000000;">{</span>
  0: <span style="color: #3548cf;">""</span>,
  key1: <span style="color: #3548cf;">""</span>,
  key2: <span style="color: #0000b0;">undefined</span>,
<span style="color: #000000;">}</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:3:3 - error TS2413: 'number' index type 'string | undefined' is not assignable to 'string' index type 'string'.</span>

<span style="color: #7f0000;">////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">interface MoreNarrowStrings {      //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">[i: number]: string | undefined; //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">[i: string]: string;             //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">}                                  //</span>
<span style="color: #7f0000;">////////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</li>
</ol>
</div>
<div id="outline-container-orgd669ee2" class="outline-4">
<h4 id="orgd669ee2"><span class="section-number-4">7.2.6.</span> Nested Interfaces</h4>
<div class="outline-text-4" id="text-7-2-6">
<ul class="org-ul">
<li>就像object typeA可以nested成为 object typeB的property, interfaceA也能作为其他interface的property
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">Novel</span> <span style="color: #000000;">{</span>
  author: <span style="color: #dd22dd;">{</span>
    name: <span style="color: #531ab6;">string</span>;
  <span style="color: #dd22dd;">}</span>;
  setting: <span style="color: #005f5f;">Settings</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">Settings</span> <span style="color: #000000;">{</span>
  place: <span style="color: #531ab6;">string</span>;
  year: <span style="color: #531ab6;">number</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">myNovel</span>: <span style="color: #005f5f;">Novel</span>;

myNovel = <span style="color: #000000;">{</span>
  author: <span style="color: #dd22dd;">{</span>
    name: <span style="color: #3548cf;">"Jane Austen"</span>,
  <span style="color: #dd22dd;">}</span>,
  setting: <span style="color: #dd22dd;">{</span>
    place: <span style="color: #3548cf;">"England"</span>,
    year: 1812,
  <span style="color: #dd22dd;">}</span>,
<span style="color: #000000;">}</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:29:3 - error TS2741: Property 'year' is missing in type '{ place: string; }' but required in type 'Settings'.</span>

<span style="color: #7f0000;">//////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">myNovel = {                  //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">author: {                  //</span>
<span style="color: #7f0000;">//     </span><span style="color: #7f0000;">name: "Emilly Bronte",   //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">},                         //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">setting: {                 //</span>
<span style="color: #7f0000;">//     </span><span style="color: #7f0000;">place: "West Yorkshire", //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">},                         //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">};                           //</span>
<span style="color: #7f0000;">//////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orge26ff24" class="outline-3">
<h3 id="orge26ff24"><span class="section-number-3">7.3.</span> Interface Extensions</h3>
<div class="outline-text-3" id="text-7-3">
<ul class="org-ul">
<li>和java一样typescript的interface可以进行"继承",方法就是使用extends关键字
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">Writing</span> <span style="color: #000000;">{</span>
  title: <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">Novella</span> <span style="color: #531ab6;">extends</span> <span style="color: #005f5f;">Writing</span> <span style="color: #000000;">{</span>
  pages: <span style="color: #531ab6;">number</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">myNovella</span>: <span style="color: #005f5f;">Novella</span> = <span style="color: #000000;">{</span>
  pages: 195,
  title: <span style="color: #3548cf;">"Ethan Frome"</span>,
<span style="color: #000000;">}</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:14:5 - error TS2741: Property 'pages' is missing in type '{ title: string; }' but required in type 'Novella'.</span>

<span style="color: #7f0000;">///////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">let missingPages: Novella = { //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">title: "The Awakening",     //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">};                            //</span>
<span style="color: #7f0000;">///////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
<div id="outline-container-org1a13c62" class="outline-4">
<h4 id="org1a13c62"><span class="section-number-4">7.3.1.</span> Overridden Properties</h4>
<div class="outline-text-4" id="text-7-3-1">
<ul class="org-ul">
<li>derive interface 可以override base interface的property.这里的override和cpp里面的override是不一样的,
这里的override是说新的overridden property,比如能够assign 给base property:</li>
<li>assignable的方法一般有两种:
<ul class="org-ul">
<li><p>
使用subset of a typeo union
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#29238;&#25509;&#21475;</span>
<span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">Base</span> <span style="color: #000000;">{</span>
  status: <span style="color: #3548cf;">"active"</span> | <span style="color: #3548cf;">"inactive"</span> | <span style="color: #3548cf;">"archived"</span>; <span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#32852;&#21512;&#31867;&#22411;</span>
<span style="color: #000000;">}</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#27966;&#29983;&#25509;&#21475;</span>
<span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">Derived</span> <span style="color: #531ab6;">extends</span> <span style="color: #005f5f;">Base</span> <span style="color: #000000;">{</span>
  status: <span style="color: #3548cf;">"active"</span> | <span style="color: #3548cf;">"inactive"</span>; <span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#26356;&#20855;&#20307;&#30340;&#23376;&#38598;&#31867;&#22411;</span>
<span style="color: #000000;">}</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#31034;&#20363;&#20351;&#29992;</span>
<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">item1</span>: <span style="color: #005f5f;">Derived</span> = <span style="color: #000000;">{</span>
  status: <span style="color: #3548cf;">"active"</span>, <span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#21512;&#27861;</span>
<span style="color: #000000;">}</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:17:3 - error TS2322: Type '"archived"' is not assignable to type '"active" | "inactive"'.</span>

<span style="color: #7f0000;">//////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">const item2: Derived = { //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">status: "archived",    //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">};                       //</span>
<span style="color: #7f0000;">//////////////////////////////</span>
</pre>
</div></li>
<li><p>
使用从base interface type extend出来的type
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#29238;&#25509;&#21475;</span>
<span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">Base</span> <span style="color: #000000;">{</span>
  details: <span style="color: #dd22dd;">{</span>
    id: <span style="color: #531ab6;">number</span>;
  <span style="color: #dd22dd;">}</span>; <span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#22522;&#30784;&#31867;&#22411;</span>
<span style="color: #000000;">}</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#27966;&#29983;&#25509;&#21475;</span>
<span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">Derived</span> <span style="color: #531ab6;">extends</span> <span style="color: #005f5f;">Base</span> <span style="color: #000000;">{</span>
  details: <span style="color: #dd22dd;">{</span>
    id: <span style="color: #531ab6;">number</span>;
    name: <span style="color: #531ab6;">string</span>; <span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#26032;&#22686;&#23383;&#27573;</span>
  <span style="color: #dd22dd;">}</span>; <span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#25193;&#23637;&#31867;&#22411;</span>
<span style="color: #000000;">}</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#31034;&#20363;&#20351;&#29992;</span>
<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">item1</span>: <span style="color: #005f5f;">Derived</span> = <span style="color: #000000;">{</span>
  details: <span style="color: #dd22dd;">{</span>
    id: 1,
    name: <span style="color: #3548cf;">"Item 1"</span>, <span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#21512;&#27861;&#65292;&#22240;&#20026;&#27966;&#29983;&#25509;&#21475;&#25193;&#23637;&#20102;&#29238;&#25509;&#21475;&#30340;&#23646;&#24615;</span>
  <span style="color: #dd22dd;">}</span>,
<span style="color: #000000;">}</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:25:3 - error TS2741: Property 'name' is missing in type '{ id: number; }' but required in type '{ id: number; name: string; }'.</span>

<span style="color: #7f0000;">//////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">const item2: Derived = { //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">details: {             //</span>
<span style="color: #7f0000;">//     </span><span style="color: #7f0000;">id: 2,               //</span>
<span style="color: #7f0000;">//     </span><span style="color: #7f0000;">// name &#32570;&#22833;         //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">},                     //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">};                       //</span>
<span style="color: #7f0000;">//////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org5f34f37" class="outline-4">
<h4 id="org5f34f37"><span class="section-number-4">7.3.2.</span> Extending Multiple Interfaces</h4>
<div class="outline-text-4" id="text-7-3-2">
<ul class="org-ul">
<li>interface的extends可以extends多个不同的interface,用","隔开
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">GivesNumber</span> <span style="color: #000000;">{</span>
  <span style="color: #721045;">giveNumber</span><span style="color: #dd22dd;">()</span>: <span style="color: #531ab6;">number</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">GivesString</span> <span style="color: #000000;">{</span>
  <span style="color: #721045;">giveString</span><span style="color: #dd22dd;">()</span>: <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">GivesBothAndEither</span> <span style="color: #531ab6;">extends</span> <span style="color: #005f5f;">GivesNumber</span>, GivesString <span style="color: #000000;">{</span>
  <span style="color: #721045;">giveEither</span><span style="color: #dd22dd;">()</span>: <span style="color: #531ab6;">number</span> | <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">function</span> <span style="color: #721045;">useGivesBoth</span><span style="color: #000000;">(</span><span style="color: #005e8b;">instance</span>: <span style="color: #005f5f;">GivesBothAndEither</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  instance.<span style="color: #721045;">giveEither</span><span style="color: #dd22dd;">()</span>;
  instance.<span style="color: #721045;">giveNumber</span><span style="color: #dd22dd;">()</span>;
  instance.<span style="color: #721045;">giveString</span><span style="color: #dd22dd;">()</span>;
<span style="color: #000000;">}</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org9f8b0ec" class="outline-3">
<h3 id="org9f8b0ec"><span class="section-number-3">7.4.</span> Interface Merging</h3>
<div class="outline-text-3" id="text-7-4">
<ul class="org-ul">
<li>Interface Merging是typescript中非常特殊的特性,在其他语言中很少见.interface merging是说在同一个scope
定义的两个名字相同的interface,那么他们自动合并成一个更大的interface
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">Merged</span> <span style="color: #000000;">{</span>
  fromFirst: <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">Merged</span> <span style="color: #000000;">{</span>
  fromSecond: <span style="color: #531ab6;">number</span>;
<span style="color: #000000;">}</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Equivalent to</span>
<span style="color: #7f0000;">///////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">interface Merged {    //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">fromFirst: string;  //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">fromSecond: number; //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">}                     //</span>
<span style="color: #7f0000;">///////////////////////////</span>
</pre>
</div></li>
</ul></li>
<li>注意:Interface merging是一个让代码不容易被人理解的特性,普通程序不建议使用</li>
</ul>
</div>
<div id="outline-container-org5a9ef23" class="outline-4">
<h4 id="org5a9ef23"><span class="section-number-4">7.4.1.</span> Member Naming Conflicts</h4>
<div class="outline-text-4" id="text-7-4-1">
<ul class="org-ul">
<li>虽然我们不会太使用interface merging,但是我们这里还是介绍一下interface merging在property和method方
面的一个不同:
<ul class="org-ul">
<li><p>
在不同的merging interfaces里面是不能定义"名字相同,但是类型不同的"property的(arrow function)
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">MergedProperties</span> <span style="color: #000000;">{</span>
  same: <span style="color: #dd22dd;">(</span>input: <span style="color: #531ab6;">boolean</span><span style="color: #dd22dd;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #531ab6;">string</span>;
  different: <span style="color: #dd22dd;">(</span>input: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">MergedProperties</span> <span style="color: #000000;">{</span>
  same: <span style="color: #dd22dd;">(</span>input: <span style="color: #531ab6;">boolean</span><span style="color: #dd22dd;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #531ab6;">string</span>;

  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:8:3 - error TS2717: Subsequent property declarations must have the same type.  Property 'different' must be of type '(input: string) =&gt; string', but here has type '(input: number) =&gt; string'.</span>

  <span style="color: #7f0000;">///////////////////////////////////////////</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">different: (input: number) =&gt; string; //</span>
  <span style="color: #7f0000;">///////////////////////////////////////////</span>
<span style="color: #000000;">}</span>
</pre>
</div></li>
<li><p>
在不同的merging interfaces里面是可以定义"名字相同,但是类型不同的"method的(非arrow function)
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">MergedMethods</span> <span style="color: #000000;">{</span>
  <span style="color: #721045;">different</span><span style="color: #dd22dd;">(</span><span style="color: #005e8b;">input</span>: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">)</span>: <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">MergedMethods</span> <span style="color: #000000;">{</span>
  <span style="color: #721045;">different</span><span style="color: #dd22dd;">(</span><span style="color: #005e8b;">input</span>: <span style="color: #531ab6;">number</span><span style="color: #dd22dd;">)</span>: <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-orgf021dd7" class="outline-2">
<h2 id="orgf021dd7"><span class="section-number-2">8.</span> Chapter 8: Classes</h2>
<div class="outline-text-2" id="text-8">
</div>
<div id="outline-container-orgd1b3cb0" class="outline-3">
<h3 id="orgd1b3cb0"><span class="section-number-3">8.1.</span> Class Methods</h3>
<div class="outline-text-3" id="text-8-1">
<ul class="org-ul">
<li>在typescript看来,如下两个概念是没有区别的,都是需要些参数(没设置就是any类型), 返回值如果不是递归的,
就可以infer到:
<ul class="org-ul">
<li>class里面的method</li>
<li>普通的function</li>
</ul></li>
<li>下面就是一个简单的Greetr class(拥有greet class method)的例子
<ul class="org-ul">
<li><p>
普通class method示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">Greeter</span> <span style="color: #000000;">{</span>
  <span style="color: #721045;">greet</span><span style="color: #dd22dd;">(</span><span style="color: #005e8b;">name</span>: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #3548cf;">`</span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">name</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">, do your stuff !`</span><span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Greeter</span><span style="color: #000000;">()</span>.<span style="color: #721045;">greet</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Miss Frizzle"</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:9:15 - error TS2554: Expected 1 arguments, but got 0.</span>

<span style="color: #7f0000;">////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">new Greeter().</span><span style="color: #721045;">greet</span><span style="color: #7f0000;">(); //</span>
<span style="color: #7f0000;">////////////////////////////</span>
</pre>
</div></li>
<li><p>
constructor也被看做是普通个class method而已
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">Greeter</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">constructor</span><span style="color: #dd22dd;">(</span>message: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #3548cf;">`As I always say: </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">message</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">!`</span><span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Greeter</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"take chances, make mistaks, get messy"</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:9:1 - error TS2554: Expected 1 arguments, but got 0.</span>

<span style="color: #7f0000;">////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">new Greeter(); //</span>
<span style="color: #7f0000;">////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgf479dfd" class="outline-3">
<h3 id="orgf479dfd"><span class="section-number-3">8.2.</span> Class Properties</h3>
<div class="outline-text-3" id="text-8-2">
<ul class="org-ul">
<li>如果一个typescript的class里面的property需要写入和读取,必须explicitly的在class内部声明,没有声明的property
不会被编译器所识别
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">FieldTrip</span> <span style="color: #000000;">{</span>
  destination: <span style="color: #531ab6;">string</span>;

  <span style="color: #531ab6;">constructor</span><span style="color: #dd22dd;">(</span>destitnation: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">this</span>.destination = destitnation;
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #3548cf;">`We're going to </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">this.destination</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #008899;">)</span>;

    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:8:10 - error TS2339: Property 'nonexistent' does not exist on type 'FieldTrip'.</span>

    <span style="color: #7f0000;">//////////////////////////////////////</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">this.nonexistent = destitnation; //</span>
    <span style="color: #7f0000;">//////////////////////////////////////</span>
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">trip</span> = <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">FieldTrip</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"planetarium"</span><span style="color: #000000;">)</span>;

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>trip.destination<span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:21:18 - error TS2339: Property 'nonexistent' does not exist on type 'FieldTrip'.</span>

<span style="color: #7f0000;">////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">console.</span><span style="color: #721045;">log</span><span style="color: #7f0000;">(trip.nonexistent); //</span>
<span style="color: #7f0000;">////////////////////////////////////</span>
</pre>
</div></li>
<li>一旦在class里面创建了property,那么使用的时候就知道哪些property可以使用了,没有声明过的nonexistent显然无法使用</li>
</ul></li>
</ul>
</div>
<div id="outline-container-org0f6c7e0" class="outline-4">
<h4 id="org0f6c7e0"><span class="section-number-4">8.2.1.</span> Function Properties</h4>
<div class="outline-text-4" id="text-8-2-1">
<ul class="org-ul">
<li>我们回顾下javascript的method scoping和syntax fundamentals,以便更好的理解typescript的特性:javascript
在class里面可以声明两种member的callable function:
<ul class="org-ul">
<li>method: 第一种是直接定义一个method,这是最传统的做法</li>
<li>property: 第二种是定义一个property,只是这个property的类型刚好是function</li>
</ul></li>
<li>这两种方法在typescript上面当然也必须有相应的映射:</li>
</ul>
</div>
<ol class="org-ol">
<li><a id="org6bf4945"></a>使用方法(method)<br />
<div class="outline-text-5" id="text-8-2-1-1">
<ul class="org-ul">
<li>这是最常见的的一种方式,方法是直接定义在类上掉函数
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">CallableClass</span> <span style="color: #000000;">{</span>
  <span style="color: #721045;">callableMethod</span><span style="color: #dd22dd;">()</span>: <span style="color: #531ab6;">void</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #3548cf;">"This is a callable method!"</span><span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">instance</span> = <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">CallableClass</span><span style="color: #000000;">()</span>;
instance.<span style="color: #721045;">callableMethod</span><span style="color: #000000;">()</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>
  <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">CallableClass</span><span style="color: #dd22dd;">()</span>.callableMethod === <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">CallableClass</span><span style="color: #dd22dd;">()</span>.callableMethod,
<span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">This is a callable method!</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">true</span>
</pre>
</div></li>
</ul></li>
<li>这种定义有如下特点:
<ul class="org-ul">
<li>定义的方法会存储在类的prototype上,因此对于多个实例来说,它们共享一个函数,不会占用额外的内存</li>
<li><p>
this是动态绑定的
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">Example</span> <span style="color: #000000;">{</span>
  <span style="color: #721045;">regularFunction</span><span style="color: #dd22dd;">()</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #0000b0;">this</span><span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">obj</span> = <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Example</span><span style="color: #000000;">()</span>;
obj.<span style="color: #721045;">regularFunction</span><span style="color: #000000;">()</span>;

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">detachedFunction</span> = obj.regularFunction;
<span style="color: #721045;">detachedFunction</span><span style="color: #000000;">()</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Example {}</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">undefined</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org7ecfeb4"></a>使用属性赋值为函数(Property as Function)<br />
<div class="outline-text-5" id="text-8-2-1-2">
<ul class="org-ul">
<li>这种方式是通过类的属性值直接赋值为一个函数
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">CallableClass</span> <span style="color: #000000;">{</span>
  callbleProperty = <span style="color: #dd22dd;">()</span>: <span style="color: #531ab6;">void</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #3548cf;">"This is a callable property !"</span><span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">instance</span> = <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">CallableClass</span><span style="color: #000000;">()</span>;
instance.<span style="color: #721045;">callbleProperty</span><span style="color: #000000;">()</span>;

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>
  <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">CallableClass</span><span style="color: #dd22dd;">()</span>.callbleProperty === <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">CallableClass</span><span style="color: #dd22dd;">()</span>.callbleProperty,
<span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">This is a callable property !</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">false</span>
</pre>
</div></li>
</ul></li>
<li>这种定义有如下特点:
<ul class="org-ul">
<li>函数是直接绑定在实例上的,而不是类的prototype上,因此每个实例都会有一份独立的函数</li>
<li><p>
this是自动绑定定义时的上下文的
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">Example</span> <span style="color: #000000;">{</span>
  arrowFunction = <span style="color: #dd22dd;">()</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #0000b0;">this</span><span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">obj</span> = <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Example</span><span style="color: #000000;">()</span>;
obj.<span style="color: #721045;">arrowFunction</span><span style="color: #000000;">()</span>;

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">detachedFunction</span> = obj.arrowFunction;
<span style="color: #721045;">detachedFunction</span><span style="color: #000000;">()</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Example { arrowFunction: [Function (anonymous)] }</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Example { arrowFunction: [Function (anonymous)] }</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</li>
</ol>
</div>
<div id="outline-container-org3c9bee3" class="outline-4">
<h4 id="org3c9bee3"><span class="section-number-4">8.2.2.</span> Initialization Checking</h4>
<div class="outline-text-4" id="text-8-2-2">
<ul class="org-ul">
<li>如果设置了strict compiler setting enable,那么typescript会check每个被设置为undefined的property
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">WithValue</span> <span style="color: #000000;">{</span>
  immediate = 0;
  later: <span style="color: #531ab6;">number</span>;
  mayBeUndefined: <span style="color: #531ab6;">number</span> | <span style="color: #0000b0;">undefined</span>;

  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:6:3 - error TS2564: Property 'unused' has no initializer and is not definitely assigned in the constructor.</span>

  unused: <span style="color: #531ab6;">number</span>;

  <span style="color: #531ab6;">constructor</span><span style="color: #dd22dd;">()</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">this</span>.later = 1;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>
</pre>
</div></li>
<li>注意如果strict compiler setting没有设置的话,上面的例子是可以编译通过的</li>
</ul></li>
<li>在极端情况下,我们甚至可以通过在property后面加一个 `!` 来disable check.这通常发生在我们很确信在使用
之前我们会通过一个非constructor的方法来初始化这个property
<ul class="org-ul">
<li><p>
示例如下, 我们通过initialize()函数来初始化了pending
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">ActivitiesQueue</span> <span style="color: #000000;">{</span>
  pending!: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">[]</span>;
  <span style="color: #721045;">initialize</span><span style="color: #dd22dd;">(</span><span style="color: #005e8b;">pending</span>: <span style="color: #531ab6;">string</span><span style="color: #008899;">[]</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">this</span>.pending = pending;
  <span style="color: #dd22dd;">}</span>
  <span style="color: #721045;">next</span><span style="color: #dd22dd;">()</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">return</span> <span style="color: #531ab6;">this</span>.pending.<span style="color: #721045;">pop</span><span style="color: #008899;">()</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">activities</span> = <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">ActivitiesQueue</span><span style="color: #000000;">()</span>;

activities.<span style="color: #721045;">initialize</span><span style="color: #000000;">(</span><span style="color: #dd22dd;">[</span><span style="color: #3548cf;">"eat"</span>, <span style="color: #3548cf;">"sleep"</span>, <span style="color: #3548cf;">"learn"</span><span style="color: #dd22dd;">]</span><span style="color: #000000;">)</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>activities.<span style="color: #721045;">next</span><span style="color: #dd22dd;">()</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">learn</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgdf33816" class="outline-4">
<h4 id="orgdf33816"><span class="section-number-4">8.2.3.</span> Optional Properties</h4>
<div class="outline-text-4" id="text-8-2-3">
<ul class="org-ul">
<li>和interface一样,class的property也可以设置为optional的.
<ul class="org-ul">
<li><p>
示例如下,一旦设置为property,那么即便不在constructor里面配置,编译器也不会抱怨
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">MissingInitializer</span> <span style="color: #000000;">{</span>
  proprty?: <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span><span style="color: #531ab6;">new</span> <span style="color: #005f5f;">MissingInitializer</span><span style="color: #dd22dd;">()</span>.proprty?.length<span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">undefined</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:6:13 - error TS2532: Object is possibly 'undefined'.</span>

<span style="color: #7f0000;">///////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">console.</span><span style="color: #721045;">log</span><span style="color: #7f0000;">(new MissingInitializer().proprty.length); //</span>
<span style="color: #7f0000;">///////////////////////////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orge951e5c" class="outline-4">
<h4 id="orge951e5c"><span class="section-number-4">8.2.4.</span> Read-Only Properties</h4>
<div class="outline-text-4" id="text-8-2-4">
<ul class="org-ul">
<li>就和interface一样, class里面也能设置某些property为readonly
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">Quote</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">readonly</span> text: <span style="color: #531ab6;">string</span>;

  <span style="color: #531ab6;">constructor</span><span style="color: #dd22dd;">(</span>text: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">this</span>.text = text;
  <span style="color: #dd22dd;">}</span>

  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:9:10 - error TS2540: Cannot assign to 'text' because it is a read-only property.</span>

  <span style="color: #7f0000;">/////////////////////////</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">emphasize() {       //</span>
  <span style="color: #7f0000;">//   </span><span style="color: #7f0000;">this.text += "!"; //</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">}                   //</span>
  <span style="color: #7f0000;">/////////////////////////</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">quote</span> = <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Quote</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Hello"</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:21:7 - error TS2540: Cannot assign to 'text' because it is a read-only property.</span>

<span style="color: #7f0000;">////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">quote.text = 'Ha!" //</span>
<span style="color: #7f0000;">////////////////////////</span>
</pre>
</div></li>
</ul></li>
<li>readonly property只能在如下两个地方初始化:
<ul class="org-ul">
<li>要么是在declare的时候</li>
<li>要么是在constructor里面</li>
</ul></li>
<li>定义为readonly的类型有一个特别特别细节的优化:它们在被typescript infer类型的时候,会尽可能的"严格"
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript">jclass RandomQuote <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">readonly</span> explicit: <span style="color: #531ab6;">string</span> = <span style="color: #3548cf;">"Explicit Original"</span>;
  <span style="color: #531ab6;">readonly</span> implicit = <span style="color: #3548cf;">"Implicit Original"</span>;

  <span style="color: #531ab6;">constructor</span><span style="color: #dd22dd;">()</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">if</span> <span style="color: #008899;">(</span>Math.<span style="color: #721045;">random</span><span style="color: #972500;">()</span> &gt; 0.5<span style="color: #008899;">)</span> <span style="color: #008899;">{</span>
      <span style="color: #531ab6;">this</span>.explicit = <span style="color: #3548cf;">"Explicit New"</span>;
      <span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
      <span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:8:7 - error TS2322: Type '"Implicit New"' is not assignable to type '"Implicit Original"'.</span>

      <span style="color: #7f0000;">////////////////////////////////////</span>
      <span style="color: #7f0000;">// </span><span style="color: #7f0000;">this.implicit = "Implicit New" //</span>
      <span style="color: #7f0000;">////////////////////////////////////</span>
    <span style="color: #008899;">}</span>
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>
</pre>
</div></li>

<li>我们可以看到,如果不加string, implicit直接被infer成了更严格的literal type,也就是"Implicit Original"</li>
<li>只有加了string的explicit才真正获得了string的类型</li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org74ea0c0" class="outline-3">
<h3 id="org74ea0c0"><span class="section-number-3">8.3.</span> Classes as Types</h3>
<div class="outline-text-3" id="text-8-3">
<ul class="org-ul">
<li>Class在类型系统里面是比较特殊的,因为一个class declaration会创建两个东西:
<ul class="org-ul">
<li><p>
运行时的值-也就是类本身,可以被实例化(其实本质是一个函数),甚至是直接使用. 比如类的静态属性就是类
本身的值,不需要实例化就可以使用,如下例
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">MathUtils</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">static</span> pi = 3.14159;
  <span style="color: #531ab6;">static</span> <span style="color: #721045;">calculateArea</span><span style="color: #dd22dd;">(</span><span style="color: #005e8b;">radius</span>: <span style="color: #531ab6;">number</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">return</span> MathUtils.pi * radius * radius;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>MathUtils.pi<span style="color: #000000;">)</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>MathUtils.<span style="color: #721045;">calculateArea</span><span style="color: #dd22dd;">(</span>10<span style="color: #dd22dd;">)</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">3.14159</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">314.159</span>
</pre>
</div></li>
<li><p>
同时还是类型系统中的一个类型
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">MathUtils</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">static</span> pi = 3.14159;
  <span style="color: #531ab6;">static</span> <span style="color: #721045;">calculateArea</span><span style="color: #dd22dd;">(</span><span style="color: #005e8b;">radius</span>: <span style="color: #531ab6;">number</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">return</span> MathUtils.pi * radius * radius;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">mathUtils</span>: <span style="color: #005f5f;">MathUtils</span> = <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">MathUtils</span><span style="color: #000000;">()</span>;

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>mathUtils<span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">MathUtils {}</span>
</pre>
</div></li>
</ul></li>
<li>还有一个有意思(但是非常少发生的情况),就是我们如果一个参数是一个class,由于class也可以作为一个type,
那么我们竟然可以传递把一个符合这个type的object(不需要实例化自class).
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">SchoolBus</span> <span style="color: #000000;">{</span>
  <span style="color: #721045;">getAbilities</span><span style="color: #dd22dd;">()</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">return</span> <span style="color: #008899;">[</span><span style="color: #3548cf;">"magic"</span>, <span style="color: #3548cf;">"shapeshifting"</span><span style="color: #008899;">]</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">function</span> <span style="color: #721045;">withSchoolBus</span><span style="color: #000000;">(</span><span style="color: #005e8b;">bus</span>: <span style="color: #005f5f;">SchoolBus</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #dd22dd;">(</span>bus.<span style="color: #721045;">getAbilities</span><span style="color: #008899;">()</span><span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>

<span style="color: #721045;">withSchoolBus</span><span style="color: #000000;">(</span><span style="color: #531ab6;">new</span> <span style="color: #005f5f;">SchoolBus</span><span style="color: #dd22dd;">()</span><span style="color: #000000;">)</span>;

<span style="color: #721045;">withSchoolBus</span><span style="color: #000000;">(</span><span style="color: #dd22dd;">{</span>
  getAbilities: <span style="color: #008899;">()</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #008899;">[</span><span style="color: #3548cf;">"transmogrification"</span><span style="color: #008899;">]</span>,
<span style="color: #dd22dd;">}</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">[ 'magic', 'shapeshifting' ]</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">[ 'transmogrification' ]</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:19:23 - error TS2322: Type 'number' is not assignable to type 'string[]'.</span>

<span style="color: #7f0000;">////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">withSchoolBus({            //</span>
<span style="color: #7f0000;">//                            </span><span style="color: #7f0000;">//</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">getAbilities: () =&gt; 123; //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">});                        //</span>
<span style="color: #7f0000;">////////////////////////////////</span>
</pre>
</div></li>
<li>这么做看起来是把class当做了interface,所以多数情况下是应该使用interface,而不是class</li>
<li>这么做能成功的深层次原因是typescript是"隐式"类型判断(只要你符合shape of object就可以),不需要显式的体现</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orga7343ab" class="outline-3">
<h3 id="orga7343ab"><span class="section-number-3">8.4.</span> Classes and Interfaces</h3>
<div class="outline-text-3" id="text-8-4">
<ul class="org-ul">
<li><p>
typescript里面当然也支持class和interface最原始的"编程语言定义": 那就是让class implements某个interface,
在编译器通过的情况下,class的instance都可以放在interface声明的位置
</p>
<pre class="example" id="orgdeba226">
Class can implements interfaces, doing so indicates to TypeScript that
instance of the class should be assignable to each of those interfaces
</pre></li>
<li>我们前面说过,interface有两种定义callable function成员的方法: member function和property.如果你想要
class来implements你的interface,那么推荐使用ember function的声明方法,因为class里面的实例化的样子和
interface里面声明的样子是相同的.这样写起来更让人容易理解
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">Learner</span> <span style="color: #000000;">{</span>
  name: <span style="color: #531ab6;">string</span>;
  <span style="color: #721045;">study</span><span style="color: #dd22dd;">(</span><span style="color: #005e8b;">hours</span>: <span style="color: #531ab6;">number</span><span style="color: #dd22dd;">)</span>: <span style="color: #531ab6;">void</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">class</span> <span style="color: #005f5f;">Student</span> <span style="color: #531ab6;">implements</span> <span style="color: #005f5f;">Learner</span> <span style="color: #000000;">{</span>
  name: <span style="color: #531ab6;">string</span>;
  <span style="color: #531ab6;">constructor</span><span style="color: #dd22dd;">(</span>name: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">this</span>.name = name;
  <span style="color: #dd22dd;">}</span>

  <span style="color: #721045;">study</span><span style="color: #dd22dd;">(</span><span style="color: #005e8b;">hours</span>: <span style="color: #531ab6;">number</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">for</span> <span style="color: #008899;">(</span><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">i</span> = 0; i &lt; <span style="color: #005f5f;">hours</span>; <span style="color: #005f5f;">i</span> += 1<span style="color: #008899;">)</span> <span style="color: #008899;">{</span>
      <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #972500;">(</span><span style="color: #3548cf;">"...studying..."</span><span style="color: #972500;">)</span>;
    <span style="color: #008899;">}</span>
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:19:7 - error TS2420: Class 'Slacker' incorrectly implements interface 'Learner'.</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">Property 'study' is missing in type 'Slacker' but required in type 'Learner'.</span>

<span style="color: #7f0000;">////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">class Slacker implements Learner { //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">name = "Rocky";                  //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">}                                  //</span>
<span style="color: #7f0000;">////////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
<li>需要注意的是,class implements interface的情况下, typescript主要是对class内部的成员进行check而已,
并不会自动帮class里面的类型进行infer(特别是从any infer到符合interface的类型).这是由Typescript的立场
决定的: 它主要做类型检查!
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">Learner</span> <span style="color: #000000;">{</span>
  name: <span style="color: #531ab6;">string</span>;
  <span style="color: #721045;">study</span><span style="color: #dd22dd;">(</span><span style="color: #005e8b;">hours</span>: <span style="color: #531ab6;">number</span><span style="color: #dd22dd;">)</span>: <span style="color: #531ab6;">void</span>;
<span style="color: #000000;">}</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:8:9 - error TS7006: Parameter 'hours' implicitly has an 'any' type.</span>

<span style="color: #7f0000;">////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">class Slacker implements Learner { //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">name = "Rocky";                  //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">study(</span><span style="color: #005e8b;">hours</span><span style="color: #7f0000;">) {}                  //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">}                                  //</span>
<span style="color: #7f0000;">////////////////////////////////////////</span>
</pre>
</div></li>
<li>上例中的hours还是any类型,不不会因为implements了Learner而被infer成number类型</li>
</ul></li>
</ul>
</div>
<div id="outline-container-orgefcfceb" class="outline-4">
<h4 id="orgefcfceb"><span class="section-number-4">8.4.1.</span> Implementing Multiple Interfaces</h4>
<div class="outline-text-4" id="text-8-4-1">
<ul class="org-ul">
<li><p>
和其他语言一样,TypeScript也允许一个class implements多个interface, 示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">Graded</span> <span style="color: #000000;">{</span>
  grades: <span style="color: #531ab6;">number</span><span style="color: #dd22dd;">[]</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">Reporter</span> <span style="color: #000000;">{</span>
  report: <span style="color: #dd22dd;">()</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">class</span> <span style="color: #005f5f;">ReportCard</span> <span style="color: #531ab6;">implements</span> <span style="color: #005f5f;">Graded</span>, <span style="color: #005f5f;">Reporter</span> <span style="color: #000000;">{</span>
  grades: <span style="color: #531ab6;">number</span><span style="color: #dd22dd;">[]</span>;

  <span style="color: #531ab6;">constructor</span><span style="color: #dd22dd;">(</span>grades: <span style="color: #531ab6;">number</span><span style="color: #008899;">[]</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">this</span>.grades = grades;
  <span style="color: #dd22dd;">}</span>

  <span style="color: #721045;">report</span><span style="color: #dd22dd;">()</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">return</span> <span style="color: #531ab6;">this</span>.grades.<span style="color: #721045;">join</span><span style="color: #008899;">(</span><span style="color: #3548cf;">", "</span><span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:21:7 - error TS2420: Class 'Empty' incorrectly implements interface 'Graded'.</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">Property 'grades' is missing in type 'Empty' but required in type 'Graded'.</span>

<span style="color: #7f0000;">////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">class Empty implements Graded, Reporter {} //</span>
<span style="color: #7f0000;">////////////////////////////////////////////////</span>
</pre>
</div></li>
<li>当然这几个interface要相互"容忍"对方,如果不同interface里面的成员定义相抵触,那么显然同时实现这些interface是不合理的
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">AgeIsANumber</span> <span style="color: #000000;">{</span>
  age: <span style="color: #531ab6;">number</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">AgeIsNotANumber</span> <span style="color: #000000;">{</span>
  age: <span style="color: #dd22dd;">()</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:10:3 - error TS2416: Property 'age' in type 'AsNumber' is not assignable to the same property in base type 'AgeIsNotANumber'.</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">Type 'number' is not assignable to type '() =&gt; string'.</span>

<span style="color: #7f0000;">///////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">class AsNumber implements AgeIsANumber, AgeIsNotANumber { //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">age = 0;                                                //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">}                                                         //</span>
<span style="color: #7f0000;">///////////////////////////////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orge778d5e" class="outline-3">
<h3 id="orge778d5e"><span class="section-number-3">8.5.</span> Extending a Class</h3>
<div class="outline-text-3" id="text-8-5">
<ul class="org-ul">
<li>和其他编程语言一样, class之间可以相互继承.
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">Teacher</span> <span style="color: #000000;">{</span>
  <span style="color: #721045;">teach</span><span style="color: #dd22dd;">()</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #3548cf;">"The surest test of discipline is its absense."</span><span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">class</span> <span style="color: #005f5f;">StudentTeacher</span> <span style="color: #531ab6;">extends</span> <span style="color: #005f5f;">Teacher</span> <span style="color: #000000;">{</span>
  <span style="color: #721045;">learn</span><span style="color: #dd22dd;">()</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #3548cf;">"I cannot afford the luxury of a closed mind."</span><span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">teacher</span> = <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">StudentTeacher</span><span style="color: #000000;">()</span>;
teacher.<span style="color: #721045;">teach</span><span style="color: #000000;">()</span>;
teacher.<span style="color: #721045;">learn</span><span style="color: #000000;">()</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">The surest test of discipline is its absense.</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">I cannot afford the luxury of a closed mind.</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
<div id="outline-container-orgef6b3f1" class="outline-4">
<h4 id="orgef6b3f1"><span class="section-number-4">8.5.1.</span> Extension Assignability</h4>
<div class="outline-text-4" id="text-8-5-1">
<ul class="org-ul">
<li>subclass extends 一个base class类似于class implements一个interface.那么:
<ul class="org-ul">
<li>由于interface声明的地方,都可以使用implements它的class</li>
<li><p>
那么base class声明的地方,必然可以使用subclass,示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">Lesson</span> <span style="color: #000000;">{</span>
  subject: <span style="color: #531ab6;">string</span>;

  <span style="color: #531ab6;">constructor</span><span style="color: #dd22dd;">(</span>subject: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">this</span>.subject = subject;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">class</span> <span style="color: #005f5f;">OnlineLesson</span> <span style="color: #531ab6;">extends</span> <span style="color: #005f5f;">Lesson</span> <span style="color: #000000;">{</span>
  url: <span style="color: #531ab6;">string</span>;

  <span style="color: #531ab6;">constructor</span><span style="color: #dd22dd;">(</span>subject: <span style="color: #531ab6;">string</span>, url: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">super</span><span style="color: #008899;">(</span>subject<span style="color: #008899;">)</span>;
    <span style="color: #531ab6;">this</span>.url = url;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">lesson</span>: <span style="color: #005f5f;">Lesson</span>;

lesson = <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Lesson</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"coding"</span><span style="color: #000000;">)</span>;
lesson = <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">OnlineLesson</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"coding"</span>, <span style="color: #3548cf;">"oreilly.com"</span><span style="color: #000000;">)</span>;

<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">online</span>: <span style="color: #005f5f;">OnlineLesson</span>;
online = <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">OnlineLesson</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"coding"</span>, <span style="color: #3548cf;">"oreilly.com"</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:26:1 - error TS2741: Property 'url' is missing in type 'Lesson' but required in type 'OnlineLesson'.</span>

<span style="color: #7f0000;">////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">online = new Lesson("coding"); //</span>
<span style="color: #7f0000;">////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
<li>同时,拜Typescript的structural checking(也就是隐式类型检查)所赐,如果subclass没有引入新的memeber(换句
话说,subclass和base的函数和property都一样),那么subclass声明的地方也能放置base class
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">PastGrades</span> <span style="color: #000000;">{</span>
  grades: <span style="color: #531ab6;">number</span><span style="color: #dd22dd;">[]</span> = <span style="color: #dd22dd;">[]</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">class</span> <span style="color: #005f5f;">LabeledPastGrades</span> <span style="color: #531ab6;">extends</span> <span style="color: #005f5f;">PastGrades</span> <span style="color: #000000;">{</span>
  label?: <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">subClass</span>: <span style="color: #005f5f;">LabeledPastGrades</span>;

subClass = <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">LabeledPastGrades</span><span style="color: #000000;">()</span>;
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">this can work because of TypeScript's structural typing!</span>
subClass = <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">PastGrades</span><span style="color: #000000;">()</span>;
</pre>
</div></li>
<li>由于subclass LabeledPastGrades只增加了一个optional property,所以base class竟然可以subclass声明的
地方.</li>
<li>注意!这个例子更多的是介绍Typescript的structural checking带来的副作用,常规代码中,subclass总会带来
"确定性"的不同,不会让base class能否在subclass放置的地方起作用</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgc2a4d91" class="outline-4">
<h4 id="orgc2a4d91"><span class="section-number-4">8.5.2.</span> Overriddeng Constructors</h4>
<div class="outline-text-4" id="text-8-5-2">
<ul class="org-ul">
<li>继承其实是需要调用base class的constructor的. TypeScript会帮我们进行这方面的检查,比如:
<ul class="org-ul">
<li><p>
强制要求调用base class的constructor,如果不调用就报错
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">GradeAnnouncer</span> <span style="color: #000000;">{</span>
  message: <span style="color: #531ab6;">string</span>;
  <span style="color: #531ab6;">constructor</span><span style="color: #dd22dd;">(</span>grade: <span style="color: #531ab6;">number</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">this</span>.message = grade &gt;= 65 ? <span style="color: #3548cf;">"You Pass"</span> : <span style="color: #3548cf;">"Maybe next time"</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">class</span> <span style="color: #005f5f;">PassingAnnouncer</span> <span style="color: #531ab6;">extends</span> <span style="color: #005f5f;">GradeAnnouncer</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">constructor</span><span style="color: #dd22dd;">()</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">super</span><span style="color: #008899;">(</span>100<span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:15:3 - error TS2377: Constructors for derived classes must contain a 'super' call.</span>

<span style="color: #7f0000;">//////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">class FaillingAnnouncer extends GradeAnnouncer { //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">constructor() {}                               //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">}                                                //</span>
<span style="color: #7f0000;">//////////////////////////////////////////////////////</span>
</pre>
</div></li>
<li><p>
subclass 如果调用constructor(下面的例子中不调用constructor就没事)需要调用base class的constructor
(通过super)之后,才能使用this,如果顺序不对,就报错
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">GradesTally</span> <span style="color: #000000;">{</span>
  grades: <span style="color: #531ab6;">number</span><span style="color: #dd22dd;">[]</span> = <span style="color: #dd22dd;">[]</span>;
  <span style="color: #721045;">addGrades</span><span style="color: #dd22dd;">(</span>...<span style="color: #005e8b;">grades</span>: <span style="color: #531ab6;">number</span><span style="color: #008899;">[]</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">this</span>.grades.<span style="color: #721045;">push</span><span style="color: #008899;">(</span>...grades<span style="color: #008899;">)</span>;
    <span style="color: #531ab6;">return</span> <span style="color: #531ab6;">this</span>.grades.length;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">class</span> <span style="color: #005f5f;">ContinueGradesTally</span> <span style="color: #531ab6;">extends</span> <span style="color: #005f5f;">GradesTally</span> <span style="color: #000000;">{</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:11:5 - error TS17009: 'super' must be called before accessing 'this' in the constructor of a derived class.</span>
  <span style="color: #7f0000;">////////////////////////////////////////////////////////////////</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">constructor(</span><span style="color: #005e8b;">previousGrades</span><span style="color: #7f0000;">: number[]) {                    //</span>
  <span style="color: #7f0000;">//   </span><span style="color: #7f0000;">this.grades = [...previousGrades];                       //</span>
  <span style="color: #7f0000;">//   </span><span style="color: #7f0000;">super();                                                 //</span>
  <span style="color: #7f0000;">//   </span><span style="color: #7f0000;">console.</span><span style="color: #721045;">log</span><span style="color: #7f0000;">("Starting with length", this.grades.length); //</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">}                                                          //</span>
  <span style="color: #7f0000;">////////////////////////////////////////////////////////////////</span>
<span style="color: #000000;">}</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orge83c050" class="outline-4">
<h4 id="orge83c050"><span class="section-number-4">8.5.3.</span> Overridden Methods</h4>
<div class="outline-text-4" id="text-8-5-3">
<ul class="org-ul">
<li>subclass可以redeclare base class的同名函数,只要新的类型是assignable给老类型的(所谓assignable我们之
前在函数重载部分讲到过,大意就是对应类型可以不存在,但是有必须类型相同).
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">GradeCounter</span> <span style="color: #000000;">{</span>
  <span style="color: #721045;">countGrades</span><span style="color: #dd22dd;">(</span><span style="color: #005e8b;">grades</span>: <span style="color: #531ab6;">string</span><span style="color: #008899;">[]</span>, <span style="color: #005e8b;">letter</span>: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">return</span> grades.<span style="color: #721045;">filter</span><span style="color: #008899;">(</span><span style="color: #972500;">(</span>grade<span style="color: #972500;">)</span> <span style="color: #531ab6;">=&gt;</span> grade === letter<span style="color: #008899;">)</span>.length;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">class</span> <span style="color: #005f5f;">FailureCounter</span> <span style="color: #531ab6;">extends</span> <span style="color: #005f5f;">GradeCounter</span> <span style="color: #000000;">{</span>
  <span style="color: #721045;">countGrades</span><span style="color: #dd22dd;">(</span><span style="color: #005e8b;">grades</span>: <span style="color: #531ab6;">string</span><span style="color: #008899;">[]</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">return</span> <span style="color: #531ab6;">super</span>.<span style="color: #721045;">countGrades</span><span style="color: #008899;">(</span>grades, <span style="color: #3548cf;">"F"</span><span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:14:3 - error TS2416: Property 'countGrades' in type 'AnyFailureChecker' is not assignable to the same property in base type 'GradeCounter'.</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">Type '(grades: string[]) =&gt; boolean' is not assignable to type '(grades: string[], letter: string) =&gt; number'.</span>
<span style="color: #7f0000;">//     </span><span style="color: #7f0000;">Type 'boolean' is not assignable to type 'number'.</span>

<span style="color: #7f0000;">//////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">class AnyFailureChecker extends GradeCounter {   //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">countGrades(</span><span style="color: #005e8b;">grades</span><span style="color: #7f0000;">: string[]) {                //</span>
<span style="color: #7f0000;">//     </span><span style="color: #7f0000;">return super.</span><span style="color: #721045;">countGrades</span><span style="color: #7f0000;">(grades, "F") !== 0; //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">}                                              //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">}                                                //</span>
<span style="color: #7f0000;">//////////////////////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgfc834b2" class="outline-4">
<h4 id="orgfc834b2"><span class="section-number-4">8.5.4.</span> Overridden Properties</h4>
<div class="outline-text-4" id="text-8-5-4">
<ul class="org-ul">
<li>既然能够重载method,那么重载property也是非常正常的.</li>
<li>重载property类型一定能够assignable, 对于property来说,assiable一般意味着更加specific的类型,比如union
type中少一些类型
<ul class="org-ul">
<li><p>
示例如下, 类型从头string | undefined, 变成了string,更specific
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">Assignment</span> <span style="color: #000000;">{</span>
  grade?: <span style="color: #531ab6;">number</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">class</span> <span style="color: #005f5f;">GradeAssignment</span> <span style="color: #531ab6;">extends</span> <span style="color: #005f5f;">Assignment</span> <span style="color: #000000;">{</span>
  grade: <span style="color: #531ab6;">number</span>;

  <span style="color: #531ab6;">constructor</span><span style="color: #dd22dd;">(</span>grade: <span style="color: #531ab6;">number</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">super</span><span style="color: #008899;">()</span>;
    <span style="color: #531ab6;">this</span>.grade = grade;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>
</pre>
</div></li>
</ul></li>
<li>相反,如果我们在继承的时候,expand了我们property的union type,那么是会报错的,原因很简单,我们没办法把一
个可能性更广的subclass值给base class,因为代码是根据base class来写的,根本没考虑到新增的类型.
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">NumericGrade</span> <span style="color: #000000;">{</span>
  value = 0;
<span style="color: #000000;">}</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:6:3 - error TS2416: Property 'value' in type 'VagueGrade' is not assignable to the same property in base type 'NumericGrade'.</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">Type 'string | number' is not assignable to type 'number'.</span>
<span style="color: #7f0000;">//     </span><span style="color: #7f0000;">Type 'string' is not assignable to type 'number'.</span>

<span style="color: #7f0000;">////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">class VagueGrade extends NumericGrade {    //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">value = Math.</span><span style="color: #721045;">random</span><span style="color: #7f0000;">() &gt; 0.5 ? 1 : "..."; //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">}                                          //</span>
<span style="color: #7f0000;">////////////////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org3b31213" class="outline-3">
<h3 id="org3b31213"><span class="section-number-3">8.6.</span> Abstract Classes</h3>
<div class="outline-text-3" id="text-8-6">
<ul class="org-ul">
<li>有时候我们希望创建一个base class,它的部分method是没有implementation的(换言之,其他部分都提供了实现),
而是希望subclass来实现这部分method
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">abstract</span> <span style="color: #531ab6;">class</span> <span style="color: #005f5f;">School</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">readonly</span> name: <span style="color: #531ab6;">string</span>;
  <span style="color: #531ab6;">constructor</span><span style="color: #dd22dd;">(</span>name: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">this</span>.name = name;
  <span style="color: #dd22dd;">}</span>

  <span style="color: #531ab6;">abstract</span> <span style="color: #721045;">getStudentTypes</span><span style="color: #dd22dd;">()</span>: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">[]</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">class</span> <span style="color: #005f5f;">Preschool</span> <span style="color: #531ab6;">extends</span> <span style="color: #005f5f;">School</span> <span style="color: #000000;">{</span>
  <span style="color: #721045;">getStudentTypes</span><span style="color: #dd22dd;">()</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">return</span> <span style="color: #008899;">[</span><span style="color: #3548cf;">"preschooler"</span><span style="color: #008899;">]</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:16:7 - error TS18052: Non-abstract class 'Absence' does not implement all abstract members of 'School'</span>

<span style="color: #7f0000;">/////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">class Absence extends School {} //</span>
<span style="color: #7f0000;">/////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
<li>由于abstract class缺少某些method的实现,所以abstract class是不能初始化的.
<ul class="org-ul">
<li><p>
试图初始化一个abstrct class会报错
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">abstract</span> <span style="color: #531ab6;">class</span> <span style="color: #005f5f;">School</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">readonly</span> name: <span style="color: #531ab6;">string</span>;
  <span style="color: #531ab6;">constructor</span><span style="color: #dd22dd;">(</span>name: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">this</span>.name = name;
  <span style="color: #dd22dd;">}</span>

  <span style="color: #531ab6;">abstract</span> <span style="color: #721045;">getStudentTypes</span><span style="color: #dd22dd;">()</span>: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">[]</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">class</span> <span style="color: #005f5f;">Preschool</span> <span style="color: #531ab6;">extends</span> <span style="color: #005f5f;">School</span> <span style="color: #000000;">{</span>
  <span style="color: #721045;">getStudentTypes</span><span style="color: #dd22dd;">()</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">return</span> <span style="color: #008899;">[</span><span style="color: #3548cf;">"preschooler"</span><span style="color: #008899;">]</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">school</span>: <span style="color: #005f5f;">School</span>;
school = <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Preschool</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Sunnyside Daycare"</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:19:10 - error TS2511: Cannot create an instance of an abstract class.</span>

<span style="color: #7f0000;">////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">school = new School("somewhere else"); //</span>
<span style="color: #7f0000;">////////////////////////////////////////////</span>
</pre>
</div></li>

<li>abstract class通常应用于framework: 实现了部分细节,但是留给用户来实现剩下的细节.同时我还能使用abstract
class来在需要的地方只用abstract class类型的变量站位(比如上面例子中的school: School)</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org3c526d1" class="outline-3">
<h3 id="org3c526d1"><span class="section-number-3">8.7.</span> Member Visibility</h3>
<div class="outline-text-3" id="text-8-7">
<ul class="org-ul">
<li>JavaScript引入了`#`关键字来表示某个class的member是private的
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #531ab6;">class</span> Person <span style="color: #000000;">{</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#31169;&#26377;&#23383;&#27573;</span>
  #name;

  constructor<span style="color: #dd22dd;">(</span>name<span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #0000b0;">this</span>.#name = name; <span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#21482;&#33021;&#22312;&#31867;&#20869;&#37096;&#35775;&#38382;</span>
  <span style="color: #dd22dd;">}</span>

  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#20844;&#20849;&#26041;&#27861;&#65292;&#29992;&#20110;&#35775;&#38382;&#31169;&#26377;&#23383;&#27573;</span>
  getName<span style="color: #dd22dd;">()</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">return</span> <span style="color: #0000b0;">this</span>.#name;
  <span style="color: #dd22dd;">}</span>

  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#20844;&#20849;&#26041;&#27861;&#65292;&#29992;&#20110;&#20462;&#25913;&#31169;&#26377;&#23383;&#27573;</span>
  setName<span style="color: #dd22dd;">(</span>newName<span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #0000b0;">this</span>.#name = newName;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">person</span> = <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Person</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Alice"</span><span style="color: #000000;">)</span>;

console.log<span style="color: #000000;">(</span>person.getName<span style="color: #dd22dd;">()</span><span style="color: #000000;">)</span>; <span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#36755;&#20986;: Alice</span>
person.setName<span style="color: #000000;">(</span><span style="color: #3548cf;">"Bob"</span><span style="color: #000000;">)</span>;
console.log<span style="color: #000000;">(</span>person.getName<span style="color: #dd22dd;">()</span><span style="color: #000000;">)</span>; <span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#36755;&#20986;: Bob</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Alice</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Bob</span>


<span style="color: #7f0000;">// </span><span style="color: #7f0000;">SyntaxError: Private field '#name' must be declared in an enclosing class</span>
<span style="color: #7f0000;">////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">console.log(person.#name); //</span>
<span style="color: #7f0000;">////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
<li>Typescript当然支持`#`关键字,但是它同时引入了和其他编程语言类似的三级visibility系统,关键字分别是:
<ul class="org-ul">
<li>public (default): 允许任何人访问</li>
<li>protected: 只有class和其他subclas可以访问</li>
<li>private: 只有class自己可以访问</li>
</ul></li>
<li>注意,这些关键字只是在type system里面起作用,转换为javascript的时候,就被去掉了
<ul class="org-ul">
<li><p>
我们来看一个包括这些关键字的例子
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">Base</span> <span style="color: #000000;">{</span>
  isPublicImplicit = 0;
  <span style="color: #531ab6;">public</span> isPublicExplicit = 1;
  <span style="color: #531ab6;">protected</span> isProtected = 2;
  <span style="color: #531ab6;">private</span> isPrivate = 3;
  #truePrivate = 4;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">class</span> <span style="color: #005f5f;">Subclass</span> <span style="color: #531ab6;">extends</span> <span style="color: #005f5f;">Base</span> <span style="color: #000000;">{</span>
  <span style="color: #721045;">examples</span><span style="color: #dd22dd;">()</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #531ab6;">this</span>.isPublicImplicit<span style="color: #008899;">)</span>;
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #531ab6;">this</span>.isPublicExplicit<span style="color: #008899;">)</span>;
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #531ab6;">this</span>.isProtected<span style="color: #008899;">)</span>;

    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:15:10 - error TS2341: Property 'isPrivate' is private and only accessible within class 'Base'.</span>

    <span style="color: #7f0000;">/////////////////////</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">this.isPrivate; //</span>
    <span style="color: #7f0000;">/////////////////////</span>

    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:21:10 - error TS18013: Property '#truePrivate' is not accessible outside class 'Base' because it has a private identifier.</span>

    <span style="color: #7f0000;">////////////////////////</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">this.#truePrivate; //</span>
    <span style="color: #7f0000;">////////////////////////</span>
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Subclass</span><span style="color: #000000;">()</span>.isPublicImplicit;
<span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Subclass</span><span style="color: #000000;">()</span>.isPublicExplicit;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:33:16 - error TS2445: Property 'isProtected' is protected and only accessible within class 'Base' and its subclasses.</span>

<span style="color: #7f0000;">/////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">new Subclass().isProtected; //</span>
<span style="color: #7f0000;">/////////////////////////////////</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:41:16 - error TS2341: Property 'isPrivate' is private and only accessible within class 'Base'.</span>

<span style="color: #7f0000;">///////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">new Subclass().isPrivate; //</span>
<span style="color: #7f0000;">///////////////////////////////</span>

<span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Subclass</span><span style="color: #000000;">()</span>.<span style="color: #721045;">examples</span><span style="color: #000000;">()</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">0</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">1</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">2</span>
</pre>
</div></li>
</ul></li>

<li>visibility modifier 可以和readonly一起使用, visibility modifier在前, readonly在后
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">TwoKeywords</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">private</span> <span style="color: #531ab6;">readonly</span> name: <span style="color: #531ab6;">string</span>;

  <span style="color: #531ab6;">constructor</span><span style="color: #dd22dd;">()</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">this</span>.name = <span style="color: #3548cf;">"Anne Sullivan"</span>;
  <span style="color: #dd22dd;">}</span>

  <span style="color: #721045;">log</span><span style="color: #dd22dd;">()</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #531ab6;">this</span>.name<span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">two</span> = <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">TwoKeywords</span><span style="color: #000000;">()</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:15:5 - error TS2341: Property 'name' is private and only accessible within class 'TwoKeywords'.</span>

<span style="color: #7f0000;">////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">two.name = "Savitribai Phule"; //</span>
<span style="color: #7f0000;">////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
<div id="outline-container-org2896a6a" class="outline-4">
<h4 id="org2896a6a"><span class="section-number-4">8.7.1.</span> Static Field Modifiers</h4>
<div class="outline-text-4" id="text-8-7-1">
<ul class="org-ul">
<li>javascript的static关键字用来表示某个member是class的,而不是instance的</li>
<li>TypeScript是支持这个关键字的,而且支持这个关键字和readonly一起使用.
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">Question</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">protected</span> <span style="color: #531ab6;">static</span> <span style="color: #531ab6;">readonly</span> answer: <span style="color: #3548cf;">"bash"</span>;
  <span style="color: #531ab6;">protected</span> <span style="color: #531ab6;">static</span> <span style="color: #531ab6;">readonly</span> prompt =
    <span style="color: #3548cf;">"What's an ogre's favorite programming language?"</span>;

  <span style="color: #721045;">guess</span><span style="color: #dd22dd;">(</span><span style="color: #005e8b;">getAnswer</span>: <span style="color: #008899;">(</span><span style="color: #005e8b;">prompt</span>: <span style="color: #531ab6;">string</span><span style="color: #008899;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">const</span> <span style="color: #005e8b;">answer</span> = <span style="color: #721045;">getAnswer</span><span style="color: #008899;">(</span>Question.prompt<span style="color: #008899;">)</span>;

    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">Ok</span>
    <span style="color: #531ab6;">if</span> <span style="color: #008899;">(</span>answer === Question.answer<span style="color: #008899;">)</span> <span style="color: #008899;">{</span>
      <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #972500;">(</span><span style="color: #3548cf;">"You got it!"</span><span style="color: #972500;">)</span>;
    <span style="color: #008899;">}</span> <span style="color: #531ab6;">else</span> <span style="color: #008899;">{</span>
      <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #972500;">(</span><span style="color: #3548cf;">"Try again..."</span><span style="color: #972500;">)</span>;
    <span style="color: #008899;">}</span>
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:19:22 - error TS2445: Property 'answer' is protected and only accessible within class 'Question' and its subclasses.</span>

<span style="color: #7f0000;">//////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">console.</span><span style="color: #721045;">log</span><span style="color: #7f0000;">(Question.answer) //</span>
<span style="color: #7f0000;">//////////////////////////////////</span>
</pre>
</div></li>
<li>从上面的例子来看,不同关键字放置的顺序是:
<ol class="org-ol">
<li>visibility modifier</li>
<li>static</li>
<li>readonly</li>
</ol></li>
</ul></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-orgda13b0d" class="outline-2">
<h2 id="orgda13b0d"><span class="section-number-2">9.</span> Chapter 9: Type Modifiers</h2>
<div class="outline-text-2" id="text-9">
</div>
<div id="outline-container-orge8a9a10" class="outline-3">
<h3 id="orge8a9a10"><span class="section-number-3">9.1.</span> Top Types</h3>
<div class="outline-text-3" id="text-9-1">
</div>
<div id="outline-container-orgd90420e" class="outline-4">
<h4 id="orgd90420e"><span class="section-number-4">9.1.1.</span> any, Again</h4>
<div class="outline-text-4" id="text-9-1-1">
<ul class="org-ul">
<li>any类型可以作为top type,所谓top type是指提供一个location来放置任意类型</li>
<li>any一般放置的位置是那些所有类型都可以放置的位置,比如console.log</li>
<li>any的问题是,它其实是告诉TypeScript不要再做类型检查了,这样做降低了TypeScript的作用
<ul class="org-ul">
<li><p>
示例如下,下面的代码,在把一个对象赋值给string的时候,TypeScript本来可以报错的,但是由于name定义成了
any类型,所以TypeScript也就不进行检查了
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">greetComedian</span><span style="color: #000000;">(</span><span style="color: #005e8b;">name</span>: <span style="color: #531ab6;">any</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">`Announcing </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">name.toUpperCase()</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>

<span style="color: #721045;">greetComedian</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Bea Arthur"</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Announcing BEA ARTHUR</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TypeError: name.toUpperCase is not a function</span>

<span style="color: #7f0000;">////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">greetComedian({ name: "Bea Arthur" }); //</span>
<span style="color: #7f0000;">////////////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org15759e6" class="outline-4">
<h4 id="org15759e6"><span class="section-number-4">9.1.2.</span> unknown</h4>
<div class="outline-text-4" id="text-9-1-2">
<ul class="org-ul">
<li><p>
any的危害我们已经看到了,其实TypeScript真正希望你使用的top type是unknown,而不是any
</p>
<pre class="example" id="org5b832fb">
You should generally prefer using unknown instead of any when possible
</pre></li>
<li>unknown初看起来非常的严格:
<ul class="org-ul">
<li><p>
不允许直接访问unknown(经过value narrow后就可以了哈,否则没法使用了)
</p>
<div class="org-src-container">
<pre class="src src-typescript"> <span style="color: #531ab6;">function</span> <span style="color: #721045;">greetComedian</span><span style="color: #000000;">(</span><span style="color: #005e8b;">name</span>: <span style="color: #531ab6;">unknown</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:2:29 - error TS18046: 'name' is of type 'unknown'.</span>
  <span style="color: #7f0000;">/////////////////////////////////////////////////////////</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">console.</span><span style="color: #721045;">log</span><span style="color: #7f0000;">(`Announcing ${name.</span><span style="color: #721045;">toUpperCase</span><span style="color: #7f0000;">()} !`);  //</span>
  <span style="color: #7f0000;">/////////////////////////////////////////////////////////</span>
<span style="color: #000000;">}</span>
</pre>
</div></li>
<li>unknown只允许被赋值为top type(any或者unknown)</li>
</ul></li>
<li>我们只有通过typeof或者instanceof进行了type narrow之后,我们就可以使用unknown了
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">greetComedianSafety</span><span style="color: #000000;">(</span><span style="color: #005e8b;">name</span>: <span style="color: #531ab6;">unknown</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">if</span> <span style="color: #dd22dd;">(</span><span style="color: #531ab6;">typeof</span> name === <span style="color: #3548cf;">"string"</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #3548cf;">`Announcing </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">name.toUpperCase()</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;"> !`</span><span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span> <span style="color: #531ab6;">else</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #3548cf;">"Well, I'm off."</span><span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #721045;">greetComedianSafety</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Betty White"</span><span style="color: #000000;">)</span>;
<span style="color: #721045;">greetComedianSafety</span><span style="color: #000000;">(</span><span style="color: #dd22dd;">{}</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Announcing BETTY WHITE !</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Well, I'm off.</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org1052232" class="outline-3">
<h3 id="org1052232"><span class="section-number-3">9.2.</span> Type Prddicates</h3>
<div class="outline-text-3" id="text-9-2">
<ul class="org-ul">
<li>前面我们知道了,如果使用了unknown,那么必须和typeof和instanceof来确定真实的类型,然后进行操作
<ul class="org-ul">
<li><p>
下面就是这样一个例子.
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">isNumberOrString</span><span style="color: #000000;">(</span><span style="color: #005e8b;">value</span>: <span style="color: #531ab6;">unknown</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> <span style="color: #dd22dd;">[</span><span style="color: #3548cf;">"number"</span>, <span style="color: #3548cf;">"string"</span><span style="color: #dd22dd;">]</span>.<span style="color: #721045;">includes</span><span style="color: #dd22dd;">(</span><span style="color: #531ab6;">typeof</span> value<span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">function</span> <span style="color: #721045;">logValueIfExists</span><span style="color: #000000;">(</span><span style="color: #005e8b;">value</span>: <span style="color: #531ab6;">number</span> | <span style="color: #531ab6;">string</span> | <span style="color: #0000b0;">null</span> | <span style="color: #0000b0;">undefined</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">if</span> <span style="color: #dd22dd;">(</span><span style="color: #721045;">isNumberOrString</span><span style="color: #008899;">(</span>value<span style="color: #008899;">)</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:7:5 - error TS18049: 'value' is possibly 'null' or 'undefined'.</span>

    <span style="color: #7f0000;">///////////////////////</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">value.</span><span style="color: #721045;">toString</span><span style="color: #7f0000;">(); //</span>
    <span style="color: #7f0000;">///////////////////////</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #3548cf;">"string"</span><span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span> <span style="color: #531ab6;">else</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #3548cf;">"value does not exist"</span><span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>
</pre>
</div></li>
<li>这个例子中的isNumberOrString只是返回了boolean,但是Typescript编译器并不知道value的类型是什么,所以无法调用toString</li>
</ul></li>
<li>那么有没有那么一种特性,能在返回boolean的同时,还能给Typescript编译器捎句话,告诉他参数是什么类型呢?
(unkown是非常合适的场景,因为用户创建的时候压根没写,也没法infer)
<ul class="org-ul">
<li><p>
答案是有的,就是所谓的type predicates,其原型如下
</p>
<pre class="example" id="orga5b8490">
function typePredicate(input: WideType): input is NarrowType;
</pre></li>
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">isNumberOrString</span><span style="color: #000000;">(</span><span style="color: #005e8b;">value</span>: <span style="color: #531ab6;">unknown</span><span style="color: #000000;">)</span>: value is <span style="color: #531ab6;">number</span> | <span style="color: #531ab6;">string</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> <span style="color: #dd22dd;">[</span><span style="color: #3548cf;">"number"</span>, <span style="color: #3548cf;">"string"</span><span style="color: #dd22dd;">]</span>.<span style="color: #721045;">includes</span><span style="color: #dd22dd;">(</span><span style="color: #531ab6;">typeof</span> value<span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">function</span> <span style="color: #721045;">logValueIfExists</span><span style="color: #000000;">(</span><span style="color: #005e8b;">value</span>: <span style="color: #531ab6;">number</span> | <span style="color: #531ab6;">string</span> | <span style="color: #0000b0;">null</span> | <span style="color: #0000b0;">undefined</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">if</span> <span style="color: #dd22dd;">(</span><span style="color: #721045;">isNumberOrString</span><span style="color: #008899;">(</span>value<span style="color: #008899;">)</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #3548cf;">`toString(): </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">value.toString()</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span> <span style="color: #531ab6;">else</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #3548cf;">"value does not exist:"</span>, value<span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #721045;">logValueIfExists</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"abc"</span><span style="color: #000000;">)</span>;
<span style="color: #721045;">logValueIfExists</span><span style="color: #000000;">(</span>123<span style="color: #000000;">)</span>;
<span style="color: #721045;">logValueIfExists</span><span style="color: #000000;">(</span><span style="color: #0000b0;">undefined</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">toString(): abc</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">toString(): 123</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">value does not exist: undefined</span>
</pre>
</div></li>
<li>上例会告诉Typescript:在返回为true的情况下, value的类型是number | string</li>
</ul></li>
<li>除了unknown以外,还有一个type predicate应用的场景是把interface给narrow成更加specific的interface
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">Comedian</span> <span style="color: #000000;">{</span>
  funny: <span style="color: #531ab6;">boolean</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">StandupComedian</span> <span style="color: #531ab6;">extends</span> <span style="color: #005f5f;">Comedian</span> <span style="color: #000000;">{</span>
  routine: <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">function</span> <span style="color: #721045;">isStandupComedian</span><span style="color: #000000;">(</span><span style="color: #005e8b;">value</span>: <span style="color: #005f5f;">Comedian</span><span style="color: #000000;">)</span>: <span style="color: #005e8b;">value</span> <span style="color: #531ab6;">is</span> <span style="color: #005f5f;">StandupComedian</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> <span style="color: #3548cf;">"routine"</span> <span style="color: #531ab6;">in</span> value;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">function</span> <span style="color: #721045;">workWithComedian</span><span style="color: #000000;">(</span><span style="color: #005e8b;">value</span>: <span style="color: #005f5f;">Comedian</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">if</span> <span style="color: #dd22dd;">(</span><span style="color: #721045;">isStandupComedian</span><span style="color: #008899;">(</span>value<span style="color: #008899;">)</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span>value.routine<span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span>

  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:18:21 - error TS2339: Property 'routine' does not exist on type 'Comedian'.</span>

  <span style="color: #7f0000;">/////////////////////////////////</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">console.</span><span style="color: #721045;">log</span><span style="color: #7f0000;">(value.routine); //</span>
  <span style="color: #7f0000;">/////////////////////////////////</span>
<span style="color: #000000;">}</span>
</pre>
</div></li>
<li>我们可以看到,在isStandupComedian返回true的情况下,Typescript就知道value是更加specifi的StandupComedian,
所以可以调用其routine成员</li>
</ul></li>
<li>Typescript如此精密,其不仅仅在type predicate的true case里面知道类型为更specific值,还会再false case里
面自动判断出"原始类型-specific类型"剩下的类型
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">isLongString</span><span style="color: #000000;">(</span><span style="color: #005e8b;">input</span>: <span style="color: #531ab6;">string</span> | <span style="color: #0000b0;">undefined</span><span style="color: #000000;">)</span>: input is <span style="color: #531ab6;">string</span> <span style="color: #000000;">{</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">!! &#26159;&#19968;&#20010;&#21452;&#21542;&#23450;&#25805;&#20316;&#31526;&#65292;&#23427;&#23558;&#34920;&#36798;&#24335;&#36716;&#25442;&#20026;&#24067;&#23572;&#20540;&#12290;&#36890;&#24120;&#29992;&#20110;&#30830;&#20445;&#36820;&#22238;&#30340;&#26159; true &#25110; false</span>
  <span style="color: #531ab6;">return</span> !!<span style="color: #dd22dd;">(</span>input &amp;&amp; input.length &gt;= 7<span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">function</span> <span style="color: #721045;">workWithText</span><span style="color: #000000;">(</span><span style="color: #005e8b;">text</span>: <span style="color: #531ab6;">string</span> | <span style="color: #0000b0;">undefined</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">if</span> <span style="color: #dd22dd;">(</span><span style="color: #721045;">isLongString</span><span style="color: #008899;">(</span>text<span style="color: #008899;">)</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #3548cf;">"Long Text: "</span>, text.length<span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span> <span style="color: #531ab6;">else</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:10:32 - error TS18048: 'text' is possibly 'undefined'.</span>
    <span style="color: #7f0000;">//////////////////////////////////////////////</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">console.</span><span style="color: #721045;">log</span><span style="color: #7f0000;">("Short Text:", text.length); //</span>
    <span style="color: #7f0000;">//////////////////////////////////////////////</span>
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>
</pre>
</div></li>

<li><p>
上例中的false case中,Typescript知道如果为true case是string,那么false case就是undefined了,因为
</p>
<pre class="example" id="org18363eb">
string | undefined - string = undefined
</pre></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org24035b7" class="outline-3">
<h3 id="org24035b7"><span class="section-number-3">9.3.</span> Type Operators</h3>
<div class="outline-text-3" id="text-9-3">
</div>
<div id="outline-container-org5b7ae08" class="outline-4">
<h4 id="org5b7ae08"><span class="section-number-4">9.3.1.</span> keyof</h4>
<div class="outline-text-4" id="text-9-3-1">
<ul class="org-ul">
<li>Javascript object的访问,可以在`[]`里面传入一个字符串(通常来说是字符串,但是也可以是其他类型,比如数组就是传入整型number)
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">obj</span> = <span style="color: #000000;">{</span>
  hello: <span style="color: #3548cf;">"world"</span>,
<span style="color: #000000;">}</span>;
console.log<span style="color: #000000;">(</span>obj<span style="color: #dd22dd;">[</span><span style="color: #3548cf;">"hello"</span><span style="color: #dd22dd;">]</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">world</span>
</pre>
</div></li>
</ul></li>
<li>Typescript里面,如果想传入object的这个key,那么最先想到的是把key声明为stirng类型,但是我们会看到,这样
口子开太大了,不存在的字符串也可以传递进来. 所以编译不成功
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">Ratings</span> <span style="color: #000000;">{</span>
  audience: <span style="color: #531ab6;">number</span>;
  critics: <span style="color: #531ab6;">number</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">function</span> <span style="color: #721045;">getRating</span><span style="color: #000000;">(</span><span style="color: #005e8b;">ratings</span>: <span style="color: #005f5f;">Ratings</span>, <span style="color: #005e8b;">key</span>: <span style="color: #531ab6;">string</span><span style="color: #000000;">)</span>: <span style="color: #531ab6;">number</span> <span style="color: #000000;">{</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:7:10 - error TS7053: Element implicitly has an 'any' type because expression of type 'string' can't be used to index type 'Ratings'.</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">No index signature with a parameter of type 'string' was found on type 'Ratings'.</span>

  <span style="color: #7f0000;">//////////////////////////</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">return ratings[key]; //</span>
  <span style="color: #7f0000;">//////////////////////////</span>
  <span style="color: #531ab6;">return</span> 1;
<span style="color: #000000;">}</span>
</pre>
</div></li>
<li><p>
从编译报错来看,我们最容易的改动方法,就是使用union of literal (使用那些允许的key)
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">Ratings</span> <span style="color: #000000;">{</span>
  audience: <span style="color: #531ab6;">number</span>;
  critics: <span style="color: #531ab6;">number</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">function</span> <span style="color: #721045;">getRating</span><span style="color: #000000;">(</span><span style="color: #005e8b;">ratings</span>: <span style="color: #005f5f;">Ratings</span>, <span style="color: #005e8b;">key</span>: <span style="color: #3548cf;">"audience"</span> | <span style="color: #3548cf;">"critics"</span><span style="color: #000000;">)</span>: <span style="color: #531ab6;">number</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> ratings<span style="color: #dd22dd;">[</span>key<span style="color: #dd22dd;">]</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">ratings</span>: <span style="color: #005f5f;">Ratings</span> = <span style="color: #000000;">{</span> audience: 66, critics: 86 <span style="color: #000000;">}</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span><span style="color: #721045;">getRating</span><span style="color: #dd22dd;">(</span>ratings, <span style="color: #3548cf;">"audience"</span><span style="color: #dd22dd;">)</span><span style="color: #000000;">)</span>;


<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:13:32 - error TS2345: Argument of type '"not valid"' is not assignable to parameter of type '"audience" | "critics"'.</span>

<span style="color: #7f0000;">///////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">console.</span><span style="color: #721045;">log</span><span style="color: #7f0000;">(getRating(ratings, "not valid")); //</span>
<span style="color: #7f0000;">///////////////////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
<li>union of literal的问题,是如果合理的literal有成千上万个,那么我们就不可能一一列出来,所以Typescript发明了一个语法糖来返回union of all the keys allowed on the type
<ul class="org-ul">
<li><p>
示例代码如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">Ratings</span> <span style="color: #000000;">{</span>
  audience: <span style="color: #531ab6;">number</span>;
  critics: <span style="color: #531ab6;">number</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">function</span> <span style="color: #721045;">getRating</span><span style="color: #000000;">(</span><span style="color: #005e8b;">ratings</span>: <span style="color: #005f5f;">Ratings</span>, <span style="color: #005e8b;">key</span>: <span style="color: #531ab6;">keyof</span> Ratings<span style="color: #000000;">)</span>: <span style="color: #531ab6;">number</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> ratings<span style="color: #dd22dd;">[</span>key<span style="color: #dd22dd;">]</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">ratings</span>: <span style="color: #005f5f;">Ratings</span> = <span style="color: #000000;">{</span> audience: 66, critics: 86 <span style="color: #000000;">}</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span><span style="color: #721045;">getRating</span><span style="color: #dd22dd;">(</span>ratings, <span style="color: #3548cf;">"audience"</span><span style="color: #dd22dd;">)</span><span style="color: #000000;">)</span>;


<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:13:32 - error TS2345: Argument of type '"not valid"' is not assignable to parameter of type '"audience" | "critics"'.</span>

<span style="color: #7f0000;">///////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">console.</span><span style="color: #721045;">log</span><span style="color: #7f0000;">(getRating(ratings, "not valid")); //</span>
<span style="color: #7f0000;">///////////////////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org099e6d8" class="outline-4">
<h4 id="org099e6d8"><span class="section-number-4">9.3.2.</span> typeof</h4>
<div class="outline-text-4" id="text-9-3-2">
<ul class="org-ul">
<li>有些情况下,某些value的type是非常难以书写的(或者手写很难写对),Typescript提供了一个语法糖来直接获得某个value的type
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">original</span> = <span style="color: #000000;">{</span>
  medium: <span style="color: #3548cf;">"movie"</span>,
  title: <span style="color: #3548cf;">"Mean Girls"</span>,
<span style="color: #000000;">}</span>;

<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">adaptation</span>: <span style="color: #531ab6;">typeof</span> original;

<span style="color: #531ab6;">if</span> <span style="color: #000000;">(</span>Math.<span style="color: #721045;">random</span><span style="color: #dd22dd;">()</span> &gt; 0.5<span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  adaptation = <span style="color: #dd22dd;">{</span> ...original, medium: <span style="color: #3548cf;">"play"</span> <span style="color: #dd22dd;">}</span>;
<span style="color: #000000;">}</span> <span style="color: #531ab6;">else</span> <span style="color: #000000;">{</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:11:31 - error TS2322: Type 'number' is not assignable to type 'string'.</span>
  <span style="color: #7f0000;">//////////////////////////////////////////////</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">adaptation = { ...original, medium: 2 }; //</span>
  <span style="color: #7f0000;">//////////////////////////////////////////////</span>
<span style="color: #000000;">}</span>
</pre>
</div></li>
</ul></li>

<li>注意!typeof在Typescript和Javascript里面的区别:
<ul class="org-ul">
<li>TypeScript里面的typeof是一个compile time的概念, Typescript的typeof只在type里面有效,编译成javascript
后就消失</li>
<li><p>
Javascript里面的typeof是一个runtime的概念,其在runtime返回一个字符串
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span><span style="color: #531ab6;">typeof</span> 32<span style="color: #000000;">)</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span><span style="color: #531ab6;">typeof</span> <span style="color: #0000b0;">true</span><span style="color: #000000;">)</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span><span style="color: #531ab6;">typeof</span> <span style="color: #3548cf;">"hello"</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">number</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">boolean</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">string</span>
</pre>
</div></li>
</ul></li>
<li>keyof和typeof还可以联合起来使用,对于没有明确interface type的value来说,这能节省大量的书写工作.而且
能跟着value内容改变而改变,无需手动更新.
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">ratings</span> = <span style="color: #000000;">{</span>
  imdb: 8.8,
  metacritic: 82,
<span style="color: #000000;">}</span>;

<span style="color: #531ab6;">function</span> <span style="color: #721045;">logRating</span><span style="color: #000000;">(</span><span style="color: #005e8b;">key</span>: <span style="color: #531ab6;">keyof</span> <span style="color: #531ab6;">typeof</span> ratings<span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #dd22dd;">(</span>ratings<span style="color: #008899;">[</span>key<span style="color: #008899;">]</span><span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>

<span style="color: #721045;">logRating</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"imdb"</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">8.8</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:11:11 - error TS2345: Argument of type '"invalid"' is not assignable to parameter of type '"imdb" | "metacritic"'.</span>

<span style="color: #7f0000;">///////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">logRating("invalid"); //</span>
<span style="color: #7f0000;">///////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org37bf263" class="outline-3">
<h3 id="org37bf263"><span class="section-number-3">9.4.</span> Type Assertions</h3>
<div class="outline-text-3" id="text-9-4">
<ul class="org-ul">
<li>有些情况下,代码开发者比编译器更加了解类型的时候(比如JSON.parse就只能将类型全部设置为any),可以强制"断言"类型,也就是type assertion</li>
<li>type assertion有两种形式:
<ul class="org-ul">
<li><p>
尖括号语法(因为可能与jsx相冲突,已经不推荐使用)
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">someValue</span>: <span style="color: #531ab6;">any</span> = <span style="color: #3548cf;">"this is a string"</span>;
<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">strLength</span>: <span style="color: #531ab6;">number</span> = <span style="color: #000000;">(</span>&lt;<span style="color: #531ab6;">string</span>&gt;someValue<span style="color: #000000;">)</span>.length;
</pre>
</div></li>
<li><p>
as语法
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">someValue</span>: <span style="color: #531ab6;">any</span> = <span style="color: #3548cf;">"this is a string"</span>;
<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">strLength</span>: <span style="color: #531ab6;">number</span> = <span style="color: #000000;">(</span>someValue <span style="color: #531ab6;">as</span> <span style="color: #531ab6;">string</span><span style="color: #000000;">)</span>.length;
</pre>
</div></li>
</ul></li>
<li>Typescript的最佳实践就是:能不用type assertion就不要用type assertion,尽量fully type,从而让Typescript来全盘理解类型</li>
</ul>
</div>
<div id="outline-container-org1a76f38" class="outline-4">
<h4 id="org1a76f38"><span class="section-number-4">9.4.1.</span> Asserting Caught Error Types</h4>
<div class="outline-text-4" id="text-9-4-1">
<ul class="org-ul">
<li>error handling是可能用到type assertion的地方
<ul class="org-ul">
<li><p>
比如你很确信,只会抛出Error类型的错误,那么你可以这么写
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">try</span> <span style="color: #000000;">{</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">(code that may throw an error)</span>
<span style="color: #000000;">}</span> <span style="color: #531ab6;">catch</span> <span style="color: #000000;">(</span>error<span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">warn</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">"Oh no !"</span>, <span style="color: #008899;">(</span>error <span style="color: #531ab6;">as</span> Error<span style="color: #008899;">)</span>.message<span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>
</pre>
</div></li>
<li><p>
但是其实还有更好的办法,就是使用instanceof来判断类型,进而调用Error的message
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">try</span> <span style="color: #000000;">{</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">(code that may throw an error)</span>
<span style="color: #000000;">}</span> <span style="color: #531ab6;">catch</span> <span style="color: #000000;">(</span>error<span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">warn</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">"Oh no !"</span>, error <span style="color: #531ab6;">instanceof</span> <span style="color: #005f5f;">Error</span> ? error.message : error<span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org6494811" class="outline-4">
<h4 id="org6494811"><span class="section-number-4">9.4.2.</span> Non-Null Assertions</h4>
<div class="outline-text-4" id="text-9-4-2">
<ul class="org-ul">
<li>另外一种可能用到type assertion的情况,是我们要把一个variable里面的null(undefined)去掉. 这种通常null
(and/or undefined)只在理论上存在,实际业务逻辑上不可能存在,所以我们就要去掉
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">maybeDate</span> = Math.<span style="color: #721045;">random</span><span style="color: #000000;">()</span> &gt; 0.5 ? <span style="color: #005e8b;">undefined</span> : <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Date</span><span style="color: #000000;">()</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Asserted type: Date</span>
maybeDate <span style="color: #531ab6;">as</span> Date;
</pre>
</div></li>
<li><p>
由于去掉null and /or undefined如此的常用,Typescript增加了一个"后缀!"语法糖 (也就是Non-null assertion)
来专门去掉null和undefind,下面代码和上面的代码等价
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">maybeDate</span> = Math.<span style="color: #721045;">random</span><span style="color: #000000;">()</span> &gt; 0.5 ? <span style="color: #005e8b;">undefined</span> : <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Date</span><span style="color: #000000;">()</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">same with: maybeDate as Date;</span>
maybeDate!;
</pre>
</div></li>
</ul></li>
<li>Non-null assertion对于Map.get来说非常有用,因为Map.get在key存在的时候返回value,不存在的时候返回undefined,
所以其返回类型是包含undefined的union
<ul class="org-ul">
<li><p>
使用non-null assertion就会让Map.get使用起来非常容易
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">seasonCounts</span> = <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Map</span><span style="color: #000000;">(</span><span style="color: #dd22dd;">[</span>
  <span style="color: #008899;">[</span><span style="color: #3548cf;">"I Love Lucy"</span>, <span style="color: #3548cf;">"abc"</span><span style="color: #008899;">]</span>,
  <span style="color: #008899;">[</span><span style="color: #3548cf;">"The Golden Girls"</span>, <span style="color: #3548cf;">"def"</span><span style="color: #008899;">]</span>,
<span style="color: #dd22dd;">]</span><span style="color: #000000;">)</span>;

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">maybeValue</span> = seasonCounts.<span style="color: #721045;">get</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"I Love Lucy"</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:12:13 - error TS18048: 'maybeValue' is possibly 'undefined'.</span>

<span style="color: #7f0000;">/////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">console.</span><span style="color: #721045;">log</span><span style="color: #7f0000;">(maybeValue.</span><span style="color: #721045;">toUpperCase</span><span style="color: #7f0000;">());  //</span>
<span style="color: #7f0000;">/////////////////////////////////////////////</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">knownValue</span> = seasonCounts.<span style="color: #721045;">get</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"I Love Lucy"</span><span style="color: #000000;">)</span>!;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>knownValue.<span style="color: #721045;">toUpperCase</span><span style="color: #dd22dd;">()</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">ABC</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org4708c09" class="outline-4">
<h4 id="org4708c09"><span class="section-number-4">9.4.3.</span> Type Assertin Caveats</h4>
<div class="outline-text-4" id="text-9-4-3">
<ul class="org-ul">
<li>和any一样,type assertion是Typescript的"逃生舱",换句话说,我们应该尽可能的避免使用他们,除非迫不得已</li>
<li>很多时候,我们的type assertion都是错误的:
<ul class="org-ul">
<li>要么在你写代码的时候已经错了</li>
<li>要么在后续漫长的代码维护过程中由于业务逻辑改变,之前正确的assertion也会变成错的了.</li>
</ul></li>
<li>Typescript只运行type assertion发生在这样两个type之间:"一个type可以assign给另一个type的",否则会报错
<ul class="org-ul">
<li><p>
示例如下, 在两个primitive直接assertion是不被允许的
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:1:15 - error TS2352: Conversion of type 'string' to type 'number' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first.</span>

<span style="color: #7f0000;">////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">let myValue = "Stella!" as number; //</span>
<span style="color: #7f0000;">////////////////////////////////////////</span>
</pre>
</div></li>
<li><p>
上面例子中提示我们,可以用先把myValue as成unknown,再as成number.虽然可以成功,但是这只是能编译成功而已,这是应该完全避免的写法
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">myValueDouble</span> = <span style="color: #3548cf;">"1337"</span> <span style="color: #531ab6;">as</span> <span style="color: #531ab6;">unknown</span> <span style="color: #531ab6;">as</span> <span style="color: #531ab6;">number</span>;
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org2d0e065" class="outline-3">
<h3 id="org2d0e065"><span class="section-number-3">9.5.</span> Const Assertions</h3>
<div class="outline-text-3" id="text-9-5">
<ul class="org-ul">
<li>虽然as不太推荐使用,但是as const却非常推荐使用,其作用总体上来说是让一个类型变成constant, immutable version
的它们自己,具体来说就是:
<ul class="org-ul">
<li><p>
array会被看成是reaonly tuple,而不再是mutable array
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#19968;&#20010;&#25968;&#32452;</span>
<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">colors</span> = <span style="color: #000000;">[</span><span style="color: #3548cf;">"red"</span>, <span style="color: #3548cf;">"green"</span>, <span style="color: #3548cf;">"blue"</span><span style="color: #000000;">]</span>;
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#40664;&#35748;&#24773;&#20917;&#19979;&#65292;TypeScript &#20250;&#25512;&#26029;&#20026; string[] &#31867;&#22411;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">colors &#30340;&#31867;&#22411;&#26159; (string[])</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#20351;&#29992; as const</span>
<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">colorsConst</span> = <span style="color: #000000;">[</span><span style="color: #3548cf;">"red"</span>, <span style="color: #3548cf;">"green"</span>, <span style="color: #3548cf;">"blue"</span><span style="color: #000000;">]</span> <span style="color: #531ab6;">as</span> <span style="color: #531ab6;">const</span>;
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#20351;&#29992; as const &#21518;&#65292;colorsConst &#30340;&#31867;&#22411;&#26159; readonly ["red", "green", "blue"]</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#31867;&#22411;&#21464;&#25104;&#20102;&#19968;&#20010;&#21482;&#35835;&#30340;&#20803;&#32452;&#65292;&#24182;&#19988;&#27599;&#20010;&#20803;&#32032;&#37117;&#20855;&#26377;&#20855;&#20307;&#30340;&#23383;&#38754;&#37327;&#31867;&#22411; "red", "green", "blue"</span>
</pre>
</div></li>
<li>literal会被认为是literal类型,而不是更加general的primitive类型(比如字符串"abc"会被认为是abc类型,
而不是string,这样能保证其只能被"abc"赋值,也就是readonly啦)</li>
<li>object的property变成了readonly</li>
</ul></li>
</ul>
</div>
<div id="outline-container-orgf889ea7" class="outline-4">
<h4 id="orgf889ea7"><span class="section-number-4">9.5.1.</span> Literals to Primitives</h4>
<div class="outline-text-4" id="text-9-5-1">
<ul class="org-ul">
<li>在Typescript中,literal通常会被推断为其对应的原始类型,比如"hello"会被推断为string,而不是literal类型
"hello",但是加了as const之后,就会被推断成"hello"类型了
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#19981;&#20351;&#29992; as const</span>
<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">greeting</span> = <span style="color: #3548cf;">"hello"</span>;
<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">example</span>: <span style="color: #531ab6;">typeof</span> greeting;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#25512;&#26029;&#31867;&#22411;&#20026; string&#65292;&#32780;&#19981;&#26159;&#20855;&#20307;&#30340; "hello"</span>
example = <span style="color: #3548cf;">"hello"</span>;              <span style="color: #7f0000;">// </span><span style="color: #7f0000;">ok</span>
example = <span style="color: #3548cf;">"world"</span>;              <span style="color: #7f0000;">// </span><span style="color: #7f0000;">ok</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#20351;&#29992; as const</span>
<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">greetingConst</span> = <span style="color: #3548cf;">"hello"</span> <span style="color: #531ab6;">as</span> <span style="color: #531ab6;">const</span>;
<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">exampleConst</span>: <span style="color: #531ab6;">typeof</span> greetingConst;

exampleConst = <span style="color: #3548cf;">"hello"</span>;
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:7:1 - error TS2322: Type '"world"' is not assignable to type '"hello"'.</span>

<span style="color: #7f0000;">/////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">exampleConst = "world"; //</span>
<span style="color: #7f0000;">/////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org6086610" class="outline-4">
<h4 id="org6086610"><span class="section-number-4">9.5.2.</span> Read-Only Objects</h4>
<div class="outline-text-4" id="text-9-5-2">
<ul class="org-ul">
<li>我们一旦在object定义的时候加上as const,那么相当于给object的所有成员都加上as const
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">describePreference</span><span style="color: #000000;">(</span><span style="color: #005e8b;">preference</span>: <span style="color: #3548cf;">"maybe"</span> | <span style="color: #3548cf;">"no"</span> | <span style="color: #3548cf;">"yes"</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">switch</span> <span style="color: #dd22dd;">(</span>preference<span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">case</span> <span style="color: #3548cf;">"maybe"</span>:
      <span style="color: #531ab6;">return</span> <span style="color: #3548cf;">"I suppose..."</span>;
    <span style="color: #531ab6;">case</span> <span style="color: #3548cf;">"no"</span>:
      <span style="color: #531ab6;">return</span> <span style="color: #3548cf;">"No thanks."</span>;
    <span style="color: #531ab6;">case</span> <span style="color: #3548cf;">"yes"</span>:
      <span style="color: #531ab6;">return</span> <span style="color: #3548cf;">"Yes please !"</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">preferencesMutable</span> = <span style="color: #000000;">{</span>
  movie: <span style="color: #3548cf;">"maybe"</span>,
  standup: <span style="color: #3548cf;">"yes"</span>,
<span style="color: #000000;">}</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:18:20 - error TS2345: Argument of type 'string' is not assignable to parameter of type '"maybe" | "no" | "yes"'.</span>

<span style="color: #7f0000;">///////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">describePreference(preferencesMutable.movie); //</span>
<span style="color: #7f0000;">///////////////////////////////////////////////////</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">preferencesReadonly</span> = <span style="color: #000000;">{</span>
  movie: <span style="color: #3548cf;">"maybe"</span>,
  standup: <span style="color: #3548cf;">"yes"</span>,
<span style="color: #000000;">}</span> <span style="color: #531ab6;">as</span> <span style="color: #531ab6;">const</span>;

<span style="color: #721045;">describePreference</span><span style="color: #000000;">(</span>preferencesReadonly.movie<span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:30:21 - error TS2540: Cannot assign to 'movie' because it is a read-only property.</span>

<span style="color: #7f0000;">//////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">preferencesReadonly.movie = "new value"; //</span>
<span style="color: #7f0000;">//////////////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org20b168e" class="outline-2">
<h2 id="org20b168e"><span class="section-number-2">10.</span> Chapter 10: Generics</h2>
<div class="outline-text-2" id="text-10">
<ul class="org-ul">
<li>前面我们所有的讨论,都是基于在写代码的时候,类型是确定好的.</li>
<li>但是也有某些情况,我们在写代码的时候不知道具体类型是什么(可能只知道比如输入和输出是同一种类型)</li>
<li>Javascript使用如下代码来允许所有类型的输入和输出
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">identity</span><span style="color: #000000;">(</span><span style="color: #005e8b;">input</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> input;
<span style="color: #000000;">}</span>

console.log<span style="color: #000000;">(</span>identity<span style="color: #dd22dd;">(</span><span style="color: #3548cf;">"abc"</span><span style="color: #dd22dd;">)</span><span style="color: #000000;">)</span>;
console.log<span style="color: #000000;">(</span>identity<span style="color: #dd22dd;">(</span>123<span style="color: #dd22dd;">)</span><span style="color: #000000;">)</span>;
console.log<span style="color: #000000;">(</span>identity<span style="color: #dd22dd;">(</span><span style="color: #008899;">{</span> quote: <span style="color: #3548cf;">"hello"</span> <span style="color: #008899;">}</span><span style="color: #dd22dd;">)</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">abc</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">123</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">{ quote: 'hello' }</span>
</pre>
</div></li>
</ul></li>
<li>对应的,typescript可以使用any来表示输入和输出是任意类型
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">identity</span><span style="color: #000000;">(</span><span style="color: #005e8b;">input</span>: <span style="color: #531ab6;">any</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> input;
<span style="color: #000000;">}</span>

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span><span style="color: #721045;">identity</span><span style="color: #dd22dd;">(</span>32<span style="color: #dd22dd;">)</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">32</span>
</pre>
</div></li>
<li><p>
上面的例子显然和Javascript例子,没有什么区别.我们没有能够把握住输入类型和输出类型的关系(在这个例子
中是相同的类型)
</p>
<pre class="example" id="org911e31f">
Given that input is allowed to be any input, we need a way to say that
there is a relationship between the input type and the type the function
returns.
</pre></li>
<li>在Typescript中,能够把握住这种关系的方法,叫做泛型</li>
</ul></li>
<li>Typescript的泛型通常会有type parameter,一般使用
<ul class="org-ul">
<li>单个字母比如T,U</li>
<li>驼峰单词,比如Key,Value</li>
</ul></li>
<li>注意!上述这种占位符是Type Parameter,而实例化的时候提供的具体类型就是Type Argument
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">CrateLike</span>&lt;<span style="color: #005f5f;">T</span>&gt; <span style="color: #000000;">{</span>
  contents: T;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">missingGeneric</span>: <span style="color: #005f5f;">CrateLike</span>&lt;<span style="color: #531ab6;">string</span>&gt; = <span style="color: #000000;">{</span>
  contents: <span style="color: #3548cf;">""</span>,
<span style="color: #000000;">}</span>;
</pre>
</div></li>

<li>上面例子中的T就是type parameter</li>
<li>上面例子中的string就是type argument</li>
</ul></li>
</ul>
</div>
<div id="outline-container-orgb359b20" class="outline-3">
<h3 id="orgb359b20"><span class="section-number-3">10.1.</span> Generic Functions</h3>
<div class="outline-text-3" id="text-10-1">
<ul class="org-ul">
<li>泛型最常见的场景就是函数了,需要在原来的函数里面,多处加上type parameter
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">identity</span>&lt;<span style="color: #005f5f;">T</span>&gt;<span style="color: #000000;">(</span><span style="color: #005e8b;">input</span>: T<span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> input;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">numeric</span> = <span style="color: #721045;">identity</span><span style="color: #000000;">(</span>123<span style="color: #000000;">)</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>numeric<span style="color: #000000;">)</span>;
<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">stringy</span> = <span style="color: #721045;">identity</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"me"</span><span style="color: #000000;">)</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>stringy<span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">123</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">me</span>
</pre>
</div></li>
<li><p>
arrow版本的示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">identity</span> = &lt;T&gt;<span style="color: #000000;">(</span>input: T<span style="color: #000000;">)</span> <span style="color: #531ab6;">=&gt;</span> input;

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">numeric</span> = <span style="color: #721045;">identity</span><span style="color: #000000;">(</span>123<span style="color: #000000;">)</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>numeric<span style="color: #000000;">)</span>;
<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">stringy</span> = <span style="color: #721045;">identity</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"me"</span><span style="color: #000000;">)</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>stringy<span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">123</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">me</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
<div id="outline-container-org2955dce" class="outline-4">
<h4 id="org2955dce"><span class="section-number-4">10.1.1.</span> Explicit Generic Call Types</h4>
<div class="outline-text-4" id="text-10-1-1">
<ul class="org-ul">
<li>绝大部分情况下,Typescript都可以通过你的输入来确认我们的T,U到底是什么类型,但是极个别情况却不可以.比
如参数是一个callback,callback的参数也是T,U,这种情况下,有两种方式来让TypeScript正常运行:
<ul class="org-ul">
<li><p>
明确callback的参数,比如下面例子中,明确其为string,否则Typescript无法infer
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">logWrapper</span>&lt;<span style="color: #005f5f;">Input</span>&gt;<span style="color: #000000;">(</span><span style="color: #005e8b;">callback</span>: <span style="color: #dd22dd;">(</span><span style="color: #005e8b;">input</span>: <span style="color: #005f5f;">Input</span><span style="color: #dd22dd;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #531ab6;">void</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">"inside logWrapper"</span><span style="color: #dd22dd;">)</span>;
  <span style="color: #531ab6;">return</span> <span style="color: #dd22dd;">(</span><span style="color: #005e8b;">input</span>: <span style="color: #005f5f;">Input</span><span style="color: #dd22dd;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #3548cf;">"Input:"</span>, input<span style="color: #008899;">)</span>;
    <span style="color: #721045;">callback</span><span style="color: #008899;">(</span>input<span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">lw</span> = <span style="color: #721045;">logWrapper</span><span style="color: #000000;">(</span><span style="color: #dd22dd;">(</span><span style="color: #005e8b;">input</span>: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #dd22dd;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span>input.length<span style="color: #008899;">)</span>;
<span style="color: #dd22dd;">}</span><span style="color: #000000;">)</span>;

<span style="color: #721045;">lw</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"abc"</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">inside logWrapper</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Input: abc</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">3</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:21:15 - error TS18046: 'input' is of type 'unknown'.</span>

<span style="color: #7f0000;">//////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">logWrapper((</span><span style="color: #005e8b;">input</span><span style="color: #7f0000;">) =&gt; {      //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">console.</span><span style="color: #721045;">log</span><span style="color: #7f0000;">(input.length); //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">});                          //</span>
<span style="color: #7f0000;">//////////////////////////////////</span>
</pre>
</div></li>
<li><p>
明确T,U的类型,比如下面例子中的做法
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">logWrapper</span>&lt;<span style="color: #005f5f;">Input</span>&gt;<span style="color: #000000;">(</span><span style="color: #005e8b;">callback</span>: <span style="color: #dd22dd;">(</span><span style="color: #005e8b;">input</span>: <span style="color: #005f5f;">Input</span><span style="color: #dd22dd;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #531ab6;">void</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">"inside logWrapper"</span><span style="color: #dd22dd;">)</span>;
  <span style="color: #531ab6;">return</span> <span style="color: #dd22dd;">(</span><span style="color: #005e8b;">input</span>: <span style="color: #005f5f;">Input</span><span style="color: #dd22dd;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #3548cf;">"Input:"</span>, input<span style="color: #008899;">)</span>;
    <span style="color: #721045;">callback</span><span style="color: #008899;">(</span>input<span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">lw</span> = <span style="color: #721045;">logWrapper</span>&lt;<span style="color: #005f5f;">String</span>&gt;<span style="color: #000000;">(</span><span style="color: #dd22dd;">(</span><span style="color: #005e8b;">input</span><span style="color: #dd22dd;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #dd22dd;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span>input.length<span style="color: #008899;">)</span>;
<span style="color: #dd22dd;">}</span><span style="color: #000000;">)</span>;

<span style="color: #721045;">lw</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"abc"</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">inside logWrapper</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Input: abc</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">3</span>
</pre>
</div></li>
</ul></li>
<li>明确T,U的类型的情况下,如果传入和明确的不一样,也会报警
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">logWrapper</span>&lt;<span style="color: #005f5f;">Input</span>&gt;<span style="color: #000000;">(</span><span style="color: #005e8b;">callback</span>: <span style="color: #dd22dd;">(</span><span style="color: #005e8b;">input</span>: <span style="color: #005f5f;">Input</span><span style="color: #dd22dd;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #531ab6;">void</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">"inside logWrapper"</span><span style="color: #dd22dd;">)</span>;
  <span style="color: #531ab6;">return</span> <span style="color: #dd22dd;">(</span><span style="color: #005e8b;">input</span>: <span style="color: #005f5f;">Input</span><span style="color: #dd22dd;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #3548cf;">"Input:"</span>, input<span style="color: #008899;">)</span>;
    <span style="color: #721045;">callback</span><span style="color: #008899;">(</span>input<span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span>;
<span style="color: #000000;">}</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:9:31 - error TS2345: Argument of type '(input: boolean) =&gt; void' is not assignable to parameter of type '(input: String) =&gt; void'.</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">Types of parameters 'input' and 'input' are incompatible.</span>
<span style="color: #7f0000;">//     </span><span style="color: #7f0000;">Type 'String' is not assignable to type 'boolean'.</span>

<span style="color: #7f0000;">/////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">const lw = logWrapper&lt;String&gt;((</span><span style="color: #005e8b;">input</span><span style="color: #7f0000;">: boolean) =&gt; { //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">console.</span><span style="color: #721045;">log</span><span style="color: #7f0000;">(input.length);                        //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">});                                                 //</span>
<span style="color: #7f0000;">/////////////////////////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
<li>明确T,U的类型,只是一种辅助手段,除非TypeScript自己抱怨了infer不出类型,我们不要主动使用这种方法</li>
</ul>
</div>
</div>
<div id="outline-container-org534000d" class="outline-4">
<h4 id="org534000d"><span class="section-number-4">10.1.2.</span> Multiple Function Type Parameters</h4>
<div class="outline-text-4" id="text-10-1-2">
<ul class="org-ul">
<li>我们可以在代码中使用任意个数的type parameter(但是最佳实践是最多两个,因为太多了代码太难以理解)
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">makeTuple</span>&lt;<span style="color: #005f5f;">First</span>, <span style="color: #005f5f;">Second</span>&gt;<span style="color: #000000;">(</span><span style="color: #005e8b;">first</span>: <span style="color: #005f5f;">First</span>, <span style="color: #005e8b;">second</span>: <span style="color: #005f5f;">Second</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> <span style="color: #dd22dd;">[</span>first, second<span style="color: #dd22dd;">]</span> <span style="color: #531ab6;">as</span> <span style="color: #531ab6;">const</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">tuple</span> = <span style="color: #721045;">makeTuple</span><span style="color: #000000;">(</span><span style="color: #0000b0;">true</span>, <span style="color: #3548cf;">"abc"</span><span style="color: #000000;">)</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>tuple<span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">[ true, 'abc' ]</span>
</pre>
</div></li>
</ul></li>

<li>一旦使用了多个type parameter:
<ul class="org-ul">
<li><p>
要么全部都不explicit的说明
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">makePair</span>&lt;<span style="color: #005f5f;">Key</span>, <span style="color: #005f5f;">Value</span>&gt;<span style="color: #000000;">(</span><span style="color: #005e8b;">key</span>: <span style="color: #005f5f;">Key</span>, <span style="color: #005e8b;">value</span>: <span style="color: #005f5f;">Value</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> <span style="color: #dd22dd;">{</span> key, value <span style="color: #dd22dd;">}</span>;
<span style="color: #000000;">}</span>

<span style="color: #721045;">makePair</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"abc"</span>, 123<span style="color: #000000;">)</span>;
</pre>
</div></li>
<li><p>
要么全部都explicit的说明, 这种也是有可能的,比如下例中,如果你不写,编译器肯定推断为&lt;string, number&gt;
但是如果你想要更加精细的literal类型,那么你就要自己explicit的写出来.
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">makePair</span>&lt;<span style="color: #005f5f;">Key</span>, <span style="color: #005f5f;">Value</span>&gt;<span style="color: #000000;">(</span><span style="color: #005e8b;">key</span>: <span style="color: #005f5f;">Key</span>, <span style="color: #005e8b;">value</span>: <span style="color: #005f5f;">Value</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> <span style="color: #dd22dd;">{</span> key, value <span style="color: #dd22dd;">}</span>;
<span style="color: #000000;">}</span>

<span style="color: #721045;">makePair</span>&lt;<span style="color: #531ab6;">string</span>, <span style="color: #531ab6;">number</span>&gt;<span style="color: #000000;">(</span><span style="color: #3548cf;">"abc"</span>, 123<span style="color: #000000;">)</span>;
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;&gt;&#37324;&#38754;&#30340;"abc"&#26159;string literal &#31867;&#22411;, &lt;&gt;&#37324;&#38754;&#30340;123&#26159;number literal&#31867;&#22411;</span>
<span style="color: #721045;">makePair</span>&lt;<span style="color: #3548cf;">"abc"</span>, 123&gt;<span style="color: #000000;">(</span><span style="color: #3548cf;">"abc"</span>, 123<span style="color: #000000;">)</span>;
</pre>
</div></li>
<li><p>
只说明一部分的话,Typescript是无法理解的
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">makePair</span>&lt;<span style="color: #005f5f;">Key</span>, <span style="color: #005f5f;">Value</span>&gt;<span style="color: #000000;">(</span><span style="color: #005e8b;">key</span>: <span style="color: #005f5f;">Key</span>, <span style="color: #005e8b;">value</span>: <span style="color: #005f5f;">Value</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> <span style="color: #dd22dd;">{</span> key, value <span style="color: #dd22dd;">}</span>;
<span style="color: #000000;">}</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:5:10 - error TS2558: Expected 2 type arguments, but got 1.</span>

<span style="color: #7f0000;">///////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">makePair&lt;string&gt;("abc", 123); //</span>
<span style="color: #7f0000;">///////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgf92a3e8" class="outline-3">
<h3 id="orgf92a3e8"><span class="section-number-3">10.2.</span> Generic Interface</h3>
<div class="outline-text-3" id="text-10-2">
<ul class="org-ul">
<li>Typescript的interface也可以使用泛型,type parameter用来为interface内部的成员声明类型
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">Box</span>&lt;<span style="color: #005f5f;">T</span>&gt; <span style="color: #000000;">{</span>
  inside: T;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">stringyBox</span>: <span style="color: #005f5f;">Box</span>&lt;<span style="color: #531ab6;">string</span>&gt; = <span style="color: #000000;">{</span>
  inside: <span style="color: #3548cf;">"abc"</span>,
<span style="color: #000000;">}</span>;

<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">numberBox</span>: <span style="color: #005f5f;">Box</span>&lt;<span style="color: #531ab6;">number</span>&gt; = <span style="color: #000000;">{</span>
  inside: 123,
<span style="color: #000000;">}</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:14:3 - error TS2322: Type 'boolean' is not assignable to type 'number'.</span>

<span style="color: #7f0000;">///////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">let incorrectBox: Box&lt;number&gt; = { //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">inside: false,                  //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">};                                //</span>
<span style="color: #7f0000;">///////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
<li>Typescript内置的Array method就是定义在TypeScript里面作为generic interface
<ul class="org-ul">
<li><p>
具体源代码精简如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">Array</span>&lt;<span style="color: #005f5f;">T</span>&gt; <span style="color: #000000;">{</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">...</span>
  <span style="color: #721045;">pop</span><span style="color: #dd22dd;">()</span>: T | <span style="color: #0000b0;">undefined</span>;

  <span style="color: #721045;">push</span><span style="color: #dd22dd;">(</span>...<span style="color: #005e8b;">items</span>: T<span style="color: #008899;">[]</span><span style="color: #dd22dd;">)</span>: <span style="color: #531ab6;">number</span>;
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">...</span>
<span style="color: #000000;">}</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
<div id="outline-container-orge57ec89" class="outline-4">
<h4 id="orge57ec89"><span class="section-number-4">10.2.1.</span> Inferred Generic Interface Types</h4>
<div class="outline-text-4" id="text-10-2-1">
<ul class="org-ul">
<li>就像generic function一样, generic interface也可以尽可能的infer类型
<ul class="org-ul">
<li><p>
示例如下,编译器能察觉是否有足够的函数,已经类型是否匹配
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">LinkedNode</span>&lt;<span style="color: #005f5f;">Value</span>&gt; <span style="color: #000000;">{</span>
  next?: <span style="color: #005f5f;">LinkedNode</span>&lt;<span style="color: #005f5f;">Value</span>&gt;;
  value: <span style="color: #005f5f;">Value</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">function</span> <span style="color: #721045;">getLast</span>&lt;<span style="color: #005f5f;">Value</span>&gt;<span style="color: #000000;">(</span><span style="color: #005e8b;">node</span>: <span style="color: #005f5f;">LinkedNode</span>&lt;<span style="color: #005f5f;">Value</span>&gt;<span style="color: #000000;">)</span>: <span style="color: #005f5f;">Value</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> node.next ? <span style="color: #721045;">getLast</span><span style="color: #dd22dd;">(</span>node.next<span style="color: #dd22dd;">)</span> : node.value;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">lastDate</span> = <span style="color: #721045;">getLast</span><span style="color: #000000;">(</span><span style="color: #dd22dd;">{</span>
  value: <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Date</span><span style="color: #008899;">(</span><span style="color: #3548cf;">"09-13-1993"</span><span style="color: #008899;">)</span>,
<span style="color: #dd22dd;">}</span><span style="color: #000000;">)</span>;

<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">lastFruit</span> = <span style="color: #721045;">getLast</span><span style="color: #000000;">(</span><span style="color: #dd22dd;">{</span>
  next: <span style="color: #008899;">{</span>
    value: <span style="color: #3548cf;">"banana"</span>,
  <span style="color: #008899;">}</span>,
  value: <span style="color: #3548cf;">"apple"</span>,
<span style="color: #dd22dd;">}</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:25:3 - error TS2322: Type 'boolean' is not assignable to type 'number'.</span>

<span style="color: #7f0000;">//////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">let lastMismatch = getLast({ //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">next: {                    //</span>
<span style="color: #7f0000;">//     </span><span style="color: #7f0000;">value: 123,              //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">},                         //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">value: false,              //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">});                          //</span>
<span style="color: #7f0000;">//////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
<li>如果generic interface声明定义里面包含type parameter,那么所有使用到这个interface的type annotation必
须要传递type argument
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">CrateLike</span>&lt;<span style="color: #005f5f;">T</span>&gt; <span style="color: #000000;">{</span>
  contents: T;
<span style="color: #000000;">}</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:5:21 - error TS2314: Generic type 'CrateLike&lt;T&gt;' requires 1 type argument(s).</span>

<span style="color: #7f0000;">///////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">let missingGeneric: CrateLike = { //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">inside: "",                     //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">};                                //</span>
<span style="color: #7f0000;">///////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org0f14810" class="outline-3">
<h3 id="org0f14810"><span class="section-number-3">10.3.</span> Generic Classes</h3>
<div class="outline-text-3" id="text-10-3">
<ul class="org-ul">
<li>和function, interface一样,class也可以使用type parameter
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">Secret</span>&lt;<span style="color: #005f5f;">Key</span>, <span style="color: #005f5f;">Value</span>&gt; <span style="color: #000000;">{</span>
  key: <span style="color: #005f5f;">Key</span>;
  value: <span style="color: #005f5f;">Value</span>;

  <span style="color: #531ab6;">constructor</span><span style="color: #dd22dd;">(</span>key: <span style="color: #005f5f;">Key</span>, value: <span style="color: #005f5f;">Value</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">this</span>.key = key;
    <span style="color: #531ab6;">this</span>.value = value;
  <span style="color: #dd22dd;">}</span>

  <span style="color: #721045;">getValue</span><span style="color: #dd22dd;">(</span><span style="color: #005e8b;">key</span>: <span style="color: #005f5f;">Key</span><span style="color: #dd22dd;">)</span>: <span style="color: #005f5f;">Value</span> | <span style="color: #0000b0;">undefined</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">return</span> <span style="color: #531ab6;">this</span>.key === key ? <span style="color: #531ab6;">this</span>.value : <span style="color: #0000b0;">undefined</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">storage</span> = <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Secret</span><span style="color: #000000;">(</span>12345, <span style="color: #3548cf;">"luggage"</span><span style="color: #000000;">)</span>;

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>storage.<span style="color: #721045;">getValue</span><span style="color: #dd22dd;">(</span>1987<span style="color: #dd22dd;">)</span><span style="color: #000000;">)</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>storage.<span style="color: #721045;">getValue</span><span style="color: #dd22dd;">(</span>12345<span style="color: #dd22dd;">)</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">undefined</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">luggage</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
<div id="outline-container-org7b51570" class="outline-4">
<h4 id="org7b51570"><span class="section-number-4">10.3.1.</span> Explicit Generic Class Types</h4>
<div class="outline-text-4" id="text-10-3-1">
<ul class="org-ul">
<li>实例化generic class的过程和调用generic function是一样的:
<ul class="org-ul">
<li>如果能够从参数判断出type argument,那么就不用type argument.</li>
<li>如果能够从参数不能判断出type argument,那么类型就是unknown,这时候需要提供type argument</li>
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">CurriedCallback</span>&lt;<span style="color: #005f5f;">Input</span>&gt; <span style="color: #000000;">{</span>
  #callback: <span style="color: #dd22dd;">(</span>input: <span style="color: #005f5f;">Input</span><span style="color: #dd22dd;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #531ab6;">void</span>;
  <span style="color: #531ab6;">constructor</span><span style="color: #dd22dd;">(</span>callback: <span style="color: #008899;">(</span>input: <span style="color: #005f5f;">Input</span><span style="color: #008899;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #531ab6;">void</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">this</span>.#callback = <span style="color: #008899;">(</span><span style="color: #005e8b;">input</span>: <span style="color: #005f5f;">Input</span><span style="color: #008899;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #008899;">{</span>
      <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #972500;">(</span><span style="color: #3548cf;">"Input"</span>, input<span style="color: #972500;">)</span>;
      <span style="color: #721045;">callback</span><span style="color: #972500;">(</span>input<span style="color: #972500;">)</span>;
    <span style="color: #008899;">}</span>;
  <span style="color: #dd22dd;">}</span>

  <span style="color: #721045;">call</span><span style="color: #dd22dd;">(</span><span style="color: #005e8b;">input</span>: <span style="color: #005f5f;">Input</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">this</span>.#<span style="color: #721045;">callback</span><span style="color: #008899;">(</span>input<span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">new</span> <span style="color: #005f5f;">CurriedCallback</span><span style="color: #000000;">(</span><span style="color: #dd22dd;">(</span><span style="color: #005e8b;">input</span>: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #dd22dd;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span>input.length<span style="color: #008899;">)</span>;
<span style="color: #dd22dd;">}</span><span style="color: #000000;">)</span>;

<span style="color: #531ab6;">new</span> <span style="color: #005f5f;">CurriedCallback</span>&lt;<span style="color: #531ab6;">string</span>&gt;<span style="color: #000000;">(</span><span style="color: #dd22dd;">(</span><span style="color: #005e8b;">input</span><span style="color: #dd22dd;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #dd22dd;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span>input.length<span style="color: #008899;">)</span>;
<span style="color: #dd22dd;">}</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:26:15 - error TS18046: 'input' is of type 'unknown'.</span>

<span style="color: #7f0000;">//////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">new CurriedCallback((</span><span style="color: #005e8b;">input</span><span style="color: #7f0000;">) =&gt; { //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">console.</span><span style="color: #721045;">log</span><span style="color: #7f0000;">(input.length)      //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">});                              //</span>
<span style="color: #7f0000;">//////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org3fc59b2" class="outline-4">
<h4 id="org3fc59b2"><span class="section-number-4">10.3.2.</span> Extending Generic Classes</h4>
<div class="outline-text-4" id="text-10-3-2">
<ul class="org-ul">
<li>在涉及到继承的时候,如果base class是generic的,那么编译器是不会去infer type argument的. 这时候,derived class有两种选择:
<ul class="org-ul">
<li><p>
要么,在base class里面使用明确的type argument(string[]),然后derived class来 extends这个实际上已经"实例化"了的generic base class
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">Quote</span>&lt;<span style="color: #005f5f;">T</span>&gt; <span style="color: #000000;">{</span>
  lines: T;
  <span style="color: #531ab6;">constructor</span><span style="color: #dd22dd;">(</span>lines: T<span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">this</span>.lines = lines;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">class</span> <span style="color: #005f5f;">SpokenQuote</span> <span style="color: #531ab6;">extends</span> <span style="color: #005f5f;">Quote</span>&lt;<span style="color: #531ab6;">string</span><span style="color: #000000;">[]</span>&gt; <span style="color: #000000;">{</span>
  <span style="color: #721045;">speak</span><span style="color: #dd22dd;">()</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #531ab6;">this</span>.lines.<span style="color: #721045;">join</span><span style="color: #972500;">(</span><span style="color: #3548cf;">"\n"</span><span style="color: #972500;">)</span><span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span><span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Quote</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">"The only one"</span><span style="color: #dd22dd;">)</span>.lines<span style="color: #000000;">)</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span><span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Quote</span><span style="color: #dd22dd;">(</span><span style="color: #008899;">[</span>8, 7, 5, 6<span style="color: #008899;">]</span><span style="color: #dd22dd;">)</span>.lines<span style="color: #000000;">)</span>;

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span><span style="color: #531ab6;">new</span> <span style="color: #005f5f;">SpokenQuote</span><span style="color: #dd22dd;">(</span><span style="color: #008899;">[</span><span style="color: #3548cf;">"Here I am"</span>, <span style="color: #3548cf;">"This is new"</span><span style="color: #008899;">]</span><span style="color: #dd22dd;">)</span>.lines<span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:19:18 - error TS2322: Type 'number' is not assignable to type 'string'.</span>

<span style="color: #7f0000;">//////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">new SpokenQuote([8, 7, 5, 6]).lines; //</span>
<span style="color: #7f0000;">//////////////////////////////////////////</span>
</pre>
</div></li>
<li><p>
或者,在base class里面使用derived class的type parameter(Value)
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">Quote</span>&lt;<span style="color: #005f5f;">T</span>&gt; <span style="color: #000000;">{</span>
  lines: T;
  <span style="color: #531ab6;">constructor</span><span style="color: #dd22dd;">(</span>lines: T<span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">this</span>.lines = lines;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">class</span> <span style="color: #005f5f;">AttributeQuote</span>&lt;<span style="color: #005f5f;">Value</span>&gt; <span style="color: #531ab6;">extends</span> <span style="color: #005f5f;">Quote</span>&lt;<span style="color: #005f5f;">Value</span>&gt; <span style="color: #000000;">{</span>
  speaker: <span style="color: #531ab6;">string</span>;

  <span style="color: #531ab6;">constructor</span><span style="color: #dd22dd;">(</span>value: <span style="color: #005f5f;">Value</span>, speaker: <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">super</span><span style="color: #008899;">(</span>value<span style="color: #008899;">)</span>;
    <span style="color: #531ab6;">this</span>.speaker = speaker;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">aq</span> = <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">AttributeQuote</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Here I am"</span>, <span style="color: #3548cf;">"This is new"</span><span style="color: #000000;">)</span>;

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>aq.lines<span style="color: #000000;">)</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>aq.speaker<span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Here I am</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">This is new</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgd284236" class="outline-4">
<h4 id="orgd284236"><span class="section-number-4">10.3.3.</span> Implementing Generic Interfaces</h4>
<div class="outline-text-4" id="text-10-3-3">
<ul class="org-ul">
<li>就像derived class继承base class一样, class 实现generic interfae也是可以的.但是只有generic interface
提供type argument这一条路了.
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">ActingCredit</span>&lt;<span style="color: #005f5f;">Role</span>&gt; <span style="color: #000000;">{</span>
  role: <span style="color: #005f5f;">Role</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">class</span> <span style="color: #005f5f;">MoviePart</span> <span style="color: #531ab6;">implements</span> <span style="color: #005f5f;">ActingCredit</span>&lt;<span style="color: #531ab6;">string</span>&gt; <span style="color: #000000;">{</span>
  role: <span style="color: #531ab6;">string</span>;
  speaking: <span style="color: #531ab6;">boolean</span>;

  <span style="color: #531ab6;">constructor</span><span style="color: #dd22dd;">(</span>role: <span style="color: #531ab6;">string</span>, speaking: <span style="color: #531ab6;">boolean</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">this</span>.role = role;
    <span style="color: #531ab6;">this</span>.speaking = speaking;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">part</span> = <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">MoviePart</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Miranda Priestly"</span>, <span style="color: #0000b0;">true</span><span style="color: #000000;">)</span>;

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>part.role<span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:20:3 - error TS2416: Property 'role' in type 'IncorrectExtension' is not assignable to the same property in base type 'ActingCredit&lt;string&gt;'.</span>

<span style="color: #7f0000;">////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">class IncorrectExtension implements ActingCredit&lt;string&gt; { //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">role: boolean;                                           //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">}                                                          //</span>
<span style="color: #7f0000;">////////////////////////////////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgcb8c03b" class="outline-4">
<h4 id="orgcb8c03b"><span class="section-number-4">10.3.4.</span> Method Generics</h4>
<div class="outline-text-4" id="text-10-3-4">
<ul class="org-ul">
<li>class method甚至可以设置自己的generic type(可以和class instance的generic type不一样)
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">CreatePairFactory</span>&lt;<span style="color: #005f5f;">Key</span>&gt; <span style="color: #000000;">{</span>
  key: <span style="color: #005f5f;">Key</span>;
  <span style="color: #531ab6;">constructor</span><span style="color: #dd22dd;">(</span>key: <span style="color: #005f5f;">Key</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">this</span>.key = key;
  <span style="color: #dd22dd;">}</span>

  <span style="color: #721045;">createPair</span>&lt;<span style="color: #005f5f;">Value</span>&gt;<span style="color: #dd22dd;">(</span><span style="color: #005e8b;">value</span>: <span style="color: #005f5f;">Value</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">return</span> <span style="color: #008899;">{</span> key: <span style="color: #531ab6;">this</span>.key, value <span style="color: #008899;">}</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">factory</span> = <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">CreatePairFactory</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"role"</span><span style="color: #000000;">)</span>;

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">numberPair</span> = factory.<span style="color: #721045;">createPair</span><span style="color: #000000;">(</span>10<span style="color: #000000;">)</span>;

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>numberPair<span style="color: #000000;">)</span>;

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">stringPair</span> = factory.<span style="color: #721045;">createPair</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"Sophie"</span><span style="color: #000000;">)</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>stringPair<span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">{ key: 'role', value: 10 }</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">{ key: 'role', value: 'Sophie' }</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org671840b" class="outline-4">
<h4 id="org671840b"><span class="section-number-4">10.3.5.</span> Static Class Generics</h4>
<div class="outline-text-4" id="text-10-3-5">
<ul class="org-ul">
<li>class的static member也可以拥有自己的type parameter,但是由于其无法访问instance member,所以其无法知道
instance的type parameter,它和class的联系并不紧密
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">BothLogger</span>&lt;<span style="color: #005f5f;">OnInstance</span>&gt; <span style="color: #000000;">{</span>
  <span style="color: #721045;">instanceLog</span><span style="color: #dd22dd;">(</span><span style="color: #005e8b;">value</span>: <span style="color: #005f5f;">OnInstance</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span>value<span style="color: #008899;">)</span>;
    <span style="color: #531ab6;">return</span> value;
  <span style="color: #dd22dd;">}</span>

  <span style="color: #531ab6;">static</span> <span style="color: #721045;">staticLog</span>&lt;<span style="color: #005f5f;">OnStatic</span>&gt;<span style="color: #dd22dd;">(</span><span style="color: #005e8b;">value</span>: <span style="color: #005f5f;">OnStatic</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:8:23 - error TS2302: Static members cannot reference class type parameters.</span>

    <span style="color: #7f0000;">///////////////////////////////////</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">let fromInstance: OnInstance; //</span>
    <span style="color: #7f0000;">///////////////////////////////////</span>

    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span>value<span style="color: #008899;">)</span>;
    <span style="color: #531ab6;">return</span> value;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">logger</span> = <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">BothLogger</span>&lt;<span style="color: #531ab6;">number</span><span style="color: #000000;">[]</span>&gt;<span style="color: #000000;">()</span>;
logger.<span style="color: #721045;">instanceLog</span><span style="color: #000000;">(</span><span style="color: #dd22dd;">[</span>1, 2, 3<span style="color: #dd22dd;">]</span><span style="color: #000000;">)</span>;

BothLogger.<span style="color: #721045;">staticLog</span><span style="color: #000000;">(</span><span style="color: #dd22dd;">[</span><span style="color: #0000b0;">false</span>, <span style="color: #0000b0;">true</span><span style="color: #dd22dd;">]</span><span style="color: #000000;">)</span>;

BothLogger.<span style="color: #721045;">staticLog</span>&lt;<span style="color: #531ab6;">string</span>&gt;<span style="color: #000000;">(</span><span style="color: #3548cf;">"You can't change the music of your soul"</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">[ 1, 2, 3 ]</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">[ false, true ]</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">You can't change the music of your soul</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgc6245fd" class="outline-3">
<h3 id="orgc6245fd"><span class="section-number-3">10.4.</span> Generic Type Aliases</h3>
<div class="outline-text-3" id="text-10-4">
<ul class="org-ul">
<li>type alias后面还可以跟着type argument(具体类型),这可以用来处理一些typescript里面的需要和null, undefined打交道的情况
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">type</span> <span style="color: #005f5f;">Nullish</span>&lt;<span style="color: #005f5f;">T</span>&gt; = T | <span style="color: #0000b0;">null</span> | <span style="color: #0000b0;">undefined</span>;

<span style="color: #531ab6;">type</span> <span style="color: #005f5f;">Handler</span>&lt;<span style="color: #005f5f;">T</span>&gt; = <span style="color: #000000;">(</span>input: <span style="color: #005f5f;">Nullish</span>&lt;<span style="color: #005f5f;">T</span>&gt;, defaultValue: T<span style="color: #000000;">)</span> <span style="color: #531ab6;">=&gt;</span> T;

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">handleNullish</span>: <span style="color: #005f5f;">Handler</span>&lt;<span style="color: #531ab6;">number</span>&gt; = <span style="color: #000000;">(</span><span style="color: #005e8b;">input</span>, <span style="color: #005e8b;">defaultValue</span><span style="color: #000000;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> input !== <span style="color: #0000b0;">null</span> &amp;&amp; input !== <span style="color: #0000b0;">undefined</span> ? input : defaultValue;
<span style="color: #000000;">}</span>;

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span><span style="color: #721045;">handleNullish</span><span style="color: #dd22dd;">(</span>5, 10<span style="color: #dd22dd;">)</span><span style="color: #000000;">)</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span><span style="color: #721045;">handleNullish</span><span style="color: #dd22dd;">(</span><span style="color: #0000b0;">null</span>, 10<span style="color: #dd22dd;">)</span><span style="color: #000000;">)</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span><span style="color: #721045;">handleNullish</span><span style="color: #dd22dd;">(</span><span style="color: #0000b0;">undefined</span>, 10<span style="color: #dd22dd;">)</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">5</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">10</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">10</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
<div id="outline-container-orgf3fe606" class="outline-4">
<h4 id="orgf3fe606"><span class="section-number-4">10.4.1.</span> Generic Discriminated Unions</h4>
<div class="outline-text-4" id="text-10-4-1">
<ul class="org-ul">
<li>discriminated union(object包含相同的判断field,也包含不同的field,通过union组合起来),如果能结合generic,
会产生更加好的效果.
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">type</span> <span style="color: #005f5f;">Result</span>&lt;<span style="color: #005f5f;">Data</span>&gt; = FailureResult | SuccessfulResult&lt;<span style="color: #005f5f;">Data</span>&gt;;

<span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">FailureResult</span> <span style="color: #000000;">{</span>
  error: <span style="color: #005f5f;">Error</span>;
  succeeded: <span style="color: #0000b0;">false</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">SuccessfulResult</span>&lt;<span style="color: #005f5f;">Data</span>&gt; <span style="color: #000000;">{</span>
  data: <span style="color: #005f5f;">Data</span>;
  succeeded: <span style="color: #0000b0;">true</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">function</span> <span style="color: #721045;">handleResult</span><span style="color: #000000;">(</span><span style="color: #005e8b;">result</span>: <span style="color: #005f5f;">Result</span>&lt;<span style="color: #531ab6;">string</span>&gt;<span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">if</span> <span style="color: #dd22dd;">(</span>result.succeeded<span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">Type of result: SuccessfulResult</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #3548cf;">`We did it ! </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">result.data</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span> <span style="color: #531ab6;">else</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">Type of result: Failureresult</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span><span style="color: #3548cf;">`Awww... </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">result.error</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>

<span style="color: #721045;">handleResult</span><span style="color: #000000;">(</span><span style="color: #dd22dd;">{</span> data: <span style="color: #3548cf;">"ok"</span>, succeeded: <span style="color: #0000b0;">true</span> <span style="color: #dd22dd;">}</span><span style="color: #000000;">)</span>;
<span style="color: #721045;">handleResult</span><span style="color: #000000;">(</span><span style="color: #dd22dd;">{</span> error: <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Error</span><span style="color: #008899;">(</span><span style="color: #3548cf;">"not ok"</span><span style="color: #008899;">)</span>, succeeded: <span style="color: #0000b0;">false</span> <span style="color: #dd22dd;">}</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">We did it ! ok</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Awww... Error: not ok</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org7d8a1a2" class="outline-3">
<h3 id="org7d8a1a2"><span class="section-number-3">10.5.</span> Generic Modifiers</h3>
<div class="outline-text-3" id="text-10-5">
</div>
<div id="outline-container-orgb3b267b" class="outline-4">
<h4 id="orgb3b267b"><span class="section-number-4">10.5.1.</span> Generic Defaults</h4>
<div class="outline-text-4" id="text-10-5-1">
<ul class="org-ul">
<li>类似函数有默认参数,泛型也可以指定一个默认类型,在没有明确的type argument的情况下就会默认使用这个类型
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">Quote</span>&lt;<span style="color: #005f5f;">T</span> = <span style="color: #531ab6;">string</span>&gt; <span style="color: #000000;">{</span>
  value: T;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">explicit</span>: <span style="color: #005f5f;">Quote</span>&lt;<span style="color: #531ab6;">number</span>&gt; = <span style="color: #000000;">{</span> value: 123 <span style="color: #000000;">}</span>;
<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">implicit</span>: <span style="color: #005f5f;">Quote</span> = <span style="color: #000000;">{</span> value: <span style="color: #3548cf;">"Be yourself"</span> <span style="color: #000000;">}</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:7:25 - error TS2322: Type 'number' is not assignable to type 'string'.</span>

<span style="color: #7f0000;">///////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">let mismatch: Quote = { value: 123 }; //</span>
<span style="color: #7f0000;">///////////////////////////////////////////</span>
</pre>
</div></li>
<li>上面例子的情况是type annotation,是必须要提供type argument的情况</li>
</ul></li>
<li>我们甚至后面的type parameter可以使用前面的type parameter来作为default
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">KeyValuePair</span>&lt;<span style="color: #005f5f;">Key</span>, <span style="color: #005f5f;">Value</span> = <span style="color: #005f5f;">Key</span>&gt; <span style="color: #000000;">{</span>
  key: <span style="color: #005f5f;">Key</span>;
  value: <span style="color: #005f5f;">Value</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">allExplicit</span>: <span style="color: #005f5f;">KeyValuePair</span>&lt;<span style="color: #531ab6;">string</span>, <span style="color: #531ab6;">number</span>&gt; = <span style="color: #000000;">{</span>
  key: <span style="color: #3548cf;">"rating"</span>,
  value: 10,
<span style="color: #000000;">}</span>;

<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">oneDefaulting</span>: <span style="color: #005f5f;">KeyValuePair</span>&lt;<span style="color: #531ab6;">string</span>&gt; = <span style="color: #000000;">{</span>
  key: <span style="color: #3548cf;">"rating"</span>,
  value: <span style="color: #3548cf;">"ten"</span>,
<span style="color: #000000;">}</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:16:19 - error TS2707: Generic type 'KeyValuePair&lt;Key, Value&gt;' requires between 1 and 2 type arguments.</span>

<span style="color: #7f0000;">////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">let firstMissing: KeyValuePair = { //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">key: "rating",                   //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">value: 10,                       //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">};                                 //</span>
<span style="color: #7f0000;">////////////////////////////////////////</span>
</pre>
</div></li>
<li>我们可以看到Value使用Key作为default paramter,所以,只提供一个type argument的情况下,两者一样,但是提
供两个type argument的情况下,两者可以不一样</li>
<li>另外注意,不能一个type argument也不提供,因为这样Key都无法知晓自己的具体类型</li>
</ul></li>
<li>default type parameter的后面不能有其他type parameter,换句话说,default type parameter们必须在所有的
type parameter的最后
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">inTheEnd</span>&lt;<span style="color: #005f5f;">First</span>, <span style="color: #005f5f;">Second</span>, <span style="color: #005f5f;">Third</span> = <span style="color: #531ab6;">number</span>, <span style="color: #005f5f;">Fourth</span> = <span style="color: #531ab6;">string</span>&gt;<span style="color: #000000;">()</span> <span style="color: #000000;">{}</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:2:63 - error TS2706: Required type parameters may not follow optional type parameters.</span>

<span style="color: #7f0000;">////////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">function inTheMiddle&lt;First, Second = boolean, Third = number, Fourth&gt;() {} //</span>
<span style="color: #7f0000;">////////////////////////////////////////////////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org39204f0" class="outline-3">
<h3 id="org39204f0"><span class="section-number-3">10.6.</span> Constrained Generic Types</h3>
<div class="outline-text-3" id="text-10-6">
<ul class="org-ul">
<li>泛型的type argument可以是任意的类型(class, interface, primitive, union)等等,但是有些情况下,我们只能
跟特定的某些类型进行合作.</li>
<li>这里所谓的"特定的某些类型",不是用union能够列举的.而是更加抽象的"特定类型",为了抽象出这种类型,typescript
引入了constrained generic type
<ul class="org-ul">
<li><p>
constrained generic type具体做法,就是在 type parameter后面加上一个extends, extends后面就是我们要
做的"抽象约束",示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">WithLength</span> <span style="color: #000000;">{</span>
  length: <span style="color: #531ab6;">number</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">function</span> <span style="color: #721045;">logWithLength</span>&lt;<span style="color: #005f5f;">T</span> <span style="color: #531ab6;">extends</span> <span style="color: #005f5f;">WithLength</span>&gt;<span style="color: #000000;">(</span><span style="color: #005e8b;">input</span>: T<span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">`Length: </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">input.length</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #dd22dd;">)</span>;
  <span style="color: #531ab6;">return</span> input;
<span style="color: #000000;">}</span>

<span style="color: #721045;">logWithLength</span><span style="color: #000000;">(</span><span style="color: #3548cf;">"No one can figure outt your worth but you"</span><span style="color: #000000;">)</span>;
<span style="color: #721045;">logWithLength</span><span style="color: #000000;">(</span><span style="color: #dd22dd;">[</span><span style="color: #0000b0;">false</span>, <span style="color: #0000b0;">true</span><span style="color: #dd22dd;">]</span><span style="color: #000000;">)</span>;
<span style="color: #721045;">logWithLength</span><span style="color: #000000;">(</span><span style="color: #dd22dd;">{</span> length: 23 <span style="color: #dd22dd;">}</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Length: 41</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Length: 2</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Length: 23</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:19:15 - error TS2345: Argument of type 'Date' is not assignable to parameter of type 'WithLength'.</span>

<span style="color: #7f0000;">////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">logWithLength(new Date()); //</span>
<span style="color: #7f0000;">////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
<div id="outline-container-orgfddc350" class="outline-4">
<h4 id="orgfddc350"><span class="section-number-4">10.6.1.</span> keyof and Constrained Type Parameters</h4>
<div class="outline-text-4" id="text-10-6-1">
<ul class="org-ul">
<li>值得注意的是, Constrained Type Parameters是一种"无法列举"的union,这种情况下想描述这些列举,就只好用
keyof了
<ul class="org-ul">
<li><p>
示例如下,keyof能够很好的从generic中获取key列表("favorite | others")
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">get</span>&lt;<span style="color: #005f5f;">T</span>, <span style="color: #005f5f;">Key</span> <span style="color: #531ab6;">extends</span> <span style="color: #005f5f;">keyof</span> <span style="color: #005f5f;">T</span>&gt;<span style="color: #000000;">(</span><span style="color: #005e8b;">container</span>: T, <span style="color: #005e8b;">key</span>: <span style="color: #005f5f;">Key</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> container<span style="color: #dd22dd;">[</span>key<span style="color: #dd22dd;">]</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">roles</span> = <span style="color: #000000;">{</span>
  favorite: <span style="color: #3548cf;">"Fargo"</span>,
  others: <span style="color: #dd22dd;">[</span><span style="color: #3548cf;">"Almost Famous"</span>, <span style="color: #3548cf;">"Burn After Reading"</span>, <span style="color: #3548cf;">"Nomadland"</span><span style="color: #dd22dd;">]</span>,
<span style="color: #000000;">}</span>;

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">favorite</span> = <span style="color: #531ab6;">get</span><span style="color: #000000;">(</span>roles, <span style="color: #3548cf;">"favorite"</span><span style="color: #000000;">)</span>; <span style="color: #7f0000;">// </span><span style="color: #005e8b;">Type</span><span style="color: #7f0000;">: </span><span style="color: #005e8b;">string</span>
<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">others</span> = <span style="color: #531ab6;">get</span><span style="color: #000000;">(</span>roles, <span style="color: #3548cf;">"others"</span><span style="color: #000000;">)</span>;     <span style="color: #7f0000;">// </span><span style="color: #005e8b;">Type</span><span style="color: #7f0000;">: string[]</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:12:28 - error TS2345: Argument of type '"extra"' is not assignable to parameter of type '"favorite" | "others"'.</span>

<span style="color: #7f0000;">//////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">const missing = get(roles, "extra"); //</span>
<span style="color: #7f0000;">//////////////////////////////////////////</span>
</pre>
</div></li>
<li><p>
上面例子key为"favorite"的时候,返回值类型为string, key为"others"的时候,返回值类型为string[],如此
精妙的逻辑,是由于有Key(constrained type parameter)的参与.如果是一个平反的泛型加keyof的组合,那么返
回值会是一个union类型(string | string[])
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">get</span>&lt;<span style="color: #005f5f;">T</span>&gt;<span style="color: #000000;">(</span><span style="color: #005e8b;">container</span>: T, <span style="color: #005e8b;">key</span>: <span style="color: #531ab6;">keyof</span> T<span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> container<span style="color: #dd22dd;">[</span>key<span style="color: #dd22dd;">]</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">roles</span> = <span style="color: #000000;">{</span>
  favorite: <span style="color: #3548cf;">"Fargo"</span>,
  others: <span style="color: #dd22dd;">[</span><span style="color: #3548cf;">"Almost Famous"</span>, <span style="color: #3548cf;">"Burn After Reading"</span>, <span style="color: #3548cf;">"Nomadland"</span><span style="color: #dd22dd;">]</span>,
<span style="color: #000000;">}</span>;

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">favorite</span> = <span style="color: #531ab6;">get</span><span style="color: #000000;">(</span>roles, <span style="color: #3548cf;">"favorite"</span><span style="color: #000000;">)</span>;

<span style="color: #531ab6;">let</span> <span style="color: #005e8b;">again</span>: <span style="color: #531ab6;">string</span> = <span style="color: #3548cf;">"again"</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:15:1 - error TS2322: Type 'string | string[]' is not assignable to type 'string'.</span>

<span style="color: #7f0000;">///////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">again = favorite; //</span>
<span style="color: #7f0000;">///////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org1bbd748" class="outline-3">
<h3 id="org1bbd748"><span class="section-number-3">10.7.</span> Promises</h3>
<div class="outline-text-3" id="text-10-7">
<ul class="org-ul">
<li>在Typescript中,我们把Promise变成了一个泛型,其只有一个type parameter
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">fetchData</span><span style="color: #000000;">(</span><span style="color: #005e8b;">success</span>: <span style="color: #531ab6;">boolean</span><span style="color: #000000;">)</span>: <span style="color: #005f5f;">Promise</span>&lt;<span style="color: #531ab6;">string</span>&gt; <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Promise</span><span style="color: #dd22dd;">(</span><span style="color: #008899;">(</span><span style="color: #005e8b;">resolve</span>, <span style="color: #005e8b;">reject</span><span style="color: #008899;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #008899;">{</span>
    <span style="color: #721045;">setTimeout</span><span style="color: #972500;">(</span><span style="color: #808000;">()</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #808000;">{</span>
      <span style="color: #531ab6;">if</span> <span style="color: #531ab6;">(</span>success<span style="color: #531ab6;">)</span> <span style="color: #531ab6;">{</span>
        <span style="color: #721045;">resolve</span><span style="color: #008900;">(</span><span style="color: #3548cf;">"Data Load Successfully"</span><span style="color: #008900;">)</span>;
      <span style="color: #531ab6;">}</span> <span style="color: #531ab6;">else</span> <span style="color: #531ab6;">{</span>
        <span style="color: #721045;">reject</span><span style="color: #008900;">(</span><span style="color: #3548cf;">"Data Load Failed"</span><span style="color: #008900;">)</span>;
      <span style="color: #531ab6;">}</span>
    <span style="color: #808000;">}</span>, 2000<span style="color: #972500;">)</span>;
  <span style="color: #008899;">}</span><span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>

<span style="color: #721045;">fetchData</span><span style="color: #000000;">(</span><span style="color: #0000b0;">true</span><span style="color: #000000;">)</span>
  .<span style="color: #721045;">then</span><span style="color: #000000;">(</span><span style="color: #dd22dd;">(</span><span style="color: #005e8b;">data</span><span style="color: #dd22dd;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span>data<span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span><span style="color: #000000;">)</span>
  .<span style="color: #721045;">catch</span><span style="color: #000000;">(</span><span style="color: #dd22dd;">(</span><span style="color: #005e8b;">error</span><span style="color: #dd22dd;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">error</span><span style="color: #008899;">(</span>error<span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span><span style="color: #000000;">)</span>;

<span style="color: #721045;">fetchData</span><span style="color: #000000;">(</span><span style="color: #0000b0;">false</span><span style="color: #000000;">)</span>
  .<span style="color: #721045;">then</span><span style="color: #000000;">(</span><span style="color: #dd22dd;">(</span><span style="color: #005e8b;">data</span><span style="color: #dd22dd;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #008899;">(</span>data<span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span><span style="color: #000000;">)</span>
  .<span style="color: #721045;">catch</span><span style="color: #000000;">(</span><span style="color: #dd22dd;">(</span><span style="color: #005e8b;">error</span><span style="color: #dd22dd;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #dd22dd;">{</span>
    <span style="color: #005f5f;">console</span>.<span style="color: #721045;">error</span><span style="color: #008899;">(</span>error<span style="color: #008899;">)</span>;
  <span style="color: #dd22dd;">}</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Data Load Successfully</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Data Load Failed</span>
</pre>
</div></li>
<li><p>
这里的type argument是string,也就说resolve和reject必须为stirng.我们如果改type argument为number,就会报错,如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #7f0000;">// </span><span style="color: #7f0000;">TSError: &#10799; Unable to compile TypeScript:</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">main.ts:5:17 - error TS2345: Argument of type 'string' is not assignable to parameter of type 'number | PromiseLike&lt;number&gt;'.</span>

<span style="color: #7f0000;">//          </span><span style="color: #7f0000;">resolve("Data Load Successfully");</span>
<span style="color: #7f0000;">//                   </span><span style="color: #7f0000;">~~~~~~~~~~~~~~~~~~~~~~~~</span>

<span style="color: #7f0000;">/////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">function fetchData(</span><span style="color: #005e8b;">success</span><span style="color: #7f0000;">: boolean): Promise&lt;number&gt; { //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">return new Promise((</span><span style="color: #005e8b;">resolve</span><span style="color: #7f0000;">, </span><span style="color: #005e8b;">reject</span><span style="color: #7f0000;">) =&gt; {             //</span>
<span style="color: #7f0000;">//     </span><span style="color: #7f0000;">setTimeout(() =&gt; {                                  //</span>
<span style="color: #7f0000;">//       </span><span style="color: #7f0000;">if (</span><span style="color: #005e8b;">success</span><span style="color: #7f0000;">) {                                    //</span>
<span style="color: #7f0000;">//         </span><span style="color: #7f0000;">resolve("Data Load Successfully");              //</span>
<span style="color: #7f0000;">//       </span><span style="color: #7f0000;">} else {                                          //</span>
<span style="color: #7f0000;">//         </span><span style="color: #7f0000;">reject("Data Load Failed");                     //</span>
<span style="color: #7f0000;">//       </span><span style="color: #7f0000;">}                                                 //</span>
<span style="color: #7f0000;">//     </span><span style="color: #7f0000;">}, 2000);                                           //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">});                                                   //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">}                                                       //</span>
<span style="color: #7f0000;">/////////////////////////////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
<div id="outline-container-orgd62137a" class="outline-4">
<h4 id="orgd62137a"><span class="section-number-4">10.7.1.</span> Creating Promises</h4>
<div class="outline-text-4" id="text-10-7-1">
<ul class="org-ul">
<li>在type annotion的时候,设置type argument与否会有不同的效果:
<ul class="org-ul">
<li><p>
如果不设置type argument,如下例,那么resolveUnknown类型是Promise&lt;unknown&gt;
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">resolvesUnknown</span> = <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Promise</span><span style="color: #000000;">(</span><span style="color: #dd22dd;">(</span><span style="color: #005e8b;">resolve</span><span style="color: #dd22dd;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #dd22dd;">{</span>
  <span style="color: #721045;">setTimeout</span><span style="color: #008899;">(</span><span style="color: #972500;">()</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #721045;">resolve</span><span style="color: #972500;">(</span><span style="color: #3548cf;">"Done !"</span><span style="color: #972500;">)</span>, 1000<span style="color: #008899;">)</span>;
<span style="color: #dd22dd;">}</span><span style="color: #000000;">)</span>;
</pre>
</div></li>
<li><p>
如果设置type argument为string,如下例,那么resolveString类型是Promise&lt;string&gt;
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">resolvesString</span> = <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Promise</span>&lt;<span style="color: #531ab6;">string</span>&gt;<span style="color: #000000;">(</span><span style="color: #dd22dd;">(</span><span style="color: #005e8b;">resolve</span><span style="color: #dd22dd;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #dd22dd;">{</span>
  <span style="color: #721045;">setTimeout</span><span style="color: #008899;">(</span><span style="color: #972500;">()</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #721045;">resolve</span><span style="color: #972500;">(</span><span style="color: #3548cf;">"Done !"</span><span style="color: #972500;">)</span>, 1000<span style="color: #008899;">)</span>;
<span style="color: #dd22dd;">}</span><span style="color: #000000;">)</span>;
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org9632ffb" class="outline-4">
<h4 id="org9632ffb"><span class="section-number-4">10.7.2.</span> Async Functions</h4>
<div class="outline-text-4" id="text-10-7-2">
<ul class="org-ul">
<li>在Javascrip里面一切以async开头的函数都会返回一个Promise. 如果async function的返回值不是Thenable(不含then()函数),
那么它会自动被包裹成Promise,比如下面的两个代码是等价的:
<ul class="org-ul">
<li><p>
直接返回一个string
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #531ab6;">async</span> <span style="color: #531ab6;">function</span> myAsyncFunction<span style="color: #000000;">()</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> <span style="color: #3548cf;">"Hello, async!"</span>;
<span style="color: #000000;">}</span>
</pre>
</div></li>
<li><p>
相当于返回一个Promise
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #531ab6;">function</span> <span style="color: #721045;">myAsyncFunction</span><span style="color: #000000;">()</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> Promise.resolve<span style="color: #dd22dd;">(</span><span style="color: #3548cf;">"Hello, async!"</span><span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>
</pre>
</div></li>
</ul></li>
<li><p>
Typescript肯定是要遵循Javascript的设置的,另外加上它自己的类型设置,返回的不再是Promise,而是Promise&lt;target_rgument&gt;
比如下面的例子返回的都是Promise&lt;number&gt;
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">async</span> <span style="color: #531ab6;">function</span> <span style="color: #721045;">lengthImmediately</span><span style="color: #000000;">(</span><span style="color: #005e8b;">text</span>: <span style="color: #531ab6;">string</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> text.length;
<span style="color: #000000;">}</span>
</pre>
</div></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org581a26a" class="outline-3">
<h3 id="org581a26a"><span class="section-number-3">10.8.</span> Using Generics Right</h3>
<div class="outline-text-3" id="text-10-8">
<ul class="org-ul">
<li>Typescript使用泛型的最佳实践是只有必须使用泛型的情况下才会使用泛型</li>
<li>应用代码使用泛型的机会较少,多是library代码使用泛型会较多</li>
</ul>
</div>
<div id="outline-container-org42ad22a" class="outline-4">
<h4 id="org42ad22a"><span class="section-number-4">10.8.1.</span> The Golden Rule of Generics</h4>
<div class="outline-text-4" id="text-10-8-1">
<ul class="org-ul">
<li>一个最简答的判断是否用泛型的方法就是:只有使用至少两次以上的function才需要泛型</li>
</ul>
</div>
</div>
<div id="outline-container-orgb85b5cc" class="outline-4">
<h4 id="orgb85b5cc"><span class="section-number-4">10.8.2.</span> Generic Naming Conventions</h4>
<div class="outline-text-4" id="text-10-8-2">
<ul class="org-ul">
<li>一般来说,我们使用如下顺序来给type parameter命名:
<ul class="org-ul">
<li>T</li>
<li>U</li>
<li>V</li>
</ul></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org10371e5" class="outline-2">
<h2 id="org10371e5"><span class="section-number-2">11.</span> Chapter 11: Declaration Files</h2>
<div class="outline-text-2" id="text-11">
<ul class="org-ul">
<li>即便是只希望写Typescript,也避免不了在项目中和Javascript合作,因为:
<ul class="org-ul">
<li>世界上大部分的代码还是JavaScript写的</li>
<li>即便那些用TypeScript写的代码,最终还是会以JavaScript发布</li>
</ul></li>
<li>为了解决这个问题,TypeScript可以选择把自己的type shape和implementation分开,type shape的部分就叫做
declartion files,通常以.d.ts结尾. 我们可以近似的这么对比:
<ul class="org-ul">
<li>.ts文件类似c语言中的.c文件</li>
<li>.d.ts文件类似c语言中的.h文件</li>
</ul></li>
</ul>
</div>
<div id="outline-container-orgf64e535" class="outline-3">
<h3 id="orgf64e535"><span class="section-number-3">11.1.</span> Declaration Files</h3>
<div class="outline-text-3" id="text-11-1">
<ul class="org-ul">
<li>.d.ts文件里面的内容是有要求的:
<ul class="org-ul">
<li>不能包含任何runtime的代码</li>
<li>只能包含对于runtime value, interface, module的description,以及type</li>
</ul></li>
<li>.d.ts自己不会被编译成JavaScript. 但是可以被其他TypeScript文件引用(引用之后,这个文件当然可以被编译成JavaScript)
<ul class="org-ul">
<li><p>
declaration文件types.d.ts如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">export</span> <span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">Charater</span> <span style="color: #000000;">{</span>
  catchphrase?: <span style="color: #531ab6;">string</span>;
  name: <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>
</pre>
</div></li>
<li><p>
普通文件index.ts如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">import</span> <span style="color: #000000;">{</span> Charater <span style="color: #000000;">}</span> <span style="color: #531ab6;">from</span> <span style="color: #3548cf;">"./types"</span>;

<span style="color: #531ab6;">export</span> <span style="color: #531ab6;">const</span> <span style="color: #005e8b;">character</span>: <span style="color: #005f5f;">Charater</span> = <span style="color: #000000;">{</span>
  catchphrase: <span style="color: #3548cf;">"Yee-haw!"</span>,
  name: <span style="color: #3548cf;">"Sandy Cheeks"</span>,
<span style="color: #000000;">}</span>;
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org403229d" class="outline-3">
<h3 id="org403229d"><span class="section-number-3">11.2.</span> Declaring Runtime Values</h3>
<div class="outline-text-3" id="text-11-2">
<ul class="org-ul">
<li>在TypeScript里面,function和variable都是value, 所以declaration file里面的runtime value也包括function
这些value必须以declare开头进行声明,并且不能有初始化值或者function body
<ul class="org-ul">
<li><p>
声明文件types.d.ts示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">declare</span> <span style="color: #531ab6;">let</span> <span style="color: #005e8b;">declared</span>: <span style="color: #531ab6;">string</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Initializers are not allowed in ambient contexts.</span>

<span style="color: #7f0000;">////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">declare let initializer: string = "Wanda"; //</span>
<span style="color: #7f0000;">////////////////////////////////////////////////</span>
</pre>
</div></li>
<li><p>
声明文件fairies.d.ts示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">declare</span> <span style="color: #531ab6;">function</span> <span style="color: #721045;">canGrantWish</span><span style="color: #000000;">(</span><span style="color: #005e8b;">wish</span>: <span style="color: #531ab6;">string</span><span style="color: #000000;">)</span>: <span style="color: #531ab6;">boolean</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">An implementation cannot be declared in ambient contexts. (typescript-tide)</span>

<span style="color: #7f0000;">////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">declare function grantWish(</span><span style="color: #005e8b;">wish</span><span style="color: #7f0000;">: string) { //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">return true;                             //</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">};                                         //</span>
<span style="color: #7f0000;">////////////////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
<li>由于declaration文件不允许提供实现的结构体,所以为不让我们的返回值被判定成any,我们必须在函数声明的时
候,给函数加上返回值类型</li>
<li>declare虽然绝大多数情况下是使用在declaration文件里面的,但是其实declare也可以用在普通typescript文件.
特别是普通的typescript文件需要使用一个全局变量,那么就必须在这个文件里面使用declare声明一次(定义在
其他文件)
<ul class="org-ul">
<li><p>
index.ts示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">declare</span> <span style="color: #531ab6;">const</span> <span style="color: #005e8b;">myGlobalValue</span>: <span style="color: #531ab6;">string</span>; <span style="color: #7f0000;">// </span><span style="color: #7f0000;">initialize elsewhere</span>

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>myGlobalValue<span style="color: #000000;">)</span>;

</pre>
</div></li>
</ul></li>
<li>只有interface不需要declare(但是也可以加declare),其他的value在declaration file里面必须要有declare
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">Writer</span> <span style="color: #000000;">{}</span> <span style="color: #7f0000;">// </span><span style="color: #7f0000;">ok</span>
<span style="color: #531ab6;">declare</span> <span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">Writer</span> <span style="color: #000000;">{}</span> <span style="color: #7f0000;">// </span><span style="color: #7f0000;">ok</span>

<span style="color: #531ab6;">declare</span> <span style="color: #531ab6;">const</span> <span style="color: #005e8b;">fullName</span>: <span style="color: #531ab6;">string</span>; <span style="color: #7f0000;">// </span><span style="color: #7f0000;">type is primitive string</span>
<span style="color: #531ab6;">declare</span> <span style="color: #531ab6;">const</span> <span style="color: #005e8b;">firstName</span>: <span style="color: #3548cf;">"Liz"</span>; <span style="color: #7f0000;">// </span><span style="color: #7f0000;">type is the literal "value"</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Top-level declarations in .d.ts files must start with either a 'declare' or 'export' modifier. (typescript-tide)</span>

<span style="color: #7f0000;">//////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">const lastName = "Lemon" //</span>
<span style="color: #7f0000;">//////////////////////////////</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
<div id="outline-container-orgc9b1aa0" class="outline-4">
<h4 id="orgc9b1aa0"><span class="section-number-4">11.2.1.</span> Global Values</h4>
<div class="outline-text-4" id="text-11-2-1">
<ul class="org-ul">
<li>Typescript有一个特性,那就是: 没有import或者export的文件会被看做是script,而不是module,这样一来,定义
在这个文件里面的construct(type是其中一种),就都是global variable了</li>
<li>没有export和import的declaration file就可以声明全局变量了,我们下面就是这样一个例子,这个例子需要配置很多东西:
<ul class="org-ul">
<li><p>
首先是整个项目的预览(编译后)
</p>
<div class="org-src-container">
<pre class="src src-shell">$ tree .
<span style="color: #8f0075;">.</span>
&#9500;&#9472;&#9472; dist
&#9474;&#160;&#160; &#9500;&#9472;&#9472; index.js
&#9474;&#160;&#160; &#9492;&#9472;&#9472; version.js
&#9500;&#9472;&#9472; globals.d.ts
&#9500;&#9472;&#9472; index.ts
&#9500;&#9472;&#9472; tsconfig.json
&#9492;&#9472;&#9472; version.ts
</pre>
</div></li>
<li><p>
我们首先在globals.d.ts里面声明这个全局变量
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">declare</span> <span style="color: #531ab6;">const</span> <span style="color: #005e8b;">version</span>: <span style="color: #531ab6;">string</span>;
</pre>
</div></li>
<li><p>
其次,我们在version.ts里面使用这个全局变量,我们不需要import globals.d.ts哈,因为是全局变量
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #7f0000;">// </span><span style="color: #7f0000;">declare const version: string;</span>

<span style="color: #531ab6;">export</span> <span style="color: #531ab6;">function</span> <span style="color: #721045;">logVersion</span><span style="color: #000000;">()</span> <span style="color: #000000;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">`Version: </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">version</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>
</pre>
</div></li>
<li><p>
再次,我们在index.ts里面初始化这个全局变量, 并且import version里面的使用这个全局变量的函数logVersion
并且调用这个logVersion
</p>
<div class="org-src-container">
<pre class="src src-typescript">globalThis.version = <span style="color: #3548cf;">"1.0.0"</span>;
<span style="color: #531ab6;">import</span> <span style="color: #000000;">{</span> logVersion <span style="color: #000000;">}</span> <span style="color: #531ab6;">from</span> <span style="color: #3548cf;">"./version"</span>;

<span style="color: #721045;">logVersion</span><span style="color: #000000;">()</span>;
</pre>
</div></li>
<li><p>
注意我们需要配置tsconfig.json才能编译成功
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #000000;">{</span>
  <span style="color: #3548cf;">"compilerOptions"</span>: <span style="color: #dd22dd;">{</span>
    <span style="color: #3548cf;">"target"</span>: <span style="color: #3548cf;">"ES2020"</span>,
    <span style="color: #3548cf;">"module"</span>: <span style="color: #3548cf;">"CommonJS"</span>,
    <span style="color: #3548cf;">"outDir"</span>: <span style="color: #3548cf;">"./dist"</span>,
    <span style="color: #3548cf;">"strict"</span>: <span style="color: #0000b0;">true</span>,
    <span style="color: #3548cf;">"typeRoots"</span>: <span style="color: #008899;">[</span><span style="color: #3548cf;">"./"</span><span style="color: #008899;">]</span>,
    <span style="color: #3548cf;">"esModuleInterop"</span>: <span style="color: #0000b0;">true</span>
  <span style="color: #dd22dd;">}</span>,
  <span style="color: #3548cf;">"include"</span>: <span style="color: #dd22dd;">[</span><span style="color: #3548cf;">"**/*.ts"</span><span style="color: #dd22dd;">]</span>
<span style="color: #000000;">}</span>
</pre>
</div></li>
<li><p>
编译命令如下
</p>
<div class="org-src-container">
<pre class="src src-shell">tsc
</pre>
</div></li>
<li><p>
编译后运行如下命令,成功打印1.0.0
</p>
<div class="org-src-container">
<pre class="src src-shell">$ node dist/index.js
Version: 1.0.0
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgc08452d" class="outline-4">
<h4 id="orgc08452d"><span class="section-number-4">11.2.2.</span> Global Interface Merging</h4>
<div class="outline-text-4" id="text-11-2-2">
<ul class="org-ul">
<li>我们能使用上面的方法把变量定义成global,那么我们同样也能把interface给定义成global</li>
<li>又因为typescript的interface同名情况下是merge的,所以我们可以给Windows这种global interface定义我们自
己的变量</li>
</ul>
</div>
</div>
<div id="outline-container-org381d418" class="outline-4">
<h4 id="org381d418"><span class="section-number-4">11.2.3.</span> Global Augmentations</h4>
<div class="outline-text-4" id="text-11-2-3">
<ul class="org-ul">
<li>如果要求某个declaration file没有import和export来确认global的申请,那么绝大多数情况下都会不够灵活,比
如我们希望global的变量其本身就import自其他文件,我们又想把这个类型的global,那么就势必需要另外一种更
加灵活的配置全局变量的方式,TypeScript给我们了global agumentation.下面是global agumentation的例子
<ul class="org-ul">
<li><p>
首先是整个项目的预览(编译后)
</p>
<div class="org-src-container">
<pre class="src src-shell">$ tree .
<span style="color: #8f0075;">.</span>
&#9500;&#9472;&#9472; dist
&#9474;&#160;&#160; &#9500;&#9472;&#9472; index.js
&#9474;&#160;&#160; &#9492;&#9472;&#9472; types.js
&#9500;&#9472;&#9472; globals.d.ts
&#9500;&#9472;&#9472; index.ts
&#9500;&#9472;&#9472; tsconfig.json
&#9492;&#9472;&#9472; types.ts
</pre>
</div></li>
<li><p>
我们首先在types.ts里面定义了一个interface,并且导出
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">export</span> <span style="color: #531ab6;">interface</span> <span style="color: #005f5f;">User</span> <span style="color: #000000;">{</span>
  id: <span style="color: #531ab6;">number</span>;
  name: <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>
</pre>
</div></li>
<li><p>
globals.d.ts会引入这个interface,并且使用global agument来
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">import</span> <span style="color: #000000;">{</span>User<span style="color: #000000;">}</span> <span style="color: #531ab6;">from</span> <span style="color: #3548cf;">"./types"</span>;

<span style="color: #531ab6;">declare</span> global <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">const</span> <span style="color: #005e8b;">currentUser</span>: <span style="color: #005f5f;">User</span>;
<span style="color: #000000;">}</span>
</pre>
</div></li>
<li><p>
在index里面,我们就可以直接使用这个全局变量了.
</p>
<div class="org-src-container">
<pre class="src src-typescript">globalThis.currentUser = <span style="color: #000000;">{</span>
  id: 1,
  name: <span style="color: #3548cf;">"Alice"</span>,
<span style="color: #000000;">}</span>;

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span><span style="color: #3548cf;">`Current User: </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">currentUser.name</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #000000;">)</span>;
</pre>
</div></li>
<li><p>
依然需要配置tsconfig.json
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #000000;">{</span>
  <span style="color: #3548cf;">"compilerOptions"</span>: <span style="color: #dd22dd;">{</span>
    <span style="color: #3548cf;">"target"</span>: <span style="color: #3548cf;">"ES2020"</span>,
    <span style="color: #3548cf;">"module"</span>: <span style="color: #3548cf;">"CommonJS"</span>,
    <span style="color: #3548cf;">"outDir"</span>: <span style="color: #3548cf;">"./dist"</span>,
    <span style="color: #3548cf;">"strict"</span>: <span style="color: #0000b0;">true</span>,
    <span style="color: #3548cf;">"typeRoots"</span>: <span style="color: #008899;">[</span><span style="color: #3548cf;">"./"</span><span style="color: #008899;">]</span>,
    <span style="color: #3548cf;">"esModuleInterop"</span>: <span style="color: #0000b0;">true</span>
  <span style="color: #dd22dd;">}</span>,
  <span style="color: #3548cf;">"include"</span>: <span style="color: #dd22dd;">[</span><span style="color: #3548cf;">"**/*.ts"</span><span style="color: #dd22dd;">]</span>
<span style="color: #000000;">}</span>
</pre>
</div></li>
<li><p>
在tsc编译之后,我们可以node运行编译好的js文件,如下
</p>
<div class="org-src-container">
<pre class="src src-shell">$ node dist/index.js
Current User: Alice
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgb781da5" class="outline-3">
<h3 id="orgb781da5"><span class="section-number-3">11.3.</span> Built-in Declarations</h3>
<div class="outline-text-3" id="text-11-3">
<ul class="org-ul">
<li>上面的全局变量的配置方法,其实TypeScript自己也在使用,比如Global object(比如Array, Function, Map)等
就不是在你的代码里面声明的,但是你可以使用.</li>
<li>这些Global object是runtime(Node, Deno,浏览器)以全局变量的形式提供的</li>
</ul>
</div>
<div id="outline-container-org48c4dd5" class="outline-4">
<h4 id="org48c4dd5"><span class="section-number-4">11.3.1.</span> Library Declarations</h4>
<div class="outline-text-4" id="text-11-3-1">
<ul class="org-ul">
<li>runtime提供global object的方式是听你刚刚lib files,这些file是命令规则如下:
<ul class="org-ul">
<li>lib.[target].d.ts</li>
<li>其中target是ES标准,比如ES5, ES2020等</li>
</ul></li>
<li><p>
lib file会以TypeScript包的形式分发,比如你可以在下面地址找到lib.es5.d.ts
</p>
<pre class="example" id="orgbf3d20a">
node_modules/typescript/lib/lib.es5.d.ts
</pre></li>
<li>TypeScript默认会包含一个lib flie,比如默认就是es5. 当然你可以通过tsconfig.json进行配置</li>
<li>如果要求比es5高,那么后续的lib文件,比如lib.2015.d.ts, lib.2016.d.ts都会包含.这种文件里面的interfae得
益于interface merging,增加特性比较容易</li>
</ul>
</div>
</div>
<div id="outline-container-org76cc8e4" class="outline-4">
<h4 id="org76cc8e4"><span class="section-number-4">11.3.2.</span> DOM Declarations</h4>
<div class="outline-text-4" id="text-11-3-2">
<ul class="org-ul">
<li>dom相关的declaration file也和TypeScript一同发布,其名字为lib.dom.d.ts</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org754d035" class="outline-3">
<h3 id="org754d035"><span class="section-number-3">11.4.</span> Module Declarations</h3>
<div class="outline-text-3" id="text-11-4">
<ul class="org-ul">
<li>declaration file还可以用来描述shape of module. 使用declare module来命名module,下面是例子的详情
<ul class="org-ul">
<li><p>
首先是整个项目的预览(编译后)
</p>
<div class="org-src-container">
<pre class="src src-shell">$ tree .
<span style="color: #8f0075;">.</span>
&#9500;&#9472;&#9472; dist
&#9474;&#160;&#160; &#9492;&#9472;&#9472; index.js
&#9500;&#9472;&#9472; my-example-lib.js
&#9500;&#9472;&#9472; src
&#9474;&#160;&#160; &#9500;&#9472;&#9472; index.ts
&#9474;&#160;&#160; &#9492;&#9472;&#9472; modules.d.ts
&#9492;&#9472;&#9472; tsconfig.json
</pre>
</div></li>
<li><p>
其次我们使用declare modlule给我们这个文件(modules.d.ts)取一个module名叫做"my-example-lib"
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">declare</span> <span style="color: #531ab6;">module</span> <span style="color: #3548cf;">"my-example-lib"</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">export</span> <span style="color: #531ab6;">const</span> <span style="color: #005e8b;">value</span>: <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>
</pre>
</div></li>
<li><p>
再次,我们其他的文件(index.ts)就可以import这个module名字"my-example-lib"啦
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">import</span> <span style="color: #000000;">{</span> value <span style="color: #000000;">}</span> <span style="color: #531ab6;">from</span> <span style="color: #3548cf;">"my-example-lib"</span>;

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>value<span style="color: #000000;">)</span>;
</pre>
</div></li>
<li><p>
好了,到这里我们就能编译了,而且编译是成功的,但是我们运行就失败了,因为我们的.d.ts里面只有shape没有
实现
</p>
<div class="org-src-container">
<pre class="src src-shell">$ tsc
<span style="color: #000000;">(</span>py3env<span style="color: #000000;">)</span> <span style="color: #000000;">[</span>fenghaoran@shmifenghaoran ~/github/lts/code/ch11/07<span style="color: #000000;">]</span> 19:43:56 <span style="color: #000000;">[</span>proxy_none<span style="color: #000000;">]</span> <span style="color: #000000;">[</span>main !*<span style="color: #000000;">]</span>
$ node dist/index.js
node:internal/modules/cjs/loader:1408
  throw err;
  ^

Error: Cannot find module <span style="color: #3548cf;">'my-example-lib'</span>
Require stack:
- /Users/fenghaoran/github/lts/code/ch11/07/dist/index.js
    at Function._resolveFilename <span style="color: #000000;">(</span>node:internal/modules/cjs/loader:1405:15<span style="color: #000000;">)</span>
    at defaultResolveImpl <span style="color: #000000;">(</span>node:internal/modules/cjs/loader:1061:19<span style="color: #000000;">)</span>
    at resolveForCJSWithHooks <span style="color: #000000;">(</span>node:internal/modules/cjs/loader:1066:22<span style="color: #000000;">)</span>
    at Function._load <span style="color: #000000;">(</span>node:internal/modules/cjs/loader:1215:37<span style="color: #000000;">)</span>
    at TracingChannel.traceSync <span style="color: #000000;">(</span>node:diagnostics_channel:322:14<span style="color: #000000;">)</span>
    at wrapModuleLoad <span style="color: #000000;">(</span>node:internal/modules/cjs/loader:235:24<span style="color: #000000;">)</span>
    at Module.require <span style="color: #000000;">(</span>node:internal/modules/cjs/loader:1491:12<span style="color: #000000;">)</span>
    at require <span style="color: #000000;">(</span>node:internal/modules/helpers:135:16<span style="color: #000000;">)</span>
    at Object.&lt;anonymous&gt; <span style="color: #000000;">(</span>/Users/fenghaoran/github/lts/code/ch11/07/dist/index.js:3:26<span style="color: #000000;">)</span>
    at Module._compile <span style="color: #000000;">(</span>node:internal/modules/cjs/loader:1734:14<span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  code: <span style="color: #3548cf;">'MODULE_NOT_FOUND'</span>,
  requireStack: <span style="color: #dd22dd;">[</span> <span style="color: #3548cf;">'/Users/fenghaoran/github/lts/code/ch11/07/dist/index.js'</span> <span style="color: #dd22dd;">]</span>
<span style="color: #000000;">}</span>

Node.js v23.10.0
</pre>
</div></li>
<li><p>
我们需要在当前文件夹下创建my-example-lib.js然后填写我们.d.ts文件的具体实现
</p>
<div class="org-src-container">
<pre class="src src-javascript">exports.value = <span style="color: #3548cf;">"Hello, Typescript"</span>
</pre>
</div></li>
<li><p>
最后我们调用的时候,需要把my-example-lib.js所在的文件夹加入到NODE_PATH,然后运行,如下
</p>
<div class="org-src-container">
<pre class="src src-shell">$ <span style="color: #005e8b;">NODE_PATH</span>=. node dist/index.js
Hello, Typescript
</pre>
</div></li>
</ul></li>
</ul>
</div>
<div id="outline-container-org0378ab4" class="outline-4">
<h4 id="org0378ab4"><span class="section-number-4">11.4.1.</span> Wildcard Module Declarations</h4>
<div class="outline-text-4" id="text-11-4-1">
<ul class="org-ul">
<li>我们甚至可以通过wildcard来声明一大堆的module
<ul class="org-ul">
<li><p>
示例如下, style.module.css满足*.module.css,就可以使用
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #7f0000;">// </span><span style="color: #7f0000;">styles.d.ts</span>
<span style="color: #531ab6;">declare</span> <span style="color: #531ab6;">module</span> <span style="color: #3548cf;">"*.module.css"</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">const</span> <span style="color: #005e8b;">styles</span>: <span style="color: #dd22dd;">{</span> <span style="color: #008899;">[</span>i: <span style="color: #531ab6;">string</span><span style="color: #008899;">]</span>: <span style="color: #531ab6;">string</span> <span style="color: #dd22dd;">}</span>;
  <span style="color: #531ab6;">export</span> <span style="color: #531ab6;">default</span> styles;
<span style="color: #000000;">}</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">component.ts</span>
<span style="color: #531ab6;">import</span> style <span style="color: #531ab6;">from</span> <span style="color: #3548cf;">"./styles.module.css"</span>;
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org1a72e6d" class="outline-3">
<h3 id="org1a72e6d"><span class="section-number-3">11.5.</span> Package Types</h3>
<div class="outline-text-3" id="text-11-5">
<ul class="org-ul">
<li>前面都是讲的如何在project内部declare typing,下面讲在不同package之间如何使用typing.</li>
<li>TypeScript虽然以TypeScript进行书写,但是发布还是使用JavaScript,为了让JavaScript保留typing特性,这些
JavaScript代码会跟着对应的.d.ts文件</li>
</ul>
</div>
<div id="outline-container-org0204f61" class="outline-4">
<h4 id="org0204f61"><span class="section-number-4">11.5.1.</span> declaration</h4>
<div class="outline-text-4" id="text-11-5-1">
<ul class="org-ul">
<li>TypeScript提供了declaration option来在生成js文件的同时,生成.d.ts文件
<ul class="org-ul">
<li><p>
index.ts文件如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #7f0000;">// </span><span style="color: #7f0000;">index.ts</span>
<span style="color: #531ab6;">export</span> <span style="color: #531ab6;">const</span> <span style="color: #005e8b;">greet</span> = <span style="color: #000000;">(</span><span style="color: #005e8b;">text</span>: <span style="color: #531ab6;">string</span><span style="color: #000000;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #000000;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">`Hello, </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">text</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">!`</span><span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>;
</pre>
</div></li>
<li><p>
配置了declaration, module of "es2015", target 为"es2015"之后,先得到一个js文件
</p>
<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #7f0000;">// </span><span style="color: #7f0000;">index.js</span>
<span style="color: #531ab6;">export</span> <span style="color: #531ab6;">const</span> <span style="color: #005e8b;">greet</span> = <span style="color: #000000;">(</span>text<span style="color: #000000;">)</span> =&gt; <span style="color: #000000;">{</span>
  console.log<span style="color: #dd22dd;">(</span><span style="color: #3548cf;">`Hello, ${text}!`</span><span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>;
</pre>
</div></li>
<li><p>
然后得到一个d.ts文件
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">export</span> <span style="color: #531ab6;">declare</span> <span style="color: #531ab6;">const</span> <span style="color: #005e8b;">greet</span>: <span style="color: #000000;">(</span>text: <span style="color: #531ab6;">string</span><span style="color: #000000;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #531ab6;">void</span>;
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org99d5830" class="outline-4">
<h4 id="org99d5830"><span class="section-number-4">11.5.2.</span> Dependency Package Types</h4>
<div class="outline-text-4" id="text-11-5-2">
<ul class="org-ul">
<li>在project的node_modules里面的.d.ts文件是可以被当前项目中的文件所利用的.这些node_modules里面.d.ts的
效果,相当于在当前project里面写的其他.d.ts文件一样</li>
<li>我们以一个流行的Jest pacakge为例,这个package里面的.d.ts文件直接把describe给声明成了全局变量,所以我们
的TypeScript只要package.json里面包含了jest,那么我们就能直接使用describe,不需要import,示例如下,为了
配置方便,我们这里是一个js的例子,原理是一样的
<ul class="org-ul">
<li><p>
首先创建项目
</p>
<div class="org-src-container">
<pre class="src src-shell">$ npm init -y
&#10265;Wrote to /Users/fenghaoran/github/lts/code/ch11/09/package.json:

<span style="color: #000000;">{</span>
  <span style="color: #3548cf;">"name"</span>: <span style="color: #3548cf;">"09"</span>,
  <span style="color: #3548cf;">"version"</span>: <span style="color: #3548cf;">"1.0.0"</span>,
  <span style="color: #3548cf;">"main"</span>: <span style="color: #3548cf;">"index.js"</span>,
  <span style="color: #3548cf;">"scripts"</span>: <span style="color: #dd22dd;">{</span>
    <span style="color: #3548cf;">"test"</span>: <span style="color: #3548cf;">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span>
  <span style="color: #dd22dd;">}</span>,
  <span style="color: #3548cf;">"keywords"</span>: <span style="color: #dd22dd;">[]</span>,
  <span style="color: #3548cf;">"author"</span>: <span style="color: #3548cf;">""</span>,
  <span style="color: #3548cf;">"license"</span>: <span style="color: #3548cf;">"ISC"</span>,
  <span style="color: #3548cf;">"description"</span>: <span style="color: #3548cf;">""</span>
<span style="color: #000000;">}</span>
</pre>
</div></li>
<li><p>
然后安装且仅安装jest到package.json
</p>
<div class="org-src-container">
<pre class="src src-shell">$ npm install jest --save-dev
</pre>
</div></li>
<li><p>
安装之后package.json内容如下
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #000000;">{</span>
  <span style="color: #3548cf;">"name"</span>: <span style="color: #3548cf;">"09"</span>,
  <span style="color: #3548cf;">"version"</span>: <span style="color: #3548cf;">"1.0.0"</span>,
  <span style="color: #3548cf;">"main"</span>: <span style="color: #3548cf;">"index.js"</span>,
  <span style="color: #3548cf;">"scripts"</span>: <span style="color: #dd22dd;">{</span>
    <span style="color: #3548cf;">"test"</span>: <span style="color: #3548cf;">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span>
  <span style="color: #dd22dd;">}</span>,
  <span style="color: #3548cf;">"keywords"</span>: <span style="color: #dd22dd;">[]</span>,
  <span style="color: #3548cf;">"author"</span>: <span style="color: #3548cf;">""</span>,
  <span style="color: #3548cf;">"license"</span>: <span style="color: #3548cf;">"ISC"</span>,
  <span style="color: #3548cf;">"description"</span>: <span style="color: #3548cf;">""</span>,
  <span style="color: #3548cf;">"devDependencies"</span>: <span style="color: #dd22dd;">{</span>
    <span style="color: #3548cf;">"jest"</span>: <span style="color: #3548cf;">"^29.7.0"</span>
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>
</pre>
</div></li>
<li><p>
我们然后创建我们的测试文件example.test.js,注意文件名必须以test.js结尾
</p>
<div class="org-src-container">
<pre class="src src-js">describe<span style="color: #000000;">(</span><span style="color: #3548cf;">"MyAPI"</span>, <span style="color: #dd22dd;">()</span> =&gt; <span style="color: #dd22dd;">{</span>
  it<span style="color: #008899;">(</span><span style="color: #3548cf;">"works"</span>, <span style="color: #972500;">()</span> =&gt; <span style="color: #972500;">{</span>
    <span style="color: #531ab6;">const</span> <span style="color: #005e8b;">result</span> = <span style="color: #0000b0;">true</span>;
    expect<span style="color: #808000;">(</span>result<span style="color: #808000;">)</span>.toBe<span style="color: #808000;">(</span><span style="color: #0000b0;">true</span><span style="color: #808000;">)</span>;
  <span style="color: #972500;">}</span><span style="color: #008899;">)</span>;
<span style="color: #dd22dd;">}</span><span style="color: #000000;">)</span>;
</pre>
</div></li>
<li><p>
我们可以看到,上面的js文件直接就可以使用describe, it, expect,因为这些变量都通过jest的.d.ts配置到了global
</p>
<div class="org-src-container">
<pre class="src src-shell">$ ag <span style="color: #3548cf;">"const describe"</span>
globals/build/index.d.ts
17:export declare const describe: Global.GlobalAdditions<span style="color: #000000;">[</span><span style="color: #3548cf;">'describe'</span><span style="color: #000000;">]</span>;
$ ag <span style="color: #3548cf;">"const expect"</span>
globals/build/index.d.ts
11:export declare const expect: JestExpect;
</pre>
</div></li>
<li><p>
我们运行之后得到的结果如下
</p>
<div class="org-src-container">
<pre class="src src-shell">$ npx jest
&#10265;Determining test suites to run...

 RUNS  ./example.test.js

 RUNS  ./example.test.js
 PASS  ./example.test.js

 RUNS  ./example.test.js
  MyAPI

 RUNS  ./example.test.js
    &#10003; works <span style="color: #000000;">(</span>1 ms<span style="color: #000000;">)</span>

 RUNS  ./example.test.js


 RUNS  ./example.test.js
Test Suites: 1 passed, 1 total
Tests:       1 passed, 1 total
Snapshots:   0 total
Time:        0.229 s
</pre>
</div></li>
</ul></li>
<li>虽然jest已经如此方便了,但是还是有些情况下,某些项目不想污染全局变量,它想从module里面引入describe,it,
expect.为了应对这种情况,jest又引入了@jest/globals, 使用了这个package,你就可以像普通变量一样引入describe了
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">import</span> <span style="color: #000000;">{</span> describe, it, expect <span style="color: #000000;">}</span> <span style="color: #531ab6;">from</span> <span style="color: #3548cf;">'@jest/globals'</span>;

<span style="color: #721045;">describe</span><span style="color: #000000;">(</span><span style="color: #3548cf;">'Example Test Suite'</span>, <span style="color: #dd22dd;">()</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #dd22dd;">{</span>
  <span style="color: #721045;">it</span><span style="color: #008899;">(</span><span style="color: #3548cf;">'should return true'</span>, <span style="color: #972500;">()</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #972500;">{</span>
    <span style="color: #531ab6;">const</span> <span style="color: #005e8b;">result</span> = <span style="color: #0000b0;">true</span>;
    <span style="color: #721045;">expect</span><span style="color: #808000;">(</span>result<span style="color: #808000;">)</span>.<span style="color: #721045;">toBe</span><span style="color: #808000;">(</span><span style="color: #0000b0;">true</span><span style="color: #808000;">)</span>;
  <span style="color: #972500;">}</span><span style="color: #008899;">)</span>;
<span style="color: #dd22dd;">}</span><span style="color: #000000;">)</span>;
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org02c0115" class="outline-4">
<h4 id="org02c0115"><span class="section-number-4">11.5.3.</span> Exposing Package Types</h4>
<div class="outline-text-4" id="text-11-5-3">
<ul class="org-ul">
<li>如果你的项目希望在npm发布,并且提供types给用户,那么需要在package.json里面添加types field
<ul class="org-ul">
<li><p>
package.json的示例如下
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #000000;">{</span>
  <span style="color: #3548cf;">"author"</span>: <span style="color: #3548cf;">"Eendant Publishing"</span>,
  <span style="color: #3548cf;">"main"</span>: <span style="color: #3548cf;">"./lib/index.js"</span>,
  <span style="color: #3548cf;">"name"</span>: <span style="color: #3548cf;">"coffeetable"</span>,
  <span style="color: #3548cf;">"types"</span>: <span style="color: #3548cf;">"./lib/index.d.ts"</span>,
  <span style="color: #3548cf;">"version"</span>: <span style="color: #3548cf;">"0.5.22"</span>
<span style="color: #000000;">}</span>
</pre>
</div></li>
<li>如果没有指定types field,那么TypeScript会默认使用./index.d.ts作为types,就像mai会默认为./index.js
一样</li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgaf50596" class="outline-3">
<h3 id="orgaf50596"><span class="section-number-3">11.6.</span> Definitely Typed</h3>
<div class="outline-text-3" id="text-11-6">
<ul class="org-ul">
<li>社区里面不是所有的项目都是以TypeScript书写的,但是我们的TypeScript却需要被告知这些JavaScript项目的
类型信息.</li>
<li>为了解决这个问题,TypeScript Team创建了一个叫做DefinitelyTyped的项目来跟踪这些JavaScript项目,并且为
他们提供.d.ts文件</li>
<li><p>
DefinitelyTyped项目在npm上面是以@types开头的,另外会加上"/js-package-name",比如下面就是react(著名的
使用JavaScript的npm项目)的DefinitelyTyped名字
</p>
<pre class="example" id="org6ca9ae1">
@types/react
</pre></li>
<li>注意,不同的情况下要使用不同的npm install参数来安装@types的.d.ts
<ul class="org-ul">
<li>如果你需要把你的包再发布到npm,或者给被人用,那么你需要使用&#x2013;save来保存</li>
<li>如果你的项目就是本地运行的,不需要作为其他人的lib,那么你只需要&#x2013;saveDev就可以了,这样,types只是作为
development-time的工具</li>
</ul></li>
</ul>
</div>
<div id="outline-container-org20bccf9" class="outline-4">
<h4 id="org20bccf9"><span class="section-number-4">11.6.1.</span> Type Availability</h4>
<div class="outline-text-4" id="text-11-6-1">
<ul class="org-ul">
<li>绝大多数流行的JavaScript package(没有用TypeScript编写的)都已经在DefinitelyTyped项目里面了</li>
<li>如果你使用的JavaScript package恰巧没有DefinitelyTyped,你有如下三种选择:
<ul class="org-ul">
<li>给DefinitelyTyped发pull request(最为推荐)</li>
<li>自己在package内吧使用declare module来引入</li>
<li>让TypeScript在判断不出来的情况下设置类型为any来工作(最为不推荐)</li>
</ul></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org10583e9" class="outline-2">
<h2 id="org10583e9"><span class="section-number-2">12.</span> Chapter 12: Using IDE Features</h2>
<div class="outline-text-2" id="text-12">
</div>
<div id="outline-container-org12dda2a" class="outline-3">
<h3 id="org12dda2a"><span class="section-number-3">12.1.</span> Navigating Code</h3>
<div class="outline-text-3" id="text-12-1">
<ul class="org-ul">
<li>程序员读代码的时间要远超过写代码的时间, TypeScript的language service便于我们在type definition和value之间跳转</li>
</ul>
</div>
<div id="outline-container-org0cac4db" class="outline-4">
<h4 id="org0cac4db"><span class="section-number-4">12.1.1.</span> Finding Definitions</h4>
<div class="outline-text-4" id="text-12-1-1">
<ul class="org-ul">
<li>Go to Definition就是找到变量定义或初始化的地方</li>
<li>Go to Type Definition就是找到某个instance的interfae或者class的定义地址,如果不是interface或者class的
instance,则会报"未找到"</li>
</ul>
</div>
</div>
<div id="outline-container-orgccdb54f" class="outline-4">
<h4 id="orgccdb54f"><span class="section-number-4">12.1.2.</span> Finding References</h4>
<div class="outline-text-4" id="text-12-1-2">
<ul class="org-ul">
<li>对于高压type definition或者value, find references会找到所有使用它的地方.</li>
</ul>
</div>
</div>
<div id="outline-container-org4ddf0b9" class="outline-4">
<h4 id="org4ddf0b9"><span class="section-number-4">12.1.3.</span> Finding Implementations</h4>
<div class="outline-text-4" id="text-12-1-3">
<ul class="org-ul">
<li>find implementation会找到某个class或者interface所有的实现</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org9953ece" class="outline-3">
<h3 id="org9953ece"><span class="section-number-3">12.2.</span> Writing Code</h3>
<div class="outline-text-3" id="text-12-2">
</div>
<div id="outline-container-orgf66ee67" class="outline-4">
<h4 id="orgf66ee67"><span class="section-number-4">12.2.1.</span> Completing Names</h4>
<div class="outline-text-4" id="text-12-2-1">
<ul class="org-ul">
<li>也就是自动补全啦,IDE常规操作</li>
</ul>
</div>
</div>
<div id="outline-container-orgaebd732" class="outline-4">
<h4 id="orgaebd732"><span class="section-number-4">12.2.2.</span> Automatic Import Updates</h4>
<div class="outline-text-4" id="text-12-2-2">
<ul class="org-ul">
<li>TypeScript内部都是相互import的,如果普通的更改文件位置则意味着非常复杂的import更改工作</li>
<li>在VS Code的file explorer进行更改文件的文件夹操作,会触发自动的import更新</li>
</ul>
</div>
</div>
<div id="outline-container-orgfec7b97" class="outline-4">
<h4 id="orgfec7b97"><span class="section-number-4">12.2.3.</span> Code Actions</h4>
<div class="outline-text-4" id="text-12-2-3">
<ul class="org-ul">
<li>使用IDE功能进行重命名等操作,IDE会自动改写需要改写的地方</li>
<li>还可以移除未使用的代码</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgf495460" class="outline-3">
<h3 id="orgf495460"><span class="section-number-3">12.3.</span> Working Effectively with Errors</h3>
<div class="outline-text-3" id="text-12-3">
</div>
<div id="outline-container-org2449cc1" class="outline-4">
<h4 id="org2449cc1"><span class="section-number-4">12.3.1.</span> Language Service Errors</h4>
<div class="outline-text-4" id="text-12-3-1">
<ul class="org-ul">
<li>在VS Code里面,错误会以红色下划线标记,把鼠标移上去会得到详细的提示</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-orga44f5a8" class="outline-2">
<h2 id="orga44f5a8"><span class="section-number-2">13.</span> Chapter 13: Configuration Options</h2>
<div class="outline-text-2" id="text-13">
<ul class="org-ul">
<li>TypeScript的config信息多达上百个,可以通过如下两种方式提供:
<ul class="org-ul">
<li>通过命令行参数传递给tsc</li>
<li>通过tsconfg.json配置文件配置</li>
</ul></li>
</ul>
</div>
<div id="outline-container-orgce57f6b" class="outline-3">
<h3 id="orgce57f6b"><span class="section-number-3">13.1.</span> tsc Options</h3>
<div class="outline-text-3" id="text-13-1">
<ul class="org-ul">
<li>tsc command后面跟的&#x2013;flag,就是最常见的配置方式了,比如我们想运行一个ts文件(而不产生js文件),注意这个
运行是只进行type check,而不是说运行ts代码(ts代码必须转成js运行),那么我们需要&#x2013;noEmit flag
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-shell">$ tree .
<span style="color: #8f0075;">.</span>
&#9492;&#9472;&#9472; index.ts

1 directory, 1 file
<span style="color: #000000;">(</span>py3env<span style="color: #000000;">)</span> <span style="color: #000000;">[</span>fenghaoran@shmifenghaoran ~/github/lts/code/ch13/01<span style="color: #000000;">]</span> 11:37:22 <span style="color: #000000;">[</span>proxy_none<span style="color: #000000;">]</span> <span style="color: #000000;">[</span>main !?<span style="color: #000000;">]</span>
$ tsc index.ts
<span style="color: #000000;">(</span>py3env<span style="color: #000000;">)</span> <span style="color: #000000;">[</span>fenghaoran@shmifenghaoran ~/github/lts/code/ch13/01<span style="color: #000000;">]</span> 11:37:27 <span style="color: #000000;">[</span>proxy_none<span style="color: #000000;">]</span> <span style="color: #000000;">[</span>main !?<span style="color: #000000;">]</span>
$ tree .
<span style="color: #8f0075;">.</span>
&#9500;&#9472;&#9472; index.js
&#9492;&#9472;&#9472; index.ts

1 directory, 2 files
<span style="color: #000000;">(</span>py3env<span style="color: #000000;">)</span> <span style="color: #000000;">[</span>fenghaoran@shmifenghaoran ~/github/lts/code/ch13/01<span style="color: #000000;">]</span> 11:37:29 <span style="color: #000000;">[</span>proxy_none<span style="color: #000000;">]</span> <span style="color: #000000;">[</span>main !?<span style="color: #000000;">]</span>
$ rm index.js
<span style="color: #000000;">(</span>py3env<span style="color: #000000;">)</span> <span style="color: #000000;">[</span>fenghaoran@shmifenghaoran ~/github/lts/code/ch13/01<span style="color: #000000;">]</span> 11:37:34 <span style="color: #000000;">[</span>proxy_none<span style="color: #000000;">]</span> <span style="color: #000000;">[</span>main !?<span style="color: #000000;">]</span>
$ tree .
<span style="color: #8f0075;">.</span>
&#9492;&#9472;&#9472; index.ts

1 directory, 1 file
<span style="color: #000000;">(</span>py3env<span style="color: #000000;">)</span> <span style="color: #000000;">[</span>fenghaoran@shmifenghaoran ~/github/lts/code/ch13/01<span style="color: #000000;">]</span> 11:37:37 <span style="color: #000000;">[</span>proxy_none<span style="color: #000000;">]</span> <span style="color: #000000;">[</span>main !?<span style="color: #000000;">]</span>
$ tsc index.ts --noEmit
<span style="color: #000000;">(</span>py3env<span style="color: #000000;">)</span> <span style="color: #000000;">[</span>fenghaoran@shmifenghaoran ~/github/lts/code/ch13/01<span style="color: #000000;">]</span> 11:37:44 <span style="color: #000000;">[</span>proxy_none<span style="color: #000000;">]</span> <span style="color: #000000;">[</span>main !?<span style="color: #000000;">]</span>
$ tree .
<span style="color: #8f0075;">.</span>
&#9492;&#9472;&#9472; index.ts

1 directory, 1 file
</pre>
</div></li>
</ul></li>
</ul>
</div>
<div id="outline-container-orgf0d58b3" class="outline-4">
<h4 id="orgf0d58b3"><span class="section-number-4">13.1.1.</span> Pretty Mode</h4>
<div class="outline-text-4" id="text-13-1-1">
<ul class="org-ul">
<li>默认情况下, tsc的输出是默认为pretty mode的(带颜色,且精美输出错误)
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-shell">$ tsc index.ts
index.ts:1:5 - error TS2322: Type <span style="color: #3548cf;">'string'</span> is not assignable to type <span style="color: #3548cf;">'number'</span>.

1 let notNumber: number = <span style="color: #3548cf;">"Global"</span>;
      ~~~~~~~~~


Found 1 error<span style="color: #531ab6;"> in</span> index.ts:1
</pre>
</div></li>
</ul></li>
<li>如果不需要颜色,且希望更精简浓缩的输出,那么请设置&#x2013;pretty为false
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-shell">$ tsc index.ts --pretty false
<span style="color: #721045;">index.ts</span><span style="color: #000000;">(</span>1,5<span style="color: #000000;">)</span>: error TS2322: Type <span style="color: #3548cf;">'string'</span> is not assignable to type <span style="color: #3548cf;">'number'</span>.
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org8a83384" class="outline-4">
<h4 id="org8a83384"><span class="section-number-4">13.1.2.</span> Watch Mode</h4>
<div class="outline-text-4" id="text-13-1-2">
<ul class="org-ul">
<li>我们可以配置tsc cli为watch mode(通过-w/&#x2013;watch参数)
<ul class="org-ul">
<li><p>
示例一开始,配置watch后,当前有错误. 且命令行一直在运行,不会退出
</p>
<div class="org-src-container">
<pre class="src src-shell">$ tsc index.ts --watch
<span style="color: #000000;">[</span>2:17:55 PM<span style="color: #000000;">]</span> Starting compilation<span style="color: #531ab6;"> in</span> watch mode...

index.ts:1:5 - error TS2322: Type <span style="color: #3548cf;">'string'</span> is not assignable to type <span style="color: #3548cf;">'number'</span>.

1 let notNumber: number = <span style="color: #3548cf;">"Global"</span>;
      ~~~~~~~~~

<span style="color: #000000;">[</span>2:17:56 PM<span style="color: #000000;">]</span> Found 1 error. Watching for file changes.
</pre>
</div></li>
<li><p>
我们在更正文件之后,上述运行的shell session会自动检测到更新,并且告知用户当前文件不再存在错误
</p>
<div class="org-src-container">
<pre class="src src-shell"><span style="color: #000000;">[</span>2:19:45 PM<span style="color: #000000;">]</span> File change detected. Starting incremental compilation...

<span style="color: #000000;">[</span>2:19:46 PM<span style="color: #000000;">]</span> Found 0 errors. Watching for file changes.
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org8113af1" class="outline-3">
<h3 id="org8113af1"><span class="section-number-3">13.2.</span> TSConfig Files</h3>
<div class="outline-text-3" id="text-13-2">
<ul class="org-ul">
<li>绝大部分的配置是不太可能全部设置在命令行里面的,取而代之的,是在tsconfig.json文件里面配置各种option</li>
<li>包含tsconfig.json的文件夹会被认为是TypeScript项目的root文件夹,在这个文件夹运行tsc是会读取
tsconfig.json中所有的参数的</li>
<li>如果tsconfig.json在其他文件位置,那么需要使用-p/&#x2013;project进行指定
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-shell">tsc -p path/to/tsconfig.json
</pre>
</div></li>
</ul></li>
</ul>
</div>
<div id="outline-container-org7f78b30" class="outline-4">
<h4 id="org7f78b30"><span class="section-number-4">13.2.1.</span> tsc &#x2013;init</h4>
<div class="outline-text-4" id="text-13-2-1">
<ul class="org-ul">
<li>我们可以使用tsc &#x2013;init来生成默认的tsconfig.json文件,并且这个文件里面的配置是官方推荐的,且每个配置
有简短的介绍.这也是官方最推荐的创建tsconfig.json文件的方式
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-shell">$ tsc --init

Created a new tsconfig.json with:
                                                                                                                     TS
  target: es2016
  module: commonjs
  strict: true
  esModuleInterop: true
  skipLibCheck: true
  forceConsistentCasingInFileNames: true


You can learn more at https://aka.ms/tsconfig
</pre>
</div></li>
<li><p>
文件内容如下
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #000000;">{</span>
  <span style="color: #3548cf;">"compilerOptions"</span>: <span style="color: #dd22dd;">{</span>
    <span style="color: #7f0000;">/* </span><span style="color: #7f0000;">Visit https://aka.ms/tsconfig to read more about this file</span><span style="color: #7f0000;"> */</span>

    <span style="color: #7f0000;">/* </span><span style="color: #7f0000;">Projects</span><span style="color: #7f0000;"> */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"incremental": true,                              /* Save .tsbuildinfo files to allow for incremental compilation of projects. */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"composite": true,                                /* Enable constraints that allow a TypeScript project to be used with project references. */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"tsBuildInfoFile": "./.tsbuildinfo",              /* Specify the path to .tsbuildinfo incremental compilation file. */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"disableSourceOfProjectReferenceRedirect": true,  /* Disable preferring source files instead of declaration files when referencing composite projects. */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"disableSolutionSearching": true,                 /* Opt a project out of multi-project reference checking when editing. */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"disableReferencedProjectLoad": true,             /* Reduce the number of projects loaded automatically by TypeScript. */</span>

    <span style="color: #7f0000;">/* </span><span style="color: #7f0000;">Language and Environment</span><span style="color: #7f0000;"> */</span>
    <span style="color: #3548cf;">"target"</span>: <span style="color: #3548cf;">"es2016"</span>,                                  <span style="color: #7f0000;">/* </span><span style="color: #7f0000;">Set the JavaScript language version for emitted JavaScript and include compatible library declarations.</span><span style="color: #7f0000;"> */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"lib": [],                                        /* Specify a set of bundled library declaration files that describe the target runtime environment. */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"jsx": "preserve",                                /* Specify what JSX code is generated. */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"experimentalDecorators": true,                   /* Enable experimental support for legacy experimental decorators. */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"emitDecoratorMetadata": true,                    /* Emit design-type metadata for decorated declarations in source files. */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"jsxFactory": "",                                 /* Specify the JSX factory function used when targeting React JSX emit, e.g. 'React.createElement' or 'h'. */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"jsxFragmentFactory": "",                         /* Specify the JSX Fragment reference used for fragments when targeting React JSX emit e.g. 'React.Fragment' or 'Fragment'. */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"jsxImportSource": "",                            /* Specify module specifier used to import the JSX factory functions when using 'jsx: react-jsx*'. */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"reactNamespace": "",                             /* Specify the object invoked for 'createElement'. This only applies when targeting 'react' JSX emit. */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"noLib": true,                                    /* Disable including any library files, including the default lib.d.ts. */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"useDefineForClassFields": true,                  /* Emit ECMAScript-standard-compliant class fields. */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"moduleDetection": "auto",                        /* Control what method is used to detect module-format JS files. */</span>

    <span style="color: #7f0000;">/* </span><span style="color: #7f0000;">Modules</span><span style="color: #7f0000;"> */</span>
    <span style="color: #3548cf;">"module"</span>: <span style="color: #3548cf;">"commonjs"</span>,                                <span style="color: #7f0000;">/* </span><span style="color: #7f0000;">Specify what module code is generated.</span><span style="color: #7f0000;"> */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"rootDir": "./",                                  /* Specify the root folder within your source files. */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"moduleResolution": "node10",                     /* Specify how TypeScript looks up a file from a given module specifier. */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"baseUrl": "./",                                  /* Specify the base directory to resolve non-relative module names. */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"paths": {},                                      /* Specify a set of entries that re-map imports to additional lookup locations. */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"rootDirs": [],                                   /* Allow multiple folders to be treated as one when resolving modules. */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"typeRoots": [],                                  /* Specify multiple folders that act like './node_modules/@types'. */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"types": [],                                      /* Specify type package names to be included without being referenced in a source file. */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"allowUmdGlobalAccess": true,                     /* Allow accessing UMD globals from modules. */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"moduleSuffixes": [],                             /* List of file name suffixes to search when resolving a module. */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"allowImportingTsExtensions": true,               /* Allow imports to include TypeScript file extensions. Requires '--moduleResolution bundler' and either '--noEmit' or '--emitDeclarationOnly' to be set. */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"rewriteRelativeImportExtensions": true,          /* Rewrite '.ts', '.tsx', '.mts', and '.cts' file extensions in relative import paths to their JavaScript equivalent in output files. */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"resolvePackageJsonExports": true,                /* Use the package.json 'exports' field when resolving package imports. */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"resolvePackageJsonImports": true,                /* Use the package.json 'imports' field when resolving imports. */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"customConditions": [],                           /* Conditions to set in addition to the resolver-specific defaults when resolving imports. */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"noUncheckedSideEffectImports": true,             /* Check side effect imports. */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"resolveJsonModule": true,                        /* Enable importing .json files. */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"allowArbitraryExtensions": true,                 /* Enable importing files with any extension, provided a declaration file is present. */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"noResolve": true,                                /* Disallow 'import's, 'require's or '&lt;reference&gt;'s from expanding the number of files TypeScript should add to a project. */</span>

    <span style="color: #7f0000;">/* </span><span style="color: #7f0000;">JavaScript Support</span><span style="color: #7f0000;"> */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"allowJs": true,                                  /* Allow JavaScript files to be a part of your program. Use the 'checkJS' option to get errors from these files. */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"checkJs": true,                                  /* Enable error reporting in type-checked JavaScript files. */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"maxNodeModuleJsDepth": 1,                        /* Specify the maximum folder depth used for checking JavaScript files from 'node_modules'. Only applicable with 'allowJs'. */</span>

    <span style="color: #7f0000;">/* </span><span style="color: #7f0000;">Emit</span><span style="color: #7f0000;"> */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"declaration": true,                              /* Generate .d.ts files from TypeScript and JavaScript files in your project. */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"declarationMap": true,                           /* Create sourcemaps for d.ts files. */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"emitDeclarationOnly": true,                      /* Only output d.ts files and not JavaScript files. */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"sourceMap": true,                                /* Create source map files for emitted JavaScript files. */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"inlineSourceMap": true,                          /* Include sourcemap files inside the emitted JavaScript. */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"noEmit": true,                                   /* Disable emitting files from a compilation. */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"outFile": "./",                                  /* Specify a file that bundles all outputs into one JavaScript file. If 'declaration' is true, also designates a file that bundles all .d.ts output. */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"outDir": "./",                                   /* Specify an output folder for all emitted files. */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"removeComments": true,                           /* Disable emitting comments. */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"importHelpers": true,                            /* Allow importing helper functions from tslib once per project, instead of including them per-file. */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"downlevelIteration": true,                       /* Emit more compliant, but verbose and less performant JavaScript for iteration. */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"sourceRoot": "",                                 /* Specify the root path for debuggers to find the reference source code. */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"mapRoot": "",                                    /* Specify the location where debugger should locate map files instead of generated locations. */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"inlineSources": true,                            /* Include source code in the sourcemaps inside the emitted JavaScript. */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"emitBOM": true,                                  /* Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files. */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"newLine": "crlf",                                /* Set the newline character for emitting files. */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"stripInternal": true,                            /* Disable emitting declarations that have '@internal' in their JSDoc comments. */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"noEmitHelpers": true,                            /* Disable generating custom helper functions like '__extends' in compiled output. */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"noEmitOnError": true,                            /* Disable emitting files if any type checking errors are reported. */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"preserveConstEnums": true,                       /* Disable erasing 'const enum' declarations in generated code. */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"declarationDir": "./",                           /* Specify the output directory for generated declaration files. */</span>

    <span style="color: #7f0000;">/* </span><span style="color: #7f0000;">Interop Constraints</span><span style="color: #7f0000;"> */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"isolatedModules": true,                          /* Ensure that each file can be safely transpiled without relying on other imports. */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"verbatimModuleSyntax": true,                     /* Do not transform or elide any imports or exports not marked as type-only, ensuring they are written in the output file's format based on the 'module' setting. */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"isolatedDeclarations": true,                     /* Require sufficient annotation on exports so other tools can trivially generate declaration files. */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"allowSyntheticDefaultImports": true,             /* Allow 'import x from y' when a module doesn't have a default export. */</span>
    <span style="color: #3548cf;">"esModuleInterop"</span>: <span style="color: #0000b0;">true</span>,                             <span style="color: #7f0000;">/* </span><span style="color: #7f0000;">Emit additional JavaScript to ease support for importing CommonJS modules. This enables 'allowSyntheticDefaultImports' for type compatibility.</span><span style="color: #7f0000;"> */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"preserveSymlinks": true,                         /* Disable resolving symlinks to their realpath. This correlates to the same flag in node. */</span>
    <span style="color: #3548cf;">"forceConsistentCasingInFileNames"</span>: <span style="color: #0000b0;">true</span>,            <span style="color: #7f0000;">/* </span><span style="color: #7f0000;">Ensure that casing is correct in imports.</span><span style="color: #7f0000;"> */</span>

    <span style="color: #7f0000;">/* </span><span style="color: #7f0000;">Type Checking</span><span style="color: #7f0000;"> */</span>
    <span style="color: #3548cf;">"strict"</span>: <span style="color: #0000b0;">true</span>,                                      <span style="color: #7f0000;">/* </span><span style="color: #7f0000;">Enable all strict type-checking options.</span><span style="color: #7f0000;"> */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"noImplicitAny": true,                            /* Enable error reporting for expressions and declarations with an implied 'any' type. */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"strictNullChecks": true,                         /* When type checking, take into account 'null' and 'undefined'. */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"strictFunctionTypes": true,                      /* When assigning functions, check to ensure parameters and the return values are subtype-compatible. */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"strictBindCallApply": true,                      /* Check that the arguments for 'bind', 'call', and 'apply' methods match the original function. */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"strictPropertyInitialization": true,             /* Check for class properties that are declared but not set in the constructor. */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"strictBuiltinIteratorReturn": true,              /* Built-in iterators are instantiated with a 'TReturn' type of 'undefined' instead of 'any'. */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"noImplicitThis": true,                           /* Enable error reporting when 'this' is given the type 'any'. */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"useUnknownInCatchVariables": true,               /* Default catch clause variables as 'unknown' instead of 'any'. */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"alwaysStrict": true,                             /* Ensure 'use strict' is always emitted. */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"noUnusedLocals": true,                           /* Enable error reporting when local variables aren't read. */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"noUnusedParameters": true,                       /* Raise an error when a function parameter isn't read. */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"exactOptionalPropertyTypes": true,               /* Interpret optional property types as written, rather than adding 'undefined'. */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"noImplicitReturns": true,                        /* Enable error reporting for codepaths that do not explicitly return in a function. */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"noFallthroughCasesInSwitch": true,               /* Enable error reporting for fallthrough cases in switch statements. */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"noUncheckedIndexedAccess": true,                 /* Add 'undefined' to a type when accessed using an index. */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"noImplicitOverride": true,                       /* Ensure overriding members in derived classes are marked with an override modifier. */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"noPropertyAccessFromIndexSignature": true,       /* Enforces using indexed accessors for keys declared using an indexed type. */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"allowUnusedLabels": true,                        /* Disable error reporting for unused labels. */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"allowUnreachableCode": true,                     /* Disable error reporting for unreachable code. */</span>

    <span style="color: #7f0000;">/* </span><span style="color: #7f0000;">Completeness</span><span style="color: #7f0000;"> */</span>
    <span style="color: #7f0000;">// </span><span style="color: #7f0000;">"skipDefaultLibCheck": true,                      /* Skip type checking .d.ts files that are included with TypeScript. */</span>
    <span style="color: #3548cf;">"skipLibCheck"</span>: <span style="color: #0000b0;">true</span>                                 <span style="color: #7f0000;">/* </span><span style="color: #7f0000;">Skip type checking all .d.ts files.</span><span style="color: #7f0000;"> */</span>
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgdf81186" class="outline-4">
<h4 id="orgdf81186"><span class="section-number-4">13.2.2.</span> CLI Versus Configuration</h4>
<div class="outline-text-4" id="text-13-2-2">
<ul class="org-ul">
<li>cli和tsconfig.json文件同时配置的情况下,且配置不同的情况下,cli的优先级更高.但是由于IDE主要从tsconfig.josn
读取配置,所以在tsconfig.json配置是更被作者推荐的做法</li>
<li>所有的option分成三类:
<ul class="org-ul">
<li>Compiler: 用来定义文件如何被Type进行check.这些option同时存在于cli和tsconfig.json</li>
<li>File: 用来定义哪些文件被TypeScript check,哪些不需要被check.这些option也同时存在于cli和tsconfig.json</li>
<li>Misc: 其他一些关于project preference的配置,只存在于tsconfig.json</li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgf7f52ae" class="outline-3">
<h3 id="orgf7f52ae"><span class="section-number-3">13.3.</span> File Inclusions</h3>
<div class="outline-text-3" id="text-13-3">
<ul class="org-ul">
<li>默认情况下,当前文件夹的所有.ts文件(nonhidden的)都会被TypeScript check(甚至是node_modules里面的),所
以我们需要进行配置,以缩小我们的check的文件范围</li>
</ul>
</div>
<div id="outline-container-orgecf1ac0" class="outline-4">
<h4 id="orgecf1ac0"><span class="section-number-4">13.3.1.</span> include</h4>
<div class="outline-text-4" id="text-13-3-1">
<ul class="org-ul">
<li>最常见的是include option,用来确认哪些文件或者文件夹需要被check,其配置有如下扩展:
<ul class="org-ul">
<li>`*` 匹配一个或者多个character</li>
<li>`?` 匹配一个character</li>
<li>`**/` 匹配任意的nested的directory</li>
</ul></li>
<li>下面就是两个include 例子
<ul class="org-ul">
<li><p>
一个比较复杂的例子,明确check typing文件夹下面所有d.ts文件和src下面最少两个charactor的带扩展的文件
</p>
<div class="org-src-container">
<pre class="src src-json"><span style="color: #000000;">{</span>
  <span style="color: #531ab6;">"include"</span>: <span style="color: #dd22dd;">[</span><span style="color: #3548cf;">"typings/**/*.d.ts"</span>, <span style="color: #3548cf;">"src/**/*??.*"</span><span style="color: #dd22dd;">]</span>
<span style="color: #000000;">}</span>
</pre>
</div></li>
<li><p>
其实日常工作当中,绝大部分的项目一般只需要监控src文件夹即可
</p>
<div class="org-src-container">
<pre class="src src-json"><span style="color: #000000;">{</span>
  <span style="color: #531ab6;">"include"</span>: <span style="color: #dd22dd;">[</span><span style="color: #3548cf;">"src"</span><span style="color: #dd22dd;">]</span>
<span style="color: #000000;">}</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org6ae1e2b" class="outline-4">
<h4 id="org6ae1e2b"><span class="section-number-4">13.3.2.</span> exclude</h4>
<div class="outline-text-4" id="text-13-3-2">
<ul class="org-ul">
<li>exclude是从include的"初始文件列表"中移除文件.请注意这段话"初始文件列表",也就是说exclude的能力也只是
如此.即便一个文件从"初始文件列表"里面移除了这个文件,如果include的文件里面一旦import了这个文件,那么
TypeScript还是要check的.所以如果想完全完全规避被TypeScript check那么你要保证:
<ul class="org-ul">
<li>这个文件不在include中(或者被exclude)</li>
<li>这个文件也没有被其他文件引用.</li>
</ul></li>
<li>我们来看一个例子来列举下虽然被exclude了,但是还是被TypeScript check的情况
<ul class="org-ul">
<li><p>
首先看整体的文件结构
</p>
<pre class="example" id="org480dd30">
project/
├── src/
│   ├── index.ts
│   ├── app.ts
│   ├── tests/
│   │   ├── test1.ts
│   │   └── test2.ts
│   ├── legacy/
│   │   └── oldCode.ts
│   └── utils/
│       └── helper.ts
├── dist/
</pre></li>
<li><p>
tsconfig.json的配置如下,include了所有src文件,但是exclue了src下的tests和legacy文件夹
</p>
<div class="org-src-container">
<pre class="src src-json"><span style="color: #000000;">{</span>
  <span style="color: #531ab6;">"compilerOptions"</span>: <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">"outDir"</span>: <span style="color: #3548cf;">"./dist"</span>,
    <span style="color: #531ab6;">"module"</span>: <span style="color: #3548cf;">"commonjs"</span>,
    <span style="color: #531ab6;">"target"</span>: <span style="color: #3548cf;">"es6"</span>,
    <span style="color: #531ab6;">"strict"</span>: <span style="color: #0000b0;">true</span>
  <span style="color: #dd22dd;">}</span>,
  <span style="color: #531ab6;">"include"</span>: <span style="color: #dd22dd;">[</span><span style="color: #3548cf;">"src/**/*"</span><span style="color: #dd22dd;">]</span>,
  <span style="color: #531ab6;">"exclude"</span>: <span style="color: #dd22dd;">[</span><span style="color: #3548cf;">"src/tests/**/*"</span>, <span style="color: #3548cf;">"src/legacy/**/*"</span><span style="color: #dd22dd;">]</span>
<span style="color: #000000;">}</span>
</pre>
</div></li>
<li>那么include的"初始文件列表"有
<ol class="org-ol">
<li>index.ts</li>
<li>app.ts</li>
<li>tests/test1.ts</li>
<li>tests/test2.ts</li>
<li>legacy/oldCode.ts</li>
<li>utils/helper.ts</li>
</ol></li>
<li>经过exclude将相应文件从"初始文件列表"剔除后得到最终的被check的文件:
<ol class="org-ol">
<li>index.ts</li>
<li>app.ts</li>
<li>utils/helper.ts</li>
</ol></li>
<li><p>
但是如果index.ts文件里面导入了test1, 如下,那么test1.ts还是会被check
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">import</span> <span style="color: #000000;">{</span> test <span style="color: #000000;">}</span> <span style="color: #531ab6;">from</span> <span style="color: #3548cf;">"./tests/test1"</span>;
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org025f22c" class="outline-3">
<h3 id="org025f22c"><span class="section-number-3">13.4.</span> Alternative Extensions</h3>
<div class="outline-text-3" id="text-13-4">
<ul class="org-ul">
<li>本来TypeScript只是希望处理ts为扩展名的文件,但是随着时代的发展,有些其他扩展名也需要被check</li>
</ul>
</div>
<div id="outline-container-org3fc4abd" class="outline-4">
<h4 id="org3fc4abd"><span class="section-number-4">13.4.1.</span> JSX Syntax</h4>
<div class="outline-text-4" id="text-13-4-1">
<ul class="org-ul">
<li>JSX syntax其实不是JavaScript,是类似&lt;Component /&gt;这样的UI库,它其实也是和TypeScript一样最终被编译成JavaScript来使用.</li>
<li>为了能够在你的项目里面识别JSX syntax,你需要:
<ul class="org-ul">
<li>在配置文件里面enable jsx配置. 有三种jsx的值,可根据情况选择
<ol class="org-ol">
<li>&#x2013;jsx preserve</li>
<li>&#x2013;jsx react</li>
<li>&#x2013;jsx react-native</li>
</ol></li>
<li>把你包裹JSX syntax的文件的扩展名改成tsx</li>
</ul></li>
<li>一般情况下,也不用太担心,因为使用JSX的项目比如Next.js, Remix都会自己帮你通过脚手架来配置好JSX支持.</li>
<li>前面说了,typescript的泛型和jsx syntax相冲突,示例如下:
<ul class="org-ul">
<li><p>
在一个tsx文件里面写&lt;T&gt;
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">identity</span> = &lt;T&gt;<span style="color: #000000;">(</span>input: T<span style="color: #000000;">)</span> <span style="color: #531ab6;">=&gt;</span> input;
</pre>
</div></li>
<li><p>
上面的文件会报错,如下
</p>
<div class="org-src-container">
<pre class="src src-shell">$ tsc
index.tsx:1:19 - error TS17008: JSX element <span style="color: #3548cf;">'T'</span> has no corresponding closing tag.

1 const identity = &lt;T&gt;<span style="color: #000000;">(</span>input: T<span style="color: #000000;">)</span> =&gt; input;
                    ~

index.tsx:1:33 - error TS1382: Unexpected token. Did you mean <span style="color: #8f0075;">`{'&gt;'}`</span> or <span style="color: #8f0075;">`&amp;gt;`</span>?

1 const identity = &lt;T&gt;<span style="color: #000000;">(</span>input: T<span style="color: #000000;">)</span> =&gt; input;
                                  ~

index.tsx:2:1 - error TS1005: <span style="color: #3548cf;">'&lt;/'</span> expected.
</pre>
</div></li>
<li><p>
我们需要如下改下才能编译通过
</p>
<div class="org-src-container">
<pre class="src src-diff">--- <span style="font-weight: bold;">a/code/ch13/04/index.tsx</span>
+++ <span style="font-weight: bold;">b/code/ch13/04/index.tsx</span>
<span style="background-color: #dfd5cf; font-weight: bold;">@@ -1 +1 @@</span>
<span style="color: #aa2222; background-color: #f4d0cf;">-</span><span style="color: #8f1313; background-color: #f4d0cf;">const identity = &lt;T&gt;(input: T) =&gt; input;</span>
+const identity = &lt;T <span style="color: #005000; background-color: #acd6a5;">= unknown</span>&gt;(input: T) =&gt; input;
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org22f9820" class="outline-4">
<h4 id="org22f9820"><span class="section-number-4">13.4.2.</span> resolveJsonModule</h4>
<div class="outline-text-4" id="text-13-4-2">
<ul class="org-ul">
<li>compiler option里面还有个resolveJsonModule选项,设置为true的话,我们可以从json文件里面读取object(这个
object会被看做是ts文件export的object). 示例如下:
<ul class="org-ul">
<li><p>
tsconfig.json一开始没有配置resolveJsonModule
</p>
<div class="org-src-container">
<pre class="src src-shell">$ cat tsconfig.json | grep resolveJsonModule
    // <span style="color: #3548cf;">"resolveJsonModule"</span>: true,                        /* Enable importing .json files. */
</pre>
</div></li>
<li><p>
我们有一个activist.json文件内容如下
</p>
<div class="org-src-container">
<pre class="src src-json"><span style="color: #000000;">{</span>
  <span style="color: #531ab6;">"activist"</span>: <span style="color: #3548cf;">"Mary Astell"</span>
<span style="color: #000000;">}</span>
</pre>
</div></li>
<li><p>
一个usesActivist.ts文件来引用这个json文件
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">import</span> <span style="color: #000000;">{</span> activist <span style="color: #000000;">}</span> <span style="color: #531ab6;">from</span> <span style="color: #3548cf;">"./activist.json"</span>;

<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>activist<span style="color: #000000;">)</span>;
</pre>
</div></li>
<li><p>
现在进行编译会发现编译失败
</p>
<div class="org-src-container">
<pre class="src src-shell">$ tsc
usesActivist.ts:1:26 - error TS2732: Cannot find module <span style="color: #3548cf;">'./activist.json'</span>. Consider using <span style="color: #3548cf;">'--resolveJsonModule'</span> to import module with <span style="color: #3548cf;">'.json'</span> extension.

1 import <span style="color: #000000;">{</span> activist <span style="color: #000000;">}</span> from <span style="color: #3548cf;">"./activist.json"</span>;
                           ~~~~~~~~~~~~~~~~~
Found 1 error<span style="color: #531ab6;"> in</span> usesActivist.ts:1
</pre>
</div></li>
<li><p>
我们设置resolveJsonModule为true
</p>
<div class="org-src-container">
<pre class="src src-diff">index c9c555d..3e765c5 100644
--- <span style="font-weight: bold;">a/code/ch13/05/tsconfig.json</span>
+++ <span style="font-weight: bold;">b/code/ch13/05/tsconfig.json</span>
<span style="background-color: #dfd5cf; font-weight: bold;">@@ -41,7 +41,7 @@</span>
     // "resolvePackageJsonImports": true,                /* Use the package.json 'imports' field when resolving imports. */
     // "customConditions": [],                           /* Conditions to set in addition to the resolver-specific defaults when resolving imports. */
     // "noUncheckedSideEffectImports": true,             /* Check side effect imports. */
<span style="color: #aa2222; background-color: #f4d0cf;">-</span><span style="color: #8f1313; background-color: #f4d0cf;">    // "resolveJsonModule": true,                        /* Enable importing .json files. */</span>
<span style="color: #006700; background-color: #c3ebc1;">+</span><span style="color: #005000; background-color: #c3ebc1;">    "resolveJsonModule": true,                        /* Enable importing .json files. */</span>
     // "allowArbitraryExtensions": true,                 /* Enable importing files with any extension, provided a declaration file is present. */
     // "noResolve": true,                                /* Disallow 'import's, 'require's or '&lt;reference&gt;'s from expanding the number of files TypeScript should add to a project. */
</pre>
</div></li>
<li>再编译就成功啦!</li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org2268280" class="outline-3">
<h3 id="org2268280"><span class="section-number-3">13.5.</span> Emit</h3>
<div class="outline-text-3" id="text-13-5">
</div>
<div id="outline-container-org44796a6" class="outline-4">
<h4 id="org44796a6"><span class="section-number-4">13.5.1.</span> outDir</h4>
<div class="outline-text-4" id="text-13-5-1">
<ul class="org-ul">
<li>默认情况下, typescript会把js文件放到ts文件旁边,比如fruits/apple.ts会产生fruits/apple.js</li>
<li>有些时候,我们会更希望把output文件放到一个不同的文件夹,比如很多Node项目会把output文件放到dist或者lib
文件夹.这个时候,我们就会用到&#x2013;outDir配置,这个配置会把ts文件编译到outDir指定的文件夹,并且每个文件的
位置和input每个文件的位置相同</li>
<li>比如我们使用tsc &#x2013;outDir dist来配置,那么
<ul class="org-ul">
<li><p>
最终的文件结构如下
</p>
<div class="org-src-container">
<pre class="src src-shell">$ tree .
<span style="color: #8f0075;">.</span>
&#9500;&#9472;&#9472; dist
&#9474;&#160;&#160; &#9500;&#9472;&#9472; fruits
&#9474;&#160;&#160; &#9474;&#160;&#160; &#9492;&#9472;&#9472; apple.js
&#9474;&#160;&#160; &#9492;&#9472;&#9472; vegetables
&#9474;&#160;&#160;     &#9492;&#9472;&#9472; zucchini.js
&#9500;&#9472;&#9472; fruits
&#9474;&#160;&#160; &#9492;&#9472;&#9472; apple.ts
&#9500;&#9472;&#9472; tsconfig.json
&#9492;&#9472;&#9472; vegetables
    &#9492;&#9472;&#9472; zucchini.ts
</pre>
</div></li>
</ul></li>
<li>Typescript会把所有的input文件放在一起(因为include可能会有多个文件夹),找到这些文件夹的最长公共路径来
作为root文件夹.这个root文件夹(假设是src)会在output的时候被output文件夹(假设是dist)替代
<ul class="org-ul">
<li><p>
假设我们的input文件都在src里面,如下
</p>
<div class="org-src-container">
<pre class="src src-shell">$ tree .
<span style="color: #8f0075;">.</span>
&#9500;&#9472;&#9472; fruits
&#9474;&#160;&#160; &#9492;&#9472;&#9472; apple.ts
&#9492;&#9472;&#9472; vegetables
    &#9492;&#9472;&#9472; zucchini.ts

3 directories, 2 files
</pre>
</div></li>
<li><p>
那么我们编译之后的结构就是下面这样的
</p>
<div class="org-src-container">
<pre class="src src-shell">$ tree .
<span style="color: #8f0075;">.</span>
&#9500;&#9472;&#9472; dist
&#9474;&#160;&#160; &#9500;&#9472;&#9472; fruits
&#9474;&#160;&#160; &#9474;&#160;&#160; &#9492;&#9472;&#9472; apple.js
&#9474;&#160;&#160; &#9492;&#9472;&#9472; vegetables
&#9474;&#160;&#160;     &#9492;&#9472;&#9472; zucchini.js
&#9500;&#9472;&#9472; src
&#9474;&#160;&#160; &#9500;&#9472;&#9472; fruits
&#9474;&#160;&#160; &#9474;&#160;&#160; &#9492;&#9472;&#9472; apple.ts
&#9474;&#160;&#160; &#9492;&#9472;&#9472; vegetables
&#9474;&#160;&#160;     &#9492;&#9472;&#9472; zucchini.ts
&#9492;&#9472;&#9472; tsconfig.json

7 directories, 5 files
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgd1541e5" class="outline-4">
<h4 id="orgd1541e5"><span class="section-number-4">13.5.2.</span> target</h4>
<div class="outline-text-4" id="text-13-5-2">
<ul class="org-ul">
<li>TypeScript可以把ts代码编译成最老为ES3的js代码</li>
<li>TypeScript提供了target option来设置我们要支持到多老的js代码(比如es3):
<ul class="org-ul">
<li>没有tsconfig的情况下tsc的默认target是es3,这个是1999年的标准,有些太老了</li>
<li>tsc &#x2013;init默认会设置target为es2016</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org6558f62" class="outline-4">
<h4 id="org6558f62"><span class="section-number-4">13.5.3.</span> Emitting Declarations</h4>
<div class="outline-text-4" id="text-13-5-3">
<ul class="org-ul">
<li>前面我们讲到declaration file的时候说到,我们有一个option来控制declaration file的输出,这个option就是declaration:
<ul class="org-ul">
<li><p>
在命令行如下设置(因为这是一个boolean属性,设置了就默认是true,不设置就是false)
</p>
<div class="org-src-container">
<pre class="src src-shell">tsc --declaration
</pre>
</div></li>
<li><p>
在tsconfig.json如下设置
</p>
<div class="org-src-container">
<pre class="src src-json"><span style="color: #000000;">{</span>
  <span style="color: #531ab6;">"compileroptions"</span>: <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">"declaration"</span>: <span style="color: #0000b0;">true</span>
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgf87df88" class="outline-4">
<h4 id="orgf87df88"><span class="section-number-4">13.5.4.</span> Source Maps</h4>
<div class="outline-text-4" id="text-13-5-4">
<ul class="org-ul">
<li>配置tsc &#x2013;sourceMap会配合产生.js.map(.jsx.map)文件. 这类map文件对debugger很有作用</li>
<li>配置tsc &#x2013;declarationMap会配合产生.d.ts.map文件. 这类map文件对project reference很有作用</li>
</ul>
</div>
</div>
<div id="outline-container-org0fc0cfd" class="outline-4">
<h4 id="org0fc0cfd"><span class="section-number-4">13.5.5.</span> noEmit</h4>
<div class="outline-text-4" id="text-13-5-5">
<ul class="org-ul">
<li>配置tsc &#x2013;noEmit会确保连js文件都不产生,等于把TypeScript当做一个checker来使用</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org2dfc6db" class="outline-3">
<h3 id="org2dfc6db"><span class="section-number-3">13.6.</span> Type Checking</h3>
<div class="outline-text-3" id="text-13-6">
<ul class="org-ul">
<li>本节介绍的都是关于type checker的,你可以在这里控制checker的严格与否</li>
</ul>
</div>
<div id="outline-container-org249d944" class="outline-4">
<h4 id="org249d944"><span class="section-number-4">13.6.1.</span> lib</h4>
<div class="outline-text-4" id="text-13-6-1">
<ul class="org-ul">
<li>前面介绍过target option,其作用是说,我们编译成功的js代码,最终能够在哪个标准下运行,比如es6, es2015等</li>
<li>这里介绍的lib option和target option很像(甚至不设置lib时候的默认值就是target option的值),但是它是一
个type checker概念,换句话说,就是说,lib设置什么值只影响检查的结果,不影响编译后的结果.(检查失败也是可
以编译出js的,比如检查要求太严格)</li>
<li>那么lib option是配置的什么东西呢?简单一句就是:lib option是用于指定Type Checker要加载哪些Type Definition,
这些Type Definition是Type Checker检查时候默认当前提供的全局API</li>
<li>上面这句话还是难以理解,我们需要用具体的情景来解释会更有效果.
<ul class="org-ul">
<li><p>
假设我们的项目target是es5,因为我们要在老的浏览器里面运行,那么我们的index.ts使用promise就会报错, 因为es5时代就没有promise
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #7f0000;">// </span><span style="color: #7f0000;">'Promise' only refers to a type, but is being used as a value here. Do you need to change your target library? Try changing the 'lib' compiler option to es2015 or later. (typescript-tide)</span>
<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">promise</span> = <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Promise</span><span style="color: #000000;">(</span><span style="color: #dd22dd;">(</span>resolve<span style="color: #dd22dd;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #721045;">resolve</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">"hello"</span><span style="color: #dd22dd;">)</span><span style="color: #000000;">)</span>;
</pre>
</div></li>
<li>其实很多新时代的程序员根本分不清哪些概念(全局API)是哪个时代引入的,他们想的是:"使用最新的技术开发,
然后让TypeScript编译成对应的js文件".
<ol class="org-ol">
<li>"让TypeScript编译成对应的js文件"是target的作用</li>
<li><p>
那么这个"使用最近的技术开发"就是lib的作用啦,如下更改后,报错就不存在了.
</p>
<div class="org-src-container">
<pre class="src src-diff">--- <span style="font-weight: bold;">a/code/ch13/08/tsconfig.json</span>
+++ <span style="font-weight: bold;">b/code/ch13/08/tsconfig.json</span>
<span style="background-color: #dfd5cf; font-weight: bold;">@@ -12,7 +12,7 @@</span>

     /* Language and Environment */
     "target": "es5",                                  /* Set the JavaScript language version for emitted JavaScript and include compatible library declarations. */
<span style="color: #aa2222; background-color: #f4d0cf;">-</span><span style="color: #8f1313; background-color: #f4d0cf;">    </span><span style="color: #8f1313; background-color: #f3b5a7;">//</span><span style="color: #8f1313; background-color: #f4d0cf;"> "lib": [],                                        /* Specify a set of bundled library declaration files that describe the target runtime environment. */</span>
<span style="color: #006700; background-color: #c3ebc1;">+</span><span style="color: #005000; background-color: #c3ebc1;">    "lib": [</span><span style="color: #005000; background-color: #acd6a5;">"es2015"</span><span style="color: #005000; background-color: #c3ebc1;">],                                        /* Specify a set of bundled library declaration files that describe the target runtime environment. */</span>
     // "jsx": "preserve",                                /* Specify what JSX code is generated. */
     // "experimentalDecorators": true,                   /* Enable experimental support for legacy experimental decorators. */
     // "emitDecoratorMetadata": true,                    /* Emit design-type metadata for decorated declarations in source files. */
</pre>
</div></li>
</ol></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org8ff7625" class="outline-4">
<h4 id="org8ff7625"><span class="section-number-4">13.6.2.</span> skipLibCheck</h4>
<div class="outline-text-4" id="text-13-6-2">
<ul class="org-ul">
<li>skipLibCheck的引入是为了做到如下精准的配置:
<ul class="org-ul">
<li>跳过外部依赖中声明文件(.d.ts)的检查</li>
<li>依然检查项目自身的声明文件(.d.ts)</li>
</ul></li>
<li>skipLibCheck是tsconfig.json的默认设置,这是因为外部依赖的.d.ts文件往往会出现冲突,而且其实他们不影响
我们的最终编译结果</li>
</ul>
</div>
</div>
<div id="outline-container-orga04b46c" class="outline-4">
<h4 id="orga04b46c"><span class="section-number-4">13.6.3.</span> Strict Mode</h4>
<div class="outline-text-4" id="text-13-6-3">
<ul class="org-ul">
<li>Strict Mode是TypeScript里面的一组叫做strict的编译选项.常见的有:
<ul class="org-ul">
<li>strictNullChecks</li>
<li>strictFunctionType</li>
<li>noImplicitAny</li>
<li>strictBindCallApply</li>
<li>noImplicitThis</li>
<li>等等</li>
</ul></li>
<li>需要在tsconfig.json进行相应配置
<ul class="org-ul">
<li><p>
如果enable这一组strict,那么所有的一组strict编译选择都会被enable,比如增加下面一行,就是enable上面
一组所有的选项
</p>
<div class="org-src-container">
<pre class="src src-diff">diff --git a/code/ch13/09/tsconfig.json b/code/ch13/09/tsconfig.json
index f18815d..c9c555d 100644
--- <span style="font-weight: bold;">a/code/ch13/09/tsconfig.json</span>
+++ <span style="font-weight: bold;">b/code/ch13/09/tsconfig.json</span>
<span style="background-color: #dfd5cf; font-weight: bold;">@@ -83,6 +83,7 @@</span>
     "forceConsistentCasingInFileNames": true,            /* Ensure that casing is correct in imports. */

     /* Type Checking */
+    "strict": true,                                      /* Enable all strict type-checking options. */
</pre>
</div></li>
<li><p>
如果想enable整组,但是却disable某个特定的参数(比如只disable noImplicitAny),可以如下配置
</p>
<div class="org-src-container">
<pre class="src src-diff">diff --git a/code/ch13/09/tsconfig.json b/code/ch13/09/tsconfig.json
index f18815d..e2103a9 100644
--- <span style="font-weight: bold;">a/code/ch13/09/tsconfig.json</span>
+++ <span style="font-weight: bold;">b/code/ch13/09/tsconfig.json</span>
<span style="background-color: #dfd5cf; font-weight: bold;">@@ -83,7 +83,8 @@</span>
     "forceConsistentCasingInFileNames": true,            /* Ensure that casing is correct in imports. */

     /* Type Checking */
<span style="color: #aa2222; background-color: #f4d0cf;">-</span><span style="color: #8f1313; background-color: #f4d0cf;">    // "noImplicitAny": true,                            /* Enable error reporting for expressions and declarations with an implied 'any' type. */</span>
<span style="color: #006700; background-color: #c3ebc1;">+</span><span style="color: #005000; background-color: #c3ebc1;">    "strict": true,                                      /* Enable all strict type-checking options. */</span>
+    "noImplicitAny": false,                            /* Enable error reporting for expressions and declarations with an implied 'any' type. */
</pre>
</div></li>
</ul></li>
</ul>
</div>
<ol class="org-ol">
<li><a id="org74c8c9f"></a>noImplicitAny<br />
<div class="outline-text-5" id="text-13-6-3-1">
<ul class="org-ul">
<li>如果TypeScript无法infer一个参数的类型,那么它会assume这个类型是any.如果希望TypeScript不要使用这个默
认行为,而是每次遇到这种情况都报错,那么我们要enable noImplicitAny
<ul class="org-ul">
<li><p>
一旦enable noImplicitAny 比如下面的代码就会报错
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #7f0000;">/////////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Parameter 'message' implicitly has an 'any' type. (typescript-tide) //</span>
<span style="color: #7f0000;">/////////////////////////////////////////////////////////////////////////</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">logMessage</span> = <span style="color: #000000;">(</span><span style="color: #005e8b;">message</span><span style="color: #000000;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #000000;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">`Message: </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">message</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>;
</pre>
</div></li>
<li><p>
想让报错消失也很简单,明确的设置类型
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">const</span> <span style="color: #005e8b;">logMessage</span> = <span style="color: #000000;">(</span><span style="color: #005e8b;">message</span>: <span style="color: #531ab6;">string</span><span style="color: #000000;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #000000;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">`Message: </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">message</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>;
</pre>
</div></li>
</ul></li>
<li>除非你的项目正在从JavaScript转向TypeScript,否则建议一直开启这个noImplicitAny检查</li>
</ul>
</div>
</li>
<li><a id="org250e43d"></a>strictBindCallApply<br />
<div class="outline-text-5" id="text-13-6-3-2">
<ul class="org-ul">
<li>strictBindCallApply,其实是对三个函数进行严格的检查(看看调用参数是否正确)限制, 这三个参数是:
<ul class="org-ul">
<li>bind</li>
<li>call</li>
<li>apply</li>
</ul></li>
<li>所谓"调用参数是否正确"是指,TypeScript去检查bind, call, apply的参数类型是否正确(通过判断调用bind,
call, apply的函数的原型来判断).我们用例子来看会比较好理解
<ul class="org-ul">
<li><p>
假设我们有广义函数greet,接受一个字符串参数. 如果没有配置strictBindCallApply,下面例子不会报错
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">greet</span><span style="color: #000000;">(</span><span style="color: #005e8b;">name</span>: <span style="color: #531ab6;">string</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">`Hello, </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">name</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>

greet.<span style="color: #721045;">call</span><span style="color: #000000;">(</span><span style="color: #0000b0;">null</span>, 42<span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Hello, 42</span>
</pre>
</div></li>
<li><p>
但是如果配置了strictBindCallApply, 编译器会抱怨,我们不能把一个number传递给字符串
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">greet</span><span style="color: #000000;">(</span><span style="color: #005e8b;">name</span>: <span style="color: #531ab6;">string</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">`Hello, </span><span style="color: #531ab6;">${</span><span style="color: #000000; background-color: #fbf7f0;">name</span><span style="color: #531ab6;">}</span><span style="color: #3548cf;">`</span><span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>
<span style="color: #7f0000;">//////////////////////////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Argument of type 'number' is not assignable to parameter of type 'string'. (typescript-tide) //</span>
<span style="color: #7f0000;">//////////////////////////////////////////////////////////////////////////////////////////////////</span>

greet.<span style="color: #721045;">call</span><span style="color: #000000;">(</span><span style="color: #0000b0;">null</span>, 42<span style="color: #000000;">)</span>;
</pre>
</div></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org96a4738"></a>strictFunctionTypes<br />
<div class="outline-text-5" id="text-13-6-3-3">
<ul class="org-ul">
<li><p>
strictFunctionTypes一旦设置,那么一个function typeA的参数,是另一function typeB的的参数subtype的情况下,
不再被认为是assignable
</p>
<pre class="example" id="orgc5a4c15">
A function type is no longer considered assignable to another function
type if its parameters are subtypes of that other type's parameters
</pre></li>
<li>我们用例子来解释一下
<ul class="org-ul">
<li><p>
如果没有配置strictFunctionTypes,那么下面的代码是可以通过编译的. 但是调用的时候还是会crash,因为number没有match函数
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">checkOnNumber</span><span style="color: #000000;">(</span><span style="color: #005e8b;">containsA</span>: <span style="color: #dd22dd;">(</span><span style="color: #005e8b;">input</span>: <span style="color: #531ab6;">number</span> | <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #531ab6;">boolean</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> <span style="color: #721045;">containsA</span><span style="color: #dd22dd;">(</span>1337<span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">function</span> <span style="color: #721045;">stringContainsA</span><span style="color: #000000;">(</span><span style="color: #005e8b;">input</span>: <span style="color: #531ab6;">string</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> !!input.<span style="color: #721045;">match</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">/a/</span>i<span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>

<span style="color: #7f0000;">//////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TypeError: input.match is not a function //</span>
<span style="color: #7f0000;">//////////////////////////////////////////////</span>

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">checkOnNumber(stringContainsA);</span>
</pre>
</div></li>
<li><p>
如果配置了strictFunctionTypes,那么下面的代码会有如下报错
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">function</span> <span style="color: #721045;">checkOnNumber</span><span style="color: #000000;">(</span><span style="color: #005e8b;">containsA</span>: <span style="color: #dd22dd;">(</span><span style="color: #005e8b;">input</span>: <span style="color: #531ab6;">number</span> | <span style="color: #531ab6;">string</span><span style="color: #dd22dd;">)</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #531ab6;">boolean</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> <span style="color: #721045;">containsA</span><span style="color: #dd22dd;">(</span>1337<span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">function</span> <span style="color: #721045;">stringContainsA</span><span style="color: #000000;">(</span><span style="color: #005e8b;">input</span>: <span style="color: #531ab6;">string</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> !!input.<span style="color: #721045;">match</span><span style="color: #dd22dd;">(</span><span style="color: #3548cf;">/a/</span>i<span style="color: #dd22dd;">)</span>;
<span style="color: #000000;">}</span>

<span style="color: #7f0000;">/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Argument of type '(input: string) =&gt; boolean' is not assignable to parameter of type '(input: string | number) =&gt; boolean'. //</span>
<span style="color: #7f0000;">//   </span><span style="color: #7f0000;">Types of parameters 'input' and 'input' are incompatible.                                                                 //</span>
<span style="color: #7f0000;">//     </span><span style="color: #7f0000;">Type 'string | number' is not assignable to type 'string'.                                                              //</span>
<span style="color: #7f0000;">//       </span><span style="color: #7f0000;">Type 'number' is not assignable to type 'string'. (typescript-tide)                                                   //</span>
<span style="color: #7f0000;">/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</span>

<span style="color: #721045;">checkOnNumber</span><span style="color: #000000;">(</span>stringContainsA<span style="color: #000000;">)</span>;
</pre>
</div></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org41be22a"></a>strictNullChecks<br />
<div class="outline-text-5" id="text-13-6-3-4">
<ul class="org-ul">
<li>一旦设置strictNullChecks,那么就一位置empty value(null, undefined)无法赋值给nonempty type
<ul class="org-ul">
<li><p>
示例如下,设置了strictNullCheck,下面的代码会报错
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">let</span> <span style="color: #005e8b;">value</span>: <span style="color: #531ab6;">string</span>;

value = <span style="color: #3548cf;">"abc123"</span>;

<span style="color: #7f0000;">///////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Type 'null' is not assignable to type 'string'. (typescript-tide) //</span>
<span style="color: #7f0000;">///////////////////////////////////////////////////////////////////////</span>

value = <span style="color: #0000b0;">null</span>;
</pre>
</div></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="orgab6c6e7"></a>strictPropertyInitialization<br />
<div class="outline-text-5" id="text-13-6-3-5">
<ul class="org-ul">
<li>默认情况下,class的属性并不要求要被初始化.但是这样会有隐患出现
<ul class="org-ul">
<li><p>
示例如下,默认情况下,TypeScript并不会检查属性是否初始化,虽然能编译,但是打印会打印undefined
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">class</span> <span style="color: #005f5f;">Person</span> <span style="color: #000000;">{</span>
  name: <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">p</span> = <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Person</span><span style="color: #000000;">()</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>p.name<span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">undefined</span>
</pre>
</div></li>
</ul></li>
<li>一旦设置strictPropertyInitialization,那么会进行属性是否初始化的检查
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #7f0000;">/////////////////////////////////////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #7f0000;">// </span><span style="color: #7f0000;">Property 'name' has no initializer and is not definitely assigned in the constructor. (typescript-tide) //</span>
<span style="color: #7f0000;">/////////////////////////////////////////////////////////////////////////////////////////////////////////////</span>

<span style="color: #531ab6;">class</span> <span style="color: #005f5f;">Person</span> <span style="color: #000000;">{</span>
  name: <span style="color: #531ab6;">string</span>;
<span style="color: #000000;">}</span>

<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">p</span> = <span style="color: #531ab6;">new</span> <span style="color: #005f5f;">Person</span><span style="color: #000000;">()</span>;
<span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>p.name<span style="color: #000000;">)</span>;
</pre>
</div></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org30108a7"></a>useUnknownInCatchVariabls<br />
<div class="outline-text-5" id="text-13-6-3-6">
<ul class="org-ul">
<li>在 JavaScript 和 TypeScript 中，try&#x2026;catch 语句用于捕获异常，而 catch 块中的变量默认情况下被认为是
any 类型。这意味着你可以对这个变量做任何操作，但它可能导致一些类型安全性问题，因为捕获的错误可能并
不总是你预期的类型。</li>
<li>一旦设置useUnknownInCatchVariabls, catch 块中的变量类型会从默认的 any 改为 unknown</li>
<li>相对于any, unkonw有如下优势:
<ul class="org-ul">
<li>unknown是TypeScript的一种类型,表示未知值</li>
<li>与any不同,你不能直接对unknown类型的值进行操作(需要先类型检查或者断言)</li>
</ul></li>
</ul>
</div>
</li>
</ol>
</div>
</div>
<div id="outline-container-org14f5adf" class="outline-3">
<h3 id="org14f5adf"><span class="section-number-3">13.7.</span> Modules</h3>
<div class="outline-text-3" id="text-13-7">
<ul class="org-ul">
<li>大部分的TypeScript project,都是以standardized ECMAScript module syntax来书写的
<ul class="org-ul">
<li><p>
一个ECMAScript module的例子(使用import导入,使用export导出)如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">import</span> <span style="color: #000000;">{</span> value <span style="color: #000000;">}</span> <span style="color: #531ab6;">from</span> <span style="color: #3548cf;">"my-example-lib"</span>;

<span style="color: #531ab6;">export</span> <span style="color: #531ab6;">const</span> <span style="color: #005e8b;">logValue</span> = <span style="color: #000000;">()</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>value<span style="color: #000000;">)</span>;
</pre>
</div></li>
</ul></li>
<li>除了ECMAScript moudle syntax以外,还有两种syntax比较出名:
<ul class="org-ul">
<li><p>
CommonJS, 这是node.js的默认导入导出syntax,例子如下
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#23548;&#20986;&#27169;&#22359; (CommonJS)</span>
<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">add</span> = <span style="color: #000000;">(</span>a, b<span style="color: #000000;">)</span> =&gt; a + b;
module.exports = add;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#23548;&#20837;&#27169;&#22359; (CommonJS)</span>
<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">add</span> = require<span style="color: #000000;">(</span><span style="color: #3548cf;">'./add'</span><span style="color: #000000;">)</span>;
console.log<span style="color: #000000;">(</span>add<span style="color: #dd22dd;">(</span>2, 3<span style="color: #dd22dd;">)</span><span style="color: #000000;">)</span>; <span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#36755;&#20986;: 5</span>
</pre>
</div></li>
<li><p>
AMD syntax,非阻塞的异步加载syntax,例子如下
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#23450;&#20041;&#27169;&#22359; (AMD)</span>
define<span style="color: #000000;">(</span><span style="color: #dd22dd;">[</span><span style="color: #3548cf;">'moduleA'</span>, <span style="color: #3548cf;">'moduleB'</span><span style="color: #dd22dd;">]</span>, <span style="color: #531ab6;">function</span><span style="color: #dd22dd;">(</span><span style="color: #005e8b;">moduleA</span>, <span style="color: #005e8b;">moduleB</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
  <span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#20351;&#29992; moduleA &#21644; moduleB</span>
  <span style="color: #531ab6;">return</span> <span style="color: #008899;">{</span>
    <span style="color: #721045;">hello</span>: <span style="color: #531ab6;">function</span><span style="color: #972500;">()</span> <span style="color: #972500;">{</span>
      console.log<span style="color: #808000;">(</span><span style="color: #3548cf;">'Hello from AMD!'</span><span style="color: #808000;">)</span>;
    <span style="color: #972500;">}</span>
  <span style="color: #008899;">}</span>;
<span style="color: #dd22dd;">}</span><span style="color: #000000;">)</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#20351;&#29992;&#27169;&#22359; (AMD)</span>
require<span style="color: #000000;">(</span><span style="color: #dd22dd;">[</span><span style="color: #3548cf;">'moduleA'</span><span style="color: #dd22dd;">]</span>, <span style="color: #531ab6;">function</span><span style="color: #dd22dd;">(</span><span style="color: #005e8b;">moduleA</span><span style="color: #dd22dd;">)</span> <span style="color: #dd22dd;">{</span>
  moduleA.hello<span style="color: #008899;">()</span>;
<span style="color: #dd22dd;">}</span><span style="color: #000000;">)</span>;
</pre>
</div></li>
</ul></li>
<li>为了能够让TypeScript和其他syntax进行配合,tsconfig.json引入了很多相关的配置</li>
</ul>
</div>
<div id="outline-container-org32d524b" class="outline-4">
<h4 id="org32d524b"><span class="section-number-4">13.7.1.</span> module</h4>
<div class="outline-text-4" id="text-13-7-1">
<ul class="org-ul">
<li>module就是tsconfig.json的一种compilerOption,其作用是希望TypeScript把代码编译成哪种syntax
<ul class="org-ul">
<li><p>
假设我们有如下的ECMAScript代码
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #531ab6;">import</span> <span style="color: #000000;">{</span> value <span style="color: #000000;">}</span> <span style="color: #531ab6;">from</span> <span style="color: #3548cf;">"my-example-lib"</span>;
<span style="color: #531ab6;">export</span> <span style="color: #531ab6;">const</span> <span style="color: #005e8b;">logValue</span> = <span style="color: #000000;">()</span> <span style="color: #531ab6;">=&gt;</span> <span style="color: #005f5f;">console</span>.<span style="color: #721045;">log</span><span style="color: #000000;">(</span>value<span style="color: #000000;">)</span>;
</pre>
</div></li>
<li><p>
并且我们在tsconfig里面设置了module为comonjs
</p>
<div class="org-src-container">
<pre class="src src-json"><span style="color: #000000;">{</span>
  <span style="color: #531ab6;">"compilerOptions"</span>: <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">"module"</span>: <span style="color: #3548cf;">"commonjs"</span>
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>
</pre>
</div></li>
<li><p>
那么编译后就是commonjs的形式
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3548cf;">"use strict"</span>;
Object.defineProperty<span style="color: #000000;">(</span>exports, <span style="color: #3548cf;">"__esModule"</span>, <span style="color: #dd22dd;">{</span> value: <span style="color: #0000b0;">true</span> <span style="color: #dd22dd;">}</span><span style="color: #000000;">)</span>;
exports.logValue = <span style="color: #531ab6;">void</span> 0;
<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">my_example_lib_1</span> = require<span style="color: #000000;">(</span><span style="color: #3548cf;">"my-example-lib"</span><span style="color: #000000;">)</span>;
<span style="color: #531ab6;">const</span> <span style="color: #005e8b;">logValue</span> = <span style="color: #000000;">()</span> =&gt; console.log<span style="color: #000000;">(</span>my_example_lib_1.value<span style="color: #000000;">)</span>;
exports.logValue = logValue;
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgf8d5a34" class="outline-4">
<h4 id="orgf8d5a34"><span class="section-number-4">13.7.2.</span> moduleResolution</h4>
<div class="outline-text-4" id="text-13-7-2">
<ul class="org-ul">
<li>moduleResolution的配置的值不通,会让TypeScript选择不同的module加载方式.一共两大类:
<ul class="org-ul">
<li>classic模式(已经被淘汰,几乎不会被使用):
<ol class="org-ol">
<li>尝试从当前文件夹的相对路径查找模块,如果找不到,就不会进行额外查找</li>
<li>不会查找node_modules文件夹</li>
</ol></li>
<li>node模式(包含node, nodenext, node10等)
<ol class="org-ol">
<li>绝对路径查找,比如/utils/helpers</li>
<li>相对路径查找,比如./utils/helpers,会在相对应当前文件的相对路径去查找</li>
<li>模块名称(比如loadash)会在node_modules下面查找</li>
</ol></li>
</ul></li>
<li>classic模式和node模式的区别在于,是否查找node_modules和绝对路径. 显然node模式是更现代也更全面的方式,
所以classic模式已经被淘汰</li>
</ul>
</div>
</div>
<div id="outline-container-orgb300d32" class="outline-4">
<h4 id="orgb300d32"><span class="section-number-4">13.7.3.</span> interoperability with CommonJS</h4>
<div class="outline-text-4" id="text-13-7-3">
<ul class="org-ul">
<li>JavaScript的module,有两种output方式:
<ul class="org-ul">
<li>default output (是export object的.default property)</li>
<li>namespace output(是export object它自己)</li>
</ul></li>
<li><p>
我们可以用下面的表格来区分下两个export(以及input)
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">Area of syntax</td>
<td class="org-left">CommonJS</td>
<td class="org-left">ECAMScript modules</td>
</tr>

<tr>
<td class="org-left">Default export</td>
<td class="org-left">module.exports.default = value;</td>
<td class="org-left">export default value;</td>
</tr>

<tr>
<td class="org-left">Default import</td>
<td class="org-left">const { default: value} = require("");</td>
<td class="org-left">import value from "";</td>
</tr>

<tr>
<td class="org-left">Namespace export</td>
<td class="org-left">module.exports = value;</td>
<td class="org-left">Not supported</td>
</tr>

<tr>
<td class="org-left">Namespace import</td>
<td class="org-left">const value = require("");</td>
<td class="org-left">import * as value from "";</td>
</tr>
</tbody>
</table></li>
<li>TypeScript的syntax总体上还是ECMAScript的,但是,如果你使用npm pacakge,那么这个package很大可能性是会使
用CommonJS的syntax的.所以TypeScript需要提供一些配置类弥补不同syntax带来的差异</li>
</ul>
</div>
<ol class="org-ol">
<li><a id="orgc85e3f2"></a>esModuleInterop<br />
<div class="outline-text-5" id="text-13-7-3-1">
<ul class="org-ul">
<li>一旦设置,TypeScript 将允许你对 CommonJS 模块使用 ECMAScript 样式的默认导入
<ul class="org-ul">
<li><p>
配置如下
</p>
<div class="org-src-container">
<pre class="src src-json"><span style="color: #000000;">{</span>
  <span style="color: #531ab6;">"compilerOptions"</span>: <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">"esModuleInterop"</span>: <span style="color: #0000b0;">true</span>
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>
</pre>
</div></li>
<li><p>
使用方法如下
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #7f0000;">// </span><span style="color: #7f0000;">CommonJS &#27169;&#22359;&#65288;math.js&#65289;</span>
module.exports = <span style="color: #000000;">{</span>
  add: <span style="color: #dd22dd;">(</span>a, b<span style="color: #dd22dd;">)</span> =&gt; a + b,
<span style="color: #000000;">}</span>;

<span style="color: #7f0000;">// </span><span style="color: #7f0000;">TypeScript &#25991;&#20214;&#20013;</span>
<span style="color: #531ab6;">import</span> add from <span style="color: #3548cf;">'./math'</span>; <span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#38656;&#35201; esModuleInterop &#21551;&#29992;</span>
console.log<span style="color: #000000;">(</span>add<span style="color: #dd22dd;">(</span>2, 3<span style="color: #dd22dd;">)</span><span style="color: #000000;">)</span>;
</pre>
</div></li>
</ul></li>
<li>esModuleInterop 选项改变的是 生成的 JavaScript 代码，它会调整 TypeScript 编译后的代码，使其更符合
ECMAScript 模块与 CommonJS 模块之间的互操作性规则,如果不想改变最终的编译结果,那么可以试试下面的allowSyntheticDefaultImports</li>
</ul>
</div>
</li>
<li><a id="org140048f"></a>allowSyntheticDefaultImports<br />
<div class="outline-text-5" id="text-13-7-3-2">
<ul class="org-ul">
<li>allowSyntheticDefaultImports 只影响 TypeScript 的类型系统，它不会改变生成的 JavaScript 代码</li>
<li>它告诉 TypeScript，即使模块没有真正的默认导出，类型系统也应该允许使用默认导入的语法。</li>
<li>allowSyntheticDefaultImports 只影响类型检查(不影响编译后的结果)，告诉 TypeScript 类型系统允许开发
者使用默认导入的写法，即使模块本身没有默认导出</li>
</ul>
</div>
</li>
</ol>
</div>
<div id="outline-container-orga686f98" class="outline-4">
<h4 id="orga686f98"><span class="section-number-4">13.7.4.</span> isolatedModules</h4>
<div class="outline-text-4" id="text-13-7-4">
<ul class="org-ul">
<li>一旦设置isolatedModules会启动独立模块编译模式,也就是确保每个TypeScript文件都可以被单独编译为一个模
块，而不依赖其他文件的上下文信息</li>
<li>如果使用其他的tool(比如Babel)来编译项目,设置isolatedModules是必须的.</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org56c9893" class="outline-3">
<h3 id="org56c9893"><span class="section-number-3">13.8.</span> JavaScript</h3>
<div class="outline-text-3" id="text-13-8">
<ul class="org-ul">
<li>虽然TypeScript如此优秀,以至于最好一直写TypeScript,但是在实践当中,还是有些时候要TypeScript和JavaScript
混写
<ul class="org-ul">
<li>比如一个项目从JavaScript转换为TypeScript的过程当中,就是一部分一部分的改写JavaScript到TypeScript,
所以整个改造生命周期内,项目都是TypeScript和JavaScript共存的</li>
</ul></li>
</ul>
</div>
<div id="outline-container-orga70c574" class="outline-4">
<h4 id="orga70c574"><span class="section-number-4">13.8.1.</span> allowJs</h4>
<div class="outline-text-4" id="text-13-8-1">
<ul class="org-ul">
<li>一旦设置allowJs,那么我们就可以在项目中存在js文件.
<ul class="org-ul">
<li>编译器会去编译js</li>
<li>编译器不会去check js</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org719c4bf" class="outline-4">
<h4 id="org719c4bf"><span class="section-number-4">13.8.2.</span> checkJs</h4>
<div class="outline-text-4" id="text-13-8-2">
<ul class="org-ul">
<li>如果想编译js文件的同时,还去check js,那么就要设置这个checkJs</li>
<li>一旦设置checkJs,那么整个项目的js文件都会被check</li>
</ul>
</div>
<ol class="org-ol">
<li><a id="orga3ceab7"></a>@ts-check<br />
<div class="outline-text-5" id="text-13-8-2-1">
<ul class="org-ul">
<li>如果你不想全局所有的js文件都被check,而是一部分文件被check,那么:
<ul class="org-ul">
<li>把checkJs设置为false</li>
<li><p>
在需要被check的js文件上面加上@ts-check,如下
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #7f0000;">// </span><span style="color: #7f0000;">@ts-check</span>

<span style="color: #531ab6;">function</span> <span style="color: #721045;">add</span><span style="color: #000000;">(</span><span style="color: #005e8b;">a</span>, <span style="color: #005e8b;">b</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> a + b;
<span style="color: #000000;">}</span>

add<span style="color: #000000;">(</span>10, <span style="color: #3548cf;">"20"</span><span style="color: #000000;">)</span>; <span style="color: #7f0000;">// </span><span style="color: #7f0000;">TypeScript &#20250;&#25253;&#38169;&#65306;&#19981;&#33021;&#23558; string &#31867;&#22411;&#20256;&#36882;&#32473; number &#21442;&#25968;</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</li>
</ol>
</div>
<div id="outline-container-org1d8acec" class="outline-4">
<h4 id="org1d8acec"><span class="section-number-4">13.8.3.</span> JSDoc Support</h4>
<div class="outline-text-4" id="text-13-8-3">
<ul class="org-ul">
<li>由于JavaScript没有TypeScript丰富的类型系统,所以很多时候仅靠js文件本身,无法准确的传递出自己的类型,
这个时候就需要JSDoc啦,其原理就是在不改变js代码的前提下,在注释中标注类型,让tsc能够理解
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #2a5045;">/**</span>
<span style="color: #2a5045;"> * &#35745;&#31639;&#20004;&#20010;&#25968;&#23383;&#30340;&#21644;</span>
<span style="color: #2a5045;"> * @param {number} a - &#31532;&#19968;&#20010;&#25968;&#23383;</span>
<span style="color: #2a5045;"> * @param {number} b - &#31532;&#20108;&#20010;&#25968;&#23383;</span>
<span style="color: #2a5045;"> * @returns {number} &#20004;&#20010;&#25968;&#23383;&#30340;&#21644;</span>
<span style="color: #2a5045;"> */</span>
<span style="color: #531ab6;">function</span> <span style="color: #721045;">add</span><span style="color: #000000;">(</span><span style="color: #005e8b;">a</span>, <span style="color: #005e8b;">b</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  <span style="color: #531ab6;">return</span> a + b;
<span style="color: #000000;">}</span>

add<span style="color: #000000;">(</span>10, 20<span style="color: #000000;">)</span>; <span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#27491;&#24120;</span>
add<span style="color: #000000;">(</span>10, <span style="color: #3548cf;">"20"</span><span style="color: #000000;">)</span>; <span style="color: #7f0000;">// </span><span style="color: #7f0000;">&#22914;&#26524;&#24320;&#21551; @ts-check&#65292;&#20250;&#25253;&#38169;</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orga9e2fd5" class="outline-3">
<h3 id="orga9e2fd5"><span class="section-number-3">13.9.</span> Configuration Extensions</h3>
<div class="outline-text-3" id="text-13-9">
</div>
<div id="outline-container-org584611c" class="outline-4">
<h4 id="org584611c"><span class="section-number-4">13.9.1.</span> extends</h4>
<div class="outline-text-4" id="text-13-9-1">
<ul class="org-ul">
<li>tsconfig可以选择"继承"自其他的tsconfig,extends的值有两种形式:
<ul class="org-ul">
<li><p>
relative: 以"."开头的本地文件
</p>
<div class="org-src-container">
<pre class="src src-json"><span style="color: #000000;">{</span>
  <span style="color: #531ab6;">"extends"</span>: <span style="color: #3548cf;">"./base-config.json"</span>,
  <span style="color: #531ab6;">"compilerOptions"</span>: <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">"strict"</span>: <span style="color: #0000b0;">true</span>
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>
</pre>
</div></li>
<li><p>
absolute: 以@或者alphabetical letter开头."tsconfig/recommended" 是一个 npm 包中提供的预定义配置
</p>
<div class="org-src-container">
<pre class="src src-json"><span style="color: #000000;">{</span>
  <span style="color: #531ab6;">"extends"</span>: <span style="color: #3548cf;">"tsconfig/recommended"</span>,
  <span style="color: #531ab6;">"compilerOptions"</span>: <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">"outDir"</span>: <span style="color: #3548cf;">"./dist"</span>,
    <span style="color: #531ab6;">"rootDir"</span>: <span style="color: #3548cf;">"./src"</span>
  <span style="color: #dd22dd;">}</span>
<span style="color: #000000;">}</span>
</pre>
</div></li>
</ul></li>
<li>继承配置时，TypeScript 会将父配置与当前配置合并，具体规则如下：
<ul class="org-ul">
<li>简单的对象（如 compilerOptions）会进行浅合并, 当前文件中的配置项会覆盖继承文件中的同名配置项。</li>
<li>数组属性（如 include 和 exclude）不会合并，而是直接用当前文件中的值替换父配置中的值</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgf0abf72" class="outline-4">
<h4 id="orgf0abf72"><span class="section-number-4">13.9.2.</span> Configuration Bases</h4>
<div class="outline-text-4" id="text-13-9-2">
<ul class="org-ul">
<li>除了使用tsc &#x2013;init来创建一个tsconfig以外,我们还可以使用社区推荐的配置
<ul class="org-ul">
<li><p>
使用方法如下, 首先安装
</p>
<div class="org-src-container">
<pre class="src src-shell">npm install --save-dev @tsconfig/recommended
</pre>
</div></li>
<li><p>
上述方法安装后,就可以在tsconfig.json里面如下配置. 注意自己的配置会覆盖extends里面的内容
</p>
<div class="org-src-container">
<pre class="src src-json"><span style="color: #000000;">{</span>
  <span style="color: #531ab6;">"extends"</span>: <span style="color: #3548cf;">"@tsconfig/recommended/tsconfig.json"</span>,
  <span style="color: #531ab6;">"compilerOptions"</span>: <span style="color: #dd22dd;">{</span>
    <span style="color: #531ab6;">"outDir"</span>: <span style="color: #3548cf;">"./dist"</span>,
    <span style="color: #531ab6;">"rootDir"</span>: <span style="color: #3548cf;">"./src"</span>
  <span style="color: #dd22dd;">}</span>,
  <span style="color: #531ab6;">"include"</span>: <span style="color: #dd22dd;">[</span><span style="color: #3548cf;">"src/**/*"</span><span style="color: #dd22dd;">]</span>
<span style="color: #000000;">}</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgfe22e90" class="outline-3">
<h3 id="orgfe22e90"><span class="section-number-3">13.10.</span> Project References</h3>
<div class="outline-text-3" id="text-13-10">
<ul class="org-ul">
<li>所谓project reference就是大型的前端项目可以每个部分使用自己的tsconfig.这样做的好处是:
<ul class="org-ul">
<li>不同代码可以由不同的compiler option</li>
<li>每个单独的tsconfig 部分的编译结果可以cache,提高编译速度</li>
<li>project reference可以强制"dependency tree"(也就是只允许代码部分A只能从代码部分Bimport),这样能够更
好的规划好代码结构</li>
</ul></li>
</ul>
</div>
<div id="outline-container-org944d2ac" class="outline-4">
<h4 id="org944d2ac"><span class="section-number-4">13.10.1.</span> composite</h4>
<div class="outline-text-4" id="text-13-10-1">
<ul class="org-ul">
<li>composite 是 TypeScript 中的一个选项，存在于 compilerOptions 下。它的主要作用是告诉 TypeScript：
<ul class="org-ul">
<li>当前项目是一个 "独立的构建单元"，可以被其他 TypeScript 项目引用。</li>
<li>启用了 composite 的项目必须满足一些额外的要求，确保该项目的配置可以被安全地增量构建。</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgfbc5496" class="outline-4">
<h4 id="orgfbc5496"><span class="section-number-4">13.10.2.</span> references</h4>
<div class="outline-text-4" id="text-13-10-2">
<ul class="org-ul">
<li>composite项目会被references所引用
<ul class="org-ul">
<li><p>
示例如下
</p>
<div class="org-src-container">
<pre class="src src-json"><span style="color: #000000;">{</span>
  <span style="color: #531ab6;">"references"</span>: <span style="color: #dd22dd;">[</span><span style="color: #008899;">{</span> <span style="color: #531ab6;">"path"</span>: <span style="color: #3548cf;">"../core"</span> <span style="color: #008899;">}</span><span style="color: #dd22dd;">]</span>
<span style="color: #000000;">}</span>
</pre>
</div></li>
</ul></li>
<li>references一个composite root文件夹相当于从.d.ts文件里面import</li>
</ul>
</div>
</div>
<div id="outline-container-org8ea7482" class="outline-4">
<h4 id="org8ea7482"><span class="section-number-4">13.10.3.</span> Build Mode</h4>
<div class="outline-text-4" id="text-13-10-3">
<ul class="org-ul">
<li>TypeScript 的 Build Mode 是 TypeScript 3.0 引入的一种编译模式，专为多项目构建和增量编译而设计。
<ul class="org-ul">
<li>它利用 项目引用（Project References） 来支持多个项目一起构建</li>
<li>使用时需要将 &#x2013;build 标志传递给 tsc 命令</li>
<li>它可以显著提升大型项目的编译效率，因为它会智能地跳过未修改的模块</li>
</ul></li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: harrifeng@outlook.com</p>
<p class="date">Created: 2025-04-22 Tue 12:15</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
