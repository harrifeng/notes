<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2025-02-23 Sun 23:03 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>lt</title>
<meta name="author" content="harrifeng@outlook.com" />
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="src/readtheorg_theme/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="src/readtheorg_theme/css/readtheorg.css"/>
<script type="text/javascript" src="src/lib/js/jquery.min.js"></script>
<script type="text/javascript" src="src/lib/js/bootstrap.min.js"></script>
<script type="text/javascript" src="src/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="src/readtheorg_theme/js/readtheorg.js"></script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">lt</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org94a3df3">1. Chapter 1: From JavaScript to TypeScript</a>
<ul>
<li><a href="#org4a6fa0d">1.1. History of JavaScript</a></li>
<li><a href="#org9b011e2">1.2. Vanilla JavaScript's Pitfalls</a>
<ul>
<li><a href="#org44aaf8b">1.2.1. Costly Freedom</a></li>
<li><a href="#org39b4af2">1.2.2. Losse Documentation</a></li>
<li><a href="#org397e29e">1.2.3. Weaker Developer Tooling</a></li>
</ul>
</li>
<li><a href="#org68f351f">1.3. Typescript!</a></li>
<li><a href="#org6a581da">1.4. Getting Started in the TypeScript Playground</a>
<ul>
<li><a href="#org03e9f4e">1.4.1. TypeScript in Action</a></li>
<li><a href="#orge5431cd">1.4.2. Freedom Through Restriction</a></li>
<li><a href="#org58da87f">1.4.3. Precise Documentation</a></li>
<li><a href="#org08a2178">1.4.4. Stronger Developer Tooling</a></li>
<li><a href="#org523d913">1.4.5. Compiling Syntax</a></li>
</ul>
</li>
<li><a href="#org7064245">1.5. Getting Started Locally</a>
<ul>
<li><a href="#orgfe467e9">1.5.1. Running Locally</a></li>
<li><a href="#org28a0acd">1.5.2. Editor Features</a></li>
</ul>
</li>
<li><a href="#org8343bb1">1.6. What TypeScript is Not</a>
<ul>
<li><a href="#org14af4cb">1.6.1. A Remedy for Bad Code</a></li>
<li><a href="#org6072161">1.6.2. Extensions to JavaScript(Mostly)</a></li>
<li><a href="#org4452538">1.6.3. SLower Than JavaScript</a></li>
<li><a href="#orgd26e057">1.6.4. Finished Evolving</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgae479b6">2. Chapter 2: The Type System</a>
<ul>
<li><a href="#org5ac5dfd">2.1. What's in a Type?</a>
<ul>
<li><a href="#org5dff99a">2.1.1. Type Systems</a></li>
<li><a href="#org2d4419b">2.1.2. Kinds of Errors</a></li>
</ul>
</li>
<li><a href="#orgcc6899b">2.2. Assignability</a>
<ul>
<li><a href="#org0e77bb3">2.2.1. Understanding Assignability Errors</a></li>
</ul>
</li>
<li><a href="#org4fe4a1f">2.3. Type Annotations</a>
<ul>
<li><a href="#org295142b">2.3.1. Unnecessary TYpe Annotaions</a></li>
</ul>
</li>
<li><a href="#org7149689">2.4. Type Shapes</a>
<ul>
<li><a href="#orgfa8d5ab">2.4.1. Modules</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org9f6025d">3. Chapter 3: Unions and Literals</a>
<ul>
<li><a href="#org5e23852">3.1. Union Types</a>
<ul>
<li><a href="#orgf53197a">3.1.1. Declaring Union Types</a></li>
<li><a href="#orge880ff1">3.1.2. Union Preperties</a></li>
</ul>
</li>
<li><a href="#org17e220c">3.2. Narrowing</a>
<ul>
<li><a href="#org3fad4a5">3.2.1. Assignment Narrowing</a></li>
<li><a href="#orgb1a7f8b">3.2.2. Conditional Checks</a></li>
<li><a href="#orgd6c830f">3.2.3. Typeof Checks</a></li>
</ul>
</li>
<li><a href="#org6b235ad">3.3. Literal Types</a>
<ul>
<li><a href="#orgd8af94e">3.3.1. Literal Assignability</a></li>
</ul>
</li>
<li><a href="#org92bdb11">3.4. Strict Null Checking</a>
<ul>
<li><a href="#org4800df4">3.4.1. The Billion-Dollar Mistake</a></li>
<li><a href="#orgf0e781f">3.4.2. Truthiness Narrowing</a></li>
<li><a href="#org4b354f4">3.4.3. Variables Without Initial Values</a></li>
</ul>
</li>
<li><a href="#orgb942e4d">3.5. Type Aliases</a>
<ul>
<li><a href="#org788ed72">3.5.1. Type Aliases Are Not JavaScript</a></li>
<li><a href="#org010cacd">3.5.2. Combining Type Aliases</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org8bda4db">4. Chapter 4: Objects</a>
<ul>
<li><a href="#orga923c01">4.1. Object Types</a>
<ul>
<li><a href="#org0a1c8c5">4.1.1. Declaring Object Types</a></li>
<li><a href="#orgc2cf8b7">4.1.2. Aliased Object Types</a></li>
</ul>
</li>
<li><a href="#org103e5e5">4.2. Structural Typing</a>
<ul>
<li><a href="#org8d39743">4.2.1. Usage Checking</a></li>
<li><a href="#org558a45b">4.2.2. Excess Property Checking</a></li>
<li><a href="#org72df40d">4.2.3. Nested Object Types</a></li>
<li><a href="#org7b43c9d">4.2.4. Optional Properties</a></li>
</ul>
</li>
<li><a href="#org1c47ba8">4.3. Unions of Object Types</a>
<ul>
<li><a href="#orgebf3b72">4.3.1. Inferred Object-Type Unions</a></li>
<li><a href="#orga269ab8">4.3.2. Explicit Object-Type Unions</a></li>
<li><a href="#orgbc05e65">4.3.3. Narrowing Object Types</a></li>
<li><a href="#orgfb76ec1">4.3.4. Discriminated Unions</a></li>
</ul>
</li>
<li><a href="#org8a14c45">4.4. Intersection Types</a>
<ul>
<li><a href="#orgf095726">4.4.1. Dangers of Intersection Types</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-org94a3df3" class="outline-2">
<h2 id="org94a3df3"><span class="section-number-2">1.</span> Chapter 1: From JavaScript to TypeScript</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org4a6fa0d" class="outline-3">
<h3 id="org4a6fa0d"><span class="section-number-3">1.1.</span> History of JavaScript</h3>
<div class="outline-text-3" id="text-1-1">
<ul class="org-ul">
<li>javascript是Brendan Eich在1995年用十天时间发明的语言,由于时间仓促,javascript有很多奇怪的地方</li>
<li>从2015年开始,javascript的规范化组织ECMAScript(因为javascript是火狐浏览器的商标),就每年发布新版本,并
且保证向前兼容</li>
</ul>
</div>
</div>
<div id="outline-container-org9b011e2" class="outline-3">
<h3 id="org9b011e2"><span class="section-number-3">1.2.</span> Vanilla JavaScript's Pitfalls</h3>
<div class="outline-text-3" id="text-1-2">
<ul class="org-ul">
<li>开发者把没有使用任何框架的javascript叫做vanilla(因为香草味是最常见的味道)</li>
<li>实际上很少有项目使用vanilla javascript,因为原生javascript的陷阱实在是太多了,这也是为什么Typescript会诞生的原因</li>
</ul>
</div>
<div id="outline-container-org44aaf8b" class="outline-4">
<h4 id="org44aaf8b"><span class="section-number-4">1.2.1.</span> Costly Freedom</h4>
<div class="outline-text-4" id="text-1-2-1">
<ul class="org-ul">
<li>javascript太过于自由了,导致有很多的问题.
<ul class="org-ul">
<li><p>
比如下面的代码:
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">function</span> <span style="color: #6c3163; font-weight: bold;">paintPainting</span><span style="color: #3a81c3;">(</span><span style="color: #715ab1;">painter</span>, <span style="color: #715ab1;">painting</span><span style="color: #3a81c3;">)</span> <span style="color: #3a81c3;">{</span>
  <span style="color: #3a81c3; font-weight: bold;">return</span> painter
    .prepare<span style="color: #6c3163;">()</span>
    .paint<span style="color: #6c3163;">(</span>painting, painter.ownMaterials<span style="color: #6c3163;">)</span>
    .finish<span style="color: #6c3163;">()</span>;
<span style="color: #3a81c3;">}</span>
</pre>
</div></li>
<li>由于不经过编译器确认,那么一旦paint()函数改名字了,那么代码毫无感觉,知道自己运行到这个地方</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org39b4af2" class="outline-4">
<h4 id="org39b4af2"><span class="section-number-4">1.2.2.</span> Losse Documentation</h4>
<div class="outline-text-4" id="text-1-2-2">
<ul class="org-ul">
<li>由于是动态语言,所以维持js代码的文档是非常困难的,因为:
<ul class="org-ul">
<li>很有可能JSDoc是错误的,因为它和代码是分离的</li>
<li>即便我们JSDoc是正确的,但是随着代码的重构,我们要经常性的去更改那些now-invalid JSDoc,这个是非常困难
也复杂的</li>
<li>描述复杂的对象会非常的复杂</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org397e29e" class="outline-4">
<h4 id="org397e29e"><span class="section-number-4">1.2.3.</span> Weaker Developer Tooling</h4>
<div class="outline-text-4" id="text-1-2-3">
<ul class="org-ul">
<li>Js作为动态语言,天然的没有太多开发者支持工具,比如重命名成员和跳转到定义等</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org68f351f" class="outline-3">
<h3 id="org68f351f"><span class="section-number-3">1.3.</span> Typescript!</h3>
<div class="outline-text-3" id="text-1-3">
<ul class="org-ul">
<li>Typescript由C#,Pascal语言的作者 Anders Hejlsberg在2010年发明,并在2012年开源</li>
<li>我们可以把Typescript看成是如下四个东西:
<ul class="org-ul">
<li>programming language: 一个包含所有Js的syntax的语言,外加新的TypeScript-specific syntax用来定义和使用type</li>
<li>Type checker: 还可以把ts看成是一个程序,用来检查输入的js和ts代码是否正确</li>
<li>Compiler: 还可以把ts卡成是一个编译器,用来把ts代码编译成js代码</li>
<li>Language service: 还可以把ts看成是一个服务,提供给编辑器(比如vs code)来帮助开发者开发代码</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org6a581da" class="outline-3">
<h3 id="org6a581da"><span class="section-number-3">1.4.</span> Getting Started in the TypeScript Playground</h3>
<div class="outline-text-3" id="text-1-4">
<ul class="org-ul">
<li>TypeScript主页包含了一个在线的编辑器,叫TypeScript Playground,地址如下 <a href="https://www.typescriptlang.org/play">https://www.typescriptlang.org/play</a></li>
</ul>
</div>
<div id="outline-container-org03e9f4e" class="outline-4">
<h4 id="org03e9f4e"><span class="section-number-4">1.4.1.</span> TypeScript in Action</h4>
<div class="outline-text-4" id="text-1-4-1">
<ul class="org-ul">
<li><p>
我们先来看看一个代码片段
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">const</span> <span style="color: #715ab1;">firstName</span> = <span style="color: #2d9574;">"Georgia"</span>;
<span style="color: #3a81c3; font-weight: bold;">const</span> <span style="color: #715ab1;">nameLangth</span> = firstName.length<span style="color: #3a81c3;">()</span>;
</pre>
</div></li>
<li>这段如果是js代码的话,在运行时会爆出问题,因为字符串没有length()函数</li>
<li><p>
我们把这段代码贴到Typescript Playground,我们会发现,ts作为language service会帮我们分析到
</p>
<pre class="example" id="orgfb77824">
This expression is not callable.
  Type 'Number' has no call signatures. ts(2349)
</pre></li>
<li>在代码书写阶段就得到警告,好过运行的时候整个程序崩溃</li>
</ul>
</div>
</div>
<div id="outline-container-orge5431cd" class="outline-4">
<h4 id="orge5431cd"><span class="section-number-4">1.4.2.</span> Freedom Through Restriction</h4>
<div class="outline-text-4" id="text-1-4-2">
<ul class="org-ul">
<li>ts允许我们选定参数和变量能够使用的类型</li>
<li>ts还允许我们在函数的定义改变的时候,做出告警</li>
</ul>
</div>
</div>
<div id="outline-container-org58da87f" class="outline-4">
<h4 id="org58da87f"><span class="section-number-4">1.4.3.</span> Precise Documentation</h4>
<div class="outline-text-4" id="text-1-4-3">
<ul class="org-ul">
<li><p>
我们来看看ts版本的paintPainting,即便我们还没引入ts的内容,但是你也可以看出这就是代码本身就是documentation的范本
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #3a81c3; font-weight: bold;">interface</span> <span style="color: #ba2f59; font-weight: bold;">Painter</span> <span style="color: #3a81c3;">{</span>
  <span style="color: #6c3163; font-weight: bold;">finish</span><span style="color: #6c3163;">()</span>: <span style="color: #3a81c3; font-weight: bold;">boolean</span>;
  ownMaterials: <span style="color: #ba2f59; font-weight: bold;">Material</span><span style="color: #6c3163;">[]</span>;
  <span style="color: #6c3163; font-weight: bold;">paint</span><span style="color: #6c3163;">(</span><span style="color: #715ab1;">painting</span>: <span style="color: #3a81c3; font-weight: bold;">string</span>, <span style="color: #715ab1;">materials</span>: <span style="color: #ba2f59; font-weight: bold;">Material</span><span style="color: #2d9574;">[]</span><span style="color: #6c3163;">)</span>: <span style="color: #3a81c3; font-weight: bold;">boolean</span>;
<span style="color: #3a81c3;">}</span>

<span style="color: #3a81c3; font-weight: bold;">function</span> <span style="color: #6c3163; font-weight: bold;">paintPainting</span><span style="color: #3a81c3;">(</span><span style="color: #715ab1;">painter</span>: <span style="color: #ba2f59; font-weight: bold;">Painter</span>, <span style="color: #715ab1;">painting</span>: <span style="color: #3a81c3; font-weight: bold;">string</span><span style="color: #3a81c3;">)</span>: <span style="color: #3a81c3; font-weight: bold;">boolean</span><span style="color: #3a81c3;">{</span><span style="color: #2aa1ae; background-color: #ecf3ec;">/* </span><span style="color: #2aa1ae; background-color: #ecf3ec;">... */</span><span style="color: #3a81c3;">}</span>
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-org08a2178" class="outline-4">
<h4 id="org08a2178"><span class="section-number-4">1.4.4.</span> Stronger Developer Tooling</h4>
<div class="outline-text-4" id="text-1-4-4">
<ul class="org-ul">
<li>Typescript 自己就能为vs code 提供自动补全等功能</li>
</ul>
</div>
</div>
<div id="outline-container-org523d913" class="outline-4">
<h4 id="org523d913"><span class="section-number-4">1.4.5.</span> Compiling Syntax</h4>
<div class="outline-text-4" id="text-1-4-5">
<ul class="org-ul">
<li>Typescript不仅能把ts编译成js,还能把新版本的js编译成老版本的js</li>
<li>我们可以在Typescript playground页面的右侧看到编译好的js代码</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org7064245" class="outline-3">
<h3 id="org7064245"><span class="section-number-3">1.5.</span> Getting Started Locally</h3>
<div class="outline-text-3" id="text-1-5">
<ul class="org-ul">
<li><p>
typescript是作为nodejs的一个module被安装的,如果要本地使用,记得全局安装
</p>
<div class="org-src-container">
<pre class="src src-shell">npm i -g typescript
</pre>
</div></li>
<li><p>
一旦全局安装typescript module成功之后,会有一个tsc的命令放在path
</p>
<div class="org-src-container">
<pre class="src src-shell">$ tsc --version
Version 5.0.4
</pre>
</div></li>
</ul>
</div>
<div id="outline-container-orgfe467e9" class="outline-4">
<h4 id="orgfe467e9"><span class="section-number-4">1.5.1.</span> Running Locally</h4>
<div class="outline-text-4" id="text-1-5-1">
<ul class="org-ul">
<li><p>
在一个空白的文件夹下面运行如下命令,就能在root目录创建一个新的tsconfig.json配置文件
</p>
<div class="org-src-container">
<pre class="src src-shell">$ tsc --init

Created a new tsconfig.json with:
                                                                                                              TS
  target: es2016
  module: commonjs
  strict: true
  esModuleInterop: true
  skipLibCheck: true
  forceConsistentCasingInFileNames: true


You can learn more at https://aka.ms/tsconfig
$ ls -al .
total 24
drwxr-xr-x   3 fenghaoran  staff     96 May  8 17:58 .
drwxr-xr-x  23 fenghaoran  staff    736 May  8 17:58 ..
-rw-r--r--   1 fenghaoran  staff  12288 May  8 17:58 tsconfig.json
</pre>
</div></li>
<li><p>
我们在这个文件夹里面创建一个文件index.ts并且添加如下文本
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #ba2f59; font-weight: bold;">console</span>.<span style="color: #6c3163; font-weight: bold;">blub</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Nothing is worth more than laughter."</span><span style="color: #3a81c3;">)</span>;
</pre>
</div></li>
<li><p>
我们如果使用tsc编译的话,会出现如下错误
</p>
<div class="org-src-container">
<pre class="src src-shell">$ tsc index.ts
index.ts:1:9 - error TS2339: Property <span style="color: #2d9574;">'blub'</span> does not exist on type <span style="color: #2d9574;">'Console'</span>.

1 console.blub<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Nothing is worth more than laughter."</span><span style="color: #3a81c3;">)</span>;
          ~~~~


Found 1 error<span style="color: #3a81c3; font-weight: bold;"> in</span> index.ts:1
</pre>
</div></li>
<li><p>
虽然你的写法tsc认为有问题,但是它还是给你创建了一个新的index.js文件
</p>
<div class="org-src-container">
<pre class="src src-shell">$ cat index.js
<span style="color: #6c3163; font-weight: bold;">console.blub</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Nothing is worth more than laughter."</span><span style="color: #3a81c3;">)</span>;
</pre>
</div></li>
<li>从这里看tsc的编译和我们之前理解的gcc等还是有差别的.</li>
<li><p>
我们更改错误之后,编译就不会有问题了,而且会产生新的正确的js代码
</p>
<div class="org-src-container">
<pre class="src src-shell">$ cat index.ts
<span style="color: #6c3163; font-weight: bold;">console.log</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Nothing is worth more than laughter."</span><span style="color: #3a81c3;">)</span>;
$ tsc index.ts
$ cat index.js
<span style="color: #6c3163; font-weight: bold;">console.log</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Nothing is worth more than laughter."</span><span style="color: #3a81c3;">)</span>;
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-org28a0acd" class="outline-4">
<h4 id="org28a0acd"><span class="section-number-4">1.5.2.</span> Editor Features</h4>
<div class="outline-text-4" id="text-1-5-2">
<ul class="org-ul">
<li>tsconfig.json配置文件的巨大作用,在于让vs code(或者其他编辑器,IDE)能够识别出ts project root folder</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org8343bb1" class="outline-3">
<h3 id="org8343bb1"><span class="section-number-3">1.6.</span> What TypeScript is Not</h3>
<div class="outline-text-3" id="text-1-6">
<ul class="org-ul">
<li>每个工具都有其优点,也有其局限性. ts的局限性总计起来就是</li>
</ul>
</div>
<div id="outline-container-org14af4cb" class="outline-4">
<h4 id="org14af4cb"><span class="section-number-4">1.6.1.</span> A Remedy for Bad Code</h4>
<div class="outline-text-4" id="text-1-6-1">
<ul class="org-ul">
<li>ts只会enforce type safety,它不会强制你使用任何的structure(比如class等)</li>
</ul>
</div>
</div>
<div id="outline-container-org6072161" class="outline-4">
<h4 id="org6072161"><span class="section-number-4">1.6.2.</span> Extensions to JavaScript(Mostly)</h4>
<div class="outline-text-4" id="text-1-6-2">
<ul class="org-ul">
<li>ts的设计目标说,it should:
<ul class="org-ul">
<li>遵守当前的,以及未来的ECMAScript proposal</li>
<li>能够适配所有js的runtime(比如老版本的IE11)</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org4452538" class="outline-4">
<h4 id="org4452538"><span class="section-number-4">1.6.3.</span> SLower Than JavaScript</h4>
<div class="outline-text-4" id="text-1-6-3">
<ul class="org-ul">
<li>关于ts比js慢的观点,是不准确,而且有诱导性的,因为ts慢是因为它首先要转成js,而且编译的时候有类型检查</li>
</ul>
</div>
</div>
<div id="outline-container-orgd26e057" class="outline-4">
<h4 id="orgd26e057"><span class="section-number-4">1.6.4.</span> Finished Evolving</h4>
<div class="outline-text-4" id="text-1-6-4">
<ul class="org-ul">
<li>随着web的继续发展,ts也会不断演进</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-orgae479b6" class="outline-2">
<h2 id="orgae479b6"><span class="section-number-2">2.</span> Chapter 2: The Type System</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-org5ac5dfd" class="outline-3">
<h3 id="org5ac5dfd"><span class="section-number-3">2.1.</span> What's in a Type?</h3>
<div class="outline-text-3" id="text-2-1">
<ul class="org-ul">
<li>所谓的shape,是指有哪些property和method在一个value上,也可以理解为内置的typeof操作符对这个value的解释</li>
<li><p>
比如下面的js代码,如果给ts来理解,它肯定能知道singer是一个string type的变量
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">singer</span> = <span style="color: #2d9574;">"Aretha"</span>
</pre>
</div></li>
<li>js中有如下七中原生类型,ts也同样视他们为原生类型:
<ul class="org-ul">
<li>null</li>
<li>undefined</li>
<li>boolean</li>
<li>string</li>
<li>number</li>
<li>bigint</li>
<li>symbol</li>
</ul></li>
</ul>
</div>
<div id="outline-container-org5dff99a" class="outline-4">
<h4 id="org5dff99a"><span class="section-number-4">2.1.1.</span> Type Systems</h4>
<div class="outline-text-4" id="text-2-1-1">
<ul class="org-ul">
<li>TypeScript的type system总体上是安装如下流程工作的:
<ul class="org-ul">
<li>读取你的代码,理解代码中所有的type,和所有的value</li>
<li>对每个value,试着从其初始化的地方理解其可能有的类型</li>
<li>对每个value,看看在后续代码里面其使用的方式(有没有超过其类型所限)</li>
<li>如果value采用了不符合其类型的操作,反馈给用户</li>
</ul></li>
<li>我们以一个例子来介绍下上面的几步都是什么意思:
<ul class="org-ul">
<li><p>
代码如下
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">firstName</span> = <span style="color: #2d9574;">"Whiteney"</span>;
firstName.length<span style="color: #3a81c3;">()</span>;
<span style="color: #2aa1ae; background-color: #ecf3ec;">//        </span><span style="color: #2aa1ae; background-color: #ecf3ec;">~~~~~~</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">//  </span><span style="color: #2aa1ae; background-color: #ecf3ec;">This expression is not callable.</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">//    </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Type 'Number' has no call signatures</span>
</pre>
</div></li>
<li>ts能够得到上面的报警,是依次通过如下步骤获得的:
<ol class="org-ol">
<li>读取代码,并且理解了代码里面有个变量叫做firstName</li>
<li>总结出来firstName是string类型的,因为它的初始化值为"Whitney"</li>
<li>发现代码会去让firstName去调用.length这个method</li>
<li>终于得到机会进行警告: .length是一个member,而不是一个函数</li>
</ol></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org2d4419b" class="outline-4">
<h4 id="org2d4419b"><span class="section-number-4">2.1.2.</span> Kinds of Errors</h4>
<div class="outline-text-4" id="text-2-1-2">
<ul class="org-ul">
<li>在ts里面一般会遇到两种错误:
<ul class="org-ul">
<li>syntax error: 可以认为是严重错误,导致ts无法转换成js代码(虽然也会产生js代码,但是肯定是错误的,无法运行的)</li>
<li><p>
type error: 可以认为是普通告警,syntax error不存在的情况下(所以ts成功转换成了js代码),但是ts 编译器
认为你的代码可能出错.注意type error是说,从type类型的角度上讲,你是错误的.但是从动态语言的角度讲,
不一定是错误的.比如下面的代码,一个变量开始是字符类型,后来被赋值了true,在ts看来就是type error,但是js
看来,这是再正常不过的代码
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">lastName</span> = <span style="color: #2d9574;">"King"</span>;
lastName = <span style="color: #4e3163;">true</span>;
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgcc6899b" class="outline-3">
<h3 id="orgcc6899b"><span class="section-number-3">2.2.</span> Assignability</h3>
<div class="outline-text-3" id="text-2-2">
<ul class="org-ul">
<li><p>
ts会读取变量的初始化值来判断其类型,如果后面赋值的时候类型一样还好,如果类型不一样,那么报警是跑不了
的了,而且报的就是Type error
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">lastName</span> = <span style="color: #2d9574;">"King"</span>;
lastName = <span style="color: #4e3163;">true</span>;
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Error: Type 'boolean' is not assignable to type 'string'.</span>
</pre>
</div></li>
</ul>
</div>
<div id="outline-container-org0e77bb3" class="outline-4">
<h4 id="org0e77bb3"><span class="section-number-4">2.2.1.</span> Understanding Assignability Errors</h4>
<div class="outline-text-4" id="text-2-2-1">
<ul class="org-ul">
<li>我们要试着理解Type Error报警:
<ul class="org-ul">
<li>比如 Type 'A' is not assignable to type 'B'</li>
<li>意思就是类型A无法赋值给类型B, 类型B是接受者(变量), 类型A是赋值者(新的类型)</li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org4fe4a1f" class="outline-3">
<h3 id="org4fe4a1f"><span class="section-number-3">2.3.</span> Type Annotations</h3>
<div class="outline-text-3" id="text-2-3">
<ul class="org-ul">
<li>如果一个变量没有设置初始化的值,那么ts显然不能assume它的类型,这种情况下,ts认为这个变量的类型是any</li>
<li>any类型很奇怪:
<ul class="org-ul">
<li><p>
一个any类型的变量可以先后被赋值任何类型的数值.如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">rocker</span>;                     <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Type: any</span>
rocker.<span style="color: #6c3163; font-weight: bold;">toUpperCase</span><span style="color: #3a81c3;">()</span>;

rocker = 19.58;
rocker.<span style="color: #6c3163; font-weight: bold;">toPrecision</span><span style="color: #3a81c3;">(</span>1<span style="color: #3a81c3;">)</span>;
</pre>
</div></li>
<li><p>
但是每次赋值相当于让当前变量处于某个类型,不过不能调用其他类型的method,如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">rocker</span>;                     <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Type: any</span>
rocker.<span style="color: #6c3163; font-weight: bold;">toUpperCase</span><span style="color: #3a81c3;">()</span>;

rocker = 19.58;
rocker.<span style="color: #6c3163; font-weight: bold;">toPrecision</span><span style="color: #3a81c3;">(</span>1<span style="color: #3a81c3;">)</span>;

rocker.<span style="color: #6c3163; font-weight: bold;">toUpperCase</span><span style="color: #3a81c3;">()</span>;           <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">error    2339   Property 'toUpperCase' does not exist on type 'number'. (typescript-</span><span style="color: #715ab1;">tide</span><span style="color: #2aa1ae; background-color: #ecf3ec;">)</span>

</pre>
</div></li>
</ul></li>
<li>使用any类型是不推荐的,因为它本质上是一种妥协,一旦设置了any, ts的很多类型检查就不再起作用了</li>
<li>如果没有初始化值,但是还想要设置类型怎么办? ts给出的解决方案是type annotation:
<ul class="org-ul">
<li><p>
type annotation的代码如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">rocker</span>: <span style="color: #3a81c3; font-weight: bold;">string</span>;
rocker = <span style="color: #2d9574;">"Joan Jett"</span>;
</pre>
</div></li>
<li><p>
type annotation是ts的特有syntax, js无法理解. tsc会把上面的ts代码编译成如下的js代码
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">var</span> <span style="color: #715ab1;">rocker</span>;
rocker = <span style="color: #2d9574;">"Joan Jett"</span>;
</pre>
</div></li>
</ul></li>
</ul>
</div>
<div id="outline-container-org295142b" class="outline-4">
<h4 id="org295142b"><span class="section-number-4">2.3.1.</span> Unnecessary TYpe Annotaions</h4>
<div class="outline-text-4" id="text-2-3-1">
<ul class="org-ul">
<li>只有在没有初始化值的情况下才需要type annotation,否则:
<ul class="org-ul">
<li>如果类型和初始化值一样,那么type annotation是多此一举</li>
<li>如果类型和初始化值不一样,那么还会报错</li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org7149689" class="outline-3">
<h3 id="org7149689"><span class="section-number-3">2.4.</span> Type Shapes</h3>
<div class="outline-text-3" id="text-2-4">
<ul class="org-ul">
<li>typescript不仅仅能检查赋值的时候类型是否匹配,还会理解object的shape</li>
<li>所谓object的shape,就是object能够拥有哪些:
<ul class="org-ul">
<li>property</li>
<li>method</li>
</ul></li>
</ul>
</div>
<div id="outline-container-orgfa8d5ab" class="outline-4">
<h4 id="orgfa8d5ab"><span class="section-number-4">2.4.1.</span> Modules</h4>
<div class="outline-text-4" id="text-2-4-1">
<ul class="org-ul">
<li>js自己是没有包版本管理系统的,直到2015年ECMAScript添加了ECMAScript modules(ESM),标准化了如下两个命令:
<ul class="org-ul">
<li><p>
import: 用来从其他文件读取value
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">import</span> <span style="color: #3a81c3;">{</span> value <span style="color: #3a81c3;">}</span> from <span style="color: #2d9574;">"./values"</span>;
</pre>
</div></li>
<li><p>
export: 用来把value导出到其他文件
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">export</span> <span style="color: #3a81c3; font-weight: bold;">const</span> <span style="color: #715ab1;">doubled</span> = value * 2;
</pre>
</div></li>
</ul></li>
<li>本书为了和ECAMScript规范相一致,会严格区分如下两个概念:
<ul class="org-ul">
<li>Module: 包含export或者import的文件</li>
<li>Script: 不是module的文件,都是script</li>
</ul></li>
<li>ts自然是能和Module以及Script都处理好关系的,这是最低要求</li>
<li>moduleA里面如果定义了一个变量, 并不会和moduleB里面定义的其他同名变量相conflict(例外情况是你非要从
moduleB里面import那肯定不行,比如下面的例子),这也是module的魅力
<ul class="org-ul">
<li><p>
两个module里面相同名字,没问题
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">a.ts</span>
<span style="color: #3a81c3; font-weight: bold;">export</span> <span style="color: #3a81c3; font-weight: bold;">const</span> <span style="color: #715ab1;">shared</span> = <span style="color: #2d9574;">"Cher"</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">b.ts</span>
<span style="color: #3a81c3; font-weight: bold;">export</span> <span style="color: #3a81c3; font-weight: bold;">const</span> <span style="color: #715ab1;">shared</span> = <span style="color: #2d9574;">"Cher"</span>;
</pre>
</div></li>
<li><p>
两个module里面相同名字,但是你要从另外一个module import,那么就会declaration conflicts啦
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">a.ts</span>
<span style="color: #3a81c3; font-weight: bold;">export</span> <span style="color: #3a81c3; font-weight: bold;">const</span> <span style="color: #715ab1;">shared</span> = <span style="color: #2d9574;">"Cher"</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">c.ts</span>
<span style="color: #3a81c3; font-weight: bold;">import</span> <span style="color: #3a81c3;">{</span> shared <span style="color: #3a81c3;">}</span> <span style="color: #3a81c3; font-weight: bold;">from</span> <span style="color: #2d9574;">"./a"</span>;
<span style="color: #2aa1ae; background-color: #ecf3ec;">//       </span><span style="color: #2aa1ae; background-color: #ecf3ec;">~~~~~~</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Error: Import declaration conflicts with local declaration of 'shared'.</span>

<span style="color: #3a81c3; font-weight: bold;">export</span> <span style="color: #3a81c3; font-weight: bold;">const</span> <span style="color: #715ab1;">shared</span> = <span style="color: #2d9574;">"Cher"</span>;
<span style="color: #2aa1ae; background-color: #ecf3ec;">//           </span><span style="color: #2aa1ae; background-color: #ecf3ec;">~~~~~~</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">//  </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Error: Individual declarations in merged declaration</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">//  </span><span style="color: #2aa1ae; background-color: #ecf3ec;">'shared' must b all exported or all local</span>
</pre>
</div></li>
</ul></li>
<li>在script里面,可以就不一样了,scriptA里面定义了一个变量,那么ts就认为他是全局的,同一个project下面的另
外一个scriptB文件就完全不能再定义同一个名字的变量了.
<ul class="org-ul">
<li><p>
例子如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">a.ts</span>
<span style="color: #3a81c3; font-weight: bold;">const</span> <span style="color: #715ab1;">shared</span> = <span style="color: #2d9574;">"Cher"</span>;
<span style="color: #2aa1ae; background-color: #ecf3ec;">//    </span><span style="color: #2aa1ae; background-color: #ecf3ec;">~~~~~~</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Cannot redeclare block-scoped variable 'shared'.</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">b.ts</span>
<span style="color: #3a81c3; font-weight: bold;">const</span> <span style="color: #715ab1;">shared</span> = <span style="color: #2d9574;">"Cher"</span>;
<span style="color: #2aa1ae; background-color: #ecf3ec;">//    </span><span style="color: #2aa1ae; background-color: #ecf3ec;">~~~~~~</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Cannot redeclare block-scoped variable 'shared'.</span>
</pre>
</div></li>
<li>上面的俩个文件虽然是.ts文件,但是由于没有import也没有export,那么就认为是普通script(不是module),于
是两个文件里面连同名变量都不能有</li>
<li>以后一旦看到"Cannot redeclare &#x2026;",那么看看是不是你的文件可能是script,避免这个错误的办法可以是转
换script成module</li>
<li><p>
如果实在不需要export和import,还想让你的script成为module,那么可以使用一个export {}.如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">a.ts and b.ts</span>
<span style="color: #3a81c3; font-weight: bold;">const</span> <span style="color: #715ab1;">shared</span> = <span style="color: #2d9574;">"Cher"</span>           <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">ok</span>
<span style="color: #3a81c3; font-weight: bold;">export</span> <span style="color: #3a81c3;">{}</span>;
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org9f6025d" class="outline-2">
<h2 id="org9f6025d"><span class="section-number-2">3.</span> Chapter 3: Unions and Literals</h2>
<div class="outline-text-2" id="text-3">
<ul class="org-ul">
<li>本章主要介绍如下两个特性:
<ul class="org-ul">
<li>Unions: 可以让一个value承载两种或者多种类型</li>
<li>Narrowing: 可以让一个value承载除了某几种类型以外的类型</li>
</ul></li>
</ul>
</div>
<div id="outline-container-org5e23852" class="outline-3">
<h3 id="org5e23852"><span class="section-number-3">3.1.</span> Union Types</h3>
<div class="outline-text-3" id="text-3-1">
<ul class="org-ul">
<li>有种情况,某个类型可能是多种类型
<ul class="org-ul">
<li><p>
代码如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">mathematician</span> = Math.<span style="color: #6c3163; font-weight: bold;">random</span><span style="color: #3a81c3;">()</span> &gt; 0.5
  ? <span style="color: #4e3163;">undefined</span>
  : <span style="color: #2d9574;">"Mark Goldberg"</span>;
</pre>
</div></li>
<li>mathematician是一个either undefined or string的变量.这种"either or"类型在ts
里面就叫做union</li>
<li><p>
Typescript的编译器会分析出来,并且给出mathematician的类型判断如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">mathematician</span>: <span style="color: #3a81c3; font-weight: bold;">string</span> | <span style="color: #4e3163;">undefined</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
<div id="outline-container-orgf53197a" class="outline-4">
<h4 id="orgf53197a"><span class="section-number-4">3.1.1.</span> Declaring Union Types</h4>
<div class="outline-text-4" id="text-3-1-1">
<ul class="org-ul">
<li><p>
union type的定义例子如下: 虽然thinker已经有了初始化值null,但是因为它有可能后面变成string,所以还是
给它一个string的定义
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">thinker</span>: <span style="color: #3a81c3; font-weight: bold;">string</span> | <span style="color: #4e3163;">null</span> = <span style="color: #4e3163;">null</span>;

<span style="color: #3a81c3; font-weight: bold;">if</span> <span style="color: #3a81c3;">(</span>Math.<span style="color: #6c3163; font-weight: bold;">random</span><span style="color: #6c3163;">()</span> &gt; 0.5<span style="color: #3a81c3;">)</span> <span style="color: #3a81c3;">{</span>
  thinker = <span style="color: #2d9574;">"Susanne Langer"</span>;   <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">ok</span>
<span style="color: #3a81c3;">}</span>
</pre>
</div></li>
<li>union里面的多个类型的先后顺序是不重要的</li>
</ul>
</div>
</div>
<div id="outline-container-orge880ff1" class="outline-4">
<h4 id="orge880ff1"><span class="section-number-4">3.1.2.</span> Union Preperties</h4>
<div class="outline-text-4" id="text-3-1-2">
<ul class="org-ul">
<li><p>
如果一个类型是union的,那么ts只允许你访问union内部所有类型都有的member property. 访问只有部分类型有
的member property是会报type-checking error的,例子如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">physicist</span> = Math.<span style="color: #6c3163; font-weight: bold;">random</span><span style="color: #3a81c3;">()</span> &gt; 0.5
  ? <span style="color: #2d9574;">"Marie Curie"</span>
  : 84;

physicist.<span style="color: #6c3163; font-weight: bold;">toString</span><span style="color: #3a81c3;">()</span>;


<span style="color: #2aa1ae; background-color: #ecf3ec;">////////////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">error TS2339: Property 'toUpperCase' does not exist on type 'string | number'. //</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">////////////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">physicist.</span><span style="color: #6c3163; font-weight: bold;">toUpperCase</span><span style="color: #2aa1ae; background-color: #ecf3ec;">();</span>


<span style="color: #2aa1ae; background-color: #ecf3ec;">////////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">error TS2339: Property 'toFixed' does not exist on type 'string | number'. //</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">////////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">physicist.</span><span style="color: #6c3163; font-weight: bold;">toFixed</span><span style="color: #2aa1ae; background-color: #ecf3ec;">();</span>
</pre>
</div></li>
<li>为了能够使用只有某一种类型上才有的property, 代码需要告诉ts,在某处的code是one of those more specific
type:这个过程叫做narrowing</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org17e220c" class="outline-3">
<h3 id="org17e220c"><span class="section-number-3">3.2.</span> Narrowing</h3>
<div class="outline-text-3" id="text-3-2">
<ul class="org-ul">
<li>narrowing的方法有两种:
<ul class="org-ul">
<li>一种通过assignment</li>
<li>另外一种通过check</li>
</ul></li>
</ul>
</div>
<div id="outline-container-org3fad4a5" class="outline-4">
<h4 id="org3fad4a5"><span class="section-number-4">3.2.1.</span> Assignment Narrowing</h4>
<div class="outline-text-4" id="text-3-2-1">
<ul class="org-ul">
<li>assignment narrowing有两种情况:
<ul class="org-ul">
<li><p>
初始化为其中一个类型
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">inventor</span>: <span style="color: #3a81c3; font-weight: bold;">number</span> | <span style="color: #3a81c3; font-weight: bold;">string</span> = <span style="color: #2d9574;">"Hedy Lamarr"</span>;
inventor.<span style="color: #6c3163; font-weight: bold;">toUpperCase</span><span style="color: #3a81c3;">()</span>;         <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #715ab1;">ok</span><span style="color: #2aa1ae; background-color: #ecf3ec;">: </span><span style="color: #715ab1;">string</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;">/////////////////////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">error TS2551: Property 'toFixed' does not exist on type 'string'. Did you mean 'fixed'? //</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">/////////////////////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">inventor.</span><span style="color: #6c3163; font-weight: bold;">toFixed</span><span style="color: #2aa1ae; background-color: #ecf3ec;">();</span>
</pre>
</div></li>
<li><p>
赋值为其中一个类型
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">admiral</span>: <span style="color: #3a81c3; font-weight: bold;">number</span> | <span style="color: #3a81c3; font-weight: bold;">string</span>;
admiral = <span style="color: #2d9574;">"Grace Hopper"</span>;
admiral.<span style="color: #6c3163; font-weight: bold;">toUpperCase</span><span style="color: #3a81c3;">()</span>;         <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #715ab1;">ok</span><span style="color: #2aa1ae; background-color: #ecf3ec;">: </span><span style="color: #715ab1;">string</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;">/////////////////////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">error TS2551: Property 'toFixed' does not exist on type 'string'. Did you mean 'fixed'? //</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">/////////////////////////////////////////////////////////////////////////////////////////////</span>
admiral.<span style="color: #6c3163; font-weight: bold;">toFixed</span><span style="color: #3a81c3;">()</span>;
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgb1a7f8b" class="outline-4">
<h4 id="orgb1a7f8b"><span class="section-number-4">3.2.2.</span> Conditional Checks</h4>
<div class="outline-text-4" id="text-3-2-2">
<ul class="org-ul">
<li><p>
ts非常聪明,能够判定if statement里面的变量当前是什么类型.下面的例子中在if里面scientist是字符串类型,
但是出了循环scientist就不再单单是字符串类型了
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">scientist</span> = Math.<span style="color: #6c3163; font-weight: bold;">random</span><span style="color: #3a81c3;">()</span> &gt; 0.5
  ? <span style="color: #2d9574;">"Rosalind Franklin"</span>
  : 51;

<span style="color: #3a81c3; font-weight: bold;">if</span> <span style="color: #3a81c3;">(</span>scientist === <span style="color: #2d9574;">"Rosalind Franklin"</span><span style="color: #3a81c3;">)</span> <span style="color: #3a81c3;">{</span>
  <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Type of scientist: string</span>
  scientist.<span style="color: #6c3163; font-weight: bold;">toUpperCase</span><span style="color: #6c3163;">()</span>;      <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #715ab1;">ok</span>
<span style="color: #3a81c3;">}</span>


<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">error TS2339: Property 'toUpperCase' does not exist on type 'string | number'.</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">//////////////////////////////</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">scientist.</span><span style="color: #6c3163; font-weight: bold;">toUpperCase</span><span style="color: #2aa1ae; background-color: #ecf3ec;">(); //</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">//////////////////////////////</span>
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-orgd6c830f" class="outline-4">
<h4 id="orgd6c830f"><span class="section-number-4">3.2.3.</span> Typeof Checks</h4>
<div class="outline-text-4" id="text-3-2-3">
<ul class="org-ul">
<li>除了用直接的等于(<code>=</code>)判断,typescript还支持typeof的结果</li>
<li><p>
typeof首先可以判断true的情况
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">researcher</span> = Math.<span style="color: #6c3163; font-weight: bold;">random</span><span style="color: #3a81c3;">()</span> &gt; 0.5
  ? <span style="color: #2d9574;">"Rosalind Franklin"</span>
  : 51;

<span style="color: #3a81c3; font-weight: bold;">if</span> <span style="color: #3a81c3;">(</span><span style="color: #3a81c3; font-weight: bold;">typeof</span> researcher === <span style="color: #2d9574;">"string"</span><span style="color: #3a81c3;">)</span> <span style="color: #3a81c3;">{</span>
  researcher.<span style="color: #6c3163; font-weight: bold;">toUpperCase</span><span style="color: #6c3163;">()</span>;     <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #715ab1;">ok</span>
<span style="color: #3a81c3;">}</span>
</pre>
</div></li>
<li><p>
typeof也可以判断false的情况
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">researcher</span> = Math.<span style="color: #6c3163; font-weight: bold;">random</span><span style="color: #3a81c3;">()</span> &gt; 0.5
  ? <span style="color: #2d9574;">"Rosalind Franklin"</span>
  : 51;

<span style="color: #3a81c3; font-weight: bold;">if</span> <span style="color: #3a81c3;">(</span>!<span style="color: #6c3163;">(</span><span style="color: #3a81c3; font-weight: bold;">typeof</span> researcher === <span style="color: #2d9574;">"string"</span><span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span> <span style="color: #3a81c3;">{</span>
  researcher.<span style="color: #6c3163; font-weight: bold;">toFixed</span><span style="color: #6c3163;">()</span>;          <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #715ab1;">ok</span>
<span style="color: #3a81c3;">}</span> <span style="color: #3a81c3; font-weight: bold;">else</span> <span style="color: #3a81c3;">{</span>
  researcher.<span style="color: #6c3163; font-weight: bold;">toUpperCase</span><span style="color: #6c3163;">()</span>;     <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #715ab1;">ok</span>
<span style="color: #3a81c3;">}</span>
</pre>
</div></li>
<li><p>
我们还可以把typeof写成三元表达式的情况
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">researcher</span> = Math.<span style="color: #6c3163; font-weight: bold;">random</span><span style="color: #3a81c3;">()</span> &gt; 0.5
  ? <span style="color: #2d9574;">"Rosalind Franklin"</span>
  : 51;

<span style="color: #3a81c3; font-weight: bold;">typeof</span> researcher === <span style="color: #2d9574;">"string"</span>
  ? researcher.<span style="color: #6c3163; font-weight: bold;">toUpperCase</span><span style="color: #3a81c3;">()</span>     <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #715ab1;">ok</span>
  : researcher.<span style="color: #6c3163; font-weight: bold;">toFixed</span><span style="color: #3a81c3;">()</span>;          <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #715ab1;">ok</span>
</pre>
</div></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org6b235ad" class="outline-3">
<h3 id="org6b235ad"><span class="section-number-3">3.3.</span> Literal Types</h3>
<div class="outline-text-3" id="text-3-3">
<ul class="org-ul">
<li>先来看个例子
<ul class="org-ul">
<li><p>
例子如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #3a81c3; font-weight: bold;">const</span> <span style="color: #715ab1;">philosopher</span> = <span style="color: #2d9574;">"Hypatia"</span>;
</pre>
</div></li>
<li>这个例子中的philosopher是一个string类型,这也是我们之前学到的内容</li>
<li>我们这里要学到的是,philosopher不仅仅是string类型,它还是一个更具体的类型,叫做"Hypatia"类型</li>
<li><p>
这种"更具体的类型",就是literal type,具体点说就是
</p>
<pre class="example" id="org5c33589">
The type of a value thatis known to be a specific value of a primitive,
rather than any of those primitive's value at all
</pre></li>
</ul></li>
<li>我们来看看"string类型"和"Hypatia类型"的区别:
<ul class="org-ul">
<li>primitive type string代表了所有可能的字符串</li>
<li>literal type Hypatia只能代表一种字符串</li>
</ul></li>
<li><p>
如果你创建了变量,并且给它设置为const,那么ts就直接给这个变量设置为literal type,比如下面的例子中,
mathematician的类型就是 "Mark Goldberg"
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #3a81c3; font-weight: bold;">const</span> <span style="color: #715ab1;">mathematician</span> = <span style="color: #2d9574;">"Mark Goldberg"</span>;
</pre>
</div></li>
<li><p>
你可以把每个primitive type都看成是所有可能的literal value的union
</p>
<pre class="example" id="org90ec33e">
You can think of each primitive type as a union of every possible matching literal value
</pre></li>
<li><p>
union type annotation可以混合literal和primitive,比如下面的例子
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">lifespan</span>: <span style="color: #3a81c3; font-weight: bold;">number</span> | <span style="color: #2d9574;">"ongoing"</span> | <span style="color: #2d9574;">"uncertain"</span>;

lifespan = 89;                   <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">ok</span>
lifespan = <span style="color: #2d9574;">"ongoing"</span>;            <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">ok</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;">/////////////////////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">error TS2322: Type 'true' is not assignable to type 'number | "ongoing" | "uncertain"'. //</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">/////////////////////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">//</span><span style="color: #2aa1ae; background-color: #ecf3ec;">lifespan = true;</span>
</pre>
</div></li>
</ul>
</div>
<div id="outline-container-orgd8af94e" class="outline-4">
<h4 id="orgd8af94e"><span class="section-number-4">3.3.1.</span> Literal Assignability</h4>
<div class="outline-text-4" id="text-3-3-1">
<ul class="org-ul">
<li>literal type可不是简单说说一下,它真的是一个类型:
<ul class="org-ul">
<li>我们知道,不通的primitive 类型相互之间不能赋值:比如number和string不能相互赋值</li>
<li>不同的literal type之间也不能相互赋值(虽然他们属于同一种primitive type)</li>
</ul></li>
<li>我们可以从下面的例子证明这一点:
<ul class="org-ul">
<li><p>
例子如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">specificallyAda</span>: <span style="color: #2d9574;">"Ada"</span>;
specificallyAda = <span style="color: #2d9574;">"Ada"</span>;         <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">ok</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;">/////////////////////////////////////////////////////////////////////</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">error TS2322: Type '"Byron"' is not assignable to type '"Ada"'. //</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">/////////////////////////////////////////////////////////////////////</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">specificallyAda = "Byron";</span>

<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">someStirng</span> = <span style="color: #2d9574;">""</span>;            <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Type: string</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;">////////////////////////////////////////////////////////////////////</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">error TS2322: Type 'string' is not assignable to type '"Ada"'. //</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">////////////////////////////////////////////////////////////////////</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">specificallyAda = someStirng</span>
</pre>
</div></li>
<li><p>
注意,创建一个literal type除了使用const,还可以把literal 类型像其他类型一样写在':'后面,但是注意,虽
然specificallyAda的值只能是"Ada"(因为他是"Ada"类型的),但是初始化之后没有赋值,还是不能访问的,否则
会报错.例子如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">specificallyAda</span>: <span style="color: #2d9574;">"Ada"</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">/////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">error TS2454: Variable 'specificallyAda' is used before being assigned. //</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">/////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">console.</span><span style="color: #6c3163; font-weight: bold;">log</span><span style="color: #2aa1ae; background-color: #ecf3ec;">(specificallyAda)</span>

specificallyAda = <span style="color: #2d9574;">"Ada"</span>;         <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">ok</span>
<span style="color: #ba2f59; font-weight: bold;">console</span>.<span style="color: #6c3163; font-weight: bold;">log</span><span style="color: #3a81c3;">(</span>specificallyAda<span style="color: #3a81c3;">)</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Ada</span>
</pre>
</div></li>
</ul></li>
<li>literal type相互之间不可用赋值,但是literal type却可以"向上"赋值给自己所在的primitive type,这也是
literal type作为比primitive低一个级别类型的特点."向上"赋值随时可见,只是我们没有想到.比如下面这两个
都是向上赋值:
<ul class="org-ul">
<li><p>
比较"严谨"的向上赋值
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">smile</span> : <span style="color: #2d9574;">":)"</span>;
smile = <span style="color: #2d9574;">":)"</span>;
<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">something</span> = <span style="color: #2d9574;">""</span>;

something = smile
<span style="color: #ba2f59; font-weight: bold;">console</span>.<span style="color: #6c3163; font-weight: bold;">log</span><span style="color: #3a81c3;">(</span>something<span style="color: #3a81c3;">)</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">:)</span>
</pre>
</div></li>
<li><p>
比较"常见"的向上赋值,其实是上面"严谨"版本的简化版
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">someString</span> = <span style="color: #2d9574;">":)"</span>;
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org92bdb11" class="outline-3">
<h3 id="org92bdb11"><span class="section-number-3">3.4.</span> Strict Null Checking</h3>
<div class="outline-text-3" id="text-3-4">
<ul class="org-ul">
<li>narrowed union在加上literal能够让ts非常从容的处理strict null checking</li>
</ul>
</div>
<div id="outline-container-org4800df4" class="outline-4">
<h4 id="org4800df4"><span class="section-number-4">3.4.1.</span> The Billion-Dollar Mistake</h4>
<div class="outline-text-4" id="text-3-4-1">
<ul class="org-ul">
<li>所谓的billion-dollar mistake是指, null value的发明者认为这不是一个好的发明,把null value引入编程语言
导致了几十亿美元的损失.</li>
<li>ts的编译器包含了很多option,允许我们配置编译器,最著名的一个选项就是strictNullChecks:
<ul class="org-ul">
<li><p>
如果enable,那么null(undefined)不能赋值给其他类型变量,默认的配置就是这样的
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">someString</span> = <span style="color: #2d9574;">"abc"</span>;
<span style="color: #ba2f59; font-weight: bold;">console</span>.<span style="color: #6c3163; font-weight: bold;">log</span><span style="color: #3a81c3;">(</span>someString<span style="color: #3a81c3;">)</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;">///////////////////////////////////////////////////////////////////</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">error TS2322: Type 'null' is not assignable to type 'string'. //</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">///////////////////////////////////////////////////////////////////</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">someString = null;</span>
</pre>
</div></li>
<li><p>
如果disable,那么显然就是null(undefined)可以赋值给其他变量.其实质上的原理,就是给每个类型添加如下
代码
</p>
<div class="org-src-container">
<pre class="src src-typescript">| <span style="color: #4e3163;">null</span> | <span style="color: #4e3163;">undefined</span>
</pre>
</div></li>
</ul></li>
<li>ts的最佳实践就是开启strictNullCheck,否则无法规避某些null和undefined对代码的破坏</li>
</ul>
</div>
</div>
<div id="outline-container-orgf0e781f" class="outline-4">
<h4 id="orgf0e781f"><span class="section-number-4">3.4.2.</span> Truthiness Narrowing</h4>
<div class="outline-text-4" id="text-3-4-2">
<ul class="org-ul">
<li>在js里面,判断一个变量是否为true原理如下:变量只要不是如下值,那么它们就是true:
<ul class="org-ul">
<li>false</li>
<li>0</li>
<li>-0</li>
<li>0n</li>
<li>""</li>
<li>null</li>
<li>undefined</li>
<li>NaN</li>
</ul></li>
<li>基于js的这些设置,那么ts可以在某些if为true的case里面,narrowing类型成功(到一种)
<ul class="org-ul">
<li><p>
例子如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">geneticist</span> = Math.<span style="color: #6c3163; font-weight: bold;">random</span><span style="color: #3a81c3;">()</span> &gt; 0.5
  ? <span style="color: #2d9574;">"Barbara McClintock"</span>
  : <span style="color: #4e3163;">undefined</span>;

<span style="color: #3a81c3; font-weight: bold;">if</span> <span style="color: #3a81c3;">(</span>geneticist<span style="color: #3a81c3;">)</span> <span style="color: #3a81c3;">{</span>
  geneticist.<span style="color: #6c3163; font-weight: bold;">toUpperCase</span><span style="color: #6c3163;">()</span>;      <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #715ab1;">ok</span><span style="color: #2aa1ae; background-color: #ecf3ec;">: </span><span style="color: #715ab1;">string</span>
<span style="color: #3a81c3;">}</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;">//////////////////////////////////////////////////////////</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">error TS18048: 'geneticist' is possibly 'undefined'. //</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">//////////////////////////////////////////////////////////</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">geneticist.</span><span style="color: #6c3163; font-weight: bold;">toUpperCase</span><span style="color: #2aa1ae; background-color: #ecf3ec;">();</span>
</pre>
</div></li>
<li>上面例子中,由于undefined是不可能为true的,那么if 里面是必然是string类型的</li>
<li>在if之外,就不能narrowing了,强制调用toUpperCase()会失败</li>
</ul></li>
<li>注意,这种narrowing只能在true case里面起作用,无法在false case里面起作用,因为空字符串("")和undefined
都被认为是false</li>
</ul>
</div>
</div>
<div id="outline-container-org4b354f4" class="outline-4">
<h4 id="org4b354f4"><span class="section-number-4">3.4.3.</span> Variables Without Initial Values</h4>
<div class="outline-text-4" id="text-3-4-3">
<ul class="org-ul">
<li>在js里面,如果一个变量声明之后,没有给初始化值,那么这个变量就会初始化成undefined</li>
<li>在ts中如果试图使用一个值为undefined的变量(声明之后没有赋值的变量),ts会报一个特定的错误,
<ul class="org-ul">
<li><p>
代码如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">mathematician</span>: <span style="color: #3a81c3; font-weight: bold;">string</span>;
<span style="color: #2aa1ae; background-color: #ecf3ec;">///////////////////////////////////////////////////////////////////////////</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">error TS2454: Variable 'mathematician' is used before being assigned. //</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">///////////////////////////////////////////////////////////////////////////</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">mathematician?.length;</span>

mathematician = <span style="color: #2d9574;">"Mark Goldberg"</span>;
mathematician.length;
</pre>
</div></li>
<li><p>
上面例子中出现了 `?`, 这是ts里面特有的安全链式调用,详细解释如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&#36825;&#37324; Error&#23545;&#35937;&#23450;&#20041;&#30340;stack&#26159;&#21487;&#36873;&#21442;&#25968;&#65292;&#22914;&#26524;&#36825;&#26679;&#20889;&#30340;&#35805;&#32534;&#35793;&#22120;&#20250;&#25552;&#31034;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&#20986;&#38169; TS2532: Object is possibly 'undefined'.</span>
<span style="color: #3a81c3; font-weight: bold;">return</span> <span style="color: #3a81c3; font-weight: bold;">new</span> <span style="color: #ba2f59; font-weight: bold;">Error</span><span style="color: #3a81c3;">()</span>.stack.<span style="color: #6c3163; font-weight: bold;">split</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">'\n'</span><span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&#25105;&#20204;&#21487;&#20197;&#28155;&#21152;?&#25805;&#20316;&#31526;&#65292;&#24403;stack&#23646;&#24615;&#23384;&#22312;&#26102;&#65292;&#35843;&#29992; stack.split&#12290;&#33509;stack&#19981;&#23384;&#22312;&#65292;&#21017;&#36820;&#22238;&#31354;</span>
<span style="color: #3a81c3; font-weight: bold;">return</span> <span style="color: #3a81c3; font-weight: bold;">new</span> <span style="color: #ba2f59; font-weight: bold;">Error</span><span style="color: #3a81c3;">()</span>.stack?.<span style="color: #6c3163; font-weight: bold;">split</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">'\n'</span><span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&#20197;&#19978;&#20195;&#30721;&#31561;&#21516;&#20197;&#19979;&#20195;&#30721;, &#24863;&#35874; @dingyanhe &#30340;&#30417;&#30563;</span>
<span style="color: #3a81c3; font-weight: bold;">const</span> <span style="color: #715ab1;">err</span> = <span style="color: #3a81c3; font-weight: bold;">new</span> <span style="color: #ba2f59; font-weight: bold;">Error</span><span style="color: #3a81c3;">()</span>;
<span style="color: #3a81c3; font-weight: bold;">return</span> err.stack &amp;&amp; err.stack.<span style="color: #6c3163; font-weight: bold;">split</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">'\n'</span><span style="color: #3a81c3;">)</span>;
</pre>
</div></li>
<li><p>
注意,如果类型里面union了undefined,那么上面的错误不会发生
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">mathematician</span>: <span style="color: #3a81c3; font-weight: bold;">string</span> | <span style="color: #4e3163;">undefined</span>;
<span style="color: #ba2f59; font-weight: bold;">console</span>.<span style="color: #6c3163; font-weight: bold;">log</span><span style="color: #3a81c3;">(</span>mathematician?.length<span style="color: #3a81c3;">)</span>;

mathematician = <span style="color: #2d9574;">"Mark Goldberg"</span>;
mathematician.length;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">undefined</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgb942e4d" class="outline-3">
<h3 id="orgb942e4d"><span class="section-number-3">3.5.</span> Type Aliases</h3>
<div class="outline-text-3" id="text-3-5">
<ul class="org-ul">
<li><p>
绝大多数情况下,union只有两三个成员,但是也有出现很多成员的情况,如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">rawDataFirst</span>: <span style="color: #3a81c3; font-weight: bold;">boolean</span> | <span style="color: #3a81c3; font-weight: bold;">number</span> | <span style="color: #3a81c3; font-weight: bold;">string</span> | <span style="color: #4e3163;">null</span> | <span style="color: #4e3163;">undefined</span>
<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">rawDataSecond</span>: <span style="color: #3a81c3; font-weight: bold;">boolean</span> | <span style="color: #3a81c3; font-weight: bold;">number</span> | <span style="color: #3a81c3; font-weight: bold;">string</span> | <span style="color: #4e3163;">null</span> | <span style="color: #4e3163;">undefined</span>
<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">rawDataThird</span>: <span style="color: #3a81c3; font-weight: bold;">boolean</span> | <span style="color: #3a81c3; font-weight: bold;">number</span> | <span style="color: #3a81c3; font-weight: bold;">string</span> | <span style="color: #4e3163;">null</span> | <span style="color: #4e3163;">undefined</span>
</pre>
</div></li>
<li><p>
上述例子中的 `boolean | number | string | null | undefined` 被使用了多次,为了保证DRY原则,ts又设计了
重用type列表的type alias,上面的例子就可以改写成如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #3a81c3; font-weight: bold;">type</span> <span style="color: #ba2f59; font-weight: bold;">RawData</span> = <span style="color: #3a81c3; font-weight: bold;">boolean</span> | <span style="color: #3a81c3; font-weight: bold;">number</span> | <span style="color: #3a81c3; font-weight: bold;">string</span> | <span style="color: #4e3163;">null</span> | <span style="color: #4e3163;">undefined</span>

<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">rawDataFirst</span>: <span style="color: #ba2f59; font-weight: bold;">RawData</span>
<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">rawDataSecond</span>: <span style="color: #ba2f59; font-weight: bold;">RawData</span>
<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">rawDataThird</span>: <span style="color: #ba2f59; font-weight: bold;">RawData</span>
</pre>
</div></li>
</ul>
</div>
<div id="outline-container-org788ed72" class="outline-4">
<h4 id="org788ed72"><span class="section-number-4">3.5.1.</span> Type Aliases Are Not JavaScript</h4>
<div class="outline-text-4" id="text-3-5-1">
<ul class="org-ul">
<li>type alias不会编译成javascript,它只存在于typescript里面</li>
<li><p>
既然不会被编译成js,那么你在运行时想access这个变量就是违法的,ts会报警
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #3a81c3; font-weight: bold;">type</span> <span style="color: #ba2f59; font-weight: bold;">SomeType</span> = <span style="color: #3a81c3; font-weight: bold;">string</span> | <span style="color: #4e3163;">undefined</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">////////////////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">error TS2693: 'SomeType' only refers to a type, but is being used as a value here. //</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">////////////////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">console.</span><span style="color: #6c3163; font-weight: bold;">log</span><span style="color: #2aa1ae; background-color: #ecf3ec;">(SomeType)</span>
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-org010cacd" class="outline-4">
<h4 id="org010cacd"><span class="section-number-4">3.5.2.</span> Combining Type Aliases</h4>
<div class="outline-text-4" id="text-3-5-2">
<ul class="org-ul">
<li><p>
type alias还可以互相引用
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #3a81c3; font-weight: bold;">type</span> <span style="color: #ba2f59; font-weight: bold;">Id</span> = <span style="color: #3a81c3; font-weight: bold;">number</span> | <span style="color: #3a81c3; font-weight: bold;">string</span>

<span style="color: #3a81c3; font-weight: bold;">type</span> <span style="color: #ba2f59; font-weight: bold;">IdMaybe</span> = Id | <span style="color: #4e3163;">undefined</span> | <span style="color: #4e3163;">null</span>; <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Equivalent to: number | string | undefind | null</span>
</pre>
</div></li>
<li><p>
互相引用的时候,不必要又顺序,ts编译器会全局考虑,所以使用未定义的type alias也是允许的
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #3a81c3; font-weight: bold;">type</span> <span style="color: #ba2f59; font-weight: bold;">IdMaybe</span> = Id | <span style="color: #4e3163;">undefined</span> | <span style="color: #4e3163;">null</span>; <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Equivalent to: number | string | undefind | null</span>
<span style="color: #3a81c3; font-weight: bold;">type</span> <span style="color: #ba2f59; font-weight: bold;">Id</span> = <span style="color: #3a81c3; font-weight: bold;">number</span> | <span style="color: #3a81c3; font-weight: bold;">string</span>
</pre>
</div></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org8bda4db" class="outline-2">
<h2 id="org8bda4db"><span class="section-number-2">4.</span> Chapter 4: Objects</h2>
<div class="outline-text-2" id="text-4">
</div>
<div id="outline-container-orga923c01" class="outline-3">
<h3 id="orga923c01"><span class="section-number-3">4.1.</span> Object Types</h3>
<div class="outline-text-3" id="text-4-1">
<ul class="org-ul">
<li>在ts/js里面,有种创建object的方法叫做object literal
<ul class="org-ul">
<li><p>
样子如下
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">const</span> <span style="color: #715ab1;">person</span> = <span style="color: #3a81c3;">{</span>
  name: <span style="color: #2d9574;">"adam"</span>,
  age: 23,
<span style="color: #3a81c3;">}</span>;
console.log<span style="color: #3a81c3;">(</span>person<span style="color: #3a81c3;">)</span>
console.log<span style="color: #3a81c3;">(</span><span style="color: #3a81c3; font-weight: bold;">typeof</span><span style="color: #6c3163;">(</span>person<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">{ name: 'adam', age: 23 }</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">object</span>
</pre>
</div></li>
<li>在js的语境中person的类型就是object</li>
</ul></li>
<li>ts中当然也承认这种用法,并且ts还做了js没有做的事情,给新的object person一个更加具体的类型
<ul class="org-ul">
<li>类型名字叫'{name: string; age: number;}'</li>
<li><p>
这个类型我们可以通过typescript playground可以看到,也可以通过如下的"错误"代码看到
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #3a81c3; font-weight: bold;">const</span> <span style="color: #715ab1;">person</span> = <span style="color: #3a81c3;">{</span>
  name: <span style="color: #2d9574;">"adam"</span>,
  age: 23,
<span style="color: #3a81c3;">}</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">/////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Property 'foo' does not exist on type '{ name: string; age: number; }'. //</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">/////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">person.</span><span style="color: #6c3163; font-weight: bold;">foo</span><span style="color: #2aa1ae; background-color: #ecf3ec;">()</span>
</pre>
</div></li>
</ul></li>
<li>在js和ts中,我们都可以使用如下两种方式访问object value的成员:
<ul class="org-ul">
<li>object_value.mameber</li>
<li>object_value['member']</li>
</ul></li>
<li><p>
如果访问不存在的member,那么会报警
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #3a81c3; font-weight: bold;">const</span>  <span style="color: #715ab1;">poet</span> = <span style="color: #3a81c3;">{</span>
  born: 1935,
  name: <span style="color: #2d9574;">"Mary Oliver"</span>,
<span style="color: #3a81c3;">}</span>;

<span style="color: #ba2f59; font-weight: bold;">console</span>.<span style="color: #6c3163; font-weight: bold;">log</span><span style="color: #3a81c3;">(</span>poet<span style="color: #6c3163;">[</span><span style="color: #2d9574;">'born'</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>;
<span style="color: #ba2f59; font-weight: bold;">console</span>.<span style="color: #6c3163; font-weight: bold;">log</span><span style="color: #3a81c3;">(</span>poet.name<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">////////////////////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">error TS2339: Property 'end' does not exist on type '{ born: number; name: string; }'. //</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">////////////////////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">poet.end;</span>
</pre>
</div></li>
</ul>
</div>
<div id="outline-container-org0a1c8c5" class="outline-4">
<h4 id="org0a1c8c5"><span class="section-number-4">4.1.1.</span> Declaring Object Types</h4>
<div class="outline-text-4" id="text-4-1-1">
<ul class="org-ul">
<li>ts作为一个静态的类型系统语言,当然会提供"显式"定义object type的功能
<ul class="org-ul">
<li><p>
代码如下
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">poetLater</span>: <span style="color: #3a81c3;">{</span>
  born: <span style="color: #3a81c3; font-weight: bold;">number</span>;
  name: <span style="color: #3a81c3; font-weight: bold;">string</span>;
<span style="color: #3a81c3;">}</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">ok</span>
poetLater = <span style="color: #3a81c3;">{</span>
  born: 1935,
  name: <span style="color: #2d9574;">"Mary Oliver"</span>,
<span style="color: #3a81c3;">}</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">//////////////////////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">error TS2322: Type 'string' is not assignable to type '{ born: number; name: string; }'. //</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">//////////////////////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">poetLater = "Sappho";</span>
</pre>
</div></li>
<li>注意这里的类型就是type '{ born: number; name: string; }'</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgc2cf8b7" class="outline-4">
<h4 id="orgc2cf8b7"><span class="section-number-4">4.1.2.</span> Aliased Object Types</h4>
<div class="outline-text-4" id="text-4-1-2">
<ul class="org-ul">
<li>我们发现上一节讲到的ts的类型名字都是这样的type '{ born: number; name: string; }', 这种名字是类似"匿名"
的这么一种方式(只有类型的属性,没有名字)</li>
<li><p>
如果我们想给不同的变量赋予类型,显然还是"非匿名"的方式更好,也就是给object type一个名字.这样一来,我们
的error message也会更加易读
</p>
<div class="org-src-container">
<pre class="src src-typescript"><span style="color: #3a81c3; font-weight: bold;">type</span> <span style="color: #ba2f59; font-weight: bold;">Poet</span> = <span style="color: #3a81c3;">{</span>
  born: <span style="color: #3a81c3; font-weight: bold;">number</span>;
  name: <span style="color: #3a81c3; font-weight: bold;">string</span>;
<span style="color: #3a81c3;">}</span>;

<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">poetLater</span>: <span style="color: #ba2f59; font-weight: bold;">Poet</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">ok</span>
poetLater = <span style="color: #3a81c3;">{</span>
  born: 1935,
  name: <span style="color: #2d9574;">"Sara Teasdale"</span>,
<span style="color: #3a81c3;">}</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">///////////////////////////////////////////////////////////////////</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">error TS2322: Type 'string' is not assignable to type 'Poet'. //</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">///////////////////////////////////////////////////////////////////</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">poetLater = "Emily Dickinson"</span>
</pre>
</div></li>
<li>理解ts如何解析object literal对于我们理解ts的type system非常重要,本节内容对后面理解也非常重要</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org103e5e5" class="outline-3">
<h3 id="org103e5e5"><span class="section-number-3">4.2.</span> Structural Typing</h3>
<div class="outline-text-3" id="text-4-2">
</div>
<div id="outline-container-org8d39743" class="outline-4">
<h4 id="org8d39743"><span class="section-number-4">4.2.1.</span> Usage Checking</h4>
</div>
<div id="outline-container-org558a45b" class="outline-4">
<h4 id="org558a45b"><span class="section-number-4">4.2.2.</span> Excess Property Checking</h4>
</div>
<div id="outline-container-org72df40d" class="outline-4">
<h4 id="org72df40d"><span class="section-number-4">4.2.3.</span> Nested Object Types</h4>
</div>
<div id="outline-container-org7b43c9d" class="outline-4">
<h4 id="org7b43c9d"><span class="section-number-4">4.2.4.</span> Optional Properties</h4>
</div>
</div>
<div id="outline-container-org1c47ba8" class="outline-3">
<h3 id="org1c47ba8"><span class="section-number-3">4.3.</span> Unions of Object Types</h3>
<div class="outline-text-3" id="text-4-3">
</div>
<div id="outline-container-orgebf3b72" class="outline-4">
<h4 id="orgebf3b72"><span class="section-number-4">4.3.1.</span> Inferred Object-Type Unions</h4>
</div>
<div id="outline-container-orga269ab8" class="outline-4">
<h4 id="orga269ab8"><span class="section-number-4">4.3.2.</span> Explicit Object-Type Unions</h4>
</div>
<div id="outline-container-orgbc05e65" class="outline-4">
<h4 id="orgbc05e65"><span class="section-number-4">4.3.3.</span> Narrowing Object Types</h4>
</div>
<div id="outline-container-orgfb76ec1" class="outline-4">
<h4 id="orgfb76ec1"><span class="section-number-4">4.3.4.</span> Discriminated Unions</h4>
</div>
</div>
<div id="outline-container-org8a14c45" class="outline-3">
<h3 id="org8a14c45"><span class="section-number-3">4.4.</span> Intersection Types</h3>
<div class="outline-text-3" id="text-4-4">
</div>
<div id="outline-container-orgf095726" class="outline-4">
<h4 id="orgf095726"><span class="section-number-4">4.4.1.</span> Dangers of Intersection Types</h4>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: harrifeng@outlook.com</p>
<p class="date">Created: 2025-02-23 Sun 23:03</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>