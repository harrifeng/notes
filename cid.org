#+SETUPFILE: ~/github/notes/setup/theme-readtheorg-local.setup
#+OPTIONS: ^:{}
#+TITLE: cid
#+STARTUP: latexpreview
* Chapter 01: Cascade, specificity, and inheritance
+ CSS不同于软件开发世界中的诸多事物:
  - 它并非传统意义上的编程语言，却需要抽象思维
  - 它不完全是设计工具却需要创造力
  - 它提供看似简单的声明式语法，但如果你参与过大型项目，就会明白它能演变成难以控制的复杂体系
+ 当你需要学习传统编程中的某项操作时,通常能明确该搜索什么（例如"如何在数组中查找x类型的元素?"）
+ 但使用CSS时，问题往往难以提炼成单一提问。即便能够提炼，答案也常是"视情况而定",实现目标的最佳方式往
  往取决于你的特定约束条件，以及你希望如何精确处理各种边界情况
+ 为了能够更好的学习,我们首先来总结一下常见的术语:
  - 下面这行css代码叫做declaration,一行declaration包含一个property(也就是下面的color)和一个value(也就是下面的black)
    #+begin_src css
      clolor: black
    #+end_src
  - 多个declaration包含在一个{}里面,就叫做declaration block,下例中的{}就是一个declaration block
    #+begin_src css
      body {
          color: black;
          font-family: Helvetica;
      }
    #+end_src
  - 每个declaration block前面还必须有一个selector,这个selector用来表示"后面的declaration block"将应用
    于页面上的哪些元素.上例中的body,就是一个selector,它表示后面的declaration block会被应用于body
  - 上面的selector和它后面的declaration block联合起来,叫一个ruleset.
  - ruleset的同义词是rule.但是这个名字很少使用.rule的复数形式rules用来泛指更多样式的组合
  - at-rules是指以'@'开头的语言结构,比如@import
+ 第一部分从CSS最根本的原理讲起:
  - 层叠（cascade）
  - 盒模型（box model）
  - 多样的单位体系
+ 多数开发者都听说过层叠和盒模型的概念，他们了解像素单位，或许也听过“应该用em单位替代像素”的建议。但事
  实是，这些主题蕴含的知识远不止于此——对它们的浅显理解只能让你走这么远。
+ 若想真正精通CSS，你必须首先深入掌握这些基础原理，并且是透彻地掌握
+ 本书的目标是巩固读者的css知识体系和根基,所以我们会从基础原理讲起,回顾核心概念后,我们会对每个核心概念进行深入讨论
** The cascade
+ 本质上来说,css的核心就是用来声明rules(前面讲过,rules是泛指不同样式): 也就是,在不同条件下触发特定的样式效果:
  - 当一个class被加到这个element的时候,应用这个style
  - 当elementX是elementY的child的时候,应用那个style
  - 浏览器会解析这些规则,并且确定各个规则的适用位置,最终通过渲染引擎将样式呈现到页面上
+ ​虽然在小规模示例中,CSS规则的解析过程通常清晰明了,但随着样式表规模扩大或应用页面增多，代码复杂度可能迅速攀升.
+ CSS往往提供多种途径实现相同效果——而根据所选方案的不同,当HTML结构变更或样式应用于不同页面时,结果可能截然不同
+ CSS开发的核心挑战，在于编写具备可预测性的规则.
+ 实现(编写具备可预测性的规则)这一目标的首要步骤，是确切理解浏览器如何解析CSS规则:
  - 每个规则本身可能简单明了，但当两条规则对同一元素的样式提供冲突信息时会发生什么?
  - 你可能会发现某条规则未按预期生效——因为另一条规则与其产生了冲突.
  - 要准确预测规则行为，必须深入理解层叠机制（cascade）
+ 我们通过例子来展示下CSS ruleset的冲突如何解决
  - 下面是我们的html的例子,其中<style>和</style>就是css需要写入的地方
    #+begin_src html
      <!doctype html>
      <head>
        <meta charset="utf-8" />
        <style>
          /* styles added in subsequent listings */
        </style>
      </head>
      <body>
        <header class="page-header">
          <h1 id="page-title" class="title">Wombat Coffee Roasters</h1>
          <nav>
            <ul id="main-nav" class="nav">
              <li><a href="/">Home</a></li>
              <li><a href="/coffees">Coffees</a></li>
              <li><a href="/brewers">Brewers</a></li>
              <li><a href="/specials" class="featured">Specials</a></li>
            </ul>
          </nav>
        </header>
      </body>
    #+end_src
  - 我们的css需要修饰三个地方:
    1) Wombat Coffe Roasters这个h1的title,class为title
    2) class为nav的一系列navigation link
    3) class为featured的navigation link(特殊的那个link)
  - 我们先看一个ruleset冲突的例子,我们分别使用了tag, id selector和class selector三种方式来命中了我们的title
    #+begin_src css
      h1 {
        font-family: serif;
      }

      #page-title {
        font-family: sans-serif;
      }

      .title {
        font-family: monospace;
      }
    #+end_src
  - title不可能有三种字体,那么上面的代码运行后的结果是什么呢?答案是ID selector赢了,我们的title使用了
    sans serif字体
  - 这就是所谓的cascade的例子:在多个ruleset相互冲突的时候,决定哪个ruleset起作用.
+ 下面我们解析层叠规则。当声明冲突时，层叠会按 *以下顺序* 通过六个标准来判断多个冲突ruleset的优先级。
  一旦某种标准解决了优先级问题,就退出,否则就继续使用下一个标准进行解决. 我们将逐一深入探讨这六个标准:
  1) 样式表来源(Stylesheet origin)——样式来自何处。你的样式会与浏览器的默认样式共同应用
  2) 内联样式(Inline style)——声明是通过HTML的style属性还是CSS选择器应用到元素上
  3) 层（Layer）​——样式可以定义在不同的层中，每层有不同的优先级
  4) 选择器特异性(Selector specificity)2——哪些选择器会优先于其他选择器
  5) 作用域邻近性(Scope proximity)——样式是否限定在DOM的某一部分
  6) ​源码顺序(Source order)——样式在样式表中声明的顺序
+ 注意,上面的六个标准可能会被!important所影响,我们后面会详细介绍
+ 上面的例子技术使用了Selector specificty来进行解决的: ID selector的优先级更高
+ 第3-Layer和第5-Scope proximity都是新加入到CSS的能够提供更加精确的层叠,我们会在第8,第9章详细介绍他们
+ 接下来我们来介绍剩下的四个
*** Stylesheet origin
+ 实时上,有三种stylesheet的来源,分别是:
  - author style,是在源代码添加的style,优先级最高
  - user-style,是在特定的浏览器插件或个别几种浏览器里面才能定义的style,很少被使用,优先级中等
  - user-agent style,是浏览器默认的style,优先级最低
+ 用户代理样式（user-agent styles）在不同浏览器中略有差异，但通常实现的功能相同:
  - 标题（<h1> 到 <h6>）和段落（<p>）会被赋予上下外边距(margin)
  - 列表（<ol> 和 <ul>）会被赋予左内边距(padding)
  - 链接颜色和默认字体大小也会被设置
+ 用户代理样式(user-agent styles)设置的通常是您期望的默认效果,因此不会产生完全出乎意料的行为.不同现代
  浏览器的最新版本中，这些样式往往保持高度一致.
+ 若对某些属性的默认效果不满意，只需在自定义样式表中覆盖这些值即可
  - 图1-4就是user-agent style的设置
    #+CAPTION: cid/1-4.png
    [[https://raw.githubusercontent.com/harrifeng/image/master/cid/1-4.png]]
  - 我们想对1-4进行一些改动,具体的改动后,效果
    #+CAPTION: cid/1-5.png
    [[https://raw.githubusercontent.com/harrifeng/image/master/cid/1-5.png]]
  - 具体的改动代码如下
    #+begin_src css
      h1 {
        color: #2f4f4f;
        margin-bottom: 10px; /*Reduce the margins*/
      }

      #main-nav {
        margin-top: 10px; /*Reduce the margins*/
        list-style: none; /*Remove user-agent list styles*/
        padding-left: 0; /*Remove user-agent list styles*/
      }

      /* Makes list items appear side by side rather than stacked */
      #main-nav li {
        display: inline-block;
      }

      /* Provide a button-like appearance for the naavigational links */
      #main-nav a {
        color: white;
        backgroun-color: #13a4a5;
        padding: 5px;
        border-radius: 2px;
        text-decoration: none;
      }
    #+end_src
  - 注意,上面的代码使用了ID selector,这个不是最佳实践,我们后面会详细介绍
**** Important Declarations
+ style origin rules有一个例外,那就是一旦一个declaration被标记为imporatnt(使用!important),那么这个declaration
  就会被所有的normal style优先级都要高(但是imporatnt origin的order和普通origin的order是相反的!).把
  important考虑进来之后,所有的优先级从高到低如下:
  1) Important user-agent
  2) Important user
  3) Important author
  4) Normal author
  5) Normal user
  6) Normal user-agent
*** Inline styles
+ 当冲突声明无法通过来源（origin）解决时,浏览器会检查它们是否通过内联样式（inline styles）添加到元素:
  - 通过HTML的style属性应用的样式声明仅作用于当前元素，且会覆盖外部样式表或<style>标签中的声明,比如我
    们想把最后一个Specials给给成桔色背景,那么我们可以直接在目标元素内更改
    #+begin_src diff
      diff --git a/code/ch01/1-4.html b/code/ch01/1-4.html
      index e0f6bd3..078f82b 100644
      --- a/code/ch01/1-4.html
      +++ b/code/ch01/1-4.html
      @@ -36,7 +36,7 @@
               <li><a href="/">Home</a></li>
               <li><a href="/coffees">Coffees</a></li>
               <li><a href="/brewers">Brewers</a></li>
      -        <li><a href="/specials" class="featured">Specials</a></li>
      +        <li><a href="/specials" class="featured" style="background-color: orange;">Specials</a></li>
             </ul>
           </nav>
         </header>
    #+end_src
  - 内联样式无需选择器，因其直接绑定目标元素。
+ inline style的特点如下:
  - 优先级排序​：内联样式 > 作者样式（外部/内部） > 用户代理样式（浏览器默认）
  - 特殊性计算​：内联样式的特殊性权重为1,0,0,0，高于ID选择器的0,1,0,0
  - 应用场景​：适合局部覆盖，但滥用会降低可维护性
+ 若需在stylesheet中覆盖内联声明,必须为声明添加!important以提升其优先级来源.若内联样式本身已被标记为
  !important,则无法被任何规则覆盖.建议优先通过stylesheet(而非inline style)实现此类覆盖
*** Selector specificity
+ selector specificity是一个不易察觉但是却是非常重要的CSS特性,因为:
  - 在stylesheet origin判断里面,其实冲突较少:绝大部分的style都是你通过author origin添加的
  - 但是如果不理解selector specificity,那么几乎肯定会在处理冲突的时候犯错误
+ 不同的selector首先自己就有优先级:
  - 单个ID selector比任意数目的class selector的优先级都高
  - 单个class selector比任意数目的tag selector的优先级都高
  - 下面这例子中优先级是从低到高书写的.
    #+begin_src css
      html body header h1 {
        color: blue;
      }

      body header.page-header h1 {
        color: orange;
      }

      .page-header .title {
        color: green;
      }

      #page-title {
        color: red;
      }
    #+end_src
  - 我们会发现如果存在高优先级的就比较出结果,那么如果高优先级的数目一样怎么办呢?答案是比较下一级别的
    优先级,为此我们还创建出一个Notation列表来比较优先级.上面例子的优先级使用列表列出如下(高优先级数
    目多直接获胜,否则比较下一级)
    | Selector                   | ID | Class | Tag | Notation |
    |----------------------------+----+-------+-----+----------|
    | html body heaer h1         |  0 |     0 |   4 | 0,0,4    |
    | body header.page-header h1 |  0 |     1 |   3 | 0,1,3    |
    | .page-header .title        |  0 |     2 |   0 | 0,2,0    |
    | #page-title                |  1 |     0 |   0 | 1,0,0    |
+ 由于inline style非常常用,上面的notion有时候还会在最前面加上第1个数字,整体变成四位:
  - 如果是inline style,第一位就是1,其也就拥有最高的优先级,比所有selector都高
  - 如果不是inline style,第一位就是0
+ 知道了优先级之后,我们发现:
  - 直接使用 .featured这个class selector是无法成功设置orange背景的,因为selector #main-nav是ID selector
    #+begin_src html
      <!doctype html>
      <head>
        <meta charset="utf-8" />
        <style>
          h1 {
            color: #2f4f4f;
            margin-bottom: 10px;
          }

          #main-nav {
            margin-top: 10px;
            list-style: none;
            padding-left: 0;
          }

          #main-nav li {
            display: inline-block;
          }

          #main-nav a {
            color: white;
            background-color: #13a4a4;
            padding: 5px;
            border-radius: 2px;
            text-decoration: none;
          }

          .featured {
            background-color: orange;
          }
        </style>
      </head>
      <body>
        <header class="page-header">
          <h1 id="page-title" class="title">Wombat Coffee Roasters</h1>
          <nav>
            <ul id="main-nav" class="nav">
              <li><a href="/">Home</a></li>
              <li><a href="/coffees">Coffees</a></li>
              <li><a href="/brewers">Brewers</a></li>
              <li><a href="/specials" class="featured">Specials</a></li>
            </ul>
          </nav>
        </header>
      </body>
    #+end_src
  - 一个快速但是不太推荐的做法,是在orange后面加!important,这样能做到我们想要的效果,但是不是最佳实践:
    因为加一个!important还不是问题,问题是每个declaration都加了important之后,大家还是比较老的优先级.这
    个!important只能用一次!
    #+begin_src diff
      diff --git a/code/ch01/1-7.html b/code/ch01/1-7.html
      index a4e88fe..7344b9d 100644
      --- a/code/ch01/1-7.html
      +++ b/code/ch01/1-7.html
      @@ -26,7 +26,7 @@
           }

           .featured {
      -      background-color: orange;
      +      background-color: orange !important;
           }
         </style>
       </head>
    #+end_src
+ 不能使用!important,那么我们可以从两个思路来更改我们的代码,达到使用orange作为背景的目的:
  - 第一个思路就是提升我们自己selector的优先级
    #+begin_src diff
      diff --git a/code/ch01/1-8.html b/code/ch01/1-8.html
      index 7344b9d..38aa9ae 100644
      --- a/code/ch01/1-8.html
      +++ b/code/ch01/1-8.html
      @@ -25,8 +25,8 @@
             text-decoration: none;
           }

      -    .featured {
      -      background-color: orange !important;
      +    #main-nav .featured {
      +      background-color: orange;
           }
         </style>
       </head>
    #+end_src
  - 第二个思路就是降低印象我们的selector的优先级,比如不要使用ID来做selector,把第一个#main-nav的selector
    去掉,改为使用class+tag,而我们的selector是两个class,那么我们的selector获胜
    #+begin_src diff
      diff --git a/code/ch01/1-9.html b/code/ch01/1-9.html
      index 7344b9d..12c92d8 100644
      --- a/code/ch01/1-9.html
      +++ b/code/ch01/1-9.html
      @@ -7,17 +7,17 @@
             margin-bottom: 10px;
           }

      -    #main-nav {
      +    .nav {
             margin-top: 10px;
             list-style: none;
             padding-left: 0;
           }

      -    #main-nav li {
      +    .nav li {
             display: inline-block;
           }

      -    #main-nav a {
      +    .nav a {
             color: white;
             background-color: #13a4a4;
             padding: 5px;
      @@ -25,8 +25,8 @@
             text-decoration: none;
           }

      -    .featured {
      -      background-color: orange !important;
      +    .nav .featured {
      +      background-color: orange;
           }
         </style>
       </head>
    #+end_src
+ 我们发现selector specificity就像是军备竞赛,所以我们的最佳实践就是让selector specificity的优先级尽可
  能的低,这样才能在后期进行override
*** Source order
+ 最后一步解决冲突的办法就是source order了,简单点说,所有的标准都相同的情况下,在代码中的位置越往后,优
  先级越高(因为后面的配置会override前面配置)
+ 当你开始学习CSS的时候,你可能听说CSS代码中的selector需要有一定顺序,那就是因为源代码的顺序会影响层叠
+ 我们使用link的style(a:link, a:visited,a:hover, a:active)来做介绍,这也是最经典的例子:
  - 我们先看看错误的例子.这个例子由于顺序错误,导致两个错误:悬停在未访问链接的时候还是蓝色(而不是红色),
    以及悬停在已访问链接上时候,链接依然是紫色,而不是红色
    #+begin_src css
      /* 错误顺序示例 */
      a:hover {
        color: red; /* 鼠标悬停时变红 */
      }

      a:link {
        color: blue; /* 未访问时蓝色 */
      }

      a:visited {
        color: purple; /* 已访问时紫色 */
      }

      a:active {
        color: green; /* 点击瞬间变绿 */
      }
    #+end_src
  - 更改之后的版本如下.这才是正确的版本. 正确版本的selector的顺序必须是:link,:visted,:hover,:active
    (一个容易记的方法:LoVe/HAte)
    #+begin_src css
      /* 正确顺序示例 (LVHA) */
      a:link {
        color: blue; /* 未访问时蓝色 */
      }

      a:visited {
        color: purple; /* 已访问时紫色 */
      }

      a:hover {
        color: red; /* 鼠标悬停时变红 */
      }

      a:active {
        color: green; /* 点击瞬间变绿 */
      }
    #+end_src
+ 总体上来说层叠(cascade)是比较容易处理的,我们只需要记住两个最佳实践即可:
  - 不要使用ID selector
  - 不要使用!important
** Inheritance
** Special values
*** The inherit keyword
*** The initial keyword
*** The unset keyword
*** The revert keyword
** Shorthand properties
*** Beware shorthands silently overriding other styles
*** Remember the order of shorthand values
** Progressive enhancement
*** Using the cascade for progressive enhancement
*** Progressively enhancing selectors
*** Feature queries using @supports()
