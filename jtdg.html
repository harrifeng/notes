<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2025-01-23 Thu 15:00 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>jtdg</title>
<meta name="author" content="harrifeng@outlook.com" />
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="src/readtheorg_theme/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="src/readtheorg_theme/css/readtheorg.css"/>
<script type="text/javascript" src="src/lib/js/jquery.min.js"></script>
<script type="text/javascript" src="src/lib/js/bootstrap.min.js"></script>
<script type="text/javascript" src="src/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="src/readtheorg_theme/js/readtheorg.js"></script>
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">jtdg</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org052b8e6">1. Chapter 1: Introduction to JavaScript</a>
<ul>
<li><a href="#orgec42443">1.1. Exploring JavaScript</a></li>
<li><a href="#org7f9cc9f">1.2. Hello World</a></li>
</ul>
</li>
<li><a href="#org90feb27">2. Chapter 2: Lexical Structure</a>
<ul>
<li><a href="#org4e489a7">2.1. The Text of a JavaScript Program</a></li>
<li><a href="#org60961e4">2.2. Comments</a></li>
<li><a href="#orga1deb65">2.3. Literals</a></li>
<li><a href="#orgebb64da">2.4. Identifiers and Reserved Words</a>
<ul>
<li><a href="#org9f6b1ae">2.4.1. Reserved Words</a></li>
</ul>
</li>
<li><a href="#org8dfa01d">2.5. Unicode</a>
<ul>
<li><a href="#org4a88de3">2.5.1. Unicode Escape Sequence</a></li>
<li><a href="#orgdc87f51">2.5.2. Unicode Normalization</a></li>
</ul>
</li>
<li><a href="#orgf8bc6a7">2.6. Optional Semicolons</a></li>
</ul>
</li>
<li><a href="#orgd995647">3. Chapter 3: Types, Values, and Variables</a>
<ul>
<li><a href="#orgc7532da">3.1. Overview and Definitions</a></li>
<li><a href="#org72725cf">3.2. Numbers</a>
<ul>
<li><a href="#orga8d23c9">3.2.1. Integer Literals</a></li>
<li><a href="#orgcdf86bb">3.2.2. Floating-Point Literals</a></li>
<li><a href="#org82f4b86">3.2.3. Arithmetic in JavaScript</a></li>
<li><a href="#org4744e32">3.2.4. Binary Floating-Point and ROunding Errors</a></li>
<li><a href="#orgfeb26fc">3.2.5. Arbitrary Precision Integers with BigInt</a></li>
<li><a href="#org111fc60">3.2.6. Dates and Times</a></li>
</ul>
</li>
<li><a href="#orge89aa01">3.3. Text</a>
<ul>
<li><a href="#orgbeebfc6">3.3.1. String Literals</a></li>
<li><a href="#org8b425d8">3.3.2. Escape Sequence in String Literals</a></li>
<li><a href="#org559eea5">3.3.3. Working with Strings</a></li>
<li><a href="#orgb89b845">3.3.4. Template Literals</a></li>
<li><a href="#orgd3ab9d7">3.3.5. Pattern Matching</a></li>
</ul>
</li>
<li><a href="#orga0c8fe9">3.4. Boolean Values</a></li>
<li><a href="#org55e76ec">3.5. null and undefined</a>
<ul>
<li><a href="#org7120220">3.5.1. null</a></li>
<li><a href="#org376a0f6">3.5.2. undefined</a></li>
<li><a href="#org1fe2bb1">3.5.3. 两者的联系</a></li>
</ul>
</li>
<li><a href="#orgcc312a4">3.6. Symbols</a></li>
<li><a href="#org54a286d">3.7. The Global Object</a></li>
<li><a href="#org660050f">3.8. Immutable Primitive Values and Mutable Object References</a></li>
<li><a href="#org741c960">3.9. Type Conversions</a>
<ul>
<li><a href="#org0c16222">3.9.1. Conversions and Equality</a></li>
<li><a href="#orgb1bd501">3.9.2. Explicit Conversions</a></li>
</ul>
</li>
<li><a href="#orgfbbe3c3">3.10. Variable Declaration and Assignment</a>
<ul>
<li><a href="#orgda9643a">3.10.1. Declarations with let and const</a></li>
<li><a href="#orgac7fa04">3.10.2. Variable Declarations with var</a></li>
<li><a href="#org995bd61">3.10.3. Destructuring Assignment</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orge14ef85">4. Chapter4: Expressions and Operators</a>
<ul>
<li><a href="#org471c06f">4.1. Primary Expression</a></li>
<li><a href="#org925d821">4.2. Object and Array Initializers</a></li>
<li><a href="#orgc353eee">4.3. Function Definition Expressions</a></li>
<li><a href="#orgc105b59">4.4. Property Access Expressions</a>
<ul>
<li><a href="#orge9df59a">4.4.1. Conditional Property Access</a></li>
</ul>
</li>
<li><a href="#org786b1f2">4.5. Invocation Expressions</a>
<ul>
<li><a href="#orgb4adc5c">4.5.1. Conditional Invocation</a></li>
</ul>
</li>
<li><a href="#org857ae27">4.6. Object Creation Expression</a></li>
<li><a href="#org2a59b33">4.7. Operator Overview</a>
<ul>
<li><a href="#org2c9e63b">4.7.1. Number of Operands</a></li>
<li><a href="#orgd676e5f">4.7.2. Operand and Result Type</a></li>
<li><a href="#orgc5cd1c5">4.7.3. Operator Side Effects</a></li>
<li><a href="#orgd273bee">4.7.4. Operator Precedence</a></li>
<li><a href="#orgb9f475f">4.7.5. Operator Associativity</a></li>
<li><a href="#org5895f4a">4.7.6. Order of Evaluation</a></li>
</ul>
</li>
<li><a href="#orgd2fdf36">4.8. Arithemic Expressions</a>
<ul>
<li><a href="#org06ea725">4.8.1. The + Operator</a></li>
<li><a href="#org51dbd69">4.8.2. Unary Arithmetic Operators</a></li>
<li><a href="#orgca213f6">4.8.3. Bitwise Operators</a></li>
</ul>
</li>
<li><a href="#org5673da3">4.9. Relational Expressions</a>
<ul>
<li><a href="#orgdaae4c6">4.9.1. Equality and Inequality Operators</a></li>
<li><a href="#orgad199e9">4.9.2. Comparison Operator</a></li>
<li><a href="#org003df0a">4.9.3. The in Operator</a></li>
<li><a href="#org187a0e9">4.9.4. The instanceof Operator</a></li>
</ul>
</li>
<li><a href="#org79c32c9">4.10. Logical Expressions</a>
<ul>
<li><a href="#org4332762">4.10.1. Logical AND(&amp;&amp;)</a></li>
<li><a href="#orgce83374">4.10.2. Logical OR(||)</a></li>
<li><a href="#org3dfa84a">4.10.3. Logical Not(!)</a></li>
</ul>
</li>
<li><a href="#org06bbe5a">4.11. Assignment Expressions</a>
<ul>
<li><a href="#orgbe6d820">4.11.1. Assignment with Operation</a></li>
</ul>
</li>
<li><a href="#org339c3ae">4.12. Evaluation Expressions</a></li>
<li><a href="#orgd03ca62">4.13. Miscellaneous Operators</a>
<ul>
<li><a href="#org6a223b4">4.13.1. The Conditional Operator(?:)</a></li>
<li><a href="#org94b5109">4.13.2. First-Defined(??)</a></li>
<li><a href="#org0fb742a">4.13.3. The typeof Operator</a></li>
<li><a href="#orgac4d5e4">4.13.4. The delete Operator</a></li>
<li><a href="#org9613703">4.13.5. The await Opertor</a></li>
<li><a href="#org1c8fd94">4.13.6. The void Operator</a></li>
<li><a href="#org0bf5324">4.13.7. The comma Operator(,)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgefcb634">5. Chapter 5: Statements</a>
<ul>
<li><a href="#orge392c49">5.1. Expression Statements</a></li>
<li><a href="#org291b73c">5.2. Compound and Empty Statements</a></li>
<li><a href="#orgc616ee5">5.3. Conditionals</a>
<ul>
<li><a href="#orga150ed3">5.3.1. if</a></li>
<li><a href="#org7785f1a">5.3.2. else if</a></li>
<li><a href="#org054fcea">5.3.3. switch</a></li>
</ul>
</li>
<li><a href="#orgdbc905b">5.4. Loops</a>
<ul>
<li><a href="#org3ebe407">5.4.1. while</a></li>
<li><a href="#orgd696436">5.4.2. do/while</a></li>
<li><a href="#orga4a5118">5.4.3. for</a></li>
<li><a href="#orgf26429f">5.4.4. for/of</a></li>
<li><a href="#orgf0d3c2e">5.4.5. for/in</a></li>
</ul>
</li>
<li><a href="#orgfe62525">5.5. Jumps</a>
<ul>
<li><a href="#orgb298f2a">5.5.1. Labeled Statements</a></li>
<li><a href="#org4320c3c">5.5.2. break</a></li>
<li><a href="#org94679db">5.5.3. continue</a></li>
<li><a href="#orge1593fe">5.5.4. return</a></li>
<li><a href="#org5adfe13">5.5.5. yield</a></li>
<li><a href="#orgde80767">5.5.6. throw</a></li>
<li><a href="#org8d4c077">5.5.7. try/catch/finally</a></li>
</ul>
</li>
<li><a href="#orgb8caf0c">5.6. Miscellaneous Statements</a>
<ul>
<li><a href="#orgb1837de">5.6.1. with</a></li>
<li><a href="#orgae191ca">5.6.2. debugger</a></li>
<li><a href="#org81ebbd2">5.6.3. "use strict"</a></li>
</ul>
</li>
<li><a href="#org3aecb95">5.7. Declarations</a>
<ul>
<li><a href="#org9a55360">5.7.1. const,let,and var</a></li>
<li><a href="#org130e1f7">5.7.2. function</a></li>
<li><a href="#org4a9552c">5.7.3. class</a></li>
<li><a href="#org8a7d3e0">5.7.4. import and export</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org3946c86">6. Chapter 6: Objects</a>
<ul>
<li><a href="#org1243639">6.1. Introduction to Objects</a></li>
<li><a href="#org5617114">6.2. Creating Objects</a>
<ul>
<li><a href="#orgfde8faa">6.2.1. Object Literals</a></li>
<li><a href="#org971abd5">6.2.2. Creating Objects with new</a></li>
<li><a href="#org405cd48">6.2.3. Prototypes</a></li>
<li><a href="#org5a3d0ce">6.2.4. Object.create()</a></li>
</ul>
</li>
<li><a href="#orgc1710b4">6.3. Querying and Setting Properties</a>
<ul>
<li><a href="#org63be970">6.3.1. Objects As Associative Arrays</a></li>
<li><a href="#orgb613f25">6.3.2. Inheritance</a></li>
<li><a href="#orgfcfacca">6.3.3. Property Access Errors</a></li>
</ul>
</li>
<li><a href="#org303d57c">6.4. Deleting Properties</a></li>
<li><a href="#org138796b">6.5. Testing Properties</a></li>
<li><a href="#org6021aa1">6.6. Enumerating Properties</a></li>
<li><a href="#orgd192a34">6.7. Extending Objects</a></li>
<li><a href="#org8be561b">6.8. Serializing Objects</a></li>
<li><a href="#orgae1907f">6.9. Object Methods</a>
<ul>
<li><a href="#org2b7044b">6.9.1. The toString() method</a></li>
</ul>
</li>
<li><a href="#org8d24d30">6.10. The toLocaleString() Method</a></li>
<li><a href="#org116ce24">6.11. The valueOf() Method</a></li>
<li><a href="#orgaa060db">6.12. The toJSON() Method</a></li>
<li><a href="#orgd4951df">6.13. Extended Object Literal Syntax</a>
<ul>
<li><a href="#org214a44b">6.13.1. Shorthand Properties</a></li>
<li><a href="#org4313e0c">6.13.2. Computed Property Names</a></li>
<li><a href="#orgb614ef2">6.13.3. Symbols as Property Names</a></li>
<li><a href="#org8869843">6.13.4. Spread Operator</a></li>
<li><a href="#org393cb4d">6.13.5. Shorthand Methods</a></li>
<li><a href="#org4d05445">6.13.6. Property Getters and Setters</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgf70d466">7. Chapter 7: Arrays</a>
<ul>
<li><a href="#org0c3d1d6">7.1. Creating Arrays</a>
<ul>
<li><a href="#orgf3d339a">7.1.1. Array Literals</a></li>
<li><a href="#orgfdd9d36">7.1.2. The Spread Operator</a></li>
<li><a href="#org551ccca">7.1.3. The Array() Constructor</a></li>
<li><a href="#orgd5264b5">7.1.4. Array.of()</a></li>
<li><a href="#org0c1a701">7.1.5. Array.from()</a></li>
</ul>
</li>
<li><a href="#org57509c2">7.2. Reading and Writing Array Elements</a></li>
<li><a href="#org7ea985d">7.3. Sparse Arrays</a></li>
<li><a href="#orgf75319e">7.4. Array Length</a></li>
<li><a href="#org99860fa">7.5. Adding and Deleting Array Elements</a></li>
<li><a href="#org5fb218f">7.6. Iterating Arrays</a></li>
<li><a href="#orga650393">7.7. Multidimensional Arrays</a></li>
<li><a href="#org369bb8b">7.8. Array Methods</a>
<ul>
<li><a href="#org9e8d445">7.8.1. Array Iterator Methods</a></li>
<li><a href="#orged2615a">7.8.2. Flattening arrays with flat() and flatMap()</a></li>
<li><a href="#orgaf850a9">7.8.3. Adding arrays with concat()</a></li>
<li><a href="#org08cc13e">7.8.4. Stacks and Queues with push(), pop(), shift() and unshift()</a></li>
<li><a href="#orgb5c1f94">7.8.5. Subarrays with slice(), splice(), fill() and copyWithin()</a></li>
<li><a href="#org9700967">7.8.6. Array Searching and Sorting Methods</a></li>
<li><a href="#orgb337aa7">7.8.7. Array to String Conversions</a></li>
<li><a href="#org8bdd39b">7.8.8. Static Array Function</a></li>
</ul>
</li>
<li><a href="#orgf5b8fb7">7.9. Array-Like Objects</a></li>
<li><a href="#orgfb85a24">7.10. Strings as Arrays</a></li>
</ul>
</li>
<li><a href="#orgc624609">8. Chapter 8: Functions</a>
<ul>
<li><a href="#org961c554">8.1. Defining Functions</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-org052b8e6" class="outline-2">
<h2 id="org052b8e6"><span class="section-number-2">1.</span> Chapter 1: Introduction to JavaScript</h2>
<div class="outline-text-2" id="text-1">
<ul class="org-ul">
<li>JavaScript是世界上部署最多的语言</li>
<li>最近十年,Node.js让Javascript从浏览器扩展到更广的领域</li>
<li>如果你有其他编程语言的经验,你会发现JavaScript是一个适配如下两种pattern的语言:
<ul class="org-ul">
<li>object-oriented programming</li>
<li>functional programming</li>
</ul></li>
<li>JavaScript的:
<ul class="org-ul">
<li>编程思想"first-class function",来源于Scheme</li>
<li>prototype based Inheritance是来自于编程语言Self</li>
</ul></li>
<li>JavaScript其实和Java的关系并不大</li>
<li>关于JavaScript的名字,版本,Mode有一些必须要详细的说明:
<ul class="org-ul">
<li>JavaScript是由Netscape公司发明的,所以JavaScript是Netscape公司的注册商标(现在Netscape是Oracle公司的一部分)</li>
<li>由于JavaScript为Oracle的注册商标,所以JavaScript的标准不能带有JavaScript的名字,而是叫做ECMAScript</li>
<li>本书每当想要说关于"标准","版本"的事宜的时候,会使用ECAMScript,ES来指代JavaScript</li>
<li>从2010年以来,几乎所有的浏览器都已经支持了ECMAScript Version 5,所以本书把ECMAScript Version 5当做兼容的底线,不再讨论之前的版本</li>
<li>2015年发布的ES6提供了class和module支持,这个对JavaScript来说,非常重要,将JavaScript变成一个严肃的语言</li>
<li>从ES6开始, ECMAScript的版本开始以年来命名,比如 ES2016, ES2017&#x2026;ES2020</li>
<li>在ES5之前的版本中,JavaScript存在非常多的错误,而我们不可能在新的版本中直接不支持这些错误.ES的做法是提供了一个叫做strict mode的
东西.如果你的代码开启了strict mode,那么ES5之前版本的错误将会报错.</li>
<li>ES6开始,将strict mode设置为了默认</li>
</ul></li>
<li>对于大部分语言来说,都会在标准库里面包含如下部分:
<ul class="org-ul">
<li>和字符串,数字打交道的辅助函数</li>
<li>内置的数据结构,比如map</li>
<li>基本的输入输出</li>
</ul></li>
<li>但是对于JavaScript来说,它定义了前两项,没有定义第三项. 在JavaScript世界里面,第三项(标准输入和输出)是"host environment"的责任</li>
<li>对于JavaScript来说,最开始也是当前最主要的host environment是浏览器,浏览器做到了:
<ul class="org-ul">
<li>把用户的鼠标和键盘的input,以及HTTP请求作为基本输入</li>
<li>把JavaScript代码展示的内容通过HTML和CSS输出给用户</li>
</ul></li>
<li>从2010年开始,在之前浏览器的基础上,JavaScript又多了一个host environment,那就是Node. Node做到了:
<ul class="org-ul">
<li>让JavaScript像其他编程语言一样,自己的读取操作系统上的文件,自己发送HTTP请求,也就是Node让JavaScript自己掌握了输入输出</li>
</ul></li>
<li>本书绝大部分篇章是关于JavaScript本身的,标准库的部分只有如下三章:
<ul class="org-ul">
<li>第11章介绍标准库(不包括输入输出)</li>
<li>第15章介绍host environment的浏览器(其中有浏览器代替JavaScript进行输入输出的部分)</li>
<li>第16章介绍host environment的Node 环境(这里JavaScript就有能力自己进行输入输出了)</li>
</ul></li>
</ul>
</div>
<div id="outline-container-orgec42443" class="outline-3">
<h3 id="orgec42443"><span class="section-number-3">1.1.</span> Exploring JavaScript</h3>
<div class="outline-text-3" id="text-1-1">
<ul class="org-ul">
<li>要想学习一个语言,需要有一个可以任意修改代码的环境.最简答的代码环境就是浏览器了,如下方法打开Console Tab:
<ul class="org-ul">
<li>F12 (windows)</li>
<li>Ctrl-Shift-I (Linux)</li>
<li>Command-Option-I (Mac)</li>
</ul></li>
<li><p>
另外我们可以下载Node,然后在命令行直接打node,就会得到和浏览器console一样的interpreter
</p>
<div class="org-src-container">
<pre class="src src-shell">$ node
Welcome to Node.js v22.5.1.
Type <span style="color: #2d9574;">".help"</span> for more information.
&gt; .help
.help
.break    Sometimes you get stuck, this gets you out
.clear    Alias for .break
.editor   Enter editor mode
.exit     Exit the REPL
.help     Print this help message
.load     Load JS from a file into the REPL session
.save     Save all evaluated commands<span style="color: #3a81c3; font-weight: bold;"> in</span> this REPL session to a file

Press Ctrl+C to abort current expression, Ctrl+D to exit the REPL
&gt; let x = 2, y = 3;
<span style="color: #3a81c3;">let</span> x = 2, y = 3;
undefined
&gt; x + y
x + y
5
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-org7f9cc9f" class="outline-3">
<h3 id="org7f9cc9f"><span class="section-number-3">1.2.</span> Hello World</h3>
<div class="outline-text-3" id="text-1-2">
<ul class="org-ul">
<li><p>
无论是在Node还是在浏览器,我们都可以运行如下的最基础代码
</p>
<div class="org-src-container">
<pre class="src src-js">console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Hello World!"</span><span style="color: #3a81c3;">)</span>;
</pre>
</div></li>
<li>Node里面我们直接使用node hello.js运行</li>
<li>在浏览器里面,我们需要:
<ul class="org-ul">
<li><p>
一个~/hello.html文件,其内容包含
</p>
<div class="org-src-container">
<pre class="src src-html">&lt;<span style="color: #6c3163; font-weight: bold;">script</span> <span style="color: #715ab1;">src</span>=<span style="color: #2d9574;">"hello.js"</span>&gt;&lt;/<span style="color: #6c3163; font-weight: bold;">script</span>&gt;
</pre>
</div></li>
<li>一个~/hello.js代码,注意两者相对位置</li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org90feb27" class="outline-2">
<h2 id="org90feb27"><span class="section-number-2">2.</span> Chapter 2: Lexical Structure</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-org4e489a7" class="outline-3">
<h3 id="org4e489a7"><span class="section-number-3">2.1.</span> The Text of a JavaScript Program</h3>
<div class="outline-text-3" id="text-2-1">
<ul class="org-ul">
<li>JavaScript是一个case-sensitive的语言</li>
<li>JavaScript会忽略所有的space以及line break(行尾的line break在没有分号的时候会被解析成分号)</li>
<li>除了space character(\u0020), JavaScript也会吧tabs, ASCII controll characters作为空格对待.</li>
</ul>
</div>
</div>
<div id="outline-container-org60961e4" class="outline-3">
<h3 id="org60961e4"><span class="section-number-3">2.2.</span> Comments</h3>
<div class="outline-text-3" id="text-2-2">
<ul class="org-ul">
<li>JavaScript支持两种注释:
<ul class="org-ul">
<li>使用//注释一样</li>
<li>使用/**/注释一段</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orga1deb65" class="outline-3">
<h3 id="orga1deb65"><span class="section-number-3">2.3.</span> Literals</h3>
<div class="outline-text-3" id="text-2-3">
<ul class="org-ul">
<li><p>
literal就是直接出现在程序里面的data value,下面全部都是literal的例子
</p>
<div class="org-src-container">
<pre class="src src-js">12
1.2
<span style="color: #2d9574;">"hello world"</span>
<span style="color: #2d9574;">'Hi'</span>
<span style="color: #4e3163;">true</span>
<span style="color: #4e3163;">false</span>
<span style="color: #4e3163;">null</span>
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-orgebb64da" class="outline-3">
<h3 id="orgebb64da"><span class="section-number-3">2.4.</span> Identifiers and Reserved Words</h3>
<div class="outline-text-3" id="text-2-4">
<ul class="org-ul">
<li>JavaScript的变量必须以如下三种情况开头:
<ul class="org-ul">
<li>letter</li>
<li>underscore(_)</li>
<li>dollar sign($)</li>
</ul></li>
<li>和其他语言一样,"保留关键字"是不能作为变量名的</li>
</ul>
</div>
<div id="outline-container-org9f6b1ae" class="outline-4">
<h4 id="org9f6b1ae"><span class="section-number-4">2.4.1.</span> Reserved Words</h4>
<div class="outline-text-4" id="text-2-4-1">
<ul class="org-ul">
<li><p>
当前已经使用的关键字
</p>
<pre class="example" id="orge513032">
as       void        async    while    await    with        break
yield    case        catch    class    const    continue    debugger   default
delete   do          else     export   extends  false       finally    for
from     function    get      null     target
if       of          this     import   return   throw
in       set         true     instanceof        static      try
let      super       typeof   new      switch   var
</pre></li>
<li>为将来预留的关键字:
<ul class="org-ul">
<li>enum</li>
<li>implements</li>
<li>interface</li>
<li>package</li>
<li>private</li>
<li>protected</li>
<li>public</li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org8dfa01d" class="outline-3">
<h3 id="org8dfa01d"><span class="section-number-3">2.5.</span> Unicode</h3>
<div class="outline-text-3" id="text-2-5">
<ul class="org-ul">
<li>JavaScript是支持Unicode的</li>
</ul>
</div>
<div id="outline-container-org4a88de3" class="outline-4">
<h4 id="org4a88de3"><span class="section-number-4">2.5.1.</span> Unicode Escape Sequence</h4>
<div class="outline-text-4" id="text-2-5-1">
<ul class="org-ul">
<li><p>
有些硬件和软件无法正确显示所有Unicode character, 为了应对这个情况, JavaScript确定了escape sequence
机制.
</p>
<pre class="example" id="orgd2043ad">
所谓escape sequence,就是指允许用户只使用ASCII character来表达Unicode character
</pre></li>
<li>JavaScript的escape sequence有两种写法,都是以\u:
<ul class="org-ul">
<li>使用固定四位的十六进制数字,早期版本只支持这一种escape sequence</li>
<li>使用{}包裹的,1到6位的十六进制数据,从ES6才开始支持这种escape sequence</li>
<li><p>
下例中分别就是:1直接写和两种escape sequence的例子
</p>
<div class="org-src-container">
<pre class="src src-shell">&gt; let caf&#233; = 1;
<span style="color: #3a81c3;">let</span> caf&#233; = 1;
undefined
&gt; caf\u00e9
caf\u00e9
1
&gt; caf\u<span style="color: #3a81c3;">{</span>E9<span style="color: #3a81c3;">}</span>
caf\u<span style="color: #3a81c3;">{</span>E9<span style="color: #3a81c3;">}</span>
1
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgdc87f51" class="outline-4">
<h4 id="orgdc87f51"><span class="section-number-4">2.5.2.</span> Unicode Normalization</h4>
<div class="outline-text-4" id="text-2-5-2">
<ul class="org-ul">
<li><p>
一旦使用Unicode,那么就要注意Unicode中的一个难以发现的问题:
</p>
<pre class="example" id="org3c1a25b">
两个看起来完全相同的变量,由于是由不同的Unicode创建的,所以会被认为是不同的变量
</pre></li>
<li>比如é ,其可以有如下两种组成方式:
<ul class="org-ul">
<li>由\u00E9一个character组成</li>
<li>由e这个character,外加另外一个character \u0301(用来表示"尖音符组合符号"),一共两个character</li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgf8bc6a7" class="outline-3">
<h3 id="orgf8bc6a7"><span class="section-number-3">2.6.</span> Optional Semicolons</h3>
<div class="outline-text-3" id="text-2-6">
<ul class="org-ul">
<li>和许多语言一样,JavaScript是使用分号来分割statement的</li>
<li>如果两个statement是写在了单独的行,那么你可以省略分号</li>
<li>如果JavaScript无法把下一行解析为前一行的"继续",那么JavaScript总是把line break解析成分号</li>
<li>但是有些情况下,即便JavaScript知道下面一行是前一行的"继续",它依然会把line break解析成分号
<ol class="org-ol">
<li>第一个例外和return, throw, yield, break, continue等关键字相关.这三个关键字后面的line break永远
是分号</li>
<li>++ 和 &#x2013; 前后的line break也都强制解析成分号,所以想用这些符号,必须和前后的变量在同一行</li>
<li>箭头函数的"=&gt;"和"参数列表"必须在同一行</li>
</ol></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgd995647" class="outline-2">
<h2 id="orgd995647"><span class="section-number-2">3.</span> Chapter 3: Types, Values, and Variables</h2>
<div class="outline-text-2" id="text-3">
</div>
<div id="outline-container-orgc7532da" class="outline-3">
<h3 id="orgc7532da"><span class="section-number-3">3.1.</span> Overview and Definitions</h3>
<div class="outline-text-3" id="text-3-1">
<ul class="org-ul">
<li>JavaScript的type可以分成如下两类:
<ul class="org-ul">
<li>primitive type: 包括number, string boolean等</li>
<li>object type</li>
</ul></li>
<li>如下两个特殊的JavaScript value,也是primitive,但是他们不是number,string和boolean.它们被认为是自己类
型里面的唯一一个value:
<ul class="org-ul">
<li>null</li>
<li>undefined</li>
</ul></li>
<li>ES6添加了一个新的特殊用途的primitive类型,叫做Symbol(用来保证兼容性的情况下,定义语言扩展)</li>
<li><p>
以上都是对primitive type成员的罗列,那么所有不属于primitive类型的value都是object类型
</p>
<pre class="example" id="org3dbad84">
Any JavaScript value that is not a number, a string, a boolean, a symbol, null,
or undefined is an object
</pre></li>
<li>object type类型的每个变量都是一个object,每个object都是一系列的property的组合,并且每个property都有:
<ul class="org-ul">
<li>一个name</li>
<li>一个value: 可以是primitive类型,也可以是object类型</li>
</ul></li>
<li>数组其实也是一个object,只不过:
<ul class="org-ul">
<li>它的name是0,1,2, 它的value是一样的</li>
<li>由于name是0,1,2,所以数组是ordered of numbered values,而普通object是unordered of named values</li>
</ul></li>
<li>我们由一个全局的object,叫做global object会在后面讨论</li>
<li>除了上面说的basic object和array, object type的还有:
<ul class="org-ul">
<li>Set object</li>
<li>Map object</li>
<li>RegExp type object</li>
<li>Date type object</li>
<li>Error type object</li>
<li>function object</li>
<li>class object</li>
</ul></li>
<li>JavaScript解释器会自动进行GC,所以JS开发者不需要关系value的destruction</li>
<li><p>
JavaScript同时支持面向对象编程:也就是说,不再使用全局的function来进行数据处理,而是在type内部就定义
函数,这些function只能处理type内部的数据.这种只能处理type内部数据的function,我们也叫method,比如下面
是a.sort()就是一个method
</p>
<div class="org-src-container">
<pre class="src src-js">a = <span style="color: #3a81c3;">[</span>5, 1, 2, 3<span style="color: #3a81c3;">]</span>;
a.sort<span style="color: #3a81c3;">()</span>;
console.log<span style="color: #3a81c3;">(</span>a<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[ 1, 2, 3, 5 ]</span>
</pre>
</div></li>
<li>在JavaScript中:
<ul class="org-ul">
<li>所有的object数据都拥有method</li>
<li>所有的number, strings, boolean, symbol value看上去好像能调用method,但是这是语法糖的效果</li>
<li>null和undefined完全无法触发method</li>
</ul></li>
<li>JavaScript的object type是mutable的,而primitive type是immutable的:
<ul class="org-ul">
<li>对于object,你可以更改他的property,对于array,你可以更改它的element</li>
<li>但是你无法更改number, boolean, symbol, string</li>
</ul></li>
<li>JavaScript比较难以理解的语法在于其"隐式转换"类型的能力,比如:
<ul class="org-ul">
<li>你的程序希望获得一个string类型,但是你提供过来一个number,那么JavaScript会自动转换:把number转换为string</li>
<li>你的程序希望获得一个boolean类型,但是你提供了一个其他类型,那么JavaScript会自动转换:把其他类型转换为boolean</li>
</ul></li>
<li>JavaScript世界中的等于判断,就包含了是否有"隐式转换":
<ul class="org-ul">
<li>"=="" equality operator就是会在判断的时候遇到不匹配的type,主动进行类型转换后再比较</li>
<li>"<code>=</code>" 直接进行比较,不进行类型转换</li>
</ul></li>
<li>如果不考虑"赋值"的话,所有的的"声明"在JavaScript里面都是untype的:
<ul class="org-ul">
<li>我们使用const声明一个常量的时候不会指定类型</li>
<li>我们使用let(或者老版本的js使用var)声明一个变量的时候不会指定类型</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org72725cf" class="outline-3">
<h3 id="org72725cf"><span class="section-number-3">3.2.</span> Numbers</h3>
<div class="outline-text-3" id="text-3-2">
<ul class="org-ul">
<li>JavaScript的number类型是64-bit的floating-point format</li>
<li>当一个number直接出现在JavaScript代码中的时候,就叫做numeric literal, JavaScript支持多种格式的numeric
literal,下面会介绍</li>
</ul>
</div>
<div id="outline-container-orga8d23c9" class="outline-4">
<h4 id="orga8d23c9"><span class="section-number-4">3.2.1.</span> Integer Literals</h4>
<div class="outline-text-4" id="text-3-2-1">
<ul class="org-ul">
<li><p>
在JavaScript中, base-10 整数是最直观的存在,比如
</p>
<pre class="example" id="orga0f5714">
0
3
10000000
</pre></li>
<li><p>
对于程序开发人员,十六进制的表达也很常见(以0x或者0X开头)
</p>
<pre class="example" id="orge0bd94e">
0xff
0XBADCAFE
</pre></li>
<li>在ES6之后,我们还可以使用base2和base8两种整数表示
<ul class="org-ul">
<li><p>
以0b开头表示base2
</p>
<pre class="example" id="org057a53f">
0b10101
</pre></li>
<li><p>
以0o开头表示base8
</p>
<pre class="example" id="org2754196">
0o377
</pre></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgcdf86bb" class="outline-4">
<h4 id="orgcdf86bb"><span class="section-number-4">3.2.2.</span> Floating-Point Literals</h4>
<div class="outline-text-4" id="text-3-2-2">
<ul class="org-ul">
<li><p>
我们可以以下面的公式来表示floating-point literal
</p>
<pre class="example" id="orga5127f1">
[digits][.digits][(E|e)[(+|-)]digits]
</pre></li>
<li><p>
下面是几个floating-pint literal的例子
</p>
<pre class="example" id="org2726539">
3.14
2345.6789
.3333333333333
6.02e23
1.4738223E-32
</pre></li>
</ul>
</div>
</div>
<div id="outline-container-org82f4b86" class="outline-4">
<h4 id="org82f4b86"><span class="section-number-4">3.2.3.</span> Arithmetic in JavaScript</h4>
<div class="outline-text-4" id="text-3-2-3">
<ul class="org-ul">
<li>在JavaScript中,如下的"加减乘除"和"余数"肯定是非常早期就支持了
<ul class="org-ul">
<li>addition(+)</li>
<li>subtraction(-)</li>
<li>multiplication(*)</li>
<li>division(/)</li>
<li>modulo(%)</li>
</ul></li>
<li>ES6开始还支持了指数(**)</li>
<li>除此以外JavaScript还通过Math object的method和constant定义了很多复杂的操作数和操作符,比如:
<ul class="org-ul">
<li><p>
乘方
</p>
<div class="org-src-container">
<pre class="src src-js">Math.pow<span style="color: #3a81c3;">(</span>2, 53<span style="color: #3a81c3;">)</span>
</pre>
</div></li>
<li><p>
绝对值
</p>
<div class="org-src-container">
<pre class="src src-js">Math.abs<span style="color: #3a81c3;">(</span>-5<span style="color: #3a81c3;">)</span>
</pre>
</div></li>
<li><p>
圆周率
</p>
<div class="org-src-container">
<pre class="src src-js">Math.PI
</pre>
</div></li>
</ul></li>
<li>ES6在Math object上定义了更多的method和const
<ul class="org-ul">
<li><p>
立方根
</p>
<div class="org-src-container">
<pre class="src src-js">Math.cbrt<span style="color: #3a81c3;">(</span>27<span style="color: #3a81c3;">)</span>
</pre>
</div></li>
<li><p>
去掉浮点数的小数部分,直接返回整数部分
</p>
<div class="org-src-container">
<pre class="src src-js">Math.trunc<span style="color: #3a81c3;">(</span>3.9<span style="color: #3a81c3;">)</span>
</pre>
</div></li>
</ul></li>
<li>JavaScript在如下的极端情况下,都不会报错:
<ul class="org-ul">
<li>overflow</li>
<li>underflow</li>
<li>division by zero</li>
</ul></li>
<li>不会报错,但是会返回一些特殊的值:
<ul class="org-ul">
<li>如果计算结果比JavaScript可以表示的最大的值还大(Overflow的一种),那么返回Infinity</li>
<li>如果计算结果比JavaScript可以表示的最小的值还小(Overflow的另外一种),那么返回-Infinity</li>
<li>如果计算结果非常接近0,且大于0(Underflow的一种),那么JavaScript直接返回0</li>
<li><p>
如果计算结果非常接近0,且小于0(Underflow的另外一种),那么JavaScript直接返回"negative zero"(-0),
"-0"和"0"是两个不同的数字.
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">negativeZero</span> = -1 / <span style="color: #4e3163;">Infinity</span>;
console.log<span style="color: #3a81c3;">(</span>negativeZero<span style="color: #3a81c3;">)</span>;

<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">x</span> = -0;
console.log<span style="color: #3a81c3;">(</span>Object.is<span style="color: #6c3163;">(</span>x, -0<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>Object.is<span style="color: #6c3163;">(</span>x, 0<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">-0</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">true</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">false</span>
</pre>
</div></li>
<li><p>
"-0"和"0"是两个不同的数字,但是他们的值却相等,而Infinity和-Infinity却不相等
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">zero</span> = 0;
<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">negz</span> = -0;
console.log<span style="color: #3a81c3;">(</span>zero === negz<span style="color: #3a81c3;">)</span>;

console.log<span style="color: #3a81c3;">(</span>1 / zero<span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>1 / negz<span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>1 / zero === 1 / negz<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">true</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Infinity</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">-Infinity</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">false</span>
</pre>
</div></li>
<li>Division by zero其实要分两种情况考虑:
<ol class="org-ol">
<li>如果是普通的正数或负数初以0,那么得到infinity或者negative infinity</li>
<li>如果是0除以0,那么得到NaN</li>
</ol></li>
<li>NaN也会在如下情况下出现,感觉是表达了一种对计算结果的"无奈"(NaN是Not a Number的缩写):
<ol class="org-ol">
<li>使用infinity初以infinity</li>
<li>为负数开方</li>
<li>对使用"数学操作符"操作"non-number操作数",结果肯定是non-number的,只能用NaN表示</li>
</ol></li>
</ul></li>
<li><p>
Infinity和NaN在JavaScript里面是global constant,但是其实这两个也存在于Number object里面
</p>
<div class="org-src-container">
<pre class="src src-shell">$ node
Welcome to Node.js v22.5.1.
Type <span style="color: #2d9574;">".help"</span> for more information.
&gt; Infinity
Infinity
&gt; Number.POSITIVE_INFINITY
Infinity
&gt; -Infinity
-Infinity
&gt; Number.NEGATIVE_INFINITY
-Infinity
&gt; NaN
NaN
&gt; Number.NaN
NaN
</pre>
</div></li>
<li>NaN有一个特别的特性:
<ul class="org-ul">
<li><p>
它和谁进行比较都得到false,包括它自己
</p>
<pre class="example" id="orgb854892">
NaN dose not compare qual to any other value, including itself
</pre></li>
<li><p>
这也就意味着,我们要判断一个数是不是NaN只能使用如下两种方法:
</p>
<div class="org-src-container">
<pre class="src src-js">Number.isNaN<span style="color: #3a81c3;">(</span>x<span style="color: #3a81c3;">)</span>
x != x
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org4744e32" class="outline-4">
<h4 id="org4744e32"><span class="section-number-4">3.2.4.</span> Binary Floating-Point and ROunding Errors</h4>
<div class="outline-text-4" id="text-3-2-4">
<ul class="org-ul">
<li>实数其实是无穷的,但是JavaScript能表达的数字个数确是有穷的.那么这就意味着我们的数字其实只可能是真实
数字的一个接近值</li>
<li>JavaScript使用的浮点数规范是IEEE-754,这是一种binary representation,这种表达方式能够精确的表达1/2,
1/8等,但是我们日常生活中常用的确实decimal reprsentation,比如1/10, 1/100这就导致binary representation
连0.1都无法准确的表达.
<ul class="org-ul">
<li><p>
比如下面的例子
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">x</span> = 0.3 - 0.2;
<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">y</span> = 0.2 - 0.1;
console.log<span style="color: #3a81c3;">(</span>x === y<span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>x<span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>y<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">false</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">0.09999999999999998</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">0.1</span>
</pre>
</div></li>
<li>我们可以看到由于"近似取数字"带来的误差,如下两个近似的大小不同:
<ol class="org-ol">
<li>.3和.2之间是不到.1的是0.09999999999999998</li>
<li>.2和.1直接是刚好.1</li>
</ol></li>
</ul></li>
<li>注意浮点数的不精确是所有编程语言都存在的问题.之所以在JS里面比较令人诟病是因为JS之前只有Number类型,我们
无法通过放大浮点数为整数,来准确的实现一些计算,从而模拟浮点数真实的计算</li>
</ul>
</div>
</div>
<div id="outline-container-orgfeb26fc" class="outline-4">
<h4 id="orgfeb26fc"><span class="section-number-4">3.2.5.</span> Arbitrary Precision Integers with BigInt</h4>
<div class="outline-text-4" id="text-3-2-5">
<ul class="org-ul">
<li>JavaScript最新的特性,就是添加了一个新的numeric type叫做BigInt,这种类型的诞生,能够让JS和其他编程语言
和API进行兼容</li>
<li>JavaScript的BigInt是一种64-bit的整数实现,可以表达非常大的数.</li>
<li>Big literal看起来就是string of digits并且在最后加上 一个n作为后缀:
<ul class="org-ul">
<li><p>
10进制的情况
</p>
<div class="org-src-container">
<pre class="src src-js">1234n
</pre>
</div></li>
<li><p>
二进制的情况
</p>
<div class="org-src-container">
<pre class="src src-js">0b111111n
</pre>
</div></li>
<li><p>
八进制的情况
</p>
<div class="org-src-container">
<pre class="src src-js">0o7777n
</pre>
</div></li>
</ul></li>
<li><p>
你可以使用BigInt()来将普通的JavaScript number或者string转换为BigInt value
</p>
<div class="org-src-container">
<pre class="src src-js">console.log<span style="color: #3a81c3;">(</span>BigInt<span style="color: #6c3163;">(</span>Number.MAX_SAFE_INTEGER<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>;
<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">string</span> = <span style="color: #2d9574;">"1"</span> + <span style="color: #2d9574;">"0"</span>.repeat<span style="color: #3a81c3;">(</span>100<span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>string<span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>BigInt<span style="color: #6c3163;">(</span>string<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">9007199254740991n</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000n</span>
</pre>
</div></li>
<li><p>
BigInt的行为和其他语言的整数类型一致,加减正常,除法会抛弃掉余数
</p>
<div class="org-src-container">
<pre class="src src-js">console.log<span style="color: #3a81c3;">(</span>1000n + 2000n<span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>3000n - 2000n<span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>2000n * 3000n<span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>3000n / 997n<span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>3000n % 997n<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">3000n</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">1000n</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">6000000n</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">3n</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">9n</span>
</pre>
</div></li>
<li>由于BigInt其实只是用64-bit来表达整数,而number是用64-bit来表达浮点数.所以两者没有谁更强,所以如果把
这两者进行如下的运算(加减乘除和取余),得到的结果应该包容两者优点.但是由于JavaScript里面没有这种类型,
所以JavaScript直接不允许这两者混合着进行如下运算:
<ul class="org-ul">
<li>addition(+)</li>
<li>subtraction(-)</li>
<li>multiplication(*)</li>
<li>division(/)</li>
<li>modulo(%)</li>
</ul></li>
<li><p>
我们可以混合BigInt和Number进行比较
</p>
<div class="org-src-container">
<pre class="src src-shell"> &gt; 1 &lt; 2n
true
&gt; 2 &gt; 1n
true
&gt; 0 == 0n                       <span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">convert before check</span>
true
&gt; 0 === 0n                      <span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">check type equality as well</span>
false
</pre>
</div></li>
<li>Math object的不接受BigInt数字作为参数的</li>
</ul>
</div>
</div>
<div id="outline-container-org111fc60" class="outline-4">
<h4 id="org111fc60"><span class="section-number-4">3.2.6.</span> Dates and Times</h4>
<div class="outline-text-4" id="text-3-2-6">
<ul class="org-ul">
<li>JavaScript定义了Date class用来表示日期和时间</li>
<li><p>
JavaScript Date是object type,但是它是可以通过函数转换为number表达的:millisecond单位的Unixtime
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">timestamp</span> = Date.now<span style="color: #3a81c3;">()</span>;
console.log<span style="color: #3a81c3;">(</span>timestamp<span style="color: #3a81c3;">)</span>;

<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">now</span> = <span style="color: #3a81c3; font-weight: bold;">new</span> <span style="color: #ba2f59; font-weight: bold;">Date</span><span style="color: #3a81c3;">()</span>;
console.log<span style="color: #3a81c3;">(</span>now<span style="color: #3a81c3;">)</span>;
<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">ms</span> = now.getTime<span style="color: #3a81c3;">()</span>;
console.log<span style="color: #3a81c3;">(</span>ms<span style="color: #3a81c3;">)</span>;

<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">iso</span> = now.toISOString<span style="color: #3a81c3;">()</span>;
console.log<span style="color: #3a81c3;">(</span>iso<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">1723124985815</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">2024-08-08T13:49:45.821Z</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">1723124985821</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">2024-08-08T13:49:45.821Z</span>
</pre>
</div></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orge89aa01" class="outline-3">
<h3 id="orge89aa01"><span class="section-number-3">3.3.</span> Text</h3>
<div class="outline-text-3" id="text-3-3">
<ul class="org-ul">
<li>JavaScript中,表示文本的类型是string</li>
<li>string是一个immutable ordered sequence</li>
<li>string的成员都是16-bit value,每个都是一个Unicode character</li>
<li>string的长度,就是16-bit的character的个数</li>
<li>JavaScript Text系统和其他编程语言不一样的地方在于,它没有表示单个字符的类型(比如golang里面的char),
而是只有string. 如果要表示单个16-bit value,那么就用长度为1的string</li>
<li>Javascript是支持Unicode的,绝大部分的Unicode用16bit就完美支持了.少部分Unicode可能需要两个16bit.这种
情况下我们的string长度可能是2,但是仅仅展示出一个unicode character</li>
<li>在ES6中, for loop的单位是character,而不是16-bit value</li>
</ul>
</div>
<div id="outline-container-orgbeebfc6" class="outline-4">
<h4 id="orgbeebfc6"><span class="section-number-4">3.3.1.</span> String Literals</h4>
<div class="outline-text-4" id="text-3-3-1">
<ul class="org-ul">
<li>在JavaScript中,有三种字符串的表达形式:
<ul class="org-ul">
<li>单引号</li>
<li>双引号</li>
<li>反引号: ES6中引入</li>
</ul></li>
<li>在ES5之后,如果你的文档非常长,需要多行展示但是不想中间由换行符的话,你需要 "\" 来进行(这也是之前bash命令的多行显示手段).</li>
<li>如果你想要在单行里面引入"换行",那么就要用"\n", 或者使用ES6引入的反括号:
<ul class="org-ul">
<li><p>
反括号内部的换行符也是字符串的一部分
</p>
<div class="org-src-container">
<pre class="src src-js">line = <span style="color: #2d9574;">`the newline character at the end of this line</span>
<span style="color: #2d9574;">is included literally in this string`</span>;
console.log<span style="color: #3a81c3;">(</span>line<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">the newline character at the end of this line</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">is included literally in this string</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org8b425d8" class="outline-4">
<h4 id="org8b425d8"><span class="section-number-4">3.3.2.</span> Escape Sequence in String Literals</h4>
<div class="outline-text-4" id="text-3-3-2">
<ul class="org-ul">
<li>像其他Unix下的语言一样, JavaScript使用\来作为转义符(英文名叫escape sequence,也就是escape后面字符本来的意义的意思):
<ul class="org-ul">
<li>\n表示newline</li>
<li>\'表示撇号,在字符串包裹的英文中如果需要I'm 这种撇号,需要加转义符</li>
<li>\x后面可以加两个十六进制数,表示小的Unicode</li>
<li>\u后面可以跟四个十六进制数,表示大范围的Unicode</li>
<li>\u后面跟{},在{}里面输入最多可以表示到\u{10FFFF},也就是最大范围的Unicode</li>
</ul></li>
<li><p>
如果没有定义过这个转义字符,那么加上\的效果就是没有任何效果
</p>
<div class="org-src-container">
<pre class="src src-js">a = <span style="color: #2d9574;">"#"</span>;
b = <span style="color: #2d9574;">"#"</span>;
console.log<span style="color: #3a81c3;">(</span>a<span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>b<span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>a === b<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">#</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">#</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">true</span>
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-org559eea5" class="outline-4">
<h4 id="org559eea5"><span class="section-number-4">3.3.3.</span> Working with Strings</h4>
<div class="outline-text-4" id="text-3-3-3">
<ul class="org-ul">
<li><p>
JavaScript的内置特性是使用+来把不同的string进行连接
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">msg</span> = <span style="color: #2d9574;">"Hello, "</span> +<span style="color: #2d9574;">"world"</span>;
console.log<span style="color: #3a81c3;">(</span>msg<span style="color: #3a81c3;">)</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Hello, world</span>
</pre>
</div></li>
<li>我们可以使用===和!==对两个字符串进行对比是否相同</li>
<li>我们也可以使用如下操作符进行比较,比较的方法,其实就是挨个比较16-bit value
<ol class="org-ol">
<li>&lt;</li>
<li>&lt;=</li>
<li>&gt;</li>
<li>&gt;=</li>
</ol></li>
<li>我们使用length method来计算string的长度,计算方法是计算string里面16-bit value的个数</li>
<li>在JavaScript里面,针对string有非常多的method:
<ul class="org-ul">
<li>substring</li>
<li>slice</li>
<li>split</li>
<li>indexOf</li>
<li>startsWith</li>
<li>replace</li>
<li>toUpperCase</li>
</ul></li>
<li>我们的JavaScript中的string是immutable的,所以上面的replace()和toUpperCase()方法会返回新的字符串,而
不会改变这些字符串</li>
<li><p>
String可以被看做是read-only array,所以你可以通过如下方法access 每个单独的character
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">s</span> = <span style="color: #2d9574;">"hello, world"</span>;
console.log<span style="color: #3a81c3;">(</span>s<span style="color: #6c3163;">[</span>0<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>s<span style="color: #6c3163;">[</span>s.length - 1<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">h</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">d</span>
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-orgb89b845" class="outline-4">
<h4 id="orgb89b845"><span class="section-number-4">3.3.4.</span> Template Literals</h4>
<div class="outline-text-4" id="text-3-3-4">
<ul class="org-ul">
<li><p>
在ES6之后,string lietras可以使用反引号来创建,比如
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">s</span> = <span style="color: #2d9574;">`hello world`</span>;
</pre>
</div></li>
<li>这种字符串比ES6之前的字符串要"高级":
<ul class="org-ul">
<li><p>
他可以是一种template literal,可以包含任意的JavaScript表达式
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">name</span> = <span style="color: #2d9574;">"Bill"</span>;
<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">greeting</span> = <span style="color: #2d9574;">`hello ${name}.`</span>;
console.log<span style="color: #3a81c3;">(</span>greeting<span style="color: #3a81c3;">)</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">hello Bill.</span>
</pre>
</div></li>
<li><p>
类似于python里面的"f"开头的字符串
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #715ab1;">name</span> = <span style="color: #2d9574;">"Bill"</span>
<span style="color: #715ab1;">greeting</span> = f<span style="color: #2d9574;">"Hello </span>{name}<span style="color: #2d9574;">"</span>

<span style="color: #3a81c3;">print</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"""|greeting|=&gt;"""</span>, greeting<span style="color: #3a81c3;">)</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;"># </span><span style="color: #2aa1ae; background-color: #ecf3ec;">|greeting|=&gt; Hello Bill</span>
</pre>
</div></li>
</ul></li>
<li>ES6有一个内置的处理raw函数的function叫做String.raw():
<ul class="org-ul">
<li>用例代码如下</li>
<li>我们可以看到,这个函数最明显的特点是调用的时候,不用(),直接和template string相结合</li>
<li>第二个特点就是通过返回值观察到,这个函数返回值不会转义,所以'\n'在String.raw这里长度就是2,而普通字
符串'\n'转义成换行符,长度就是1</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgd3ab9d7" class="outline-4">
<h4 id="orgd3ab9d7"><span class="section-number-4">3.3.5.</span> Pattern Matching</h4>
<div class="outline-text-4" id="text-3-3-5">
<ul class="org-ul">
<li>正则表达式也是JS已经具备的功能.在JS里面两个"/"之间的字符串就是正则表达式,例子如下:
<ul class="org-ul">
<li><p>
匹配所有以HTML开头的字符串
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #2d9574;">/^HTML/</span>
</pre>
</div></li>
<li><p>
匹配"javascript"这个小写字母
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #2d9574;">/\bjavascript\b/</span>i
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orga0c8fe9" class="outline-3">
<h3 id="orga0c8fe9"><span class="section-number-3">3.4.</span> Boolean Values</h3>
<div class="outline-text-3" id="text-3-4">
<ul class="org-ul">
<li>boolean在JS里面只有两个可能的值:
<ul class="org-ul">
<li>true</li>
<li>false</li>
</ul></li>
<li>JavaScript value可以convert成boolean值,比如下面的值就等同于false:
<ul class="org-ul">
<li>undefined</li>
<li>null</li>
<li>0</li>
<li>-0</li>
<li>NaN</li>
<li>""</li>
</ul></li>
<li>这六个value加上false是起到"否"的作用,其他所有值都是起到"是"的作用</li>
<li>和其他语言一样JavaScript也有如下的操作:
<ul class="org-ul">
<li>&amp;&amp;: 与</li>
<li>||: 或</li>
<li>!: Not</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org55e76ec" class="outline-3">
<h3 id="org55e76ec"><span class="section-number-3">3.5.</span> null and undefined</h3>
<div class="outline-text-3" id="text-3-5">
</div>
<div id="outline-container-org7120220" class="outline-4">
<h4 id="org7120220"><span class="section-number-4">3.5.1.</span> null</h4>
<div class="outline-text-4" id="text-3-5-1">
<ul class="org-ul">
<li>null用来说明一种value absent的状态,null是关键字</li>
<li>如果对null使用typeof的话,会发现返回值为object,这说明null可以被认为是一种特殊的object:"no object"</li>
<li>实践当中,我们不把null作为object类型,而是把他作为null type. null也就是null type的唯一数据</li>
<li>null和python中的None类似</li>
</ul>
</div>
</div>
<div id="outline-container-org376a0f6" class="outline-4">
<h4 id="org376a0f6"><span class="section-number-4">3.5.2.</span> undefined</h4>
<div class="outline-text-4" id="text-3-5-2">
<ul class="org-ul">
<li>undefind也是用来说明一种value absent状态的,不过它是定义在global域的一个const</li>
<li>如果对undefind进行typeof,就会发现返回undefined.</li>
<li>undefined也是undefined type的唯一value</li>
</ul>
</div>
</div>
<div id="outline-container-org1fe2bb1" class="outline-4">
<h4 id="org1fe2bb1"><span class="section-number-4">3.5.3.</span> 两者的联系</h4>
<div class="outline-text-4" id="text-3-5-3">
<ul class="org-ul">
<li>如果用equality operator(==)的话,两者相等.</li>
<li>如果用strict euqality operator(<code>=</code>),两者就不会相等了,因为类型不一样.</li>
<li>两者在if后面都表示false</li>
<li>两者都没有任何的method,试图使用"."或者"[]"在这两者身上都会造成TypeError</li>
<li>两者在编译语义方面真正的区别:
<ul class="org-ul">
<li><p>
undefined代表了一种unexpected的error的数据缺席
</p>
<pre class="example" id="orge70baf4">
undefined to represent a system-level, unexpected, or error-like absensence of value
</pre></li>
<li><p>
null则代表了一种expected的数据缺席
</p>
<pre class="example" id="org9b0373c">
null to represent a program-level, normal, or expected absense of value
</pre></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgcc312a4" class="outline-3">
<h3 id="orgcc312a4"><span class="section-number-3">3.6.</span> Symbols</h3>
<div class="outline-text-3" id="text-3-6">
<ul class="org-ul">
<li>symbol是在ES6中才被引入的,用来作为object类型中property的name的类型:
<ul class="org-ul">
<li>注意,在ES6之前,object类型的property的name是string类型</li>
</ul></li>
<li><p>
Symbol作为property的name比stirng好的地方在于,使用Symbol()函数创建的Symbol值是唯一的,即便使用相同的
参数创建他们. 由于Symbol的唯一性,可以避免不同代码库直接不同模块之间的属性名称冲突
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">const</span> <span style="color: #715ab1;">sym1</span> = Symbol<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"description"</span><span style="color: #3a81c3;">)</span>;
<span style="color: #3a81c3; font-weight: bold;">const</span> <span style="color: #715ab1;">sym2</span> = Symbol<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"description"</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>sym1 === sym2<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">const sym1 = Symbol("description")</span>
</pre>
</div></li>
<li>Symbol.iterator可以定义对象的迭代行为</li>
<li>可以使用Symbol.for()和Symbol.keyFor()在全局Symbol注册表中恭喜Symbol</li>
</ul>
</div>
</div>
<div id="outline-container-org54a286d" class="outline-3">
<h3 id="org54a286d"><span class="section-number-3">3.7.</span> The Global Object</h3>
<div class="outline-text-3" id="text-3-7">
<ul class="org-ul">
<li>有一个object类型的value非常重要,那就是global object</li>
<li>每当JavaScript解释器启动(比如浏览器加载了一个新的页面),那么就会创建一个global object,并且给这个
global object初始化了如下的property:
<ul class="org-ul">
<li>全局const,比如:undefined, Infinity, NaN</li>
<li>全局函数,比如: isNaN(), parseInt(), eval()</li>
<li>Constructor函数,比如: Date(), RegExp(), String(), Object(), Array()</li>
<li>全局Object,比如Math, JSON</li>
</ul></li>
<li>global object最开始的这些property不是"保留关键字",但是实践当中,他们都被赋予了"保留关键字"的地位</li>
<li>Node里面global object有一个property的名字叫做global,global指向global object自己,所以你可以在Node代
码中访问global object</li>
<li>在浏览器领域和Node中global对应的property名字叫做window. 但是浏览器里面的global object会额外定义很多
浏览器特定的property</li>
<li><p>
ES2020最终决定使用关键字globalThis来指代global object.globalThis和之前的global,window一样,访问自己就是返回自己
</p>
<div class="org-src-container">
<pre class="src src-js">console.log<span style="color: #3a81c3;">(</span>globalThis === globalThis.globalThis<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">true</span>
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-org660050f" class="outline-3">
<h3 id="org660050f"><span class="section-number-3">3.8.</span> Immutable Primitive Values and Mutable Object References</h3>
<div class="outline-text-3" id="text-3-8">
<ul class="org-ul">
<li><p>
在JavaScript里面primitive value(undefined, null, boolean, number, string)和object(包括array,function)有本质上的不同:
</p>
<pre class="example" id="orgbe89b6f">
primitive类型的数据是immutable的, 你没办法更改一个primitive value
</pre></li>
<li>对于number和boolean来说,immutable是很直观且容易理解的.但是人们普遍认为string是一个char的array,那么
我岂不是可以更改这个array里面的char,从而间接更改了string?</li>
<li><p>
事实恰恰相反,JavaScript里面所有更改字符串的函数,都是返回一个新的字符串,老的字符串保持不变
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">s</span> = <span style="color: #2d9574;">"hello"</span>;
console.log<span style="color: #3a81c3;">(</span>s.toUpperCase<span style="color: #6c3163;">()</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>s<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">HELLO</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">hello</span>
</pre>
</div></li>
<li>primivite和object对于值的比价也是不一样的:
<ul class="org-ul">
<li><p>
primitive的比较是比较值:两个string只要内容一样,那么必然一样
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">s1</span> = <span style="color: #2d9574;">"hello world"</span>;
<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">s2</span> = <span style="color: #2d9574;">"hello world"</span>;
console.log<span style="color: #3a81c3;">(</span>s1 === s2<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">true</span>
</pre>
</div></li>
<li><p>
object的比较是比较reference,而不是值:两个数组即便是内部数据完全一样,也有可能比较结果为false,只有
两个变量底层指向的object是同一个地址的时候,两者才能相等
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">a</span> = <span style="color: #3a81c3;">[</span>1, 2, 3<span style="color: #3a81c3;">]</span>;
<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">b</span> = <span style="color: #3a81c3;">[</span>1, 2, 3<span style="color: #3a81c3;">]</span>;

console.log<span style="color: #3a81c3;">(</span>a === b<span style="color: #3a81c3;">)</span>;

sa = a.join<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">""</span><span style="color: #3a81c3;">)</span>;
sb = b.join<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">""</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>sa === sb<span style="color: #3a81c3;">)</span>;

<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">c</span> = b;
console.log<span style="color: #3a81c3;">(</span>c === b<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">false</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">true</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">true</span>
</pre>
</div></li>
</ul></li>
<li>object通过reference来进行比较的特性让有一些麻烦的地方:
<ul class="org-ul">
<li>如果我们把object赋值给另外一个object,它其实没有创建新的copy,如果需要创建新的copy,那么需要用for函数依次创建</li>
<li>如果想比较两个地址不一样的对象,其内容是否一致,那么也需要for函数依次比较</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org741c960" class="outline-3">
<h3 id="org741c960"><span class="section-number-3">3.9.</span> Type Conversions</h3>
<div class="outline-text-3" id="text-3-9">
<ul class="org-ul">
<li>我们前面看到过,JavaScript其实有很方便的自动类型转换,比如很多类型能够直接转换为boolean类型</li>
<li>JavaScript另外一个特点,就是一旦两个不同类型数据相加,它甚至会自动帮你转换类型.而且这个过程当中,很多意
想不到,且没有规律. 我们这里就介绍一些非常常见的例子:
<ul class="org-ul">
<li><p>
无论什么类型,和string一旦相加,就会变成string.所以string的"魅力"是比较强的
</p>
<div class="org-src-container">
<pre class="src src-js">console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"string and number"</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>1 + <span style="color: #2d9574;">"2"</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>2 + <span style="color: #2d9574;">"1"</span><span style="color: #3a81c3;">)</span>;

console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"string and boolean"</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"1"</span> + <span style="color: #4e3163;">true</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"1"</span> + <span style="color: #4e3163;">false</span><span style="color: #3a81c3;">)</span>;

console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"string and null"</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"1"</span> + <span style="color: #4e3163;">null</span><span style="color: #3a81c3;">)</span>;

console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"string and undefined"</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"1"</span> + <span style="color: #4e3163;">undefined</span><span style="color: #3a81c3;">)</span>;

console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"string and object"</span><span style="color: #3a81c3;">)</span>;
obj = <span style="color: #3a81c3;">{}</span>
console.log<span style="color: #3a81c3;">(</span>obj + 1<span style="color: #3a81c3;">)</span>
</pre>
</div></li>
<li><p>
Number的魅力稍弱,但是遇到boolean和null还是能将其转换.不弱在遇到undefine的时候,两者最终得到NaN
</p>
<div class="org-src-container">
<pre class="src src-js">console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"number and boolean"</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>1 + <span style="color: #4e3163;">true</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>1 + <span style="color: #4e3163;">false</span><span style="color: #3a81c3;">)</span>;

console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"number and null"</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>1 + <span style="color: #4e3163;">null</span><span style="color: #3a81c3;">)</span>;

console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"number and undefined"</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>1 + <span style="color: #4e3163;">undefined</span><span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">number and boolean</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">2</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">1</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">number and null</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">1</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">number and undefined</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">NaN</span>
</pre>
</div></li>
<li><p>
undefined和其他类型转换的时候,"力量"也很高,但是"魅力"不足,最终经常可以将对方和自己打造成NaN,而不是undefined
</p>
<div class="org-src-container">
<pre class="src src-js">console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"number and undefind"</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>1 + <span style="color: #4e3163;">undefined</span><span style="color: #3a81c3;">)</span>;

console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"boolean and undefined"</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span><span style="color: #4e3163;">true</span> + <span style="color: #4e3163;">undefined</span><span style="color: #3a81c3;">)</span>;

console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"null and undefined"</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span><span style="color: #4e3163;">null</span> + <span style="color: #4e3163;">undefined</span><span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">number and undefind</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">NaN</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">boolean and undefined</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">NaN</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">null and undefined</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">NaN</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
<div id="outline-container-org0c16222" class="outline-4">
<h4 id="org0c16222"><span class="section-number-4">3.9.1.</span> Conversions and Equality</h4>
<div class="outline-text-4" id="text-3-9-1">
<ul class="org-ul">
<li>JavaScript有两个测试value是否相等的符号:
<ul class="org-ul">
<li>strict equality operator: 首先保证类型相同,然后再做判断,不会为操作数进行类型转换</li>
<li><p>
equality operator: 类型不同的情况下,会为操作数进行类型转换,然后做等值判断
</p>
<div class="org-src-container">
<pre class="src src-js">console.log<span style="color: #3a81c3;">(</span><span style="color: #4e3163;">null</span> == <span style="color: #4e3163;">undefined</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"0"</span> == 0<span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>0 == <span style="color: #4e3163;">false</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"0"</span> == <span style="color: #4e3163;">false</span><span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">true</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">true</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">true</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">true</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgb1bd501" class="outline-4">
<h4 id="orgb1bd501"><span class="section-number-4">3.9.2.</span> Explicit Conversions</h4>
<div class="outline-text-4" id="text-3-9-2">
<ul class="org-ul">
<li>虽然JavaScript有implicit的conversion,但是使用explicit的转换很显然能带来更加清晰的代码</li>
<li><p>
最常见的显式转换的代码是使用Boolean(), Number()和String()函数,如下:
</p>
<div class="org-src-container">
<pre class="src src-js">console.log<span style="color: #3a81c3;">(</span>Number<span style="color: #6c3163;">(</span><span style="color: #2d9574;">"3"</span><span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>String<span style="color: #6c3163;">(</span><span style="color: #4e3163;">false</span><span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>Boolean<span style="color: #6c3163;">(</span><span style="color: #2d9574;">[]</span><span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">3</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">false</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">true</span>
</pre>
</div></li>
<li><p>
注意, 这几个函数还有和new的配合方法,我们遵循书中的如下建议
</p>
<pre class="example" id="org4f22a93">
使用new 和Boolean(), Number(), String()函数创建wrapper object的特性,已经不再推荐使用
</pre></li>
<li><p>
number class的toString()函数其地位和golang里面的String()函数是一样的
</p>
<div class="org-src-container">
<pre class="src src-go"><span style="color: #3a81c3; font-weight: bold;">package</span> main

<span style="color: #3a81c3; font-weight: bold;">import</span> <span style="color: #3a81c3;">(</span>
        <span style="color: #2d9574;">"fmt"</span>
<span style="color: #3a81c3;">)</span>

<span style="color: #3a81c3; font-weight: bold;">type</span> <span style="color: #ba2f59; font-weight: bold;">User</span> <span style="color: #3a81c3; font-weight: bold;">struct</span> <span style="color: #3a81c3;">{</span>
        Name <span style="color: #ba2f59; font-weight: bold;">string</span>
<span style="color: #3a81c3;">}</span>

<span style="color: #3a81c3; font-weight: bold;">func</span> <span style="color: #3a81c3;">(</span><span style="color: #715ab1;">u</span> <span style="color: #ba2f59; font-weight: bold;">User</span><span style="color: #3a81c3;">)</span> <span style="color: #6c3163; font-weight: bold;">String</span><span style="color: #3a81c3;">()</span> <span style="color: #ba2f59; font-weight: bold;">string</span> <span style="color: #3a81c3;">{</span>
        <span style="color: #3a81c3; font-weight: bold;">return</span> fmt.<span style="color: #6c3163; font-weight: bold;">Sprintf</span><span style="color: #6c3163;">(</span><span style="color: #2d9574;">"User:[%v]"</span>, u.Name<span style="color: #6c3163;">)</span>
<span style="color: #3a81c3;">}</span>

<span style="color: #3a81c3; font-weight: bold;">func</span> <span style="color: #6c3163; font-weight: bold;">main</span><span style="color: #3a81c3;">()</span> <span style="color: #3a81c3;">{</span>
        fmt.<span style="color: #6c3163; font-weight: bold;">Println</span><span style="color: #6c3163;">(</span><span style="color: #2d9574;">"Results:"</span><span style="color: #6c3163;">)</span>

        <span style="color: #715ab1;">u</span> := <span style="color: #ba2f59; font-weight: bold;">User</span><span style="color: #6c3163;">{</span><span style="color: #2d9574;">"alice"</span><span style="color: #6c3163;">}</span>

        fmt.<span style="color: #6c3163; font-weight: bold;">Println</span><span style="color: #6c3163;">(</span>u<span style="color: #6c3163;">)</span>
<span style="color: #3a81c3;">}</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Results:</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">User:[alice]</span>
</pre>
</div></li>
<li>JavaScript中的toStriong()函数,几乎所有的类型都有,但是有些继承后更改了参数,具体如下:
<ul class="org-ul">
<li><p>
对象的toStirng(),没有参数
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">obj</span> = <span style="color: #3a81c3;">{}</span>;
console.log<span style="color: #3a81c3;">(</span>obj.toString<span style="color: #6c3163;">()</span><span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[object Object]</span>
</pre>
</div></li>
<li><p>
数组的toString()也没有参数,返回逗号分隔的字符串
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">arr</span> = <span style="color: #3a81c3;">[</span>1, 2, 3<span style="color: #3a81c3;">]</span>;
console.log<span style="color: #3a81c3;">(</span>arr.toString<span style="color: #6c3163;">()</span><span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">1,2,3</span>
</pre>
</div></li>
<li><p>
数字的toString()可以使用一个参数来指定"进制",什么都不加的时候(空参数)表示"十进制".这个特性在日常
生活中非常有用,可以临时用node的repl来处理很多转换的问题
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">num</span> = 123;
console.log<span style="color: #3a81c3;">(</span>num.toString<span style="color: #6c3163;">()</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>num.toString<span style="color: #6c3163;">(</span>10<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>num.toString<span style="color: #6c3163;">(</span>2<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>num.toString<span style="color: #6c3163;">(</span>16<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">123</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">123</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">1111011</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">7b</span>
</pre>
</div></li>
</ul></li>
<li>JavaSctipt中还有将字符串转换为数字的函数,最常用的就是parseInt. parseInt有非常多的参数选择:
<ul class="org-ul">
<li><p>
最有用的,是两个参数版本:和刚才的toString("x进制")相对应的是下面的用法,parseInt()第一个参数为字符串,
第二个参数为想要如何解释第一个参数的"进制",这样可以把字符串反设置为整型
</p>
<div class="org-src-container">
<pre class="src src-js">console.log<span style="color: #3a81c3;">(</span>parseInt<span style="color: #6c3163;">(</span><span style="color: #2d9574;">"11"</span>, 2<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>parseInt<span style="color: #6c3163;">(</span><span style="color: #2d9574;">"ff"</span>, 16<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>parseInt<span style="color: #6c3163;">(</span><span style="color: #2d9574;">"zz"</span>, 36<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>parseInt<span style="color: #6c3163;">(</span><span style="color: #2d9574;">"077"</span>, 8<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>parseInt<span style="color: #6c3163;">(</span><span style="color: #2d9574;">"077"</span>, 10<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">3</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">255</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">1295</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">63</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">77</span>
</pre>
</div></li>
<li><p>
最常用的,则是一个参数的版本. 这个版本里面parseInt()会尽最大努力的去解析字符串
</p>
<div class="org-src-container">
<pre class="src src-js">console.log<span style="color: #3a81c3;">(</span>parseInt<span style="color: #6c3163;">(</span><span style="color: #2d9574;">" 3.14 meters"</span><span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>parseInt<span style="color: #6c3163;">(</span><span style="color: #2d9574;">"3 blind mice"</span><span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>parseInt<span style="color: #6c3163;">(</span><span style="color: #2d9574;">"-12.34"</span><span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">3</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">3</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">-12</span>
</pre>
</div></li>
<li>我们看到字符串如下的"不合适"都会被parseInt所克服:
<ol class="org-ol">
<li>字符串开始的空格被忽略</li>
<li>字符串后面剩余的不是数字的文字被忽略</li>
<li>符号被正确的处理</li>
</ol></li>
<li><p>
那么如果有些字符串特别"过分"的情况下怎么办呢?parseInt会返回NaN
</p>
<div class="org-src-container">
<pre class="src src-js">console.log<span style="color: #3a81c3;">(</span>parseInt<span style="color: #6c3163;">(</span><span style="color: #2d9574;">".1"</span><span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>parseInt<span style="color: #6c3163;">(</span><span style="color: #2d9574;">"$1.2"</span><span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">NaN</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">NaN</span>
</pre>
</div></li>
</ul></li>
<li>由于Javascript的number类型本质上是float类型,所以Javascript自然也准备了和parseInt类似的parseFloat函数
<ul class="org-ul">
<li><p>
parseFloat能够对"不过分"的字符串进行解析
</p>
<div class="org-src-container">
<pre class="src src-js">console.log<span style="color: #3a81c3;">(</span>parseFloat<span style="color: #6c3163;">(</span><span style="color: #2d9574;">".1"</span><span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>parseFloat<span style="color: #6c3163;">(</span><span style="color: #2d9574;">"-12.3"</span><span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">0.1</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">-12.3</span>
</pre>
</div></li>
<li><p>
parseFloat对"过分"的字符串,也是返回NaN
</p>
<div class="org-src-container">
<pre class="src src-js">console.log<span style="color: #3a81c3;">(</span>parseFloat<span style="color: #6c3163;">(</span><span style="color: #2d9574;">"$1.23"</span><span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">NaN</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgfbbe3c3" class="outline-3">
<h3 id="orgfbbe3c3"><span class="section-number-3">3.10.</span> Variable Declaration and Assignment</h3>
<div class="outline-text-3" id="text-3-10">
<ul class="org-ul">
<li>计算机编程最基础的操作,就是创造了变量:我们使用一个name来代表value,把一个name和一个value给绑定起来
就让我们能够在程序中使用他们.在编程中,通常有两种name:
<ul class="org-ul">
<li>如果我们把这个name叫做variable(变量),那么很显然这个name指向的数据是会变的,也就是新的value可以赋给这个name</li>
<li>如果我们把这个name叫做const(常量),那么就是说这个name和这个value永远绑定,无法赋一个新value给这个name</li>
</ul></li>
<li>在ES6之后:
<ul class="org-ul">
<li>变量用let声明变量</li>
<li>常量用const声明常量</li>
</ul></li>
<li>在ES6之前,只有一种声明方式(不支持常量),那就是var</li>
</ul>
</div>
<div id="outline-container-orgda9643a" class="outline-4">
<h4 id="orgda9643a"><span class="section-number-4">3.10.1.</span> Declarations with let and const</h4>
<div class="outline-text-4" id="text-3-10-1">
<ul class="org-ul">
<li>我们先来看看ES6之后的let使用方法:
<ul class="org-ul">
<li><p>
使用let单独来declare一个变量,但是不进行初始化,这种情况下,由于没有初始化值,所以变量的值是undefined,
直到有新的值赋予给这个变量
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">i</span>;
console.log<span style="color: #3a81c3;">(</span>i<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">undefined</span>
</pre>
</div></li>
<li><p>
使用let单独来declare一个变量,然后马上进行初始化.这样变量就在声明的一瞬间就有了初始化值
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">message</span> = <span style="color: #2d9574;">"hello"</span>;
console.log<span style="color: #3a81c3;">(</span>message<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">hello</span>
</pre>
</div></li>
<li><p>
let声明后马上赋值,在for循环中非常常见,比如
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">for</span> <span style="color: #3a81c3;">(</span><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">i</span> = 0, <span style="color: #715ab1;">len</span> = 3; i &lt; len; i++<span style="color: #3a81c3;">)</span> <span style="color: #3a81c3;">{</span>
  console.log<span style="color: #6c3163;">(</span>i<span style="color: #6c3163;">)</span>;
<span style="color: #3a81c3;">}</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">0</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">1</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">2</span>
</pre>
</div></li>
</ul></li>
<li><p>
常量需要使用const来声明并且初始化(之所以说"声明并初始化",因为常量不能"先声明",然后"初始化",必须一气呵成)
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">const</span> <span style="color: #715ab1;">H</span> = 75;
<span style="color: #3a81c3; font-weight: bold;">const</span> <span style="color: #715ab1;">AU</span> = 1.596e8;

console.log<span style="color: #3a81c3;">(</span>H<span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>AU<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">75</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">159600000</span>
</pre>
</div></li>
<li>我们也注意到常量"一般来说"都是用全大写的字母组成的</li>
<li><p>
任何试图更改const的行为都会造成TypeError
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">const</span> <span style="color: #715ab1;">C</span> = 299.58;
C = 300;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">C = 300;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">//   </span><span style="color: #2aa1ae; background-color: #ecf3ec;">^</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">TypeError: Assignment to constant variable.</span>
</pre>
</div></li>
<li>let和const对于常量和变量的定义是有scope的.这个scope的范围和其他编程语言差不多,如下情况都是一个scope:
<ul class="org-ul">
<li>class 结构体内</li>
<li>function 结构体内</li>
<li>if/else 结构体内</li>
<li>while 结构体内</li>
<li>for 结构体内</li>
</ul></li>
<li>需要注意的是,虽然上面的scope都是结构体内,但是在for或者while的括号里面使用let,const定义的变量,也算在
这个结构体内</li>
<li>如果声明出现在所有的block以外,我们就叫他们global variable, global const. global在Javascript的不同领
域有不同设置:
<ul class="org-ul">
<li>如果是Node文件,那么在js文件所有的函数外就是global,那么这个变量或者常量,在这个文件里面是随处可见的.
但是其他文件就不知道它了</li>
<li>如果是传统的HTML文件,在一个&lt;script&gt;里面定义出来的常量或者变量,在其他&lt;script&gt;里面也是可见的.</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgac7fa04" class="outline-4">
<h4 id="orgac7fa04"><span class="section-number-4">3.10.2.</span> Variable Declarations with var</h4>
<div class="outline-text-4" id="text-3-10-2">
<ul class="org-ul">
<li>在ES6之前,唯一定义变量的方法就是var.而在ES6之前是无法定义常量的,所以可以理解为var就是let的古早版本</li>
<li>var定义变量有很多"反直觉"的地方,在ES6之后,我们不应该再使用var定义变量.我们这里介绍var是为了向前兼容</li>
<li>我们这里着重介绍下var和let的不同点:
<ol class="org-ol">
<li>作用域(scope):
<ul class="org-ul">
<li><p>
var只是在函数内部是局部变量. if等scope无法限制var定义的变量,var总会"上升"到最近的function里面
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">function</span> <span style="color: #6c3163; font-weight: bold;">testVar</span><span style="color: #3a81c3;">()</span> <span style="color: #3a81c3;">{</span>
  <span style="color: #3a81c3; font-weight: bold;">if</span> <span style="color: #6c3163;">(</span><span style="color: #4e3163;">true</span><span style="color: #6c3163;">)</span> <span style="color: #6c3163;">{</span>
    <span style="color: #3a81c3; font-weight: bold;">var</span> <span style="color: #715ab1;">x</span> = 1;
  <span style="color: #6c3163;">}</span>
  console.log<span style="color: #6c3163;">(</span>x<span style="color: #6c3163;">)</span>;
<span style="color: #3a81c3;">}</span>

testVar<span style="color: #3a81c3;">()</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">1</span>
</pre>
</div></li>
<li><p>
let是作用域比较清晰,就在自己定义的作用域里面,所定义的变量是局部的,复合现代编程语言的"直觉"
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">function</span> <span style="color: #6c3163; font-weight: bold;">testLet</span><span style="color: #3a81c3;">()</span> <span style="color: #3a81c3;">{</span>
  <span style="color: #3a81c3; font-weight: bold;">if</span> <span style="color: #6c3163;">(</span><span style="color: #4e3163;">true</span><span style="color: #6c3163;">)</span> <span style="color: #6c3163;">{</span>
    <span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">x</span> = 1;
  <span style="color: #6c3163;">}</span>
  console.log<span style="color: #6c3163;">(</span>x<span style="color: #6c3163;">)</span>;
<span style="color: #3a81c3;">}</span>

testLet<span style="color: #3a81c3;">()</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">//   </span><span style="color: #2aa1ae; background-color: #ecf3ec;">console.log(x);</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">//               </span><span style="color: #2aa1ae; background-color: #ecf3ec;">^</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">ReferenceError: x is not defined</span>
</pre>
</div></li>
</ul></li>
<li>变量提升(Hoisting)
<ul class="org-ul">
<li><p>
var会变量提升,在代码执行之前,var声明的变量会被提升到作用域(var的作用域本来就奇怪,在function内部)
的顶部,但不会初始化
</p>
<div class="org-src-container">
<pre class="src src-js">console.log<span style="color: #3a81c3;">(</span>a<span style="color: #3a81c3;">)</span>;
<span style="color: #3a81c3; font-weight: bold;">var</span> <span style="color: #715ab1;">a</span> = 2;
console.log<span style="color: #3a81c3;">(</span>a<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">undefined</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">2</span>
</pre>
</div></li>
<li><p>
let不会变量提升:在let声明变量之前,无法使用这个变量
</p>
<div class="org-src-container">
<pre class="src src-js">console.log<span style="color: #3a81c3;">(</span>b<span style="color: #3a81c3;">)</span>;
<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">b</span> = 2;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">console.log(b)</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">//             </span><span style="color: #2aa1ae; background-color: #ecf3ec;">^</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">ReferenceError: Cannot access 'b' before initialization</span>
</pre>
</div></li>
</ul></li>
<li>重复声明(Redeclaration)
<ul class="org-ul">
<li><p>
var: 允许在同一作用域内重复声明变量
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">var</span> <span style="color: #715ab1;">a</span> = 1;
console.log<span style="color: #3a81c3;">(</span>a<span style="color: #3a81c3;">)</span>;
<span style="color: #3a81c3; font-weight: bold;">var</span> <span style="color: #715ab1;">a</span> = 2;
console.log<span style="color: #3a81c3;">(</span>a<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">1</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">2</span>
</pre>
</div></li>
<li><p>
let: 不允许在同一作用域里面重复声明变量
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">b</span> = 1;
<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">b</span> = 2;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">let b = 2;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">//     </span><span style="color: #2aa1ae; background-color: #ecf3ec;">^</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">SyntaxError: Identifier 'b' has already been declared</span>
</pre>
</div></li>
</ul></li>
<li>全局对象属性(Global Object Property)
<ul class="org-ul">
<li><p>
var: 在全局作用域中声明的对象会成为全局对象(window)的property(曾经在早期版本node里面也会成为global的property)
</p>
<pre class="example" id="org952f51d">
window.x
undefined
var x = 123;
undefined
window.x
123
</pre></li>
<li><p>
let: 不会成为全局对象的属性
</p>
<pre class="example" id="org175105e">
let y = 2
undefined
window.y
undefined
</pre></li>
</ul></li>
</ol></li>
</ul>
</div>
</div>
<div id="outline-container-org995bd61" class="outline-4">
<h4 id="org995bd61"><span class="section-number-4">3.10.3.</span> Destructuring Assignment</h4>
<div class="outline-text-4" id="text-3-10-3">
<ul class="org-ul">
<li>解构赋值是ES6引入的一种全新语法,允许从数组和对象中取值,并且将值赋给变量,这种语法使得代码简洁易读</li>
<li><p>
最基本的例子如下,从数组赋值
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #3a81c3;">[</span><span style="color: #715ab1;">x</span>, <span style="color: #715ab1;">y</span><span style="color: #3a81c3;">]</span> = <span style="color: #3a81c3;">[</span>1, 2<span style="color: #3a81c3;">]</span>;
console.log<span style="color: #3a81c3;">(</span>x, y<span style="color: #3a81c3;">)</span>;
<span style="color: #3a81c3;">[</span>x, y<span style="color: #3a81c3;">]</span> = <span style="color: #3a81c3;">[</span>x + 1, y + 1<span style="color: #3a81c3;">]</span>;
console.log<span style="color: #3a81c3;">(</span>x, y<span style="color: #3a81c3;">)</span>;
<span style="color: #3a81c3;">[</span>x, y<span style="color: #3a81c3;">]</span> = <span style="color: #3a81c3;">[</span>y, x<span style="color: #3a81c3;">]</span>;
console.log<span style="color: #3a81c3;">(</span>x, y<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">1 2</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">2 3</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">3 2</span>
</pre>
</div></li>
<li><p>
最基本的例子稍微扩展一点,就是在函数返回值里面返回多个值的情况,可以返回一个数组.然后使用解构赋值读取
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">function</span> <span style="color: #6c3163; font-weight: bold;">toPolar</span><span style="color: #3a81c3;">(</span><span style="color: #715ab1;">x</span>, <span style="color: #715ab1;">y</span><span style="color: #3a81c3;">)</span> <span style="color: #3a81c3;">{</span>
  <span style="color: #3a81c3; font-weight: bold;">return</span> <span style="color: #6c3163;">[</span>Math.sqrt<span style="color: #2d9574;">(</span>x * x + y * y<span style="color: #2d9574;">)</span>, Math.atan2<span style="color: #2d9574;">(</span>y, x<span style="color: #2d9574;">)</span><span style="color: #6c3163;">]</span>;
<span style="color: #3a81c3;">}</span>

<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #3a81c3;">[</span><span style="color: #715ab1;">r</span>, <span style="color: #715ab1;">theta</span><span style="color: #3a81c3;">]</span> = toPolar<span style="color: #3a81c3;">(</span>1.0, 1.0<span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>r, theta<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">1.4142135623730951 0.7853981633974483</span>
</pre>
</div></li>
<li><p>
我们可以在for循环里面使用解构赋值
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">o</span> = <span style="color: #3a81c3;">{</span> x: 1, y: 2 <span style="color: #3a81c3;">}</span>;
<span style="color: #3a81c3; font-weight: bold;">for</span> <span style="color: #3a81c3;">(</span><span style="color: #3a81c3; font-weight: bold;">const</span> <span style="color: #6c3163;">[</span><span style="color: #715ab1;">name</span>, <span style="color: #715ab1;">value</span><span style="color: #6c3163;">]</span> <span style="color: #3a81c3; font-weight: bold;">of</span> Object.entries<span style="color: #6c3163;">(</span>o<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span> <span style="color: #3a81c3;">{</span>
  console.log<span style="color: #6c3163;">(</span>name, value<span style="color: #6c3163;">)</span>;
<span style="color: #3a81c3;">}</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">x 1</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">y 2</span>
</pre>
</div></li>
<li>解构赋值的左右两边可以数量不等:
<ul class="org-ul">
<li><p>
如果左边的参数多了,那么没轮上赋值的就是undefined
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #3a81c3;">[</span><span style="color: #715ab1;">x</span>, <span style="color: #715ab1;">y</span><span style="color: #3a81c3;">]</span> = <span style="color: #3a81c3;">[</span>1<span style="color: #3a81c3;">]</span>;
console.log<span style="color: #3a81c3;">(</span>x, y<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">1 undefined</span>
</pre>
</div></li>
<li><p>
如果右边多了,那么就有些右边参数没有赋值给变量而已
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #3a81c3;">[</span><span style="color: #715ab1;">x</span>, <span style="color: #715ab1;">y</span><span style="color: #3a81c3;">]</span> = <span style="color: #3a81c3;">[</span>1, 2, 3<span style="color: #3a81c3;">]</span>;
console.log<span style="color: #3a81c3;">(</span>x, y<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">1 2</span>
</pre>
</div></li>
<li><p>
我们甚至可以跳过一些值,只把部分值赋值给左边
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #3a81c3;">[</span>, <span style="color: #715ab1;">x</span>, , <span style="color: #715ab1;">y</span><span style="color: #3a81c3;">]</span> = <span style="color: #3a81c3;">[</span>1, 2, 3, 4<span style="color: #3a81c3;">]</span>;
console.log<span style="color: #3a81c3;">(</span>x, y<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">2 4</span>
</pre>
</div></li>
<li><p>
如果右边参数多了,左边少了.配对到最后,左边只剩一个,右边多个,我们想把右边的多个赋值给左边的一个,那
么我们可以如下配置
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #3a81c3;">[</span>x, ...y<span style="color: #3a81c3;">]</span> = <span style="color: #3a81c3;">[</span>1, 2, 3, 4<span style="color: #3a81c3;">]</span>;
console.log<span style="color: #3a81c3;">(</span>x, y<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">1 [ 2, 3, 4 ]</span>
</pre>
</div></li>
</ul></li>
<li><p>
解构赋值还可以做嵌入式的array赋值
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #3a81c3;">[</span><span style="color: #715ab1;">a</span>, <span style="color: #6c3163;">[</span><span style="color: #715ab1;">b</span>, <span style="color: #715ab1;">c</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">]</span> = <span style="color: #3a81c3;">[</span>1, <span style="color: #6c3163;">[</span>2, 2.5<span style="color: #6c3163;">]</span>, 3<span style="color: #3a81c3;">]</span>;
console.log<span style="color: #3a81c3;">(</span>a, b, c<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">1 2 2.5</span>
</pre>
</div></li>
<li><p>
解构赋值的右边不需要是数组,可以使用任何的iterable object,比如字符串
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #3a81c3;">[</span>first, ...rest<span style="color: #3a81c3;">]</span> = <span style="color: #2d9574;">"Hello"</span>;

console.log<span style="color: #3a81c3;">(</span>first, rest<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">H [ 'e', 'l', 'l', 'o' ]</span>
</pre>
</div></li>
<li><p>
解构赋值的左边甚至可以不是数组(那么当然右边也不是数组啦), 左右替代数组的是对象,这种解构赋值就更加
的灵活
</p>
<pre class="example" id="orge47ddd1">
这种解构的灵活性来源于结构体解构可以使用key,而数组解构只能利用index
</pre></li>
<li>成员变量肯定是最常见的结构体解构赋值的
<ul class="org-ul">
<li><p>
例子如下
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">transparent</span> = <span style="color: #3a81c3;">{</span> r: 0.0, g: 0.0, b: 0.0, a: 1.0 <span style="color: #3a81c3;">}</span>;
<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #3a81c3;">{</span> r, g, b <span style="color: #3a81c3;">}</span> = transparent;
console.log<span style="color: #3a81c3;">(</span>r, g, b<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">0 0 0</span>
</pre>
</div></li>
<li>我们注意到上面的transparent object肯定不止这三个成员变量,那么其他没有被左边"提起到"的成员(比如a),
就不会被赋值啦</li>
</ul></li>
<li>成员函数也是可以被解构赋值的
<ul class="org-ul">
<li><p>
例子如下
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">const</span> <span style="color: #3a81c3;">{</span> sin, cos, tan <span style="color: #3a81c3;">}</span> = Math;

console.log<span style="color: #3a81c3;">(</span>sin<span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>cos<span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>tan<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[Function: sin]</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[Function: cos]</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[Function: tan]</span>
</pre>
</div></li>
<li>我们注意到上面的Math object肯定不止这三个成员函数,那么其他没有被左边"提起到"的成员,就不会被赋值啦</li>
<li><p>
如果左边变量"提起到"的成员,不是右边的成员,那么左边的这些变量直接就是undefined
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">const</span> <span style="color: #3a81c3;">{</span> sin, cos, tan, somename <span style="color: #3a81c3;">}</span> = Math;

console.log<span style="color: #3a81c3;">(</span>somename<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">undefined</span>
</pre>
</div></li>
</ul></li>
<li>结构体解构还有其他高阶的用法,但是鉴于这些用法既难写,又难读,所以作者不建议我们使用,我们就不继续进行
介绍了</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-orge14ef85" class="outline-2">
<h2 id="orge14ef85"><span class="section-number-2">4.</span> Chapter4: Expressions and Operators</h2>
<div class="outline-text-2" id="text-4">
<ul class="org-ul">
<li><p>
本章我们介绍expression和operator,之所以把这两个合起来讲,是因为
</p>
<pre class="example" id="orgeef84c3">
复杂的expression就是operator把简单的expression给组合起来得到的
</pre></li>
<li><p>
在JavaScript里面,所有能够得到value的一段代码都是expression
</p>
<pre class="example" id="org24a0967">
An expression is a phrase of JavaScript that can be evaluated to produce a value
</pre></li>
</ul>
</div>
<div id="outline-container-org471c06f" class="outline-3">
<h3 id="org471c06f"><span class="section-number-3">4.1.</span> Primary Expression</h3>
<div class="outline-text-3" id="text-4-1">
<ul class="org-ul">
<li>最简单的expression就是primary expression,它们的特点是不包含任何的更简单的expression(已经不能再简单了)</li>
<li>在Javascript中有如下几种primary expression:
<ul class="org-ul">
<li><p>
常量或者literal value
</p>
<div class="org-src-container">
<pre class="src src-shell">&gt; 1.23
1.23
&gt; <span style="color: #2d9574;">"hello"</span>
<span style="color: #2d9574;">'hello'</span>
&gt; /pattern/
/pattern/
</pre>
</div></li>
<li><p>
部分关键字
</p>
<div class="org-src-container">
<pre class="src src-shell">&gt; true
true
&gt; false
false
&gt; null
null
&gt; this
&lt;ref *1&gt; Object <span style="color: #3a81c3;">[</span>global<span style="color: #3a81c3;">]</span> <span style="color: #3a81c3;">{</span>
  global: <span style="color: #6c3163;">[</span>Circular *1<span style="color: #6c3163;">]</span>,
  clearImmediate: <span style="color: #6c3163;">[</span>Function: clearImmediate<span style="color: #6c3163;">]</span>,
  setImmediate: <span style="color: #6c3163;">[</span>Function: setImmediate<span style="color: #6c3163;">]</span> <span style="color: #6c3163;">{</span>
    <span style="color: #2d9574;">[</span>Symbol<span style="color: #67b11d;">(</span>nodejs.util.promisify.custom<span style="color: #67b11d;">)</span><span style="color: #2d9574;">]</span>: <span style="color: #2d9574;">[</span>Getter<span style="color: #2d9574;">]</span>
  <span style="color: #6c3163;">}</span>,
  clearInterval: <span style="color: #6c3163;">[</span>Function: clearInterval<span style="color: #6c3163;">]</span>,
  clearTimeout: <span style="color: #6c3163;">[</span>Function: clearTimeout<span style="color: #6c3163;">]</span>,
  setInterval: <span style="color: #6c3163;">[</span>Function: setInterval<span style="color: #6c3163;">]</span>,
  setTimeout: <span style="color: #6c3163;">[</span>Function: setTimeout<span style="color: #6c3163;">]</span> <span style="color: #6c3163;">{</span>
    <span style="color: #2d9574;">[</span>Symbol<span style="color: #67b11d;">(</span>nodejs.util.promisify.custom<span style="color: #67b11d;">)</span><span style="color: #2d9574;">]</span>: <span style="color: #2d9574;">[</span>Getter<span style="color: #2d9574;">]</span>
  <span style="color: #6c3163;">}</span>,
  queueMicrotask: <span style="color: #6c3163;">[</span>Function: queueMicrotask<span style="color: #6c3163;">]</span>,
  structuredClone: <span style="color: #6c3163;">[</span>Function: structuredClone<span style="color: #6c3163;">]</span>,
  atob: <span style="color: #6c3163;">[</span>Getter/Setter<span style="color: #6c3163;">]</span>,
  btoa: <span style="color: #6c3163;">[</span>Getter/Setter<span style="color: #6c3163;">]</span>,
  performance: <span style="color: #6c3163;">[</span>Getter/Setter<span style="color: #6c3163;">]</span>,
  fetch: <span style="color: #6c3163;">[</span>Function: fetch<span style="color: #6c3163;">]</span>,
  navigator: <span style="color: #6c3163;">[</span>Getter<span style="color: #6c3163;">]</span>,
  crypto: <span style="color: #6c3163;">[</span>Getter<span style="color: #6c3163;">]</span>
<span style="color: #3a81c3;">}</span>
</pre>
</div></li>
<li><p>
变量,变量单独一行就是一个expression,但是要小心,如果变量没有初始化过,那么其实就不能叫变量,我们试图
evaluate没有初始化过的name,就会得到ReferenceError
</p>
<div class="org-src-container">
<pre class="src src-shell">&gt; i
Uncaught ReferenceError: i is not defined
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org925d821" class="outline-3">
<h3 id="org925d821"><span class="section-number-3">4.2.</span> Object and Array Initializers</h3>
<div class="outline-text-3" id="text-4-2">
<ul class="org-ul">
<li><p>
我们创建object或者array的时候,都会用到literal. 这种literal不是primarty expression,它是由opetartor和
primary expression组合起来的.比如
</p>
<div class="org-src-container">
<pre class="src src-shell">&gt; <span style="color: #3a81c3;">[</span>1, 2, 3<span style="color: #3a81c3;">]</span>
<span style="color: #3a81c3;">[</span> 1, 2, 3 <span style="color: #3a81c3;">]</span>
&gt; <span style="color: #3a81c3;">{</span>x:2.3, y:1.2<span style="color: #3a81c3;">}</span>
<span style="color: #3a81c3;">{</span> x: 2.3, y: 1.2 <span style="color: #3a81c3;">}</span>
</pre>
</div></li>
<li><p>
初始化数组的literal的叫做array literal,其实可以有多种变化,比如可以临时计算,可以嵌套,还可以忽略某些
成员进行初始化(未指明的index会被初始化为undefined)
</p>
<div class="org-src-container">
<pre class="src src-js">&gt; <span style="color: #3a81c3;">[]</span>
<span style="color: #3a81c3;">[]</span>
&gt; <span style="color: #3a81c3;">[</span>1+2, 5+6<span style="color: #3a81c3;">]</span>
<span style="color: #3a81c3;">[</span> 3, 11 <span style="color: #3a81c3;">]</span>
&gt; <span style="color: #3a81c3;">[</span><span style="color: #6c3163;">[</span>1,2,3<span style="color: #6c3163;">]</span>, <span style="color: #6c3163;">[</span>4, 5, 6<span style="color: #6c3163;">]</span>, <span style="color: #6c3163;">[</span>7,8,9<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">]</span>
<span style="color: #3a81c3;">[</span> <span style="color: #6c3163;">[</span> 1, 2, 3 <span style="color: #6c3163;">]</span>, <span style="color: #6c3163;">[</span> 4, 5, 6 <span style="color: #6c3163;">]</span>, <span style="color: #6c3163;">[</span> 7, 8, 9 <span style="color: #6c3163;">]</span> <span style="color: #3a81c3;">]</span>
&gt; <span style="color: #3a81c3;">[</span>1,,,5<span style="color: #3a81c3;">]</span>
<span style="color: #3a81c3;">[</span> 1, &lt;2 empty items&gt;, 5 <span style="color: #3a81c3;">]</span>
&gt; sparseArray=<span style="color: #3a81c3;">[</span>1,,,,5<span style="color: #3a81c3;">]</span>
<span style="color: #3a81c3;">[</span> 1, &lt;3 empty items&gt;, 5 <span style="color: #3a81c3;">]</span>
&gt; sparseArray<span style="color: #3a81c3;">[</span>0<span style="color: #3a81c3;">]</span>
1
&gt; sparseArray<span style="color: #3a81c3;">[</span>1<span style="color: #3a81c3;">]</span>
<span style="color: #4e3163;">undefined</span>
&gt; sparseArray<span style="color: #3a81c3;">[</span>2<span style="color: #3a81c3;">]</span>
<span style="color: #4e3163;">undefined</span>
&gt; sparseArray<span style="color: #3a81c3;">[</span>3<span style="color: #3a81c3;">]</span>
<span style="color: #4e3163;">undefined</span>
&gt; sparseArray<span style="color: #3a81c3;">[</span>4<span style="color: #3a81c3;">]</span>
5
</pre>
</div></li>
<li><p>
初始化对象的literal叫做object literal,也有很多变化,比如:从ES6开始,支持嵌套
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">rectangle</span> = <span style="color: #3a81c3;">{</span>
  upperLeft: <span style="color: #6c3163;">{</span> x: 2, y: 2 <span style="color: #6c3163;">}</span>,
  lowerRight: <span style="color: #6c3163;">{</span> x: 4, y: 5 <span style="color: #6c3163;">}</span>,
<span style="color: #3a81c3;">}</span>;

console.log<span style="color: #3a81c3;">(</span>rectangle<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">{ upperLeft: { x: 2, y: 2 }, lowerRight: { x: 4, y: 5 } }</span>
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-orgc353eee" class="outline-3">
<h3 id="orgc353eee"><span class="section-number-3">4.3.</span> Function Definition Expressions</h3>
<div class="outline-text-3" id="text-4-3">
<ul class="org-ul">
<li>前面说了很多literal,比如array literal, object literal,其实litral是动态语言的精髓,所以在JavaScript里
面function也有自己的literal. 而且function literal也自然是一个expression,所以functional literal比较
正式的名字叫做function expression
<ul class="org-ul">
<li><p>
functional literal的例子如下
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">square</span> = <span style="color: #3a81c3; font-weight: bold;">function</span> <span style="color: #3a81c3;">(</span><span style="color: #715ab1;">x</span><span style="color: #3a81c3;">)</span> <span style="color: #3a81c3;">{</span>
  <span style="color: #3a81c3; font-weight: bold;">return</span> x * x;
<span style="color: #3a81c3;">}</span>;
console.log<span style="color: #3a81c3;">(</span>square<span style="color: #6c3163;">(</span>3<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">9</span>
</pre>
</div></li>
<li>上面例子中的square就是一个类型为function的对象.</li>
<li><p>
上面例子我们更经常的写法是function statement,例子如下
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">function</span> <span style="color: #6c3163; font-weight: bold;">square</span><span style="color: #3a81c3;">(</span><span style="color: #715ab1;">x</span><span style="color: #3a81c3;">)</span> <span style="color: #3a81c3;">{</span>
  <span style="color: #3a81c3; font-weight: bold;">return</span> x * x;
<span style="color: #3a81c3;">}</span>
console.log<span style="color: #3a81c3;">(</span>square<span style="color: #6c3163;">(</span>3<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">9</span>
</pre>
</div></li>
</ul></li>
<li>从ES6开始,除了上面的function literal和function statement以外,新增了第三种创建function的方法:
arrow function.我们后面会介绍</li>
</ul>
</div>
</div>
<div id="outline-container-orgc105b59" class="outline-3">
<h3 id="orgc105b59"><span class="section-number-3">4.4.</span> Property Access Expressions</h3>
<div class="outline-text-3" id="text-4-4">
<ul class="org-ul">
<li>所谓property access expression,就是对象和数组调用自己成员时候的语句:
<ul class="org-ul">
<li><p>
使用"点"的例子,只能用于对象:
</p>
<pre class="example" id="orgbd05eef">
expression . identifier
</pre></li>
<li><p>
使用"括号"的例子,可以用于对象和数组
</p>
<pre class="example" id="orga17bc2b">
expression [ expression ]
</pre></li>
</ul></li>
<li>这里我们专门岔开一下来了解下数组和对象的区别:
<ul class="org-ul">
<li>数组其实就是一种对象</li>
<li><p>
在不考虑Symbol的情况下.对象的key都是字符串.数组唯一的特征就是
</p>
<pre class="example" id="orgce58b10">
数组在使用"中括号"访问key的时候,"中括号"里面可以是整形(当然也能用字符串).而普通对象key必须是整形
</pre></li>
<li><p>
例子如下,我们可以看到数组是可以用"整形和字符串"来作为key的
</p>
<div class="org-src-container">
<pre class="src src-js">arr = <span style="color: #3a81c3;">[</span>0, 1, 2, 3<span style="color: #3a81c3;">]</span>;
console.log<span style="color: #3a81c3;">(</span>arr<span style="color: #6c3163;">[</span>1<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>arr<span style="color: #6c3163;">[</span><span style="color: #2d9574;">"1"</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">1</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">1</span>
</pre>
</div></li>
<li><p>
下面的例子中,数组竟然还可以有其他"整形字符串"的key.说明数组就是一种object.
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">arr</span> = <span style="color: #3a81c3;">[</span>10, 20, 30<span style="color: #3a81c3;">]</span>;
console.log<span style="color: #3a81c3;">(</span>arr<span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>arr.length<span style="color: #3a81c3;">)</span>;
arr<span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"key_name"</span><span style="color: #3a81c3;">]</span> = <span style="color: #2d9574;">"MyArray"</span>;
console.log<span style="color: #3a81c3;">(</span>arr<span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>arr.length<span style="color: #3a81c3;">)</span>;
arr<span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"3"</span><span style="color: #3a81c3;">]</span> = 100;
console.log<span style="color: #3a81c3;">(</span>arr<span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>arr.length<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[ 10, 20, 30 ]</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">3</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[ 10, 20, 30, key_name: 'MyArray' ]</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">3</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[ 10, 20, 30, 100, key_name: 'MyArray' ]</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">4</span>
</pre>
</div></li>
<li>上面的例子中我们特意打印了数组的length,我们发现数组的length只统计那些"整型key",我们添加的"字符串
型key"没有被统计进去.</li>
</ul></li>
<li>上面的例子总体的evaluate的过程如下:
<ol class="org-ol">
<li>首先,在使用的时候,无论是"点"还是"括号"的情况,我们都是先evaluate最前面的expression,如果这个expression
本身就是null或者undefined(只有这两个类型不能有property),那么,就会报错TypeError</li>
<li>其次,如果是"括号"的情况下,那么"括号"里面的内容有可能也是expression,那么就需要再次把括号里面的内
容evaluate成整型(只有数组支持整型的key)或者字符串</li>
<li>同时,不是"括号"而是"点",那么情况就简单的多,因为"点"后面跟着的,比如是一个legal的identifer:这就意
味着:
<ul class="org-ul">
<li>如果你的key是带空格(或其他特殊字符),那么就不能用"点"</li>
<li>如果你的key是整型(比如数组),那么你也不能用"点"</li>
</ul></li>
</ol></li>
<li>我们刚才把数组看成是特殊的对象,我们其实还可以把"括号"看成"升级版本的"点":"括号"的能力是"点"能力的
超集</li>
</ul>
</div>
<div id="outline-container-orge9df59a" class="outline-4">
<h4 id="orge9df59a"><span class="section-number-4">4.4.1.</span> Conditional Property Access</h4>
<div class="outline-text-4" id="text-4-4-1">
<ul class="org-ul">
<li><p>
conditional property access是ES2020才加入的新特性,就是为了null和undefined这两个抛出TypeError异常的
特例准备的,其格式如下
</p>
<pre class="example" id="orge75b693">
expression ?. identifier
expression ?. [ expression ]
</pre></li>
<li>最经典的用法就是当调用者为null或者undefiend的情况下,"点"和"括号"都不会抛出TypeError了
<ul class="org-ul">
<li><p>
例子如下
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">a</span> = <span style="color: #4e3163;">null</span>;
console.log<span style="color: #3a81c3;">(</span>a?.b<span style="color: #3a81c3;">)</span>;
<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">c</span> = <span style="color: #4e3163;">undefined</span>;
console.log<span style="color: #3a81c3;">(</span>c?.b<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">undefined</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">undefined</span>
</pre>
</div></li>
</ul></li>
<li>更加进阶也容易让人错判的连续调用"点","括号"的例子
<ul class="org-ul">
<li><p>
代码如下
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">a</span> = <span style="color: #3a81c3;">{</span> b: <span style="color: #4e3163;">null</span> <span style="color: #3a81c3;">}</span>;
console.log<span style="color: #3a81c3;">(</span>a.b?.c.d<span style="color: #3a81c3;">)</span>;
<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">d</span> = <span style="color: #3a81c3;">[</span>1, <span style="color: #4e3163;">undefined</span><span style="color: #3a81c3;">]</span>;
console.log<span style="color: #3a81c3;">(</span>d<span style="color: #6c3163;">[</span>1<span style="color: #6c3163;">]</span>?.<span style="color: #6c3163;">[</span>2<span style="color: #6c3163;">][</span>3<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">undefined</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">undefined</span>
</pre>
</div></li>
<li><p>
我们以"点"的例子讲解,a.b肯定是有值的,但是值是null,那么很显然a.b?.c就肯定是undefined了,这里奇怪的
就是(a.b?.c)作为一个整体(为undefiend)调用d的时候,为什么不抛出异常?答案是
</p>
<pre class="example" id="org51b938d">
如果?.左边的子表达式得到了undefined或者null的结果了,那么整个表达式直接返回
undefined,就不在向后进行evaluate了
</pre></li>
</ul></li>
<li>比较让人容易理解的,就是可以连用"?.",比如下面的例子
<ul class="org-ul">
<li><p>
代码如下
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">a</span> = <span style="color: #3a81c3;">{</span> b: <span style="color: #6c3163;">{}</span> <span style="color: #3a81c3;">}</span>;
console.log<span style="color: #3a81c3;">(</span>a.b?.c?.d<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">undefined</span>
</pre>
</div></li>
<li>由于b并不是undefined或者null,那么"?."左边没有得到undefined,所以如果第二个"?."不加的话,会触发
TypeError</li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org786b1f2" class="outline-3">
<h3 id="org786b1f2"><span class="section-number-3">4.5.</span> Invocation Expressions</h3>
<div class="outline-text-3" id="text-4-5">
<ul class="org-ul">
<li>所谓invocation expression,其实就是包括两种函数调用方式:
<ul class="org-ul">
<li><p>
function调用
</p>
<div class="org-src-container">
<pre class="src src-js">f<span style="color: #3a81c3;">(</span>0<span style="color: #3a81c3;">)</span>
</pre>
</div></li>
<li><p>
method调用
</p>
<div class="org-src-container">
<pre class="src src-js">a.sort<span style="color: #3a81c3;">()</span>
</pre>
</div></li>
</ul></li>
<li>invocation expression之所以被称之为一个expression,是因为它能evaludate出一个value来,在invocation
expression的body里面:
<ul class="org-ul">
<li>如果有return,那么return后面的就会作为evaludate的value值</li>
<li>如果没有return,那么就会使用undefined作为evaludate的value值</li>
</ul></li>
<li>这里多说一句method invocation,其和function不一样的地方在于:
<ul class="org-ul">
<li>method invocation有一个调用对象</li>
<li>method invocation body内部可以用this来指代这个对象,这个对象的property就可以通过this.property的方
法来触发</li>
</ul></li>
</ul>
</div>
<div id="outline-container-orgb4adc5c" class="outline-4">
<h4 id="orgb4adc5c"><span class="section-number-4">4.5.1.</span> Conditional Invocation</h4>
<div class="outline-text-4" id="text-4-5-1">
<ul class="org-ul">
<li>前面介绍了Conditional Property Access,与之相对应的就是Conditional Invocation</li>
<li>Conditional Invocation通常用在optional参数为function的情况:
<ul class="org-ul">
<li><p>
比如在ES2020之前,我们的函数有一个optional参数是log function,如果我们要确认能调用这个log函数,我们
必须check一下它是否是undefined或者null
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">function</span> <span style="color: #6c3163; font-weight: bold;">square</span><span style="color: #3a81c3;">(</span><span style="color: #715ab1;">x</span>, <span style="color: #715ab1;">log</span><span style="color: #3a81c3;">)</span> <span style="color: #3a81c3;">{</span>
  <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">the second argument is an optional function</span>
  <span style="color: #3a81c3; font-weight: bold;">if</span> <span style="color: #6c3163;">(</span>log<span style="color: #6c3163;">)</span> <span style="color: #6c3163;">{</span>
    log<span style="color: #2d9574;">(</span>x<span style="color: #2d9574;">)</span>;
  <span style="color: #6c3163;">}</span>
  <span style="color: #3a81c3; font-weight: bold;">return</span> x * x;
<span style="color: #3a81c3;">}</span>
</pre>
</div></li>
<li><p>
但是有了conditional invocation,我们可以直接调用.不会抛出异常(注意这个例子中是"?."左边是否是undefiend,
null的情况conditional invocation会去check,如果你左边给一个x这种存在的变量,但是不是函数,还是会抛出异常)
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">function</span> <span style="color: #6c3163; font-weight: bold;">square</span><span style="color: #3a81c3;">(</span><span style="color: #715ab1;">x</span>, <span style="color: #715ab1;">log</span><span style="color: #3a81c3;">)</span> <span style="color: #3a81c3;">{</span>
  <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">the second argument is an optional function</span>
  log?.<span style="color: #6c3163;">(</span>x<span style="color: #6c3163;">)</span>;
  <span style="color: #3a81c3; font-weight: bold;">return</span> x * x;
<span style="color: #3a81c3;">}</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org857ae27" class="outline-3">
<h3 id="org857ae27"><span class="section-number-3">4.6.</span> Object Creation Expression</h3>
<div class="outline-text-3" id="text-4-6">
<ul class="org-ul">
<li><p>
所谓的object creation expression,就是创建新object的表达式,这个创建过程使用new ClassName()的形式,并
且会触发Class的constructor,例子如下
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">new</span> <span style="color: #ba2f59; font-weight: bold;">Object</span><span style="color: #3a81c3;">()</span>;
<span style="color: #3a81c3; font-weight: bold;">new</span> <span style="color: #ba2f59; font-weight: bold;">Point</span><span style="color: #3a81c3;">(</span>2, 3<span style="color: #3a81c3;">)</span>;
</pre>
</div></li>
<li>如果没有参数需要传递,那么括号可以省略,换句话说,下面两个语句等价:
<ul class="org-ul">
<li><p>
空参数加()
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">const</span> <span style="color: #715ab1;">now</span> = <span style="color: #3a81c3; font-weight: bold;">new</span> <span style="color: #ba2f59; font-weight: bold;">Date</span><span style="color: #3a81c3;">()</span>;
console.log<span style="color: #3a81c3;">(</span>now<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">2024-09-04T03:45:16.181Z</span>
</pre>
</div></li>
<li><p>
直接不加()
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">const</span> <span style="color: #715ab1;">now</span> = <span style="color: #3a81c3; font-weight: bold;">new</span> <span style="color: #ba2f59; font-weight: bold;">Date</span>;
console.log<span style="color: #3a81c3;">(</span>now<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">2024-09-04T03:45:16.181Z</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org2a59b33" class="outline-3">
<h3 id="org2a59b33"><span class="section-number-3">4.7.</span> Operator Overview</h3>
<div class="outline-text-3" id="text-4-7">
<ul class="org-ul">
<li>操作符在JavaScript中的用处非常广泛,包括:
<ul class="org-ul">
<li>arithmetic expression</li>
<li>comparision expression</li>
<li>logical expression</li>
<li>assignment expression</li>
</ul></li>
<li>操作符有两种形态:
<ul class="org-ul">
<li>最容易被理解的形态:标点符号形态,比如"+,-"</li>
<li>最容易被忽略的形态:关键字形态,比如"delete, instanceof"</li>
</ul></li>
<li>操作符之间是有优先级的,优先级的判断在各种语言中都是难题,我们不需要掌握,在拿不准的情况下,直接加括号即可.</li>
</ul>
</div>
<div id="outline-container-org2c9e63b" class="outline-4">
<h4 id="org2c9e63b"><span class="section-number-4">4.7.1.</span> Number of Operands</h4>
<div class="outline-text-4" id="text-4-7-1">
<ul class="org-ul">
<li>Operator(操作符)可以根据Operand(操作数)的数目来进行分类:
<ul class="org-ul">
<li>binary operator: 因为这种操作符有两个操作数,比如"*",这是最常见的操作符</li>
<li>unary operator: 这种操作符只有一个操作数,比如"-"</li>
<li>ternary operator:这种操作符有三个操作数,比如"?:"</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgd676e5f" class="outline-4">
<h4 id="orgd676e5f"><span class="section-number-4">4.7.2.</span> Operand and Result Type</h4>
<div class="outline-text-4" id="text-4-7-2">
<ul class="org-ul">
<li>JavaScript的操作符有如下三个特点:
<ul class="org-ul">
<li>有些操作符可以和任意的类型进行工作</li>
<li>绝大多数的操作符只能和specific的type进行工作</li>
<li>我们还记得expression的定义是要evaluate出一个值,绝大多数操作符evaluate的结果是特性的类型(specific type)</li>
</ul></li>
<li>为了满足这三个特点,operator往往是把自己的操作数的类型进行convert,然后进行计算,比如
<ul class="org-ul">
<li><p>
例子如下
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">ret</span> = <span style="color: #2d9574;">"3"</span> * <span style="color: #2d9574;">"5"</span>;
console.log<span style="color: #3a81c3;">(</span>ret === 15<span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>ret === <span style="color: #2d9574;">"15"</span><span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">true</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">false</span>
</pre>
</div></li>
<li>上例中乘号,我们即便给了字符串型的操作数,乘号也会把string类型操作数转换为Number来进行计算</li>
</ul></li>
<li>还有些operator也满足上面三个特点,但是其操作数不同,行为不同,比如:
<ul class="org-ul">
<li><p>
例子如下
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">a</span> = 1 + 2;
<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">b</span> = <span style="color: #2d9574;">"1"</span> + <span style="color: #2d9574;">"2"</span>;
console.log<span style="color: #3a81c3;">(</span>a === 3<span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>b === <span style="color: #2d9574;">"12"</span><span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">true</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">true</span>
</pre>
</div></li>
<li>上面的例子中,"+"在面对Number类型的时候,是把他们相加</li>
<li>上面的例子中,"+"在面对String类型的时候,是把他们相concatenate</li>
</ul></li>
<li>最后我们讲一讲assignment operator里面经常遇到的一个名字lval:
<ul class="org-ul">
<li>所谓lval是lvalue,  left value的简称</li>
<li><p>
这种value是一种历史名字,意味着某些expression可以合法的出现在assignment的左边
</p>
<pre class="example" id="org608b23a">
lvalue is a historical term that means: an expression that can legally
appear on the left side of an assignment expression
</pre></li>
<li>在JavaScript中有如下的lvalue:
<ol class="org-ol">
<li>variable</li>
<li>property of object</li>
<li>element of array</li>
</ol></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgc5cd1c5" class="outline-4">
<h4 id="orgc5cd1c5"><span class="section-number-4">4.7.3.</span> Operator Side Effects</h4>
<div class="outline-text-4" id="text-4-7-3">
<ul class="org-ul">
<li>绝大多数的expresion都是没有side effect的,比如2*3产生了结果是6,但是仅此而已,本次计算如果用
repl的话可能会在命令行留下一个6,除此以外,不会有任何其他的影响</li>
<li>但是有些expression可不是这样,他们一旦出现,就会有额外的副作用,比如:
<ul class="org-ul">
<li>assignment operator: 一旦把一个value赋值给一个variable,那么事实上就改变了这个value</li>
<li>&#x2013; operator: 一旦对一个变量进行了&#x2013;(或者++),那么这个变量的值就会改变</li>
<li>delete operator: 一旦删除了一个property,那么就相当于给这个property赋了undefined值</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgd273bee" class="outline-4">
<h4 id="orgd273bee"><span class="section-number-4">4.7.4.</span> Operator Precedence</h4>
<div class="outline-text-4" id="text-4-7-4">
<ul class="org-ul">
<li>operator都有自己的优先级的,这个在我们小时候学数学的时候,就遇到过:
<ul class="org-ul">
<li><p>
例子如下
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">x</span> = 1;
<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">y</span> = 2;
<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">z</span> = 3;
<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">w</span> = x + y * z;
console.log<span style="color: #3a81c3;">(</span>w<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">7</span>
</pre>
</div></li>
<li>小学的知识告诉我们,乘法的优先级更高,所以先计算乘法再计算加法的结果</li>
<li>编程的最基本知识告诉我们,assignment的优先级一般来说最低,这样才能让赋值最后发生</li>
<li>除了上面的两条,我们不需要记忆优先级,遇到优先级问题不再上面讨论范围的,我们可以直接加括号解决</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgb9f475f" class="outline-4">
<h4 id="orgb9f475f"><span class="section-number-4">4.7.5.</span> Operator Associativity</h4>
<div class="outline-text-4" id="text-4-7-5">
<ul class="org-ul">
<li>operator还有一个特性叫做associativity,说的就是这个operator使用的时候,是从左到右还是从右到左进行计算</li>
<li>最常见的operator都是Left-to-Right计算的,换句话说,下面的两个例子等价:
<ul class="org-ul">
<li><p>
例子1
</p>
<div class="org-src-container">
<pre class="src src-js">w = x - y - z;
</pre>
</div></li>
<li><p>
例子2
</p>
<div class="org-src-container">
<pre class="src src-js">w = <span style="color: #3a81c3;">(</span><span style="color: #6c3163;">(</span>x - y<span style="color: #6c3163;">)</span> - z<span style="color: #3a81c3;">)</span>;
</pre>
</div></li>
</ul></li>
<li>而一些不常见的operator是Right-to-Left进行结合的,比如:
<ul class="org-ul">
<li><p>
exponentiation
</p>
<div class="org-src-container">
<pre class="src src-js">y = a ** b ** c;
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">equals to</span>
y = <span style="color: #3a81c3;">(</span>a ** <span style="color: #6c3163;">(</span>b ** c<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>;
</pre>
</div></li>
<li><p>
unary
</p>
<div class="org-src-container">
<pre class="src src-js">x = ~~y;
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">equals</span>
x = ~<span style="color: #3a81c3;">(</span>~y<span style="color: #3a81c3;">)</span>;
</pre>
</div></li>
<li><p>
assignment
</p>
<div class="org-src-container">
<pre class="src src-js">w = x = y = z;
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">equals</span>
w = <span style="color: #3a81c3;">(</span>x = <span style="color: #6c3163;">(</span>y = z<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>;
</pre>
</div></li>
<li><p>
ternary(三元操作符)
</p>
<div class="org-src-container">
<pre class="src src-js">q = a?b:c?d:e?f:g;
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">equals</span>
q = a?b:<span style="color: #3a81c3;">(</span>c?d:<span style="color: #6c3163;">(</span>e?f:g<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>;
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org5895f4a" class="outline-4">
<h4 id="org5895f4a"><span class="section-number-4">4.7.6.</span> Order of Evaluation</h4>
<div class="outline-text-4" id="text-4-7-6">
<ul class="org-ul">
<li>JavaScript的evaluation顺序在绝大多数的情况下都是从左到右的</li>
<li>我们用括号:
<ul class="org-ul">
<li>改变的是order of mulitiplication, addition, assignment</li>
<li>但是无法改变order of evaluation</li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgd2fdf36" class="outline-3">
<h3 id="orgd2fdf36"><span class="section-number-3">4.8.</span> Arithemic Expressions</h3>
<div class="outline-text-3" id="text-4-8">
<ul class="org-ul">
<li>这部分主要讲算术表达式,所谓算术表达式,最常见的就是乘法,除法,加减法等</li>
<li>我们单独给加法设置了一个小节,因为加法会涉及到和字符串相互转换,另外unary operator自己有一小节,bitwise operator有自己一小节</li>
<li>常见的算术表达式除了我们要单独列一小节的addition(+,优先级第三高)以外,剩下的还有:
<ul class="org-ul">
<li>exponentiation(**,优先级第一高)</li>
<li>multiplication(*,优先级第二高)</li>
<li>division(/,优先级第二高)</li>
<li>modulo(%,优先级第二高)</li>
<li>subtraction(-,优先级第三高)</li>
</ul></li>
<li>这五种操作符只能对number类型操作数进行操作,如果一旦混入了不能转换成number类型的操作数,那么结果就是NaN</li>
<li>指数操作符(** operator)的特点是其是right-to-left的方向进行求值的
<ul class="org-ul">
<li><p>
多个**计算的例子如下
</p>
<div class="org-src-container">
<pre class="src src-js">  <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">left to right</span>
console.log<span style="color: #3a81c3;">(</span>2 ** 2 ** 3<span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>2 ** 8<span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">(</span>2 ** 2<span style="color: #6c3163;">)</span> ** 3<span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>4 ** 3<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">256</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">256</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">64</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">64</span>
</pre>
</div></li>
<li>我们可以看到2**2**3其实是等于2**8,而不是4**3</li>
</ul></li>
<li>如果负数和指数操作符一块计算,比如-3**2容易引起误会,我们可能有如下两种解释:(-3) ** 2 或者是-(3**2),
JavaScript为了防止大家用错,直接判断这种用法syntax error. 强制让你用括号来确定计算顺序
<ul class="org-ul">
<li><p>
例子如下
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">x</span> = -3**2

<span style="color: #2aa1ae; background-color: #ecf3ec;">/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">let x = -3**2                                                                                                                               //</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">//         </span><span style="color: #2aa1ae; background-color: #ecf3ec;">^^^^                                                                                                                                //</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">//                                                                                                                                             </span><span style="color: #2aa1ae; background-color: #ecf3ec;">//</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">SyntaxError: Unary operator used immediately before exponentiation expression. Parenthesis must be used to disambiguate operator precedence //</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</span>
</pre>
</div></li>
</ul></li>
<li>指数符号(** operator)是ES2016才引入的特性,在指数符号引入之前,指数计算一直是用的Math.pow()</li>
<li>除法符号(/ operator)在JavaScript里面得到的永远是浮点数</li>
<li>除法无论怎样都不会raise error
<ul class="org-ul">
<li><p>
例子如下
</p>
<div class="org-src-container">
<pre class="src src-js">console.log<span style="color: #3a81c3;">(</span>1 / 0<span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>-1 / 0<span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>0 / 0<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Infinity</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">-Infinity</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">NaN</span>
</pre>
</div></li>
<li>如果除以0,在JavaScript也只是得到positive infinity或者negative infinity</li>
<li>比较特殊的是0/0得到NaN</li>
</ul></li>
<li>取余符(% operator)在JavaScript里面除了能给整数用,还可以给浮点数用
<ul class="org-ul">
<li><p>
例子如下
</p>
<div class="org-src-container">
<pre class="src src-js">console.log<span style="color: #3a81c3;">(</span>5 % 2<span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>6.5 % 2.1<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">1</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">0.19999999999999973</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
<div id="outline-container-org06ea725" class="outline-4">
<h4 id="org06ea725"><span class="section-number-4">4.8.1.</span> The + Operator</h4>
<div class="outline-text-4" id="text-4-8-1">
<ul class="org-ul">
<li>Add operator是一个binary的操作符,可以用来对数字进行加减,或者对两个字符串进行连接:
<ul class="org-ul">
<li>如果两个操作数都是数字,那么结果是数字,两个操作数都是数字的情况下,add operator才真的进行plus运算</li>
<li>如果两个操作数都是字符串,那么结果是字符串</li>
<li>如果不是前面的任何一种情况,那么就要进行type conversion:
<ol class="org-ol">
<li>如果任意一个操作数是object,那么这个object就要通过object-to-primitive算法转换成primitive.对于
object-to-primitive算法来说:极少部分的object有valueOf()函数,可能会转化为非字符串,绝大部分的
object类型其实就是使用toString()来转换为字符</li>
<li>object-to-primitive算法之后,如果任意一个操作数是字符串类型,那么另外一个操作数也必须转换为字符
串类型,然后两者进行concatenate</li>
<li>如果两个操作数都不是字符串,那么就强制把两个操作数转换为number(不能转换成number的转换成NaN),然后两者相加</li>
</ol></li>
<li><p>
我们举几个add operator的例子
</p>
<div class="org-src-container">
<pre class="src src-js">console.log<span style="color: #3a81c3;">(</span>1 + 2<span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"1"</span> + <span style="color: #2d9574;">"2"</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>1 + <span style="color: #6c3163;">{}</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span><span style="color: #4e3163;">true</span> + <span style="color: #4e3163;">true</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>2 + <span style="color: #4e3163;">null</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>2 + <span style="color: #4e3163;">undefined</span><span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">3</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">12</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">1[object Object]</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">2</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">2</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">NaN</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org51dbd69" class="outline-4">
<h4 id="org51dbd69"><span class="section-number-4">4.8.2.</span> Unary Arithmetic Operators</h4>
<div class="outline-text-4" id="text-4-8-2">
<ul class="org-ul">
<li>Unary operator会更改单个操作数,并且返回一个新的value,在JavaScript里面,unary operator都有很高的优先级,
并且是right-associative的</li>
<li>常见的unary arithmetic operator有如下:
<ul class="org-ul">
<li>Unary plus(+): 这个操作符会把操作数转换为number(或者NaN),如果本来就是number,那么就不做任何事情.这个
操作符不能用在BigInt value上</li>
<li>Unary minus(-):这个会把操作数转换为number(或者NaN),并且改变符号(sign)</li>
<li>Increment(++):
<ol class="org-ol">
<li>只能对lvalue(variable, element of array, property of object)起作用</li>
<li><p>
++ operator的返回值要看操作数是在操作符的前面还是后面:如果在前面的话,那么除了增加以外,把加一值
返回,如果在后面的话,那么除了增加以外,把原值返回
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">x</span> = 1;
console.log<span style="color: #3a81c3;">(</span>++x<span style="color: #3a81c3;">)</span>;
<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">y</span> = 1;
console.log<span style="color: #3a81c3;">(</span>y++<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">2</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">1</span>
</pre>
</div></li>
<li><p>
由于++总是把操作数转换为Number(而不是像binary operator那样优先转换为字符串),所以x++不一定等同于x=x+1
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">x</span> = <span style="color: #2d9574;">"1"</span>;
console.log<span style="color: #3a81c3;">(</span>++x<span style="color: #3a81c3;">)</span>;
x = <span style="color: #2d9574;">"1"</span>;
console.log<span style="color: #3a81c3;">(</span>x + 1<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">2</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">11</span>
</pre>
</div></li>
</ol></li>
<li>Decrement(&#x2013;): 所有特性和Increment相同,只不过效果是减,而不是加</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgca213f6" class="outline-4">
<h4 id="orgca213f6"><span class="section-number-4">4.8.3.</span> Bitwise Operators</h4>
<div class="outline-text-4" id="text-4-8-3">
<ul class="org-ul">
<li>bitwise operator其实是对bit进行操作的,在广义上应该不属于数学计算,但是由于bitwise operator是对Number
类型进行操作,而且返回值也是Number类型,所以我们暂且将它归为算术计算</li>
<li>我们知道JavaScript是没有Int类型的,所有的Number类型其实都是float64,但是bitwise其实只针对Int类型有意
义,这里就又出现了JavaScript里面非常随意的一幕(和其他编程语言相比),它应对的方法是:
<ul class="org-ul">
<li>首先把所有的操作数都转换为Number类型</li>
<li>把Number类型本来的float64转换为32-bit Integer,这个过程当中,抛弃所有的小数部分和超过32位的部分(只
保留0到31位)</li>
<li>bitwise的操作过程当中一旦出现了NaN,Infinity,-Infinity,都会自动转换为0</li>
</ul></li>
<li>下面我们分别介绍一下这些bitwise operator:
<ul class="org-ul">
<li>Bitwise AND(&amp;): 两个操作数的对应位置都为1,那个最后位置才得到1</li>
<li>Bitwise OR(|): 两个操作数的对应位置有一个为1,最后位置就可以得到1</li>
<li>Bitwise XOR(^): 两个操作数的对应位置有且只有一个为1,最后位置才为1</li>
<li>Bitwise NOT(~): 这个bitwise operator只针对一个操作数.经过Bitwise Not后,操作数的所有位都会被置反</li>
<li>Shift left(&lt;&lt;): 这个操作会把第一个操作数的整体往左移动(右边补0),比如 a&lt;&lt;1 就会把之前的1st bit变成2nd
bit,2nd bit变成3rd bit,以此类推,最后第32bit会被放弃,1st bit会变成0</li>
<li>Shift right with sign (&gt;&gt;): 这个操作和Shift left相反,只不过左边补充的时候:
<ol class="org-ol">
<li>如果原来是正数,那么就补充0</li>
<li>如果原来是负数,那么就补充1</li>
</ol></li>
<li>Shift right with zero fill (&gt;&gt;&gt;): 和 (&gt;&gt;) 类似,只不过永远在左边补充0</li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org5673da3" class="outline-3">
<h3 id="org5673da3"><span class="section-number-3">4.9.</span> Relational Expressions</h3>
<div class="outline-text-3" id="text-4-9">
<ul class="org-ul">
<li>所谓的relational expression,就是把两个value进行如下类型的比较,得到true或者false:
<ul class="org-ul">
<li>equal</li>
<li>less than</li>
<li>property of</li>
</ul></li>
</ul>
</div>
<div id="outline-container-orgdaae4c6" class="outline-4">
<h4 id="orgdaae4c6"><span class="section-number-4">4.9.1.</span> Equality and Inequality Operators</h4>
<div class="outline-text-4" id="text-4-9-1">
<ul class="org-ul">
<li>"<code>="和"==</code>" 都是用来判断两个value是否相同.
<ul class="org-ul">
<li>这两者相同的地方是:
<ol class="org-ol">
<li>都接受任意类型的操作数</li>
<li>如果两个操作数完全一样就返回true,否则就返回false</li>
</ol></li>
<li>这两者不同的地方是:
`===` 是所谓的strict equality operator,它使用strict definition of sameness</li>
<li>`==` 是所谓equality operator, 它使用的是more relaxed definition of sameness</li>
</ul></li>
<li>`==`对应的不相等符号是`!=`, `===`对应的不相等符号是`!==`</li>
<li>我们之前介绍过,JavaScript object 其实是compared by reference(not by value),也就是说:
<ul class="org-ul">
<li>一个object只可能和自己相等</li>
<li>两个object永远无法相等,即便两者有同样数量的property,每个property的name和value都相同</li>
<li>两个数组永远无法相等,即便两者有相同数量,相同顺序和相同value的成员</li>
</ul></li>
</ul>
</div>
<ol class="org-ol">
<li><a id="orge829f46"></a>strict equality<br />
<div class="outline-text-5" id="text-4-9-1-1">
<ul class="org-ul">
<li>strict quality operator 对两个操作数比较的时候, 按照如下步骤进行(注意不会有type conversion):
<ul class="org-ul">
<li>如果两个value的类型不相同,那么返回 not equal</li>
<li>如果两个value都是null, 或者两个value都是undefined,那么返回equal</li>
<li>如果两个value都是true, 或者两个value都是false,那么返回equal</li>
<li>如果两个value都是NaN,或者其中一个value是NaN,那么返回not equal(这个非常反直觉,因为NaN和任意值都不
相等,甚至包括他自己,想判断一个值是不是NaN,我们就可以用x !==x, 或者isNan函数)</li>
<li>如果两个value都是number,并且他们的值相同(0和-0也算相同),那么返回equal.</li>
<li>如果两个value都是string,并且每个value 的16-bit value序列都是一样的,那么两者equal(注意,我们为什么
说是16-bit value,因为有些看上去一样的字符,是由不同的unicode组成的,我们判断的依据只能是16-bit value)</li>
<li>如果两个value都是object(array, function),那么只有他们自己和自己比较是equal</li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org346be1d"></a>Equality with type conversion<br />
<div class="outline-text-5" id="text-4-9-1-2">
<ul class="org-ul">
<li>equality operator和strict quality operator类似,但是没有那么严格,因为它发现两个操作数的类型不一样会
先试图进行type conversion,然后再进行比较. 整体步骤如下:
<ul class="org-ul">
<li>如果两个value是同一个类型,那么就按照上面strict equality的步骤进行判定,上面是equal这里就是equal</li>
<li>如果两个value不是同一类型,那么它使用如下规则进行判定:
<ol class="org-ol">
<li>如果一个value是null,另外一个value是undefiend, 那么返回equal</li>
<li>如果一个value是number,另外一个value是string,那么就先把string转换为number,然后再进行比较</li>
<li>如果任意一个value是true(或者false),那么把它转换为1(或者0),再进行比较.</li>
<li>如果一个为object,另外一个是string或者Number,那么就是把object使用toString()或者valueOf()转换后进行比较</li>
<li>除此以外的任意其他的比较都是not equal</li>
</ol></li>
</ul></li>
<li>注意上面的type conversion有可能进行多次
<ul class="org-ul">
<li><p>
比如下面的例子
</p>
<div class="org-src-container">
<pre class="src src-js">console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"1"</span> == <span style="color: #4e3163;">true</span><span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">true</span>
</pre>
</div></li>
<li>其中一个value是true, true首先根据要求要转换为1.这是第一次转换</li>
<li>第一次转换之后,其中一个value是1(true转换来的),那么另外一个String value就要转换为Number,也就是"1"
会转换为1,这是第二次转换</li>
<li>两次转换后,就是比较1==1,肯定为true</li>
</ul></li>
</ul>
</div>
</li>
</ol>
</div>
<div id="outline-container-orgad199e9" class="outline-4">
<h4 id="orgad199e9"><span class="section-number-4">4.9.2.</span> Comparison Operator</h4>
<div class="outline-text-4" id="text-4-9-2">
<ul class="org-ul">
<li>所谓comparison operator,就是测试两个操作数的相对顺序啦,常见的比较操作符有:
<ul class="org-ul">
<li>Less than (&lt;)</li>
<li>Greater than (&gt;)</li>
<li>Less than or equal (&lt;=)</li>
<li>Greater than or equal (&gt;=)</li>
</ul></li>
<li>上溯这些比较操作符的操作数可以是任意类型,但是比较却只能发生在:number之间,或者string之间,那么很明显
操作数不是number或者string的需要convert.具体的步骤如下:
<ol class="org-ol">
<li>无论哪个操作数是object类型的,那么就把这个object convert成primitive类型(先使用valueOf函数,不行再
使用toString函数)</li>
<li>现在没有操作数是object类型的了,如果两个操作数现在都是string类型,那么两个string现在进行比对(使用
alphabetical order,也就是挨个16-bit Unicode按顺序比对)</li>
<li>现在没有操作数是object类型的了,如果两个操作数有一个不是string类型,那么我们就得把两个操作数都转
成number来进行比较:
<ul class="org-ul">
<li>0 和 -0 被认为是相等</li>
<li>Infinity比所有的number都大(除了它自己,和自己相等)</li>
<li>-Infinity比所有的number都小(除了它自己,和自己相等)</li>
<li><p>
如果有一个操作数是NaN(可能是转换来的),那么比较的结果永远是false
</p>
<div class="org-src-container">
<pre class="src src-js">console.log<span style="color: #3a81c3;">(</span>1 &gt; <span style="color: #4e3163;">NaN</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>1 &gt;= <span style="color: #4e3163;">NaN</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>1 &lt; <span style="color: #4e3163;">NaN</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>1 &lt;= <span style="color: #4e3163;">NaN</span><span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">false</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">false</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">false</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">false</span>
</pre>
</div></li>
<li>虽然算术操作符里面不允许BigInt和number类型混用,但是我们比较操作符是运行两者混用的</li>
</ul></li>
</ol></li>
<li>通过这一系列的步骤,我们可以完成我们的比较操作.我们这里可以看到比较操作符和Add操作符的不同:
<ul class="org-ul">
<li>Add 操作符比较喜欢string: 一旦有一个操作数是string,就会进行string链接</li>
<li>比较操作符比较喜欢number: 绝大多数情况都是比较两个number(转换前或者转换后),除非两个操作数都是string</li>
</ul></li>
<li>&lt;= 和 &gt;= 都不进行等于判断(包括equality或者strict equality)</li>
</ul>
</div>
</div>
<div id="outline-container-org003df0a" class="outline-4">
<h4 id="org003df0a"><span class="section-number-4">4.9.3.</span> The in Operator</h4>
<div class="outline-text-4" id="text-4-9-3">
<ul class="org-ul">
<li>in operator对两个操作数都有要求:
<ul class="org-ul">
<li>要求左操作数是一个可以转换为string的类型,比如:symbol</li>
<li>要求右操作数是一个object</li>
</ul></li>
<li><p>
in operator的左操作数如果是右边object的一个property的name的话,那么返回true,否则返回false
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">point</span> = <span style="color: #3a81c3;">{</span> x: 1, y: 1 <span style="color: #3a81c3;">}</span>;
console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"x"</span> <span style="color: #3a81c3; font-weight: bold;">in</span> point<span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"z"</span> <span style="color: #3a81c3; font-weight: bold;">in</span> point<span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"toString"</span> <span style="color: #3a81c3; font-weight: bold;">in</span> point<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">true</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">false</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">true</span>
</pre>
</div></li>
<li><p>
注意,由于数组也是一种object(key是index,value是数组成员),所以显然我们也是可以把in operator的第二个操
作数写成数组
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">data</span> = <span style="color: #3a81c3;">[</span>7, 8, 9<span style="color: #3a81c3;">]</span>;
console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"0"</span> <span style="color: #3a81c3; font-weight: bold;">in</span> data<span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>1 <span style="color: #3a81c3; font-weight: bold;">in</span> data<span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>3 <span style="color: #3a81c3; font-weight: bold;">in</span> data<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">true</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">true</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">false</span>
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-org187a0e9" class="outline-4">
<h4 id="org187a0e9"><span class="section-number-4">4.9.4.</span> The instanceof Operator</h4>
<div class="outline-text-4" id="text-4-9-4">
<ul class="org-ul">
<li>instanceof operator对两个操作数的要求是:
<ul class="org-ul">
<li>要求左操作数是一个object,左操作数如果不是object,那么instanceof永远返回false</li>
<li><p>
要求右操作数是一个class,右操作数如果不是class of object,那么instanceof抛出TypeError异常(注意在ES6
引入class这个概念之前,class其实可以理解为生成object的函数),例子如下
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">class</span> MyClass <span style="color: #3a81c3;">{</span>
  constructor<span style="color: #6c3163;">(</span>name<span style="color: #6c3163;">)</span> <span style="color: #6c3163;">{</span>
    <span style="color: #4e3163;">this</span>.name = name;
  <span style="color: #6c3163;">}</span>
<span style="color: #3a81c3;">}</span>
obj = <span style="color: #3a81c3; font-weight: bold;">new</span> <span style="color: #ba2f59; font-weight: bold;">MyClass</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"hello"</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>obj <span style="color: #3a81c3; font-weight: bold;">instanceof</span> <span style="color: #ba2f59; font-weight: bold;">MyClass</span><span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">equals</span>
<span style="color: #3a81c3; font-weight: bold;">function</span> <span style="color: #6c3163; font-weight: bold;">MyFunClass</span><span style="color: #3a81c3;">(</span><span style="color: #715ab1;">name</span><span style="color: #3a81c3;">)</span> <span style="color: #3a81c3;">{</span>
  <span style="color: #4e3163;">this</span>.name = name;
<span style="color: #3a81c3;">}</span>
funObj = <span style="color: #3a81c3; font-weight: bold;">new</span> <span style="color: #ba2f59; font-weight: bold;">MyFunClass</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"world"</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>funObj <span style="color: #3a81c3; font-weight: bold;">instanceof</span> <span style="color: #ba2f59; font-weight: bold;">MyFunClass</span><span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">true</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">true</span>
</pre>
</div></li>
</ul></li>
<li>instanceof的左操作数是右操作数的一般instance的话,那么返回true,否则返回false.这句话听起来很空洞,我们
举个例子来看下:
<ul class="org-ul">
<li><p>
例子如下
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">function</span> <span style="color: #6c3163; font-weight: bold;">Vehicle</span><span style="color: #3a81c3;">()</span> <span style="color: #3a81c3;">{}</span>
<span style="color: #3a81c3; font-weight: bold;">function</span> <span style="color: #6c3163; font-weight: bold;">Car</span><span style="color: #3a81c3;">()</span> <span style="color: #3a81c3;">{}</span>

Car.<span style="color: #4e3163;">prototype</span> = Object.create<span style="color: #3a81c3;">(</span>Vehicle.<span style="color: #4e3163;">prototype</span><span style="color: #3a81c3;">)</span>; <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Car&#32487;&#25215;&#33258;Vehicle</span>

console.log<span style="color: #3a81c3;">(</span><span style="color: #3a81c3; font-weight: bold;">typeof</span> Car<span style="color: #3a81c3;">)</span>; <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">=&gt; function</span>
console.log<span style="color: #3a81c3;">(</span><span style="color: #3a81c3; font-weight: bold;">typeof</span> Car.<span style="color: #4e3163;">prototype</span><span style="color: #3a81c3;">)</span>; <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">=&gt; object</span>

<span style="color: #3a81c3; font-weight: bold;">const</span> <span style="color: #715ab1;">myCar</span> = <span style="color: #3a81c3; font-weight: bold;">new</span> <span style="color: #ba2f59; font-weight: bold;">Car</span><span style="color: #3a81c3;">()</span>;

console.log<span style="color: #3a81c3;">(</span>myCar <span style="color: #3a81c3; font-weight: bold;">instanceof</span> <span style="color: #ba2f59; font-weight: bold;">Car</span><span style="color: #3a81c3;">)</span>; <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">=&gt; true</span>

console.log<span style="color: #3a81c3;">(</span>myCar <span style="color: #3a81c3; font-weight: bold;">instanceof</span> <span style="color: #ba2f59; font-weight: bold;">Vehicle</span><span style="color: #3a81c3;">)</span>; <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">=&gt; true</span>

console.log<span style="color: #3a81c3;">(</span>myCar <span style="color: #3a81c3; font-weight: bold;">instanceof</span> <span style="color: #ba2f59; font-weight: bold;">Object</span><span style="color: #3a81c3;">)</span>; <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">=&gt; true</span>

console.log<span style="color: #3a81c3;">(</span>myCar <span style="color: #3a81c3; font-weight: bold;">instanceof</span> <span style="color: #ba2f59; font-weight: bold;">Array</span><span style="color: #3a81c3;">)</span>; <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">=&gt; false</span>

console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Car's proptotype:"</span>, Car.<span style="color: #4e3163;">prototype</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Vehicle's prototype:"</span>, Vehicle.<span style="color: #4e3163;">prototype</span><span style="color: #3a81c3;">)</span>;

<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">proto</span> = myCar.__proto__;
<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">myCarProtoList</span> = <span style="color: #3a81c3;">[]</span>;
<span style="color: #3a81c3; font-weight: bold;">while</span> <span style="color: #3a81c3;">(</span>proto<span style="color: #3a81c3;">)</span> <span style="color: #3a81c3;">{</span>
  myCarProtoList.push<span style="color: #6c3163;">(</span>proto<span style="color: #6c3163;">)</span>;
  proto = proto.__proto__;
<span style="color: #3a81c3;">}</span>

console.log<span style="color: #3a81c3;">(</span>myCarProtoList<span style="color: #3a81c3;">)</span>;    <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">=&gt; [ Vehicle {}, {}, [Object: null prototype] {} ]</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">function</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">object</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">true</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">true</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">true</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">false</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Car's proptotype: Vehicle {}</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Vehicle's prototype: {}</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[ Vehicle {}, {}, [Object: null prototype] {} ]</span>
</pre>
</div></li>
<li><p>
我们从这个例子中可以看到一个class Car它会有一个property叫做prototype,这个prototype指向的是当前class
的父对象.所以我们会发现Car的类型是function,而Car.prototype的类型是object
</p>
<div class="org-src-container">
<pre class="src src-js">console.log<span style="color: #3a81c3;">(</span><span style="color: #3a81c3; font-weight: bold;">typeof</span> Car<span style="color: #3a81c3;">)</span>; <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">=&gt; function</span>
console.log<span style="color: #3a81c3;">(</span><span style="color: #3a81c3; font-weight: bold;">typeof</span> Car.<span style="color: #4e3163;">prototype</span><span style="color: #3a81c3;">)</span>; <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">=&gt; object</span>
</pre>
</div></li>
<li>而使用Car初始化的instance myCar,它是使用__proto__来存储这个instance对应的class的prototype,听起来
有点绕.但是其实就是:
<ol class="org-ol">
<li>prototype其实是class的特性</li>
<li>prototype虽然是class的特性,但是它指向的,却是一个instance</li>
<li><p>
所以作为instance的__proto__来说,它更容易链式存储整个链条的所有prototype,因prototype本来就是对
象(instance),所以,我们用__proto__就可以得到一个数组,里面是instance从父class到Object的整个prototype
链条(当然了Object自己的prototype,就是[Object: null prototype]).
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">proto</span> = myCar.__proto__;
<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">myCarProtoList</span> = <span style="color: #3a81c3;">[]</span>;
<span style="color: #3a81c3; font-weight: bold;">while</span> <span style="color: #3a81c3;">(</span>proto<span style="color: #3a81c3;">)</span> <span style="color: #3a81c3;">{</span>
  myCarProtoList.push<span style="color: #6c3163;">(</span>proto<span style="color: #6c3163;">)</span>;
  proto = proto.__proto__;
<span style="color: #3a81c3;">}</span>

console.log<span style="color: #3a81c3;">(</span>myCarProtoList<span style="color: #3a81c3;">)</span>;    <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">=&gt; [ Vehicle {}, {}, [Object: null prototype] {} ]</span>

</pre>
</div></li>
</ol></li>
<li>有了链条之后,那么判断就很简单了,我们首先通过__proto__把左操作数prototype链条数组取出来,然后取出
右操作数的prototype,看看右操作数的prototype在不在左边的数组就可以了.</li>
</ul></li>
<li>注意:除了极少部分的例外(比如Symbol),绝大部分的对象都是instance of Object</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org79c32c9" class="outline-3">
<h3 id="org79c32c9"><span class="section-number-3">4.10.</span> Logical Expressions</h3>
<div class="outline-text-3" id="text-4-10">
</div>
<div id="outline-container-org4332762" class="outline-4">
<h4 id="org4332762"><span class="section-number-4">4.10.1.</span> Logical AND(&amp;&amp;)</h4>
<div class="outline-text-4" id="text-4-10-1">
<ul class="org-ul">
<li>从最简答的维度上来说,&amp;&amp; operator就是做一个boolean AND的操作,两个操作数都为true, &amp;&amp;的结果才为true:
<ul class="org-ul">
<li><p>
两个操作数经常为两个relational expression(relational expression的值往往是boolean),因为&amp;&amp;优先级低,
所以反而不用加括号
</p>
<div class="org-src-container">
<pre class="src src-js">x === 0 &amp;&amp; y === 0
</pre>
</div></li>
<li>两个操作数其实不要求为bool值,因为JavaScript值被分成了truthy或者falsy. 我们的JavaScript就聪明的利
用了这一点:
<ol class="org-ol">
<li><p>
如果左操作数是truthy,那么我直接返回右操作数(右操作数是truthy就是truthy,右操作数是falsy就是falsy)
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">o</span> = <span style="color: #3a81c3;">{</span> x: 123 <span style="color: #3a81c3;">}</span>;
console.log<span style="color: #3a81c3;">(</span>o &amp;&amp; o.x<span style="color: #3a81c3;">)</span>; <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">o is truthy so return value of o.x</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">123</span>
</pre>
</div></li>
<li><p>
如果左操作数是falsy,那么直接返回这个左操作数
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">p</span> = <span style="color: #4e3163;">null</span>;

console.log<span style="color: #3a81c3;">(</span>p &amp;&amp; p.x<span style="color: #3a81c3;">)</span>; <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">p is falsy so return it and don't evaluate p.x, so there is no TypeError here</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">null</span>
</pre>
</div></li>
</ol></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgce83374" class="outline-4">
<h4 id="orgce83374"><span class="section-number-4">4.10.2.</span> Logical OR(||)</h4>
<div class="outline-text-4" id="text-4-10-2">
<ul class="org-ul">
<li>Logical OR和 Logical AND是类似的,它是一个boolean OR操作,两个都为false, ||的结果才为false:
<ul class="org-ul">
<li>两个操作数不要求为bool值,因为JavaScript值被分成了ruty或者falsy, 我们的JavaScript就聪明的利用了这
一点:
<ol class="org-ol">
<li>如果左操作数是truthy,那么我们就直接返回左操作数</li>
<li>如果左操作数是falsy,那么直接返回右操作数(右操作数是truthy就是truthy,右操作数是falsy就是falsy)</li>
</ol></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org3dfa84a" class="outline-4">
<h4 id="org3dfa84a"><span class="section-number-4">4.10.3.</span> Logical Not(!)</h4>
<div class="outline-text-4" id="text-4-10-3">
<ul class="org-ul">
<li>!operator是一个但操作符,这就意味着它只有一个操作数.它的作用就是把操作数的boolean 置反:比如
<ul class="org-ul">
<li>本来是truthy,那么!operator之后就是false.</li>
<li>本来是falsy,那么!operator之后,就是true</li>
</ul></li>
<li>注意上面的两个case的用词,!operator之后是true, false不是truthy, falsy说明!operator是和&amp;&amp;, || 不一样的,
它永远只返回boolean值</li>
<li><p>
我们可以利用这个特性在一个变量前面加上两个!!来获取某个value 的equivalent boolean value
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">x</span> = 12;
console.log<span style="color: #3a81c3;">(</span>x<span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>!!x<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">12</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">true</span>
</pre>
</div></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org06bbe5a" class="outline-3">
<h3 id="org06bbe5a"><span class="section-number-3">4.11.</span> Assignment Expressions</h3>
<div class="outline-text-3" id="text-4-11">
<ul class="org-ul">
<li>JavaScript使用=operator来把一个value赋值给一个variable(或者property)</li>
<li>我们前面讲过=operator要求其左边的操作数是一个lvalue,常见的lvalue有:
<ul class="org-ul">
<li>variable</li>
<li>object property</li>
<li>array element</li>
</ul></li>
<li><p>
=operator的有操作数可以是任何值,整个assignment expression的value也就是右操作数
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">x</span>;
console.log<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">(</span>x = 25<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">25</span>
</pre>
</div></li>
<li><p>
assignment operator的associativity是从右向左的,这也就意味着多个赋值在一行的时候,是从右向左evaluate
的,如下
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">i</span> = <span style="color: #3a81c3;">(</span>j = k = 12<span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>i, j, k<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">12 12 12</span>
</pre>
</div></li>
</ul>
</div>
<div id="outline-container-orgbe6d820" class="outline-4">
<h4 id="orgbe6d820"><span class="section-number-4">4.11.1.</span> Assignment with Operation</h4>
<div class="outline-text-4" id="text-4-11-1">
<ul class="org-ul">
<li>和其他语言一样,这里我们也支持assignment和其他算术操作符一起使用,也就是下面两个是等价的:
<ul class="org-ul">
<li>a op= b</li>
<li>a = a op b</li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org339c3ae" class="outline-3">
<h3 id="org339c3ae"><span class="section-number-3">4.12.</span> Evaluation Expressions</h3>
<div class="outline-text-3" id="text-4-12">
<ul class="org-ul">
<li><p>
和其他解释型语言一样,JavaScript也有能力解析"JavaScript Code组成的字符串",然后让这些字符串产生value
</p>
<div class="org-src-container">
<pre class="src src-shell">&gt; eval<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"3+2"</span><span style="color: #3a81c3;">)</span>
5
&gt; eval<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"6+true"</span><span style="color: #3a81c3;">)</span>
7
&gt; eval<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"6+false"</span><span style="color: #3a81c3;">)</span>
6
&gt; eval<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"'a'+1"</span><span style="color: #3a81c3;">)</span>
<span style="color: #2d9574;">'a1'</span>
</pre>
</div></li>
<li>普通开发者永远用不到eval的特性,所以很多web server直接禁掉了这个功能</li>
</ul>
</div>
</div>
<div id="outline-container-orgd03ca62" class="outline-3">
<h3 id="orgd03ca62"><span class="section-number-3">4.13.</span> Miscellaneous Operators</h3>
<div class="outline-text-3" id="text-4-13">
<ul class="org-ul">
<li>JavaScript还支持一些其他的操作符,这一节进行罗列</li>
</ul>
</div>
<div id="outline-container-org6a223b4" class="outline-4">
<h4 id="org6a223b4"><span class="section-number-4">4.13.1.</span> The Conditional Operator(?:)</h4>
<div class="outline-text-4" id="text-4-13-1">
<ul class="org-ul">
<li><p>
conditional operator是JavaScript里面唯一的三元操作符,所以很多时候我们直接叫他三元操作符(ternary oprator)
下面是一个取x绝对值的例子
</p>
<div class="org-src-container">
<pre class="src src-js">x &gt; 0 ? x : -x
</pre>
</div></li>
<li>三元操作符的操作数可以是各种类型,第一个操作数会被evaluated成boolean:
<ul class="org-ul">
<li>如果第一个操作符的结果是truthy,那么第二个操作数会被evaluated,并且evaluate的结果会被返回</li>
<li>如果第一个操作符的结果是falsy,那么第三个操作数会被evaluated,并且evaluate的结果会被返回</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org94b5109" class="outline-4">
<h4 id="org94b5109"><span class="section-number-4">4.13.2.</span> First-Defined(??)</h4>
<div class="outline-text-4" id="text-4-13-2">
<ul class="org-ul">
<li>这个操作符有两个操作数,如果第一个操作数不是null或者undefined,那么就返回第一个操作数,否则返回第二个操作数</li>
</ul>
</div>
</div>
<div id="outline-container-org0fb742a" class="outline-4">
<h4 id="org0fb742a"><span class="section-number-4">4.13.3.</span> The typeof Operator</h4>
<div class="outline-text-4" id="text-4-13-3">
<ul class="org-ul">
<li>typeof是一元操作符,其操作数为任意类型,其返回值为一个string用来说明操作数的类型
<ul class="org-ul">
<li><p>
我们用例子来说明一下typeof对待普通类型的情况
</p>
<div class="org-src-container">
<pre class="src src-js">console.log<span style="color: #3a81c3;">(</span><span style="color: #3a81c3; font-weight: bold;">typeof</span> <span style="color: #4e3163;">undefined</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span><span style="color: #3a81c3; font-weight: bold;">typeof</span> <span style="color: #4e3163;">true</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span><span style="color: #3a81c3; font-weight: bold;">typeof</span> <span style="color: #2d9574;">"hello"</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span><span style="color: #3a81c3; font-weight: bold;">typeof</span> 123<span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span><span style="color: #3a81c3; font-weight: bold;">typeof</span> <span style="color: #4e3163;">null</span><span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">undefined</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">boolean</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">string</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">number</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">object</span>
</pre>
</div></li>
<li>从上面的例子可以看到,大部分情况下typeof的结果都是符合预期的,除了null,它的typeof返回"object"</li>
<li><p>
typeof只能区分出是object,但是具体是什么object区分不出来,另外function虽然也是一种object,但是typeof
却认为它有返回值,所以和object稍有区别,给了个function类型
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">function</span> <span style="color: #6c3163; font-weight: bold;">hello</span><span style="color: #3a81c3;">()</span> <span style="color: #3a81c3;">{</span>
  <span style="color: #3a81c3; font-weight: bold;">return</span> 1;
<span style="color: #3a81c3;">}</span>
console.log<span style="color: #3a81c3;">(</span><span style="color: #3a81c3; font-weight: bold;">typeof</span> hello<span style="color: #3a81c3;">)</span>;

obj = <span style="color: #3a81c3;">{}</span>;
console.log<span style="color: #3a81c3;">(</span><span style="color: #3a81c3; font-weight: bold;">typeof</span> obj<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">function</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">object</span>
</pre>
</div></li>
</ul></li>
<li>typeof在工作当中,基本只能用来区分一个对象是object,还是primitive类型.更精细是做不到的.</li>
</ul>
</div>
</div>
<div id="outline-container-orgac4d5e4" class="outline-4">
<h4 id="orgac4d5e4"><span class="section-number-4">4.13.4.</span> The delete Operator</h4>
<div class="outline-text-4" id="text-4-13-4">
<ul class="org-ul">
<li>delete 是一个一元操作符,其作用是:
<ul class="org-ul">
<li><p>
删除一个数组的成员
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">a</span> = <span style="color: #3a81c3;">[</span>1, 2, 3<span style="color: #3a81c3;">]</span>;
console.log<span style="color: #3a81c3;">(</span>a<span style="color: #3a81c3;">)</span>;
<span style="color: #3a81c3; font-weight: bold;">delete</span> a<span style="color: #3a81c3;">[</span>1<span style="color: #3a81c3;">]</span>;
console.log<span style="color: #3a81c3;">(</span>a<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[ 1, 2, 3 ]</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[ 1, &lt;1 empty item&gt;, 3 ]</span>
</pre>
</div></li>
<li><p>
删除一个object的property
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">o</span> = <span style="color: #3a81c3;">{</span> x: 1, y: 2 <span style="color: #3a81c3;">}</span>;
console.log<span style="color: #3a81c3;">(</span>o<span style="color: #3a81c3;">)</span>;
<span style="color: #3a81c3; font-weight: bold;">delete</span> o.x;
console.log<span style="color: #3a81c3;">(</span>o<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">{ x: 1, y: 2 }</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">{ y: 2 }</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org9613703" class="outline-4">
<h4 id="org9613703"><span class="section-number-4">4.13.5.</span> The await Opertor</h4>
<div class="outline-text-4" id="text-4-13-5">
<ul class="org-ul">
<li>await在ES2017才引入,其作用是为了能够在async函数里面等待Promise的resolved或者rejected,在这个过程当中,
整个函数是暂停的
<ul class="org-ul">
<li><p>
例子如下
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Return Promise</span>
<span style="color: #3a81c3; font-weight: bold;">function</span> <span style="color: #6c3163; font-weight: bold;">fetchData</span><span style="color: #3a81c3;">()</span> <span style="color: #3a81c3;">{</span>
  <span style="color: #3a81c3; font-weight: bold;">return</span> <span style="color: #3a81c3; font-weight: bold;">new</span> <span style="color: #ba2f59; font-weight: bold;">Promise</span><span style="color: #6c3163;">(</span><span style="color: #2d9574;">(</span>resolve<span style="color: #2d9574;">)</span> =&gt; <span style="color: #2d9574;">{</span>
    setTimeout<span style="color: #67b11d;">(</span><span style="color: #b1951d;">()</span> =&gt; <span style="color: #b1951d;">{</span>
      resolve<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Return from fetchData"</span><span style="color: #3a81c3;">)</span>;
    <span style="color: #b1951d;">}</span>, 2000<span style="color: #67b11d;">)</span>;
  <span style="color: #2d9574;">}</span><span style="color: #6c3163;">)</span>;
<span style="color: #3a81c3;">}</span>

<span style="color: #3a81c3; font-weight: bold;">async</span> <span style="color: #3a81c3; font-weight: bold;">function</span> getData<span style="color: #3a81c3;">()</span> <span style="color: #3a81c3;">{</span>
  console.log<span style="color: #6c3163;">(</span><span style="color: #2d9574;">"Starting..."</span><span style="color: #6c3163;">)</span>;
  <span style="color: #3a81c3; font-weight: bold;">const</span> <span style="color: #715ab1;">data</span> = <span style="color: #3a81c3; font-weight: bold;">await</span> fetchData<span style="color: #6c3163;">()</span>;
  console.log<span style="color: #6c3163;">(</span>data<span style="color: #6c3163;">)</span>;
  console.log<span style="color: #6c3163;">(</span><span style="color: #2d9574;">"Finished"</span><span style="color: #6c3163;">)</span>;
<span style="color: #3a81c3;">}</span>

getData<span style="color: #3a81c3;">()</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Starting...</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Return from fetchData</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Finished</span>
</pre>
</div></li>
<li>注意这个例子中的await必须在async函数里面,否则会报错</li>
<li>在getData函数里面,当等待fetchData()的返回值Promise在处理的时候,我们的await可以在这里等待这个过程
完成,但是同时却不会真的block(这个非常重要,不是busy waiting,而是其他异步操作可以进行)</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org1c8fd94" class="outline-4">
<h4 id="org1c8fd94"><span class="section-number-4">4.13.6.</span> The void Operator</h4>
<div class="outline-text-4" id="text-4-13-6">
<ul class="org-ul">
<li>void是一个一元操作符,其操作数可以是任何类型</li>
<li>这个操作符使用的非常少,因为它的作用是:evaluate他的操作数,丢弃evaluate的结果,并且返回undefind</li>
</ul>
</div>
</div>
<div id="outline-container-org0bf5324" class="outline-4">
<h4 id="org0bf5324"><span class="section-number-4">4.13.7.</span> The comma Operator(,)</h4>
<div class="outline-text-4" id="text-4-13-7">
<ul class="org-ul">
<li>comma是一个二元操作符,它的作用是:
<ul class="org-ul">
<li>evaluate 左操作数</li>
<li>evaluate 右操作数</li>
<li>返回右操作数</li>
</ul></li>
<li><p>
comma基本也只存在于for函数里面(当for函数有多个变量的时候)
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">for</span> <span style="color: #3a81c3;">(</span><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">i</span> = 0, <span style="color: #715ab1;">j</span> = 10; i &lt; j; i++, j--<span style="color: #3a81c3;">)</span> <span style="color: #3a81c3;">{</span>
  console.log<span style="color: #6c3163;">(</span>i + j<span style="color: #6c3163;">)</span>;
<span style="color: #3a81c3;">}</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">10</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">10</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">10</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">10</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">10</span>
</pre>
</div></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-orgefcb634" class="outline-2">
<h2 id="orgefcb634"><span class="section-number-2">5.</span> Chapter 5: Statements</h2>
<div class="outline-text-2" id="text-5">
</div>
<div id="outline-container-orge392c49" class="outline-3">
<h3 id="orge392c49"><span class="section-number-3">5.1.</span> Expression Statements</h3>
<div class="outline-text-3" id="text-5-1">
<ul class="org-ul">
<li>在JavaScript里面,最简单的statement是一个又side effect的expression,我们把这种expression叫做expression
statement:
<ul class="org-ul">
<li><p>
最常见的expression statement就是assignment(++,&#x2013;也算assignment)
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">i</span> = 1;
i *= 3;
<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">j</span> = 5;
j++;
<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">greeting</span>;
greeting = <span style="color: #2d9574;">"Hello"</span>;
console.log<span style="color: #3a81c3;">(</span>i, j, greeting<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">3 6 Hello</span>
</pre>
</div></li>
<li>delete也肯定会产生side effect,所以也是expression statement</li>
<li>function call如果产生side effect的,就会是expression statement.</li>
</ul></li>
<li><p>
有些不产生side effect的function,可以作为statement的一部分,比如下面的例子,Math.cos(x)本身没有side
effect,但是它一旦赋值给cx,就有side effect了
</p>
<div class="org-src-container">
<pre class="src src-js">cx = Math.cos<span style="color: #3a81c3;">(</span>x<span style="color: #3a81c3;">)</span>
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-org291b73c" class="outline-3">
<h3 id="org291b73c"><span class="section-number-3">5.2.</span> Compound and Empty Statements</h3>
<div class="outline-text-3" id="text-5-2">
<ul class="org-ul">
<li>就像Comma operator可以把多个expression变成一个expression一样,statement block可以把多个statement变
成一个compound statement
<ul class="org-ul">
<li><p>
statement block的例子如下
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3;">{</span>
  x = Math.PI;
  cx = Math.cos<span style="color: #6c3163;">(</span>x<span style="color: #6c3163;">)</span>;
<span style="color: #3a81c3;">}</span>
</pre>
</div></li>
<li>注意,statement block最后没有分号</li>
<li>在statement block里面,通常有缩进,便于我们阅读.</li>
</ul></li>
<li>statement block的最大作用,是把多个statement编程一个statement,然后就可以作为while语句等语句的
substatement了</li>
<li><p>
如果我们一个循环语句里面什么都不想做,我们可以如下设置(使用一个`;`,但是要有注释)
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">for</span> <span style="color: #3a81c3;">(</span><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">i</span> = 0; i &lt; a.length; a<span style="color: #6c3163;">[</span>i++<span style="color: #6c3163;">]</span> = 0<span style="color: #3a81c3;">)</span> <span style="color: #2aa1ae; background-color: #ecf3ec;">/* </span><span style="color: #2aa1ae; background-color: #ecf3ec;">empty</span><span style="color: #2aa1ae; background-color: #ecf3ec;"> */</span>;
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-orgc616ee5" class="outline-3">
<h3 id="orgc616ee5"><span class="section-number-3">5.3.</span> Conditionals</h3>
<div class="outline-text-3" id="text-5-3">
<ul class="org-ul">
<li>条件是语句是让你判断是执行还是跳过某些语句的,常见的有if/else或者switch</li>
</ul>
</div>
<div id="outline-container-orga150ed3" class="outline-4">
<h4 id="orga150ed3"><span class="section-number-4">5.3.1.</span> if</h4>
<div class="outline-text-4" id="text-5-3-1">
<ul class="org-ul">
<li>if statment比较直观
<ul class="org-ul">
<li><p>
例子如下
</p>
<pre class="example" id="orgef6c69e">
if (expression)
    statement
</pre></li>
<li>如果expression是truly,那么statement就不执行</li>
</ul></li>
<li>稍微进阶一点的是if-else pattern
<ul class="org-ul">
<li><p>
例子如下
</p>
<pre class="example" id="orgfb10370">
if (expression)
    statement1
else
    statement2
</pre></li>
<li>需要注意的是else是和最近的if配对的.在多个if的情况下,需要注意</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org7785f1a" class="outline-4">
<h4 id="org7785f1a"><span class="section-number-4">5.3.2.</span> else if</h4>
<div class="outline-text-4" id="text-5-3-2">
<ul class="org-ul">
<li>其实有if else,我们的代码也就能够完成所有的逻辑编写.
<ul class="org-ul">
<li><p>
但是这样会有很深的缩进,如下
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">if</span> <span style="color: #3a81c3;">(</span>n == 1<span style="color: #3a81c3;">)</span> <span style="color: #3a81c3;">{</span>
  <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">block 1</span>
<span style="color: #3a81c3;">}</span> <span style="color: #3a81c3; font-weight: bold;">else</span> <span style="color: #3a81c3;">{</span>
  <span style="color: #3a81c3; font-weight: bold;">if</span> <span style="color: #6c3163;">(</span>n == 2<span style="color: #6c3163;">)</span> <span style="color: #6c3163;">{</span>
    <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">block 2</span>
  <span style="color: #6c3163;">}</span> <span style="color: #3a81c3; font-weight: bold;">else</span> <span style="color: #6c3163;">{</span>
    <span style="color: #3a81c3; font-weight: bold;">if</span> <span style="color: #2d9574;">(</span>n == 3<span style="color: #2d9574;">)</span> <span style="color: #2d9574;">{</span>
      <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">block 3</span>
    <span style="color: #2d9574;">}</span> <span style="color: #3a81c3; font-weight: bold;">else</span> <span style="color: #2d9574;">{</span>
      <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">block 4</span>
    <span style="color: #2d9574;">}</span>
  <span style="color: #6c3163;">}</span>
<span style="color: #3a81c3;">}</span>
</pre>
</div></li>
<li><p>
所以我们引入了else if,让缩进减少,更美观.
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">if</span> <span style="color: #3a81c3;">(</span>n == 1<span style="color: #3a81c3;">)</span> <span style="color: #3a81c3;">{</span>
  <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">block 1</span>
<span style="color: #3a81c3;">}</span> <span style="color: #3a81c3; font-weight: bold;">else</span> <span style="color: #3a81c3; font-weight: bold;">if</span> <span style="color: #3a81c3;">(</span>n == 2<span style="color: #3a81c3;">)</span> <span style="color: #3a81c3;">{</span>
  <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">block 2</span>
<span style="color: #3a81c3;">}</span> <span style="color: #3a81c3; font-weight: bold;">else</span> <span style="color: #3a81c3; font-weight: bold;">if</span> <span style="color: #3a81c3;">(</span>n == 3<span style="color: #3a81c3;">)</span> <span style="color: #3a81c3;">{</span>
  <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">block 3</span>
<span style="color: #3a81c3;">}</span> <span style="color: #3a81c3; font-weight: bold;">else</span> <span style="color: #3a81c3;">{</span>
  <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">block 4</span>
<span style="color: #3a81c3;">}</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org054fcea" class="outline-4">
<h4 id="org054fcea"><span class="section-number-4">5.3.3.</span> switch</h4>
<div class="outline-text-4" id="text-5-3-3">
<ul class="org-ul">
<li>if else其实也能满足所有的情况,但是如果每次的判断条件都相同,那么写N次相同的判断条件不够优雅,所以C语
言又发明了switch,JavaScript也就集成了switch
<ul class="org-ul">
<li><p>
样例如下
</p>
<pre class="example" id="orgd62d955">
switch(expression) {
   case a:
       statements A
   case b:
       statements B
   default:
}
</pre></li>
<li><p>
else if的或括号里面我们要自己写expression,这就我们就需要进行如下判断,注意,判断使用的是strict equal operator
</p>
<div class="org-src-container">
<pre class="src src-js">expression === a
</pre>
</div></li>
<li><p>
真实例子中,绝大多数情况下,每个case后面都要跟break,比如下面的例子和上面else if例子的功能相同
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">switch</span> <span style="color: #3a81c3;">(</span>n<span style="color: #3a81c3;">)</span> <span style="color: #3a81c3;">{</span>
  <span style="color: #3a81c3; font-weight: bold;">case</span> 1:
    <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">block 1</span>
    <span style="color: #3a81c3; font-weight: bold;">break</span>;
  <span style="color: #3a81c3; font-weight: bold;">case</span> 2:
    <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">block 2</span>
    <span style="color: #3a81c3; font-weight: bold;">break</span>;
  <span style="color: #3a81c3; font-weight: bold;">case</span> 3:
    <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">block 3</span>
    <span style="color: #3a81c3; font-weight: bold;">break</span>;
  <span style="color: #3a81c3; font-weight: bold;">default</span>:
    <span style="color: #3a81c3; font-weight: bold;">break</span>;
<span style="color: #3a81c3;">}</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgdbc905b" class="outline-3">
<h3 id="orgdbc905b"><span class="section-number-3">5.4.</span> Loops</h3>
<div class="outline-text-3" id="text-5-4">
</div>
<div id="outline-container-org3ebe407" class="outline-4">
<h4 id="org3ebe407"><span class="section-number-4">5.4.1.</span> while</h4>
<div class="outline-text-4" id="text-5-4-1">
<ul class="org-ul">
<li><p>
最基本的loop,形式为
</p>
<pre class="example" id="org9b773b1">
while (expression)
    statement
</pre></li>
</ul>
</div>
</div>
<div id="outline-container-orgd696436" class="outline-4">
<h4 id="orgd696436"><span class="section-number-4">5.4.2.</span> do/while</h4>
<div class="outline-text-4" id="text-5-4-2">
<ul class="org-ul">
<li>和while一样,但是由于expression在后面进行验证,所以statement至少会执行一次</li>
</ul>
</div>
</div>
<div id="outline-container-orga4a5118" class="outline-4">
<h4 id="orga4a5118"><span class="section-number-4">5.4.3.</span> for</h4>
<div class="outline-text-4" id="text-5-4-3">
<ul class="org-ul">
<li><p>
for是比while更具有普适性的一种循环方法,格式如下
</p>
<pre class="example" id="orgdc19f16">
for (initialize; test; increment)
</pre></li>
<li><p>
comma operator唯一常用的地方就是for循环,因为for循环的初始化可以初始化多个变量
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">i</span>,
  j,
  sum = 0;
<span style="color: #3a81c3; font-weight: bold;">for</span> <span style="color: #3a81c3;">(</span>i = 0, j = 10; i &lt; 10; i++, j--<span style="color: #3a81c3;">)</span> <span style="color: #3a81c3;">{</span>
  sum += i * j;
  console.log<span style="color: #6c3163;">(</span>sum<span style="color: #6c3163;">)</span>;
<span style="color: #3a81c3;">}</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">0</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">9</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">25</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">46</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">70</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">95</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">119</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">140</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">156</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">165</span>
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-orgf26429f" class="outline-4">
<h4 id="orgf26429f"><span class="section-number-4">5.4.4.</span> for/of</h4>
<div class="outline-text-4" id="text-5-4-4">
<ul class="org-ul">
<li>ES6 定义了一种新的loop: for/of, 这种for/of loop是作用在iterable object上的.所谓iterable object,我们可
以简单的理解为如下类型:
<ul class="org-ul">
<li>array</li>
<li>string</li>
<li>set</li>
<li>map</li>
</ul></li>
<li>我们举一个for/of在array里面的例子:
<ul class="org-ul">
<li><p>
代码如下
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">data</span> = <span style="color: #3a81c3;">[</span>1, 2, 3, 4, 5, 6, 7, 8, 9<span style="color: #3a81c3;">]</span>;
<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">sum</span> = 0;
<span style="color: #3a81c3; font-weight: bold;">for</span> <span style="color: #3a81c3;">(</span><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">element</span> <span style="color: #3a81c3; font-weight: bold;">of</span> data<span style="color: #3a81c3;">)</span> <span style="color: #3a81c3;">{</span>
  sum += element;
<span style="color: #3a81c3;">}</span>

console.log<span style="color: #3a81c3;">(</span>sum<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">45</span>
</pre>
</div></li>
</ul></li>
<li>下面是for/of在object里面的例子
<ul class="org-ul">
<li><p>
先看一个错误的例子
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">o</span> = <span style="color: #3a81c3;">{</span> x: 1, y: 2, z: 3 <span style="color: #3a81c3;">}</span>;
<span style="color: #3a81c3; font-weight: bold;">for</span> <span style="color: #3a81c3;">(</span><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">element</span> <span style="color: #3a81c3; font-weight: bold;">of</span> o<span style="color: #3a81c3;">)</span> <span style="color: #3a81c3;">{</span>
  console.log<span style="color: #6c3163;">(</span>element<span style="color: #6c3163;">)</span>;
<span style="color: #3a81c3;">}</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">TypeError: o is not iterable</span>
</pre>
</div></li>
<li>上面的例子报错,因为object不是一个iterable</li>
<li><p>
object不是iterable,但是object的所有的key可以通过Object.keys()来做到iterable,也就可以for/of
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">o</span> = <span style="color: #3a81c3;">{</span> x: 1, y: 2, z: 3 <span style="color: #3a81c3;">}</span>;
<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">keys</span> = <span style="color: #2d9574;">""</span>;
<span style="color: #3a81c3; font-weight: bold;">for</span> <span style="color: #3a81c3;">(</span><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">k</span> <span style="color: #3a81c3; font-weight: bold;">of</span> Object.keys<span style="color: #6c3163;">(</span>o<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span> <span style="color: #3a81c3;">{</span>
  keys += k;
<span style="color: #3a81c3;">}</span>

console.log<span style="color: #3a81c3;">(</span>keys<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">xyz</span>
</pre>
</div></li>
<li><p>
object不是iterable,但是object的所有的value可以通过Object.values()来做到iterable,也就可以for/of
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">o</span> = <span style="color: #3a81c3;">{</span> x: 1, y: 2, z: 3 <span style="color: #3a81c3;">}</span>;
<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">values</span> = <span style="color: #2d9574;">""</span>;
<span style="color: #3a81c3; font-weight: bold;">for</span> <span style="color: #3a81c3;">(</span><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">k</span> <span style="color: #3a81c3; font-weight: bold;">of</span> Object.values<span style="color: #6c3163;">(</span>o<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span> <span style="color: #3a81c3;">{</span>
  values += k;
<span style="color: #3a81c3;">}</span>

console.log<span style="color: #3a81c3;">(</span>values<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">123</span>
</pre>
</div></li>
<li><p>
对key和value都感兴趣,可以用Object.entries(),这个函数返回一个array of array, 所以下面的例子中,我
们还用了解构赋值
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">o</span> = <span style="color: #3a81c3;">{</span> x: 1, y: 2, z: 3 <span style="color: #3a81c3;">}</span>;
<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">pairs</span> = <span style="color: #2d9574;">""</span>;
<span style="color: #3a81c3; font-weight: bold;">for</span> <span style="color: #3a81c3;">(</span><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #6c3163;">[</span><span style="color: #715ab1;">k</span>, <span style="color: #715ab1;">v</span><span style="color: #6c3163;">]</span> <span style="color: #3a81c3; font-weight: bold;">of</span> Object.entries<span style="color: #6c3163;">(</span>o<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span> <span style="color: #3a81c3;">{</span>
  pairs += k + v;
<span style="color: #3a81c3;">}</span>

console.log<span style="color: #3a81c3;">(</span>pairs<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">x1y2z3</span>
</pre>
</div></li>
</ul></li>
<li>下面是for/in在string中的例子
<ul class="org-ul">
<li><p>
代码如下
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">frequency</span> = <span style="color: #3a81c3;">{}</span>;
<span style="color: #3a81c3; font-weight: bold;">for</span> <span style="color: #3a81c3;">(</span><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">letter</span> <span style="color: #3a81c3; font-weight: bold;">of</span> <span style="color: #2d9574;">"mississippi"</span><span style="color: #3a81c3;">)</span> <span style="color: #3a81c3;">{</span>
  <span style="color: #3a81c3; font-weight: bold;">if</span> <span style="color: #6c3163;">(</span>frequency<span style="color: #2d9574;">[</span>letter<span style="color: #2d9574;">]</span><span style="color: #6c3163;">)</span> <span style="color: #6c3163;">{</span>
    frequency<span style="color: #2d9574;">[</span>letter<span style="color: #2d9574;">]</span>++;
  <span style="color: #6c3163;">}</span> <span style="color: #3a81c3; font-weight: bold;">else</span> <span style="color: #6c3163;">{</span>
    frequency<span style="color: #2d9574;">[</span>letter<span style="color: #2d9574;">]</span> = 1;
  <span style="color: #6c3163;">}</span>
<span style="color: #3a81c3;">}</span>

console.log<span style="color: #3a81c3;">(</span>frequency<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">{ m: 1, i: 4, s: 4, p: 2 }</span>
</pre>
</div></li>
</ul></li>
<li>for/of 还能对内置的ES6 Set起作用
<ul class="org-ul">
<li>代码如下</li>
</ul></li>
<li>for/of 还能对内置的ES6 Map起作用
<ul class="org-ul">
<li><p>
代码如下
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">m</span> = <span style="color: #3a81c3; font-weight: bold;">new</span> <span style="color: #ba2f59; font-weight: bold;">Map</span><span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span><span style="color: #2d9574;">[</span>1, <span style="color: #2d9574;">"one"</span><span style="color: #2d9574;">]</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>;
<span style="color: #3a81c3; font-weight: bold;">for</span> <span style="color: #3a81c3;">(</span><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #6c3163;">[</span><span style="color: #715ab1;">key</span>, <span style="color: #715ab1;">value</span><span style="color: #6c3163;">]</span> <span style="color: #3a81c3; font-weight: bold;">of</span> m<span style="color: #3a81c3;">)</span> <span style="color: #3a81c3;">{</span>
  console.log<span style="color: #6c3163;">(</span>key<span style="color: #6c3163;">)</span>;
  console.log<span style="color: #6c3163;">(</span>value<span style="color: #6c3163;">)</span>;
<span style="color: #3a81c3;">}</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">1</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">one</span>
</pre>
</div></li>
<li>注意,上面的代码也用了解构赋值,因为Map每次循环返回的是一个数组</li>
</ul></li>
<li>ES2018引入了asynchronous iterator,名字叫做for/await(我们可以看做是for/of的变体)
<ul class="org-ul">
<li><p>
例子如下.
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">async</span> <span style="color: #3a81c3; font-weight: bold;">function</span> printStream<span style="color: #3a81c3;">(</span><span style="color: #715ab1;">stream</span><span style="color: #3a81c3;">)</span> <span style="color: #3a81c3;">{</span>
  <span style="color: #3a81c3; font-weight: bold;">for</span> <span style="color: #3a81c3; font-weight: bold;">await</span> <span style="color: #6c3163;">(</span><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">chunk</span> <span style="color: #3a81c3; font-weight: bold;">of</span> stream<span style="color: #6c3163;">)</span> <span style="color: #6c3163;">{</span>
    console.log<span style="color: #2d9574;">(</span>chunk<span style="color: #2d9574;">)</span>;
  <span style="color: #6c3163;">}</span>
<span style="color: #3a81c3;">}</span>,
</pre>
</div></li>
<li>我们可能需要到12章,13章才能理解上面的例子,我们暂时这里把例子列到这里</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgf0d3c2e" class="outline-4">
<h4 id="orgf0d3c2e"><span class="section-number-4">5.4.5.</span> for/in</h4>
<div class="outline-text-4" id="text-5-4-5">
<ul class="org-ul">
<li>和for/of要求iterable object不同,for/in要求in后面跟着的是object类型, for/in明显比for/of从英语语法上
看起来更合理,因为for/in从JavaScript早期就已经存在了.
<ul class="org-ul">
<li><p>
例子如下
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">o</span> = <span style="color: #3a81c3;">{</span> x: 1, y: 2, z: 3 <span style="color: #3a81c3;">}</span>;
<span style="color: #3a81c3; font-weight: bold;">for</span> <span style="color: #3a81c3;">(</span><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">p</span> <span style="color: #3a81c3; font-weight: bold;">in</span> o<span style="color: #3a81c3;">)</span> <span style="color: #3a81c3;">{</span>
  console.log<span style="color: #6c3163;">(</span>o<span style="color: #2d9574;">[</span>p<span style="color: #2d9574;">]</span><span style="color: #6c3163;">)</span>;
<span style="color: #3a81c3;">}</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">1</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">2</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">3</span>
</pre>
</div></li>
<li>需要注意的是,for/in其实主要使用的范围就是object,每当你在数组里面想循环的时候,其实你是想用for/of,
请注意区别,不要混用</li>
<li>还需要注意的是for/in其实功能不怎么好用,因为它只能loop那些enumerable property,object下面的成员都不
是enumerable property,比如:
<ol class="org-ol">
<li>很多JavaScript的built-in 函数不是enumerable的,比如toString()</li>
<li>很多JavaScript的built-in property不是enumerable的</li>
<li>ES6引入的name为symbol的property也不是enumerable的</li>
</ol></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgfe62525" class="outline-3">
<h3 id="orgfe62525"><span class="section-number-3">5.5.</span> Jumps</h3>
<div class="outline-text-3" id="text-5-5">
<ul class="org-ul">
<li>另外一大类的JavaScript statment就是跳转:也就是让JavaScript解释器跳转到新的位置开始运行</li>
</ul>
</div>
<div id="outline-container-orgb298f2a" class="outline-4">
<h4 id="orgb298f2a"><span class="section-number-4">5.5.1.</span> Labeled Statements</h4>
<div class="outline-text-4" id="text-5-5-1">
<ul class="org-ul">
<li><p>
任意的statement都可以在最前面加一个label,样式如下
</p>
<pre class="example" id="org38bc17e">
identifier: statement
</pre></li>
<li>上面的indentifer可以被如下两个语句使用
<ul class="org-ul">
<li><p>
break: 直接break的话,就只能break自己所在的循环,但是break identifer可以break更高层的循环,比如下面
的例子
</p>
<div class="org-src-container">
<pre class="src src-js">outerLoop: <span style="color: #3a81c3; font-weight: bold;">for</span> <span style="color: #3a81c3;">(</span><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">i</span> = 0; i &lt; 5; i++<span style="color: #3a81c3;">)</span> <span style="color: #3a81c3;">{</span>
  console.log<span style="color: #6c3163;">(</span><span style="color: #2d9574;">"Outer Loop:"</span>, i<span style="color: #6c3163;">)</span>;

  <span style="color: #3a81c3; font-weight: bold;">for</span> <span style="color: #6c3163;">(</span><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">j</span> = 0; j &lt; 5; j++<span style="color: #6c3163;">)</span> <span style="color: #6c3163;">{</span>
    console.log<span style="color: #2d9574;">(</span><span style="color: #2d9574;">"Inner Loop:"</span>, j<span style="color: #2d9574;">)</span>;

    <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&#24403;j&#31561;&#20110;3&#26102;&#65292;&#36339;&#20986;&#22806;&#23618;&#24490;&#29615;</span>
    <span style="color: #3a81c3; font-weight: bold;">if</span> <span style="color: #2d9574;">(</span>j === 3<span style="color: #2d9574;">)</span> <span style="color: #2d9574;">{</span>
      <span style="color: #3a81c3; font-weight: bold;">break</span> outerLoop;
    <span style="color: #2d9574;">}</span>
  <span style="color: #6c3163;">}</span>
<span style="color: #3a81c3;">}</span>

console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Loop Ended"</span><span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Outer Loop: 0</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Inner Loop: 0</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Inner Loop: 1</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Inner Loop: 2</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Inner Loop: 3</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Loop Ended</span>
</pre>
</div></li>
<li><p>
continue. continue的用法比break更直观一点:就是跳到label的位置继续执行
</p>
<div class="org-src-container">
<pre class="src src-js">outerLoop: <span style="color: #3a81c3; font-weight: bold;">for</span> <span style="color: #3a81c3;">(</span><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">i</span> = 0; i &lt; 3; i++<span style="color: #3a81c3;">)</span> <span style="color: #3a81c3;">{</span>
  console.log<span style="color: #6c3163;">(</span><span style="color: #2d9574;">"Outer Loop Start:"</span>, i<span style="color: #6c3163;">)</span>;

  <span style="color: #3a81c3; font-weight: bold;">for</span> <span style="color: #6c3163;">(</span><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">j</span> = 0; j &lt; 3; j++<span style="color: #6c3163;">)</span> <span style="color: #6c3163;">{</span>
    <span style="color: #3a81c3; font-weight: bold;">if</span> <span style="color: #2d9574;">(</span>j === 1<span style="color: #2d9574;">)</span> <span style="color: #2d9574;">{</span>
      <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&#24403;j&#31561;&#20110;1&#26102;&#65292;&#36339;&#36807;&#22806;&#23618;&#24490;&#29615;&#30340;&#24403;&#21069;&#36845;&#20195;</span>
      <span style="color: #3a81c3; font-weight: bold;">continue</span> outerLoop;
    <span style="color: #2d9574;">}</span>
    console.log<span style="color: #2d9574;">(</span><span style="color: #2d9574;">"  Inner Loop:"</span>, j<span style="color: #2d9574;">)</span>;
  <span style="color: #6c3163;">}</span>

  console.log<span style="color: #6c3163;">(</span><span style="color: #2d9574;">"Outer Loop End:"</span>, i<span style="color: #6c3163;">)</span>;
<span style="color: #3a81c3;">}</span>

console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Loop Ended"</span><span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Outer Loop Start: 0</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">//   </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Inner Loop: 0</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Outer Loop Start: 1</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">//   </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Inner Loop: 0</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Outer Loop Start: 2</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">//   </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Inner Loop: 0</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Loop Ended</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org4320c3c" class="outline-4">
<h4 id="org4320c3c"><span class="section-number-4">5.5.2.</span> break</h4>
<div class="outline-text-4" id="text-5-5-2">
<ul class="org-ul">
<li>break是能够让loop或者switch退出,所以只有在loop或者switch内部的break才有意义.</li>
<li>上一节我们展示了如果想从inner的loop中直接跳出outer loop的break的例子.</li>
<li><p>
而break在没有label的帮助下,其主要作用是break当前的loop
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">for</span> <span style="color: #3a81c3;">(</span><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">i</span> = 0; i &lt; a.length; i++<span style="color: #3a81c3;">)</span> <span style="color: #3a81c3;">{</span>
  <span style="color: #3a81c3; font-weight: bold;">if</span> <span style="color: #6c3163;">(</span>a<span style="color: #2d9574;">[</span>i<span style="color: #2d9574;">]</span> === target<span style="color: #6c3163;">)</span> <span style="color: #3a81c3; font-weight: bold;">break</span>;
<span style="color: #3a81c3;">}</span>
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-org94679db" class="outline-4">
<h4 id="org94679db"><span class="section-number-4">5.5.3.</span> continue</h4>
<div class="outline-text-4" id="text-5-5-3">
<ul class="org-ul">
<li>continue statement和break相反,其不是结束当前的loop,而是重新执行loop</li>
<li>上一节我们展示了如果想从inner的loop中直接继续执行outer loop的continue的例子.</li>
<li><p>
而continue在没有label的帮助下,其主要作用是continue当前的loop
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">for</span> <span style="color: #3a81c3;">(</span><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">i</span> = 0; i &lt; data.length; i++<span style="color: #3a81c3;">)</span> <span style="color: #3a81c3;">{</span>
  <span style="color: #3a81c3; font-weight: bold;">if</span> <span style="color: #6c3163;">(</span>!data<span style="color: #2d9574;">[</span>i<span style="color: #2d9574;">]</span><span style="color: #6c3163;">)</span> <span style="color: #6c3163;">{</span>
    contiue;
  <span style="color: #6c3163;">}</span>
  total += data<span style="color: #6c3163;">[</span>i<span style="color: #6c3163;">]</span>;
<span style="color: #3a81c3;">}</span>
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-orge1593fe" class="outline-4">
<h4 id="orge1593fe"><span class="section-number-4">5.5.4.</span> return</h4>
<div class="outline-text-4" id="text-5-5-4">
<ul class="org-ul">
<li>return是为function提供返回值的.所以必须在function里面</li>
<li><p>
return如果后面没有任何的值或者变量,那么就等于是返回一个undefined
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">function</span> <span style="color: #6c3163; font-weight: bold;">returnUndefined</span><span style="color: #3a81c3;">()</span> <span style="color: #3a81c3;">{</span>
  console.log<span style="color: #6c3163;">(</span><span style="color: #2d9574;">"in function"</span><span style="color: #6c3163;">)</span>;
  <span style="color: #3a81c3; font-weight: bold;">return</span>;
<span style="color: #3a81c3;">}</span>

console.log<span style="color: #3a81c3;">(</span>returnUndefined<span style="color: #6c3163;">()</span><span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">in function</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">undefined</span>
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-org5adfe13" class="outline-4">
<h4 id="org5adfe13"><span class="section-number-4">5.5.5.</span> yield</h4>
<div class="outline-text-4" id="text-5-5-5">
<ul class="org-ul">
<li>yield是ES6 generator function的return
<ul class="org-ul">
<li>例子如下</li>
<li><p>
注意generator function的函数关键字是function*
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&#23450;&#20041;&#19968;&#20010;&#29983;&#25104;&#22120;&#20989;&#25968;</span>
<span style="color: #3a81c3; font-weight: bold;">function</span>* <span style="color: #6c3163; font-weight: bold;">numberGenerator</span><span style="color: #3a81c3;">()</span> <span style="color: #3a81c3;">{</span>
    <span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">num</span> = 1;
    <span style="color: #3a81c3; font-weight: bold;">while</span> <span style="color: #6c3163;">(</span>num &lt;= 5<span style="color: #6c3163;">)</span> <span style="color: #6c3163;">{</span>
        <span style="color: #3a81c3; font-weight: bold;">yield</span> num;  <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&#26242;&#20572;&#24182;&#36820;&#22238;&#24403;&#21069;&#30340;num&#20540;</span>
        num++;
    <span style="color: #6c3163;">}</span>
<span style="color: #3a81c3;">}</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&#21019;&#24314;&#29983;&#25104;&#22120;&#23545;&#35937;</span>
<span style="color: #3a81c3; font-weight: bold;">const</span> <span style="color: #715ab1;">generator</span> = numberGenerator<span style="color: #3a81c3;">()</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&#20351;&#29992;&#29983;&#25104;&#22120;&#23545;&#35937;&#33719;&#21462;&#20540;</span>
console.log<span style="color: #3a81c3;">(</span>generator.next<span style="color: #6c3163;">()</span>.value<span style="color: #3a81c3;">)</span>; <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&#36755;&#20986;: 1</span>
console.log<span style="color: #3a81c3;">(</span>generator.next<span style="color: #6c3163;">()</span>.value<span style="color: #3a81c3;">)</span>; <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&#36755;&#20986;: 2</span>
console.log<span style="color: #3a81c3;">(</span>generator.next<span style="color: #6c3163;">()</span>.value<span style="color: #3a81c3;">)</span>; <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&#36755;&#20986;: 3</span>
console.log<span style="color: #3a81c3;">(</span>generator.next<span style="color: #6c3163;">()</span>.value<span style="color: #3a81c3;">)</span>; <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&#36755;&#20986;: 4</span>
console.log<span style="color: #3a81c3;">(</span>generator.next<span style="color: #6c3163;">()</span>.value<span style="color: #3a81c3;">)</span>; <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&#36755;&#20986;: 5</span>
console.log<span style="color: #3a81c3;">(</span>generator.next<span style="color: #6c3163;">()</span>.value<span style="color: #3a81c3;">)</span>; <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&#36755;&#20986;: undefined (&#22240;&#20026;&#29983;&#25104;&#22120;&#24050;&#23436;&#25104;)</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">1</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">2</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">3</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">4</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">5</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">undefined</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgde80767" class="outline-4">
<h4 id="orgde80767"><span class="section-number-4">5.5.6.</span> throw</h4>
<div class="outline-text-4" id="text-5-5-6">
<ul class="org-ul">
<li><p>
throw是用来抛出异常的语句. 具体语法如下
</p>
<pre class="example" id="org5c395eb">
throw expression;
</pre></li>
<li>从语法上来说,其实你是可以throw任意的expression的,但是一般来说JavaScript interpreter自己会throw
Error class(或者其subclass)</li>
<li>一旦throw之后,JavaScript intepreter会自动寻找最近的handler,如果没有,会继续向外层找,找不到的话,最终
会上报给用户</li>
</ul>
</div>
</div>
<div id="outline-container-org8d4c077" class="outline-4">
<h4 id="org8d4c077"><span class="section-number-4">5.5.7.</span> try/catch/finally</h4>
<div class="outline-text-4" id="text-5-5-7">
<ul class="org-ul">
<li><p>
这是包裹exception的语法,具体语法如下
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">try</span> <span style="color: #3a81c3;">{</span>
  <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Here, throws an exception</span>
<span style="color: #3a81c3;">}</span> <span style="color: #3a81c3; font-weight: bold;">catch</span><span style="color: #3a81c3;">(</span>e<span style="color: #3a81c3;">)</span> <span style="color: #3a81c3;">{</span>
  <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">The statement in this block are executed if, and only</span>
  <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">if, the try block throws an exception</span>
<span style="color: #3a81c3;">}</span> <span style="color: #3a81c3; font-weight: bold;">finally</span> <span style="color: #3a81c3;">{</span>
  <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">This block contains statements that are always executed</span>
<span style="color: #3a81c3;">}</span>
</pre>
</div></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgb8caf0c" class="outline-3">
<h3 id="orgb8caf0c"><span class="section-number-3">5.6.</span> Miscellaneous Statements</h3>
<div class="outline-text-3" id="text-5-6">
</div>
<div id="outline-container-orgb1837de" class="outline-4">
<h4 id="orgb1837de"><span class="section-number-4">5.6.1.</span> with</h4>
<div class="outline-text-4" id="text-5-6-1">
<ul class="org-ul">
<li><p>
这是已经被淘汰的用法,不要再使用,其作用是把某个object临时拨开,我可以看一个例子
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&#23450;&#20041;&#19968;&#20010;&#23545;&#35937;</span>
<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">person</span> = <span style="color: #3a81c3;">{</span>
  firstName: <span style="color: #2d9574;">"John"</span>,
  lastName: <span style="color: #2d9574;">"Doe"</span>,
  age: 30,
  <span style="color: #6c3163; font-weight: bold;">fullName</span>: <span style="color: #3a81c3; font-weight: bold;">function</span> <span style="color: #6c3163;">()</span> <span style="color: #6c3163;">{</span>
    <span style="color: #3a81c3; font-weight: bold;">return</span> <span style="color: #4e3163;">this</span>.firstName + <span style="color: #2d9574;">" "</span> + <span style="color: #4e3163;">this</span>.lastName;
  <span style="color: #6c3163;">}</span>,
<span style="color: #3a81c3;">}</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&#20351;&#29992; with &#35821;&#21477;&#35775;&#38382;&#23545;&#35937;&#30340;&#23646;&#24615;</span>
<span style="color: #3a81c3; font-weight: bold;">with</span> <span style="color: #3a81c3;">(</span>person<span style="color: #3a81c3;">)</span> <span style="color: #3a81c3;">{</span>
  console.log<span style="color: #6c3163;">(</span><span style="color: #2d9574;">"First Name: "</span> + firstName<span style="color: #6c3163;">)</span>;
  console.log<span style="color: #6c3163;">(</span><span style="color: #2d9574;">"Last Name: "</span> + lastName<span style="color: #6c3163;">)</span>;
  console.log<span style="color: #6c3163;">(</span><span style="color: #2d9574;">"Age: "</span> + age<span style="color: #6c3163;">)</span>;
  console.log<span style="color: #6c3163;">(</span><span style="color: #2d9574;">"Full Name: "</span> + fullName<span style="color: #2d9574;">()</span><span style="color: #6c3163;">)</span>;
<span style="color: #3a81c3;">}</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">First Name: John</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Last Name: Doe</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Age: 30</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Full Name: John Doe</span>
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-orgae191ca" class="outline-4">
<h4 id="orgae191ca"><span class="section-number-4">5.6.2.</span> debugger</h4>
<div class="outline-text-4" id="text-5-6-2">
<ul class="org-ul">
<li><p>
JavaScript里面用来断点调试的语句,例子如下
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">function</span> <span style="color: #6c3163; font-weight: bold;">calculateSum</span><span style="color: #3a81c3;">(</span><span style="color: #715ab1;">a</span>, <span style="color: #715ab1;">b</span><span style="color: #3a81c3;">)</span> <span style="color: #3a81c3;">{</span>
  <span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">sum</span> = a + b;

  <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&#22312;&#27492;&#22788;&#35774;&#32622;&#26029;&#28857;</span>
  <span style="color: #3a81c3; font-weight: bold;">debugger</span>;

  <span style="color: #3a81c3; font-weight: bold;">return</span> sum;
<span style="color: #3a81c3;">}</span>

<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">result</span> = calculateSum<span style="color: #3a81c3;">(</span>5, 3<span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"The sum is: "</span> + result<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">$ node inspect 5-17.js</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">//   </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt; Debugger listening on ws://127.0.0.1:9229/4b4862cf-3594-4ef3-936a-e54ce888e11c</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">//   </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt; For help, see: https://nodejs.org/en/docs/inspector</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt; Debugger attached.</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">//  </span><span style="color: #2aa1ae; background-color: #ecf3ec;">ok</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Break on start in 5-17.js:10</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">8 }</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">//   </span><span style="color: #2aa1ae; background-color: #ecf3ec;">9</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">//   </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&gt;10 let result = calculateSum(5, 3);</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">11 console.log("The sum is: " + result);</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">//  </span><span style="color: #2aa1ae; background-color: #ecf3ec;">12</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">debug&gt; n</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">ambiguous in 5-17.js:5</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">//   </span><span style="color: #2aa1ae; background-color: #ecf3ec;">3</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">//   </span><span style="color: #2aa1ae; background-color: #ecf3ec;">4     // &#22312;&#27492;&#22788;&#35774;&#32622;&#26029;&#28857;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">//   </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&gt; 5     debugger;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">//   </span><span style="color: #2aa1ae; background-color: #ecf3ec;">6</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">7     return sum;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">debug&gt; repl</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Press Ctrl+C to leave debug repl</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&gt; a</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">5</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&gt; b</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">3</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&gt; sum</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">8</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&gt;</span>
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-org81ebbd2" class="outline-4">
<h4 id="org81ebbd2"><span class="section-number-4">5.6.3.</span> "use strict"</h4>
<div class="outline-text-4" id="text-5-6-3">
<ul class="org-ul">
<li>"use strict" 是ES5引入的一个指令,只能放在如下位置:
<ul class="org-ul">
<li>脚本开头</li>
<li>函数开头</li>
</ul></li>
<li>"use strict"用来以严格模式运行代码.严格模式提供更严格的错误检测,产生更安全的JavaScript代码</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org3aecb95" class="outline-3">
<h3 id="org3aecb95"><span class="section-number-3">5.7.</span> Declarations</h3>
<div class="outline-text-3" id="text-5-7">
<ul class="org-ul">
<li>关键字const, let,var,function, class, import, export等其实严格意义上不是statement,但是由于他们和
statement使用方式类似,我们在statement这一章介绍这些关键字</li>
</ul>
</div>
<div id="outline-container-org9a55360" class="outline-4">
<h4 id="org9a55360"><span class="section-number-4">5.7.1.</span> const,let,and var</h4>
<div class="outline-text-4" id="text-5-7-1">
<ul class="org-ul">
<li>ES6之前,没有办法定义常量, ES6之后const用来定义常量</li>
<li>ES6之前,使用var定义变量, ES6之后let用来定义变量,当今时代不再推荐使用var,应该使用let</li>
</ul>
</div>
</div>
<div id="outline-container-org130e1f7" class="outline-4">
<h4 id="org130e1f7"><span class="section-number-4">5.7.2.</span> function</h4>
<div class="outline-text-4" id="text-5-7-2">
<ul class="org-ul">
<li>function关键字是用来定义function object,并且马上给function object一个名字</li>
<li>function declaration总是在function调用之前的.注意并不是说你写的时候要把declartion写在前面,因为
javascript编译器会把block里面所有的function declaration都调到scope的最前面(这叫做hoisted)</li>
<li>现代javascript还有两种特殊的function:
<ul class="org-ul">
<li>generator: 使用`function *`</li>
<li>asynchronous function: 使用`async function`</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org4a9552c" class="outline-4">
<h4 id="org4a9552c"><span class="section-number-4">5.7.3.</span> class</h4>
<div class="outline-text-4" id="text-5-7-3">
<ul class="org-ul">
<li><p>
在ES6之后,class declaration会创建新的class,并且给这个class一个名字.一个例子如下
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">class</span> Circle <span style="color: #3a81c3;">{</span>
  constructor<span style="color: #6c3163;">(</span>radius<span style="color: #6c3163;">)</span> <span style="color: #6c3163;">{</span>
    <span style="color: #4e3163;">this</span>.r = radius;
  <span style="color: #6c3163;">}</span>
  area<span style="color: #6c3163;">()</span> <span style="color: #6c3163;">{</span>
    <span style="color: #3a81c3; font-weight: bold;">return</span> Math.PI * <span style="color: #4e3163;">this</span>.r * <span style="color: #4e3163;">this</span>.r;
  <span style="color: #6c3163;">}</span>
<span style="color: #3a81c3;">}</span>
</pre>
</div></li>
<li>和function不同,class不会被调到scope的最前面(不会被hoisted),所以你必须把class定义先写好,再使用它</li>
</ul>
</div>
</div>
<div id="outline-container-org8a7d3e0" class="outline-4">
<h4 id="org8a7d3e0"><span class="section-number-4">5.7.4.</span> import and export</h4>
<div class="outline-text-4" id="text-5-7-4">
<ul class="org-ul">
<li>在讲解import和export之前,要了解下module的定义</li>
<li>module是一个文件,里面有JavaScript代码,且这些代码有自己的global namespace</li>
<li>一个moduleA里面的value(function, class)想被moduleB所利用,就需要:
<ul class="org-ul">
<li>首先moduleA要在代码里面export</li>
<li>其次moduleB要在自己代码里面import</li>
</ul></li>
<li><p>
如果只导出一个value(function, class),可以使用export default,比如
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">module.js</span>
<span style="color: #3a81c3; font-weight: bold;">export</span> <span style="color: #3a81c3; font-weight: bold;">default</span> <span style="color: #3a81c3; font-weight: bold;">function</span> greet<span style="color: #3a81c3;">()</span> <span style="color: #3a81c3;">{</span>
  console.log<span style="color: #6c3163;">(</span><span style="color: #2d9574;">"Hello!"</span><span style="color: #6c3163;">)</span>;
<span style="color: #3a81c3;">}</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">main.js</span>
<span style="color: #3a81c3; font-weight: bold;">import</span> greetFunction from <span style="color: #2d9574;">"./module.js"</span>;
greetFunction<span style="color: #3a81c3;">()</span>; <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&#35843;&#29992;&#30340;&#26159;&#40664;&#35748;&#23548;&#20986;&#30340;&#20989;&#25968;</span>
</pre>
</div></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org3946c86" class="outline-2">
<h2 id="org3946c86"><span class="section-number-2">6.</span> Chapter 6: Objects</h2>
<div class="outline-text-2" id="text-6">
</div>
<div id="outline-container-org1243639" class="outline-3">
<h3 id="org1243639"><span class="section-number-3">6.1.</span> Introduction to Objects</h3>
<div class="outline-text-3" id="text-6-1">
<ul class="org-ul">
<li>object是一个unordered collection of property</li>
<li>object的property大部分是string(从ES6开始,也可以是Symbol),所以我们可以把object叫做map strings to values</li>
<li>JavaScript的Object除了自己有一系列property以外,它还会集成其他object的property.这个其他object就叫作
prototype</li>
<li>一个object的method大部分都是继承来的property,这种prototype inheritance是JavaScript的关键特色</li>
<li>JavaScript Object是动态的,换句话说就是property可以增加,也可以删除. 但是即便如此,我们还是可以用object来模拟:
<ul class="org-ul">
<li>其他静态语言的struct</li>
<li>Set(忽略value)</li>
</ul></li>
<li>JavaScript的value可以是如下类型:
<ul class="org-ul">
<li>string</li>
<li>number</li>
<li>Symbol</li>
<li>true,false,null,undefined</li>
<li>object</li>
</ul></li>
<li>在JavaScript里面,传递都是by reference而不是by value的,又由于Object的可变的.
<ul class="org-ul">
<li>所以x如果指向一个对象,并且我们有let y = x</li>
<li>那么y得到的是一个reference to the same object. 任何通过y进行的改变都能被x看到</li>
</ul></li>
<li>在JavaScript Object里面最重要的就是区分下面的两种property:
<ul class="org-ul">
<li>直接定义在object里面的property(own property)</li>
<li>从prototype object继承来的property(inherited property)</li>
</ul></li>
<li>除了name和value,每个property还有三个属性:
<ol class="org-ol">
<li>是只读还是可写(read-only, writable)</li>
<li>是否可以被for/in loop发现(enumerable, non-enumerable)</li>
<li>是否可以被配置,也就是删除或改动(configurable, non-configurable)</li>
</ol></li>
<li>绝大部分JavaScript的内置object的property的属性默认:
<ul class="org-ul">
<li>read-only</li>
<li>non-enumerable</li>
<li>non-configurable</li>
</ul></li>
<li>用户手写的对象的属性都是:
<ul class="org-ul">
<li>writable</li>
<li>enumerable</li>
<li>configurable</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org5617114" class="outline-3">
<h3 id="org5617114"><span class="section-number-3">6.2.</span> Creating Objects</h3>
<div class="outline-text-3" id="text-6-2">
</div>
<div id="outline-container-orgfde8faa" class="outline-4">
<h4 id="orgfde8faa"><span class="section-number-4">6.2.1.</span> Object Literals</h4>
<div class="outline-text-4" id="text-6-2-1">
<ul class="org-ul">
<li><p>
最简单的创建object的方法就是object literal,例子如下
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">empty</span> = <span style="color: #3a81c3;">{}</span>;
<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">point</span> = <span style="color: #3a81c3;">{</span> x: 0, y: 0 <span style="color: #3a81c3;">}</span>;
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-org971abd5" class="outline-4">
<h4 id="org971abd5"><span class="section-number-4">6.2.2.</span> Creating Objects with new</h4>
<div class="outline-text-4" id="text-6-2-2">
<ul class="org-ul">
<li>我们还可以使用new operator来创建和初始化新object
<ul class="org-ul">
<li><p>
new operator后面必须跟上function invocation,如下
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">o</span> = <span style="color: #3a81c3; font-weight: bold;">new</span> <span style="color: #ba2f59; font-weight: bold;">Object</span><span style="color: #3a81c3;">()</span>; <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">same as {}</span>
<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">a</span> = <span style="color: #3a81c3; font-weight: bold;">new</span> <span style="color: #ba2f59; font-weight: bold;">Array</span><span style="color: #3a81c3;">()</span>; <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">same as []</span>
<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">d</span> = <span style="color: #3a81c3; font-weight: bold;">new</span> <span style="color: #ba2f59; font-weight: bold;">Date</span><span style="color: #3a81c3;">()</span>;
<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">r</span> = <span style="color: #3a81c3; font-weight: bold;">new</span> <span style="color: #ba2f59; font-weight: bold;">Map</span><span style="color: #3a81c3;">()</span>;
</pre>
</div></li>
<li>在这种情况下被使用的function,比如上面的Object(), Array()叫做constructor</li>
<li><p>
JavaScript的内置类型都有constructor.后面我们会学到自己也可以定义自己的constructor
function来初始化化对象
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&#23450;&#20041;&#19968;&#20010;&#26500;&#36896;&#20989;&#25968;&#65292;&#29992;&#20110;&#21019;&#24314;Person&#23545;&#35937;</span>
<span style="color: #3a81c3; font-weight: bold;">function</span> <span style="color: #6c3163; font-weight: bold;">Person</span><span style="color: #3a81c3;">(</span><span style="color: #715ab1;">name</span>, <span style="color: #715ab1;">age</span><span style="color: #3a81c3;">)</span> <span style="color: #3a81c3;">{</span>
  <span style="color: #4e3163;">this</span>.name = name; <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&#32473;&#23545;&#35937;&#28155;&#21152;name&#23646;&#24615;</span>
  <span style="color: #4e3163;">this</span>.age = age; <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&#32473;&#23545;&#35937;&#28155;&#21152;age&#23646;&#24615;</span>

  <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&#28155;&#21152;&#19968;&#20010;&#26041;&#27861;&#65292;&#23637;&#31034;&#23545;&#35937;&#30340;&#20449;&#24687;</span>
  <span style="color: #4e3163;">this</span>.sayHello = <span style="color: #3a81c3; font-weight: bold;">function</span> <span style="color: #6c3163;">()</span> <span style="color: #6c3163;">{</span>
    console.log<span style="color: #2d9574;">(</span>
      <span style="color: #2d9574;">`Hello, my name is ${this.name} and I am ${this.age} years old.`</span>,
    <span style="color: #2d9574;">)</span>;
  <span style="color: #6c3163;">}</span>;
<span style="color: #3a81c3;">}</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&#20351;&#29992;&#26500;&#36896;&#20989;&#25968;&#21019;&#24314;&#26032;&#30340;Person&#23545;&#35937;</span>
<span style="color: #3a81c3; font-weight: bold;">var</span> <span style="color: #715ab1;">person1</span> = <span style="color: #3a81c3; font-weight: bold;">new</span> <span style="color: #ba2f59; font-weight: bold;">Person</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Alice"</span>, 30<span style="color: #3a81c3;">)</span>;
<span style="color: #3a81c3; font-weight: bold;">var</span> <span style="color: #715ab1;">person2</span> = <span style="color: #3a81c3; font-weight: bold;">new</span> <span style="color: #ba2f59; font-weight: bold;">Person</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Bob"</span>, 25<span style="color: #3a81c3;">)</span>;

person1.sayHello<span style="color: #3a81c3;">()</span>;
person2.sayHello<span style="color: #3a81c3;">()</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Hello, my name is Alice and I am 30 years old.</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Hello, my name is Bob and I am 25 years old.</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org405cd48" class="outline-4">
<h4 id="org405cd48"><span class="section-number-4">6.2.3.</span> Prototypes</h4>
<div class="outline-text-4" id="text-6-2-3">
<ul class="org-ul">
<li>在我们介绍第三种(literal, new之后)创建object的技术之前,我们要停下来介绍一个概念prototype:
<ul class="org-ul">
<li>绝大多数JavaScript Object(自己被称之为first object以外)都会继承自一个second object</li>
<li>继承自的另外一个second object就叫做prototype. first object会从second object里面继承prototype</li>
</ul></li>
<li><p>
所有使用object literal创建的对象都有相同的prototype object,它叫做Object.prototype.它也是唯一没有
prototype的object,因为它是所有对象的root object
</p>
<div class="org-src-container">
<pre class="src src-js">o = <span style="color: #3a81c3;">{}</span>;
console.log<span style="color: #3a81c3;">(</span>o.__proto__ == Object.<span style="color: #4e3163;">prototype</span><span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">true</span>
</pre>
</div></li>
<li>所有使用new+constructor创建的对象,都使用constructor的prototype property作为自己的prototype,这句话听
着像是谜语,我们来解释一下:
<ul class="org-ul">
<li><p>
prototype property是一个高级概念,只有函数才有prototype property(而且只有构造函数的property property
才有意义,也就是用来在new的时候,作为新建对象的prototype).
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&#21019;&#24314;&#19968;&#20010;&#26500;&#36896;&#20989;&#25968;</span>
<span style="color: #3a81c3; font-weight: bold;">function</span> <span style="color: #6c3163; font-weight: bold;">Car</span><span style="color: #3a81c3;">(</span><span style="color: #715ab1;">brand</span>, <span style="color: #715ab1;">model</span><span style="color: #3a81c3;">)</span> <span style="color: #3a81c3;">{</span>
  <span style="color: #4e3163;">this</span>.brand = brand;
  <span style="color: #4e3163;">this</span>.model = model;
<span style="color: #3a81c3;">}</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&#21521;&#26500;&#36896;&#20989;&#25968;&#30340;prototype&#23646;&#24615;&#28155;&#21152;&#19968;&#20010;&#26041;&#27861;</span>
Car.<span style="color: #4e3163;">prototype</span>.getDetails = <span style="color: #3a81c3; font-weight: bold;">function</span> <span style="color: #3a81c3;">()</span> <span style="color: #3a81c3;">{</span>
  <span style="color: #3a81c3; font-weight: bold;">return</span> <span style="color: #2d9574;">`Car: ${this.brand} ${this.model}`</span>;
<span style="color: #3a81c3;">}</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&#21019;&#24314;&#19968;&#20010;Car&#23545;&#35937;&#30340;&#23454;&#20363;</span>
<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">myCar</span> = <span style="color: #3a81c3; font-weight: bold;">new</span> <span style="color: #ba2f59; font-weight: bold;">Car</span><span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Toyota"</span>, <span style="color: #2d9574;">"Corolla"</span><span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&#20351;&#29992;&#23454;&#20363;&#26469;&#35843;&#29992;&#36890;&#36807;prototype&#28155;&#21152;&#30340;&#26041;&#27861;</span>
console.log<span style="color: #3a81c3;">(</span>myCar.getDetails<span style="color: #6c3163;">()</span><span style="color: #3a81c3;">)</span>; <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&#36755;&#20986;: Car: Toyota Corolla</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&#26597;&#25214;Car&#20989;&#25968;&#30340;prototype&#23646;&#24615;</span>
console.log<span style="color: #3a81c3;">(</span>Car.<span style="color: #4e3163;">prototype</span><span style="color: #3a81c3;">)</span>; <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&#36755;&#20986;: { getDetails: [Function] }</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&#39564;&#35777;&#23454;&#20363;&#30340;&#21407;&#22411;&#26159;&#21542;&#31561;&#20110;Car&#30340;prototype</span>
console.log<span style="color: #3a81c3;">(</span>Object.getPrototypeOf<span style="color: #6c3163;">(</span>myCar<span style="color: #6c3163;">)</span> === Car.<span style="color: #4e3163;">prototype</span><span style="color: #3a81c3;">)</span>; <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&#36755;&#20986;: true</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Car: Toyota Corolla</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">{ getDetails: [Function (anonymous)] }</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">true</span>
</pre>
</div></li>
<li>prototype(不加property)是每个object都有的一个指针,可以理解为这指针指向另外一个object.当前object从
另外这个object身上继承属性和函数</li>
<li>内置的Object(), Array(), Date()都是构造函数,他们都是构造函数,有自己的prototype property(只不过它
们在源代码里面是c++实现的,我们看不到罢了),比如:
<ol class="org-ol">
<li>Object()的prototype property是Object.prototype</li>
<li>Array()的prototype property是Array.prototype</li>
<li>Date()的prototype property是Date.prototype</li>
</ol></li>
</ul></li>
<li>Object.prototype是一个对象,而且是为数不多的,没有prototype的对象,换句话说,Object.prototype没有继承
任何property.我们可以认为Object.prototype是一个root object</li>
<li>既然是root object,那么内置的constructor(比如Date())或者用户创建的constructor,都会把自己的prototype property
的prototype设置为Object.prototype. 这句话非常的饶.
<ul class="org-ul">
<li><p>
我们看个例子
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">JavaScript&#24341;&#25806;&#20869;&#37096;&#30340;&#20266;&#23454;&#29616;</span>
<span style="color: #3a81c3; font-weight: bold;">function</span> <span style="color: #6c3163; font-weight: bold;">MyConstructor</span><span style="color: #3a81c3;">()</span> <span style="color: #3a81c3;">{</span>
  <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&#26500;&#36896;&#20989;&#25968;&#30340;&#36923;&#36753;</span>
<span style="color: #3a81c3;">}</span>

console.log<span style="color: #3a81c3;">(</span>MyConstructor.<span style="color: #4e3163;">prototype</span>.__proto__ == Object.<span style="color: #4e3163;">prototype</span><span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">true</span>
</pre>
</div></li>
<li>注意,我们随意写一个函数,其实都是构造函数.JavaScript里面所有的函数都可以是构造函数,都能被new调用,
只不过构造函数从convention上来讲构造函数是大写,且会用this进行逻辑编写</li>
<li>我们在什么都没做的情况下,每个函数都会获得一个prototype property对象,而且这个prototype property对
象的__proto__(也就是prototype)会自动指向Object.prototype.这样我们也就获得了Object.prototype的
属性和方法</li>
</ul></li>
<li>既然Date.prototype继承自Object.prototype,那么我们new Date()创建一个Date object的话,它就会从Date.prototype
继承属性和方法,同时还会继承Object.prototype的属性和方法.这就形成了JavaScript的prototype chain</li>
</ul>
</div>
</div>
<div id="outline-container-org5a3d0ce" class="outline-4">
<h4 id="org5a3d0ce"><span class="section-number-4">6.2.4.</span> Object.create()</h4>
<div class="outline-text-4" id="text-6-2-4">
<ul class="org-ul">
<li>前面介绍了两个大的概念,总结起来就是:
<ul class="org-ul">
<li>prototype property:只有函数有</li>
<li>prototype: 所有对象都有</li>
</ul></li>
<li>既然prototype是所有对象都有的,那么创建对象的时候,同时配置prototype则是一个再正常不过的需求了.Object.create()
就是为了满足这个需求创建的API: Object.create()返回一个对象,新对象使用Object.create的第一个参数作为其prototype
<ul class="org-ul">
<li><p>
例子如下
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">o1</span> = Object.create<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">{</span> x: 1, y: 2 <span style="color: #6c3163;">}</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>o1.x<span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>o1.y<span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>o1.__proto__<span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>o1.__proto__.__proto__ == Object.<span style="color: #4e3163;">prototype</span><span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">1</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">2</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">{ x: 1, y: 2 }</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">true</span>
</pre>
</div></li>
<li>上面例子中.我们新创建的o1,其__proto__就是object literal创建的对象,而这个对象的__proto__就是Object.prototype</li>
<li><p>
我们当然也可以选择使用null来作为object.create的第一次参数,只不过这样的话,它就没有继承任何属性和方法(包括toString())
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">o2</span> = Object.create<span style="color: #3a81c3;">(</span><span style="color: #4e3163;">null</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">{}</span>.toString<span style="color: #6c3163;">()</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>o2.toString<span style="color: #6c3163;">()</span><span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[object Object]</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">/Users/fenghaoran/github/jtdg/code/ch06/6-06.js:3</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">console.log(o2.toString());</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">//                </span><span style="color: #2aa1ae; background-color: #ecf3ec;">^</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">TypeError: o2.toString is not a function</span>
</pre>
</div></li>
<li><p>
常见的和object literal等价的方法是把Object.prototype作为参数传递进去
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">o3</span> = Object.create<span style="color: #3a81c3;">(</span>Object.<span style="color: #4e3163;">prototype</span><span style="color: #3a81c3;">)</span>;
</pre>
</div></li>
</ul></li>
<li>Object.create()还有第二个可选参数,用来描述新对象的propertry</li>
<li>Object.create()的一个经典用法是用来保护传入的对象
<ul class="org-ul">
<li><p>
例子如下:
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&#21407;&#22987;&#37197;&#32622;&#23545;&#35937;</span>
<span style="color: #3a81c3; font-weight: bold;">const</span> <span style="color: #715ab1;">config</span> = <span style="color: #3a81c3;">{</span>
  apiEndpoint: <span style="color: #2d9574;">"https://api.example.com"</span>,
  timeout: 5000,
<span style="color: #3a81c3;">}</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&#22806;&#37096;&#24211;&#20989;&#25968;&#65292;&#21487;&#33021;&#20250;&#23545;&#20256;&#20837;&#30340;&#23545;&#35937;&#36827;&#34892;&#20462;&#25913;</span>
<span style="color: #3a81c3; font-weight: bold;">function</span> <span style="color: #6c3163; font-weight: bold;">libraryFunction</span><span style="color: #3a81c3;">(</span><span style="color: #715ab1;">obj</span><span style="color: #3a81c3;">)</span> <span style="color: #3a81c3;">{</span>
  <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&#26080;&#24847;&#20013;&#20462;&#25913;&#20256;&#20837;&#23545;&#35937;&#30340;timeout&#23646;&#24615;</span>
  obj.timeout = 10000;
  <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&#35835;&#21462;&#23646;&#24615;</span>
  console.log<span style="color: #6c3163;">(</span><span style="color: #2d9574;">"API Endpoint:"</span>, obj.apiEndpoint<span style="color: #6c3163;">)</span>;
  console.log<span style="color: #6c3163;">(</span><span style="color: #2d9574;">"Timeout:"</span>, obj.timeout<span style="color: #6c3163;">)</span>;
<span style="color: #3a81c3;">}</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&#20351;&#29992;Object.create&#21019;&#24314;&#19968;&#20010;&#32487;&#25215;&#33258;config&#30340;&#26032;&#23545;&#35937;</span>
<span style="color: #3a81c3; font-weight: bold;">const</span> <span style="color: #715ab1;">protectedConfig</span> = Object.create<span style="color: #3a81c3;">(</span>config<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&#23558;&#26032;&#23545;&#35937;&#20256;&#36882;&#32473;&#24211;&#20989;&#25968;</span>
libraryFunction<span style="color: #3a81c3;">(</span>protectedConfig<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&#26816;&#26597;&#21407;&#22987;&#23545;&#35937;&#26159;&#21542;&#34987;&#20462;&#25913;</span>
console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"Original Timeout:"</span>, config.timeout<span style="color: #3a81c3;">)</span>; <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&#36755;&#20986;: 5000</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">API Endpoint: https://api.example.com</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Timeout: 10000</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Original Timeout: 5000</span>
</pre>
</div></li>
<li>上面例子中,如果直接传入config对象,那么这个对象一旦在函数内部被更改,那么外部的config也会被更改.但
是被Object.create保护后(其实就是创建了新的object),就不会发生这种事情了</li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgc1710b4" class="outline-3">
<h3 id="orgc1710b4"><span class="section-number-3">6.3.</span> Querying and Setting Properties</h3>
<div class="outline-text-3" id="text-6-3">
<ul class="org-ul">
<li>如果想获取(或者设置)property的value,有两种方法,左边是object,右边可以:
<ul class="org-ul">
<li>使用dot(.), 且右边必须是simple identifier类型的property name</li>
<li>使用括号([]), 右边的括号里,可以是一个expression,其结果evaluate成property name</li>
</ul></li>
</ul>
</div>
<div id="outline-container-org63be970" class="outline-4">
<h4 id="org63be970"><span class="section-number-4">6.3.1.</span> Objects As Associative Arrays</h4>
<div class="outline-text-4" id="text-6-3-1">
<ul class="org-ul">
<li>我们知道如下两种访问property的方法是等价的:
<ul class="org-ul">
<li>object.property</li>
<li>object["peroperty"]</li>
</ul></li>
<li>第二种访问的方法和访问array类似,只不过array使用的是index,而这里使用的是string,这种用string index的
也可以叫做array,只不过叫做associative array(也叫hashmap, dictionary)</li>
<li>在C/C++,Java中,一个对象可以:
<ul class="org-ul">
<li>有固定数目的property,</li>
<li>property必须在编译时间设置好.</li>
</ul></li>
<li>但是JavaScript则不一样:
<ul class="org-ul">
<li>JavaScript可以创建无数多的property</li>
<li>property可以在runtime的时候才创建并赋值(必须使用[],使用"."是不行的)</li>
</ul></li>
<li>这也就意味着我们可以写出如下代码:
<ul class="org-ul">
<li><p>
一个object的property可以runtime随意调整
</p>
<div class="org-src-container">
<pre class="src src-js">customer = <span style="color: #3a81c3;">{</span>
  address0: <span style="color: #2d9574;">"v0"</span>,
  address1: <span style="color: #2d9574;">"v1"</span>,
  address2: <span style="color: #2d9574;">"v2"</span>,
<span style="color: #3a81c3;">}</span>;

<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">addr</span> = <span style="color: #2d9574;">""</span>;
<span style="color: #3a81c3; font-weight: bold;">for</span> <span style="color: #3a81c3;">(</span><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">i</span> = 0; i &lt; 3; i++<span style="color: #3a81c3;">)</span> <span style="color: #3a81c3;">{</span>
  addr += customer<span style="color: #6c3163;">[</span><span style="color: #2d9574;">`address${i}`</span><span style="color: #6c3163;">]</span> + <span style="color: #2d9574;">"\n"</span>;
<span style="color: #3a81c3;">}</span>

console.log<span style="color: #3a81c3;">(</span>addr<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">v0</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">v1</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">v2</span>
</pre>
</div></li>
<li>上面的代码是无法用golang写出来的.golang的对象只能用"."访问.golang必须是在编译器确定的identifer,而
JavaScript是可以在runtime进行拼接的字符串</li>
</ul></li>
<li>在ES6之前,Object通常作为hashmap使用,但是ES6之后引入了Map,我们就推荐使用Map来做hashmap了</li>
</ul>
</div>
</div>
<div id="outline-container-orgb613f25" class="outline-4">
<h4 id="orgb613f25"><span class="section-number-4">6.3.2.</span> Inheritance</h4>
<div class="outline-text-4" id="text-6-3-2">
<ul class="org-ul">
<li>Javascript object拥有一些自己的property,他们还从他们的prototype object里面继承了一些property</li>
<li>为了详细解释上面的情况,我们会使用Object.create()来创建object,因为它可以指定新object的prototype</li>
<li>假设你希望查询object o的一个property叫做x, 步骤如下:
<ul class="org-ul">
<li>如果这个x不是o的own property,那么o的prototype object就会被查询(查询的名字当然还是x)</li>
<li>如果这个x也不是o的prototype object,同时o的prototype object自己也有prototype object,那么继续查找
最老的prototype object</li>
<li>最root的prototype object是null,如果找到这里还没找到,那么就放弃查找</li>
</ul></li>
<li>我们再来看一下赋值,假设你给一个object o赋一个property x:
<ul class="org-ul">
<li>如果o已经有一个叫x的own property(非继承),那么直接更改这个property</li>
<li><p>
如果o没有一个叫做x的own property(非继承),那么这个赋值就会在x的own property列表里面新建一个own
property,名字叫做x.注意!如果o之前在继承的property里面也有x(我们称之为继承x),那么这个继承x,就被新
建的x给hidden了,换句话说,就是在当前的对象创建property,永远不会去prototype chain上面创建property
</p>
<pre class="example" id="org60d89d6">
If o previously inherited the property x, that inherited property is now hidden by
the newly created own property with the same name.
</pre></li>
<li>注意,上面的流程成立的前提,是x是可写的一个属性,如果x是一个read-only的属性,那么assignment是不被允许的</li>
<li><p>
我们用一个例子来展示下上面的解释
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">unitcircle</span> = <span style="color: #3a81c3;">{</span> r: 1 <span style="color: #3a81c3;">}</span>; <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">An object t inherit from</span>
<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">c</span> = Object.create<span style="color: #3a81c3;">(</span>unitcircle<span style="color: #3a81c3;">)</span>; <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">c inherits the property r</span>
c.x = 1;
c.y = 1; <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">c defines two prpperties of it own</span>
c.r = 2; <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">c overrides its inherited property</span>
console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">`|unitcircle.r| =&gt; ${unitcircle.r}`</span><span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">|unitcircle.r| =&gt; 1</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgfcfacca" class="outline-4">
<h4 id="orgfcfacca"><span class="section-number-4">6.3.3.</span> Property Access Errors</h4>
<div class="outline-text-4" id="text-6-3-3">
<ul class="org-ul">
<li><p>
如果我们查询的property并不是own property,也不是inherited property.那么js也不会报错,而是会返回
undefined
</p>
<div class="org-src-container">
<pre class="src src-js">o = <span style="color: #3a81c3;">{}</span>;
console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">`|o.someproperty| =&gt; ${o.someproperty}`</span><span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">|o.someproperty| =&gt; undefined</span>
</pre>
</div></li>
<li><p>
但是如果是想查询一个"不存在的object"的property,那是会报错的,比如null和undefined都是没有property的
</p>
<div class="org-src-container">
<pre class="src src-js">o = <span style="color: #3a81c3;">{}</span>;
console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">`|o.someproperty| =&gt; ${o.someproperty}`</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">`|o.someproperty.length| =&gt; ${o.someproperty.length}`</span><span style="color: #3a81c3;">)</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">|o.someproperty| =&gt; undefined</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">...</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">TypeError: Cannot read properties of undefined (reading 'length')</span>
</pre>
</div></li>
<li>查询一个"不存在的object"的property会报TypeError,同样的写入一个"不存在的object"的property也会报TypeError</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org303d57c" class="outline-3">
<h3 id="org303d57c"><span class="section-number-3">6.4.</span> Deleting Properties</h3>
<div class="outline-text-3" id="text-6-4">
<ul class="org-ul">
<li>delete operator是用来从一个object里面移除一个property,但是注意,delete只能删除own property,而不能删除inherited property</li>
<li>delete删除语句是有返回值的,返回true的情况有如下:
<ul class="org-ul">
<li><p>
如果成功删除,那么返回true
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">o</span> = <span style="color: #3a81c3;">{</span> x: 1 <span style="color: #3a81c3;">}</span>;
console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">`|delete o.x| =&gt; ${delete o.x}`</span><span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">|delete o.x| =&gt; true</span>
</pre>
</div></li>
<li><p>
如果删除操作没有任何effect,比如删除了一个不存在的property,那么也返回true
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">o</span> = <span style="color: #3a81c3;">{</span> x: 1 <span style="color: #3a81c3;">}</span>;
console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">`|delete o.toString| =&gt; ${delete o.toString}`</span><span style="color: #3a81c3;">)</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">|delete o.toString| =&gt; true</span>
</pre>
</div></li>
<li><p>
如果delete后面跟的压根不是一个"object加expression的组合",也返回true
</p>
<div class="org-src-container">
<pre class="src src-js">console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">`|delete 1| =&gt; ${delete 1}`</span><span style="color: #3a81c3;">)</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">|delete 1| =&gt; true</span>
</pre>
</div></li>
</ul></li>
<li>delete返回false的情况通常是在non-strict mode下,因为在strict mode下,同样的场景会直接TypeError
<ul class="org-ul">
<li><p>
无法删除non-configurable的属性,部分built-in对象的某些属性是non-configurable,这些属性可以理解为JS
的核心功能,为了防止JS的核心功能被修改,这些属性是只读的,无法修改也无法删除
</p>
<div class="org-src-container">
<pre class="src src-js">console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">`|delete Object.prototype| =&gt; ${delete Object.prototype}`</span><span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">|delete Object.prototype| =&gt; false</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org138796b" class="outline-3">
<h3 id="org138796b"><span class="section-number-3">6.5.</span> Testing Properties</h3>
<div class="outline-text-3" id="text-6-5">
<ul class="org-ul">
<li>JavaScript的object可以看做是一对property的集合,那么我们就面临着一个问题:如何判断一个名字是否在object
里面</li>
<li>我们本节就会介绍很多种方法,本节的例子都是以字符串为例的,但是其实Symbol也是适用的.</li>
<li><p>
in operator可以判断object的own property或者inherited property是否含有in指定的名字
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">o</span> = <span style="color: #3a81c3;">{</span> x: 1 <span style="color: #3a81c3;">}</span>;
console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">`|"x" in o| =&gt; ${"x" in o}`</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">`|"y" in o| =&gt; ${"y" in o}`</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">`|"toString" in o| =&gt; ${"toString" in o}`</span><span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">|"x" in o| =&gt; true</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">|"y" in o| =&gt; false</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">|"toString" in o| =&gt; true</span>
</pre>
</div></li>
<li><p>
hasOwnProperty()就很直观了,只判断own property,不负责inherited property
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">o</span> = <span style="color: #3a81c3;">{</span> x: 1 <span style="color: #3a81c3;">}</span>;
console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">`|o.hasOwnProperty("x")| =&gt; ${o.hasOwnProperty("x")}`</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">`|o.hasOwnProperty("y")| =&gt; ${o.hasOwnProperty("y")}`</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>
  <span style="color: #2d9574;">`|o.hasOwnProperty("toString")| =&gt; ${o.hasOwnProperty("toString")}`</span>,
<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">|o.hasOwnProperty("x")| =&gt; true</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">|o.hasOwnProperty("y")| =&gt; false</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">|o.hasOwnProperty("toString")| =&gt; false</span>
</pre>
</div></li>
<li><p>
propertyIsEnumerable()的判断是在hasOwnProperty()为true的基础上,在保证property是enumerable的(很多内
置的property都是non-enumerable的,所以这个函数能够保证不要把内置属性给列出来)
</p>
<div class="org-src-container">
<pre class="src src-js">console.log<span style="color: #3a81c3;">(</span>
  <span style="color: #2d9574;">`|Object.prototype.hasOwnProperty("toString")| =&gt; ${Object.prototype.hasOwnProperty(</span>
<span style="color: #2d9574;">    "toString",</span>
<span style="color: #2d9574;">  )}`</span>,
<span style="color: #3a81c3;">)</span>;

console.log<span style="color: #3a81c3;">(</span>
  <span style="color: #2d9574;">`|Object.prototype.propertyIsEnumerable("toString")| =&gt; ${Object.prototype.propertyIsEnumerable(</span>
<span style="color: #2d9574;">    "toString",</span>
<span style="color: #2d9574;">  )}`</span>,
<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">|Object.prototype.hasOwnProperty("toString")| =&gt; true</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">|Object.prototype.propertyIsEnumerable("toString")| =&gt; false</span>
</pre>
</div></li>
<li><p>
很多代码中,会使用 !== 来判断object.property的组合是不是undefined.
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">o</span> = <span style="color: #3a81c3;">{</span> x: 1 <span style="color: #3a81c3;">}</span>;
console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">`|o.x !== undefined| =&gt; ${o.x !== undefined}`</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">`|o.y !== undefined| =&gt; ${o.y !== undefined}`</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">`|o.toString !== undefined| =&gt; ${o.toString !== undefined}`</span><span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">|o.x !== undefined| =&gt; true</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">|o.y !== undefined| =&gt; false</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">|o.toString !== undefined| =&gt; true</span>
</pre>
</div></li>
<li><p>
在绝大多数情况下,这个是可以平替in operator的.只有下面的corner case不可以
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">o</span> = <span style="color: #3a81c3;">{</span> x: <span style="color: #4e3163;">undefined</span> <span style="color: #3a81c3;">}</span>;
console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">`|o.x !== undefined| =&gt; ${o.x !== undefined}`</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">`|"x" in o| =&gt; ${"x" in o}`</span><span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">|o.x !== undefined| =&gt; false</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">|"x" in o| =&gt; true</span>
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-org6021aa1" class="outline-3">
<h3 id="org6021aa1"><span class="section-number-3">6.6.</span> Enumerating Properties</h3>
<div class="outline-text-3" id="text-6-6">
<ul class="org-ul">
<li>有时候我们的诉求是要把object的所有property都列一遍,常见的解决办法有:
<ul class="org-ul">
<li>for/in一个对象</li>
<li>for/of一个数组(需要我们先获取这个数组)</li>
</ul></li>
<li><p>
我们先看for/in,这个组合作用于object.获得的是enumerable的property(包括own和inherited)的.注意我们之前
提到过,内置的property通常是non-enumerable的,所以也不会列到这里
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">o</span> = <span style="color: #3a81c3;">{</span> x: 1, y: 2, z: 3 <span style="color: #3a81c3;">}</span>;
<span style="color: #3a81c3; font-weight: bold;">for</span> <span style="color: #3a81c3;">(</span><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">p</span> <span style="color: #3a81c3; font-weight: bold;">in</span> o<span style="color: #3a81c3;">)</span> <span style="color: #3a81c3;">{</span>
  console.log<span style="color: #6c3163;">(</span>p<span style="color: #6c3163;">)</span>;
<span style="color: #3a81c3;">}</span>

console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">`|o.toString()| =&gt; ${o.toString()}`</span><span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">x</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">y</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">z</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">|o.toString()| =&gt; [object Object]</span>
</pre>
</div></li>
<li><p>
如果只想展示own property,不要inherited的property,我们可以如下设置
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">const</span> <span style="color: #715ab1;">myObject</span> = <span style="color: #3a81c3;">{</span>
  name: <span style="color: #2d9574;">"Alice"</span>,
  age: 30,
  <span style="color: #6c3163; font-weight: bold;">greet</span>: <span style="color: #3a81c3; font-weight: bold;">function</span> <span style="color: #6c3163;">()</span> <span style="color: #6c3163;">{</span>
    console.log<span style="color: #2d9574;">(</span><span style="color: #2d9574;">"Hello!"</span><span style="color: #2d9574;">)</span>;
  <span style="color: #6c3163;">}</span>,
<span style="color: #3a81c3;">}</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&#21019;&#24314;&#19968;&#20010;&#32487;&#25215;&#30340;&#23545;&#35937;</span>
<span style="color: #3a81c3; font-weight: bold;">const</span> <span style="color: #715ab1;">inheritedObject</span> = Object.create<span style="color: #3a81c3;">(</span>myObject<span style="color: #3a81c3;">)</span>;
inheritedObject.job = <span style="color: #2d9574;">"Engineer"</span>;
inheritedObject.city = <span style="color: #2d9574;">"New York"</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&#20351;&#29992; for/in &#24490;&#29615;&#36941;&#21382;&#33258;&#36523;&#23646;&#24615;</span>
<span style="color: #3a81c3; font-weight: bold;">for</span> <span style="color: #3a81c3;">(</span><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">key</span> <span style="color: #3a81c3; font-weight: bold;">in</span> inheritedObject<span style="color: #3a81c3;">)</span> <span style="color: #3a81c3;">{</span>
  <span style="color: #3a81c3; font-weight: bold;">if</span> <span style="color: #6c3163;">(</span>
    inheritedObject.hasOwnProperty<span style="color: #2d9574;">(</span>key<span style="color: #2d9574;">)</span> &amp;&amp;
    <span style="color: #3a81c3; font-weight: bold;">typeof</span> inheritedObject<span style="color: #2d9574;">[</span>key<span style="color: #2d9574;">]</span> !== <span style="color: #2d9574;">"function"</span>
  <span style="color: #6c3163;">)</span> <span style="color: #6c3163;">{</span>
    console.log<span style="color: #2d9574;">(</span>key + <span style="color: #2d9574;">": "</span> + inheritedObject<span style="color: #67b11d;">[</span>key<span style="color: #67b11d;">]</span><span style="color: #2d9574;">)</span>;
  <span style="color: #6c3163;">}</span>
<span style="color: #3a81c3;">}</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">job: Engineer</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">city: New York</span>
</pre>
</div></li>
<li>再来看第二种方式,先得到一个property名字组成的数组,然后在用for/of遍历这数组.能够得到property名字数
组的函数有:
<ul class="org-ul">
<li>Object.keys(): 返回enumerable own property</li>
<li>Object.getOwnPropertyNames():在Object.keys()的基础上再返回non-enumerable成员</li>
<li>Object.getOwnPropertySymbols(): 返回名字为Symbol的own property</li>
<li>Reflect.ownKeys():返回所有的property name,包括enumerable和non-enumerable, 包括string和Symbol</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgd192a34" class="outline-3">
<h3 id="orgd192a34"><span class="section-number-3">6.7.</span> Extending Objects</h3>
<div class="outline-text-3" id="text-6-7">
<ul class="org-ul">
<li>在JavaScript编程里面,一个常见的操作,是把一个object的property全部拷贝到另外一个object的property里面</li>
<li>由于这个操作的出现频率过高,在ES6里面,专门创建了一个函数来处理这个情景,那就是Object.assign()
<ul class="org-ul">
<li><p>
Object.assign()会要求至少两个或两个以上的参数,函数的声明如下
</p>
<div class="org-src-container">
<pre class="src src-js">Object.assign<span style="color: #3a81c3;">(</span>target, source1, source2, <span style="color: #2aa1ae; background-color: #ecf3ec;">/* </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&#8230;,</span><span style="color: #2aa1ae; background-color: #ecf3ec;"> */</span> sourceN<span style="color: #3a81c3;">)</span>
</pre>
</div></li>
<li><p>
Object.assign()还会返回一个值,这个值和被更改后的target是一样的
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">const</span> <span style="color: #715ab1;">target</span> = <span style="color: #3a81c3;">{</span> a: 1, b: 2 <span style="color: #3a81c3;">}</span>;
<span style="color: #3a81c3; font-weight: bold;">const</span> <span style="color: #715ab1;">source</span> = <span style="color: #3a81c3;">{</span> b: 4, c: 5 <span style="color: #3a81c3;">}</span>;

<span style="color: #3a81c3; font-weight: bold;">const</span> <span style="color: #715ab1;">returnedTarget</span> = Object.assign<span style="color: #3a81c3;">(</span>target, source<span style="color: #3a81c3;">)</span>;

console.log<span style="color: #3a81c3;">(</span>target<span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">`|returnedTarget === target| =&gt; ${returnedTarget === target}`</span><span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">{ a: 1, b: 4, c: 5 }</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">|returnedTarget === target| =&gt; true</span>

</pre>
</div></li>
<li>Object.assign会按照如下顺序去覆盖,所以如果有重名的,最终sourceN的那个会胜出:
<ol class="org-ol">
<li>source1去覆盖target,如果有同名的也会被覆盖</li>
<li>source2,再去覆盖target,如果有同名的也会被覆盖</li>
<li>sourceN,再去覆盖target,如果有同名的也会被覆盖</li>
</ol></li>
<li>Object.assign会更改target,但是所有的source都不会被改变</li>
</ul></li>
<li>了解了Object.assign()的定义之后,我们来看一个常见的高阶应用场景:
<ul class="org-ul">
<li>场景介绍: 当前有一个对象o,我希望其有N个property,但是现在只有N-M个property,另外的对象defaults里面
有N个property,我的想法是,如果o里面有这个property,那么就不麻烦defaults了.如果没有,请defaults来帮
我初始化</li>
<li><p>
上面的场景用下面的代码是无法实现的,因为o已经有的property也被覆盖了
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">o</span> = <span style="color: #3a81c3;">{</span> x: 1, y: 2 <span style="color: #3a81c3;">}</span>;
<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">defaults</span> = <span style="color: #3a81c3;">{</span> x: 11, y: 22, z: 33 <span style="color: #3a81c3;">}</span>;

Object.assign<span style="color: #3a81c3;">(</span>o, defaults<span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>o<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">{ x: 11, y: 22, z: 33 }</span>
</pre>
</div></li>
<li><p>
上面的场景需要如下代码来实现,就是创建一个空的object,先让defaults来初始化,然后让o来覆盖
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">o</span> = <span style="color: #3a81c3;">{</span> x: 1, y: 2 <span style="color: #3a81c3;">}</span>;
<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">defaults</span> = <span style="color: #3a81c3;">{</span> x: 11, y: 22, z: 33 <span style="color: #3a81c3;">}</span>;

ret = Object.assign<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">{}</span>, defaults, o<span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>ret<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">{ x: 1, y: 2, z: 33 }</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org8be561b" class="outline-3">
<h3 id="org8be561b"><span class="section-number-3">6.8.</span> Serializing Objects</h3>
<div class="outline-text-3" id="text-6-8">
<ul class="org-ul">
<li>所谓Object serialization,就是object和json字符串相互转换的过程:
<ul class="org-ul">
<li>把object转换成json字符串的函数: JSON.stringify()</li>
<li>把json字符串转换成object的函数: JSON.parse()</li>
</ul></li>
<li>所谓的json是一个简称,正式的全程是JSON(JavaScript Object Notation),它有如下的特性:
<ul class="org-ul">
<li>JSON syntax是JavaScript syntax的子集.它只支持如下类型的展示:
<ol class="org-ol">
<li>object</li>
<li>array</li>
<li>string</li>
<li>finite number</li>
<li>true</li>
<li>false</li>
<li>null</li>
</ol></li>
<li>其他的JavaScript syntax的类型的支持就是打折的了,比如:
<ol class="org-ol">
<li>NaN,Infinity,-Infinity都会被序列化成null</li>
<li>Date会被序列化成ISO-formatted的字符串string,但是这个string被JSON.parse()转换回来的时候,只会转
换成字符串类型,无法转换为Date object了</li>
<li>Function,RegExp,Error object和undefined直接就无法序列化</li>
</ol></li>
</ul></li>
<li>从上面的叙述来看,我们发现从object转换为json字符串的过程,是问题比较多的过程,因为JavaScript syntax是
一个更高阶复杂的syntax,而从JSON syntax转换回JavaScript syntax的过程反而是一定能成功的.那么我们就着
重研究下object到json字符串的函数JSON.stringify().
<ul class="org-ul">
<li>这个函数只序列化enumerable own property</li>
<li>如果某个property无法序列号,那么这个property会被直接剔除在最终的json字符串里面</li>
<li>接受第二个参数,来指定只序列化哪些property(这个特性JSON.parse()也有)</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgae1907f" class="outline-3">
<h3 id="orgae1907f"><span class="section-number-3">6.9.</span> Object Methods</h3>
<div class="outline-text-3" id="text-6-9">
<ul class="org-ul">
<li>我们前面提到过,几乎所有的javascript object都是会从Object.prototype继承得到property(因为这是继承的终点)</li>
<li>所以Object自己的这些property就会被几乎所有的object所拥有.这些property的应用范围广,所以也值得我们全部了解一下</li>
</ul>
</div>
<div id="outline-container-org2b7044b" class="outline-4">
<h4 id="org2b7044b"><span class="section-number-4">6.9.1.</span> The toString() method</h4>
<div class="outline-text-4" id="text-6-9-1">
<ul class="org-ul">
<li>toString() method没有参数,其返回值为一个字符串,表示调用者object的value</li>
<li>除了显式的调用,JavaScript也会隐式调用:比如当你使用+operator来链接你的object和字符串的时候</li>
<li><p>
默认的toString()函数的结果不是特别的有意义,比如下面的例子,结果是[object Object]"
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">s</span> = <span style="color: #3a81c3;">{</span> x: 1, y: 2 <span style="color: #3a81c3;">}</span>;

console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">`|s.toString()| =&gt; ${s.toString()}`</span><span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">|s.toString()| =&gt; [object Object]</span>
</pre>
</div></li>
<li><p>
所以我们很多时候要定义自己的toString,例子如下
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">s</span> = <span style="color: #3a81c3;">{</span>
  x: 1,
  y: 2,
  <span style="color: #6c3163; font-weight: bold;">toString</span>: <span style="color: #3a81c3; font-weight: bold;">function</span> <span style="color: #6c3163;">()</span> <span style="color: #6c3163;">{</span>
    <span style="color: #3a81c3; font-weight: bold;">return</span> <span style="color: #2d9574;">`(${this.x}, ${this.y})`</span>;
  <span style="color: #6c3163;">}</span>,
<span style="color: #3a81c3;">}</span>;

console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">`|s.toString()| =&gt; ${s.toString()}`</span><span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">|s.toString()| =&gt; (1, 2)</span>
</pre>
</div></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org8d24d30" class="outline-3">
<h3 id="org8d24d30"><span class="section-number-3">6.10.</span> The toLocaleString() Method</h3>
<div class="outline-text-3" id="text-6-10">
<ul class="org-ul">
<li>toLocaleString()会根据不同的环境(比如美国英语环境,或者德国德语环境),返回不同的本地化字符串,多用于数字,日期等.比如1234567.89:
<ul class="org-ul">
<li>在美国英语环境中,toLocaleString()会返回"1,234,567.89"</li>
<li>在德国德语环境中,toLocaleString()会返回"1.234.567,89"</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org116ce24" class="outline-3">
<h3 id="org116ce24"><span class="section-number-3">6.11.</span> The valueOf() Method</h3>
<div class="outline-text-3" id="text-6-11">
<ul class="org-ul">
<li>valueOf()和toString()类似,只不过转换后的结果不是string,而是number</li>
</ul>
</div>
</div>
<div id="outline-container-orgaa060db" class="outline-3">
<h3 id="orgaa060db"><span class="section-number-3">6.12.</span> The toJSON() Method</h3>
<div class="outline-text-3" id="text-6-12">
<ul class="org-ul">
<li><p>
Object.prototype自己定义一个叫做toJSON()的method,而是JSON.stringify()会在序列的过程中,查询每个将要
被序列化的object,其是否有实现一个toJSON()method,如果有,就调用这个函数实现序列化.我们可以为我们自己
的object创建自己的toJSON函数,如下
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">point</span> = <span style="color: #3a81c3;">{</span>
  x: 1,
  y: 2,
  <span style="color: #6c3163; font-weight: bold;">toString</span>: <span style="color: #3a81c3; font-weight: bold;">function</span> <span style="color: #6c3163;">()</span> <span style="color: #6c3163;">{</span>
    <span style="color: #3a81c3; font-weight: bold;">return</span> <span style="color: #2d9574;">`(${this.x}, ${this.y})`</span>;
  <span style="color: #6c3163;">}</span>,
<span style="color: #3a81c3;">}</span>;

console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">`|JSON.stringify([point])| =&gt; ${JSON.stringify([point])}`</span><span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">|JSON.stringify([point])| =&gt; [{"x":1,"y":2}]</span>
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-orgd4951df" class="outline-3">
<h3 id="orgd4951df"><span class="section-number-3">6.13.</span> Extended Object Literal Syntax</h3>
<div class="outline-text-3" id="text-6-13">
<ul class="org-ul">
<li>最近JavaScript的版本开始扩展object literal,我们下面来介绍一下</li>
</ul>
</div>
<div id="outline-container-org214a44b" class="outline-4">
<h4 id="org214a44b"><span class="section-number-4">6.13.1.</span> Shorthand Properties</h4>
<div class="outline-text-4" id="text-6-13-1">
<ul class="org-ul">
<li>比如你有两个变量,x和y,然后你想创建一个对象,里面有x和y,并且值从外面的x和y来
<ul class="org-ul">
<li><p>
如果是老的JavaScript,你要写出这种比较繁杂的代码
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">x</span> = 1;
<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">y</span> = 2;
<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">o</span> = <span style="color: #3a81c3;">{</span>
  x: x,
  y: y,
<span style="color: #3a81c3;">}</span>;
</pre>
</div></li>
<li><p>
但是在ES6之后,你可以这么写(不用冒号和key)
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">x</span> = 1;
<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">y</span> = 2;
<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">o</span> = <span style="color: #3a81c3;">{</span> x, y <span style="color: #3a81c3;">}</span>;
console.log<span style="color: #3a81c3;">(</span>o<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">{ x: 1, y: 2 }</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org4313e0c" class="outline-4">
<h4 id="org4313e0c"><span class="section-number-4">6.13.2.</span> Computed Property Names</h4>
<div class="outline-text-4" id="text-6-13-2">
<ul class="org-ul">
<li>有些时候,你需要在object里面创建一个property,但是这个property的name在compile-time是无法确定的:
<ul class="org-ul">
<li><p>
如果是老的JavaScript代码你需要如下
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">const</span> <span style="color: #715ab1;">PROPERTY_NAME</span> = <span style="color: #2d9574;">"p1"</span>;
<span style="color: #3a81c3; font-weight: bold;">function</span> <span style="color: #6c3163; font-weight: bold;">computePropertyName</span><span style="color: #3a81c3;">()</span> <span style="color: #3a81c3;">{</span>
  <span style="color: #3a81c3; font-weight: bold;">return</span> <span style="color: #2d9574;">"p"</span> + 2;
<span style="color: #3a81c3;">}</span>
<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">o</span> = <span style="color: #3a81c3;">{}</span>;
o<span style="color: #3a81c3;">[</span>PROPERTY_NAME<span style="color: #3a81c3;">]</span> = 1;
o<span style="color: #3a81c3;">[</span>computePropertyName<span style="color: #6c3163;">()</span><span style="color: #3a81c3;">]</span> = 2;
console.log<span style="color: #3a81c3;">(</span>o<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">{ p1: 1, p2: 2 }</span>
</pre>
</div></li>
<li><p>
但是在ES6之后,你可以这么写
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">const</span> <span style="color: #715ab1;">PROPERTY_NAME</span> = <span style="color: #2d9574;">"p1"</span>;
<span style="color: #3a81c3; font-weight: bold;">function</span> <span style="color: #6c3163; font-weight: bold;">computePropertyName</span><span style="color: #3a81c3;">()</span> <span style="color: #3a81c3;">{</span>
  <span style="color: #3a81c3; font-weight: bold;">return</span> <span style="color: #2d9574;">"p"</span> + 2;
<span style="color: #3a81c3;">}</span>
<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">p</span> = <span style="color: #3a81c3;">{</span>
  <span style="color: #6c3163;">[</span>PROPERTY_NAME<span style="color: #6c3163;">]</span>: 1,
  <span style="color: #6c3163;">[</span>computePropertyName<span style="color: #2d9574;">()</span><span style="color: #6c3163;">]</span>: 2,
<span style="color: #3a81c3;">}</span>;
console.log<span style="color: #3a81c3;">(</span>p<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">{ p1: 1, p2: 2 }</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgb614ef2" class="outline-4">
<h4 id="orgb614ef2"><span class="section-number-4">6.13.3.</span> Symbols as Property Names</h4>
<div class="outline-text-4" id="text-6-13-3">
<ul class="org-ul">
<li>在ES6之后,property的名字可以是字符串或者Symbol.</li>
<li><p>
这个Symbol的特性我们之前说过:通过Symbol(desc string)创建成功的任意两个Symbol,即便desc string一样也
是两个不同的Symbol.
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&#21019;&#24314;&#20004;&#20010;&#20855;&#26377;&#30456;&#21516;&#25551;&#36848;&#23383;&#31526;&#20018;&#30340; Symbol</span>
<span style="color: #3a81c3; font-weight: bold;">const</span> <span style="color: #715ab1;">symbol1</span> = Symbol<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"myDescription"</span><span style="color: #3a81c3;">)</span>;
<span style="color: #3a81c3; font-weight: bold;">const</span> <span style="color: #715ab1;">symbol2</span> = Symbol<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"myDescription"</span><span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&#25171;&#21360; Symbol &#26412;&#36523;</span>
console.log<span style="color: #3a81c3;">(</span>symbol1<span style="color: #3a81c3;">)</span>; <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&#36755;&#20986;: Symbol(myDescription)</span>
console.log<span style="color: #3a81c3;">(</span>symbol2<span style="color: #3a81c3;">)</span>; <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&#36755;&#20986;: Symbol(myDescription)</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&#39564;&#35777;&#23427;&#20204;&#26159;&#21542;&#30456;&#31561;</span>
console.log<span style="color: #3a81c3;">(</span>symbol1 === symbol2<span style="color: #3a81c3;">)</span>; <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&#36755;&#20986;: false (&#23427;&#20204;&#26159;&#21807;&#19968;&#30340;)</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Symbol(myDescription)</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">Symbol(myDescription)</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">false</span>
</pre>
</div></li>
<li>Symbol的这个特性就让它作为一个函数的property用起来非常的复杂.例子如下</li>
<li>那么我们就会思考一个问题:既然Symbol作为函数的property用起来那么麻烦,那么为什么要允许Symbol来作为object的property呢?</li>
<li>我们可以简单的列一下答案,就是为了如下的常见:
<ul class="org-ul">
<li>你获取了一个第三方的JavaScript库代码</li>
<li>你需要在这个第三方的JavaScript库代码的object里面添加自己的property</li>
<li>但是你不能覆盖第三方的JavaScript代码的任何property,所以你要配置一个全世界唯一的,且第三方库也"碰撞"不了的名字</li>
<li>所以Symbol就诞生了.</li>
</ul></li>
<li>本质上讲Symbol这种特性的诞生在于JavaScript是没有权限管理的概念的,我们作为使用者,竟然可以随便向库代
码的object里面添加property,这本身在其他语言里面是不可能发生的.</li>
</ul>
</div>
</div>
<div id="outline-container-org8869843" class="outline-4">
<h4 id="org8869843"><span class="section-number-4">6.13.4.</span> Spread Operator</h4>
<div class="outline-text-4" id="text-6-13-4">
<ul class="org-ul">
<li><p>
在ES2018里面,我们还可以把多个已存在的object通过spread operator来形成一个新的object.注意这个过程的复杂度是O(n)
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">a</span> = <span style="color: #3a81c3;">{</span> x: 1 <span style="color: #3a81c3;">}</span>;
<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">b</span> = <span style="color: #3a81c3;">{</span> y: 2 <span style="color: #3a81c3;">}</span>;
<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">c</span> = <span style="color: #3a81c3;">{</span> z: 3 <span style="color: #3a81c3;">}</span>;

<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">o</span> = <span style="color: #3a81c3;">{</span> ...a, ...b, ...c <span style="color: #3a81c3;">}</span>;
console.log<span style="color: #3a81c3;">(</span>o<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">{ x: 1, y: 2, z: 3 }</span>
</pre>
</div></li>
<li><p>
需要注意的是,如果spread operator参与的多个object里面有同样名字的property,那么后面的property会覆盖前面的property
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">a</span> = <span style="color: #3a81c3;">{</span> x: 1 <span style="color: #3a81c3;">}</span>;
<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">b</span> = <span style="color: #3a81c3;">{</span> x:2, y: 2 <span style="color: #3a81c3;">}</span>;
<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">c</span> = <span style="color: #3a81c3;">{</span> z: 3 <span style="color: #3a81c3;">}</span>;

<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">o</span> = <span style="color: #3a81c3;">{</span> ...a, ...b, ...c <span style="color: #3a81c3;">}</span>;
console.log<span style="color: #3a81c3;">(</span>o<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">{ x: 2, y: 2, z: 3 }</span>
</pre>
</div></li>
<li><p>
同样需要注意的是,spread operator只能spread own property,不能spread inherited property
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">o</span> = Object.create<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">{</span> x: 1 <span style="color: #6c3163;">}</span><span style="color: #3a81c3;">)</span>;
<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">p</span> = <span style="color: #3a81c3;">{</span> ...o <span style="color: #3a81c3;">}</span>;
console.log<span style="color: #3a81c3;">(</span>p.x<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">undefined</span>
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-org393cb4d" class="outline-4">
<h4 id="org393cb4d"><span class="section-number-4">6.13.5.</span> Shorthand Methods</h4>
<div class="outline-text-4" id="text-6-13-5">
<ul class="org-ul">
<li>如果一个function被定义为object的property,那么我们可以把这function叫做method:
<ul class="org-ul">
<li><p>
定义method在老的JavaScritpt里面可以如下定义,给method一个名字,并且在冒号之后加上function定义
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">square</span> = <span style="color: #3a81c3;">{</span>
  <span style="color: #6c3163; font-weight: bold;">area</span>: <span style="color: #3a81c3; font-weight: bold;">function</span> <span style="color: #6c3163;">()</span> <span style="color: #6c3163;">{</span>
    <span style="color: #3a81c3; font-weight: bold;">return</span> <span style="color: #4e3163;">this</span>.side * <span style="color: #4e3163;">this</span>.side;
  <span style="color: #6c3163;">}</span>,
  side: 10,
<span style="color: #3a81c3;">}</span>;

console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">`|square.area()| =&gt; ${square.area()}`</span><span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">|square.area()| =&gt; 100</span>
</pre>
</div></li>
<li><p>
在ES6的object literal syntax中,引入了shorthand method的写法:允许省略function和冒号
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">square</span> = <span style="color: #3a81c3;">{</span>
  area<span style="color: #6c3163;">()</span> <span style="color: #6c3163;">{</span>
    <span style="color: #3a81c3; font-weight: bold;">return</span> <span style="color: #4e3163;">this</span>.size * <span style="color: #4e3163;">this</span>.side;
  <span style="color: #6c3163;">}</span>,
  side: 10,
<span style="color: #3a81c3;">}</span>;
console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">`|square.area()| =&gt; ${square.area()}`</span><span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">|square.area()| =&gt; NaN</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org4d05445" class="outline-4">
<h4 id="org4d05445"><span class="section-number-4">6.13.6.</span> Property Getters and Setters</h4>
<div class="outline-text-4" id="text-6-13-6">
<ul class="org-ul">
<li>我们前面介绍的所有的property都是data property,其实JavaScript还有一种property叫做accessor property</li>
<li><p>
所谓的accessor property,它有两个函数组成,一个getter(读取的时候调用),一个setter(设置的时候调用),代码如下
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">o</span> = <span style="color: #3a81c3;">{</span>
  dataProp: 1,

  get accessorProp<span style="color: #6c3163;">()</span> <span style="color: #6c3163;">{</span>
    console.log<span style="color: #2d9574;">(</span><span style="color: #2d9574;">"getter caller"</span><span style="color: #2d9574;">)</span>;
    <span style="color: #3a81c3; font-weight: bold;">return</span> <span style="color: #4e3163;">this</span>.dataProp;
  <span style="color: #6c3163;">}</span>,
  set accessorProp<span style="color: #6c3163;">(</span>value<span style="color: #6c3163;">)</span> <span style="color: #6c3163;">{</span>
    console.log<span style="color: #2d9574;">(</span><span style="color: #2d9574;">"setter caller"</span><span style="color: #2d9574;">)</span>;
    <span style="color: #4e3163;">this</span>.dataProp = value;
  <span style="color: #6c3163;">}</span>,
<span style="color: #3a81c3;">}</span>;

console.log<span style="color: #3a81c3;">(</span>o.accessorProp<span style="color: #3a81c3;">)</span>;
o.accessorProp = 12;
console.log<span style="color: #3a81c3;">(</span>o.accessorProp<span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>o<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">getter caller</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">1</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">setter caller</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">getter caller</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">12</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">{ dataProp: 12, accessorProp: [Getter/Setter] }</span>
</pre>
</div></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-orgf70d466" class="outline-2">
<h2 id="orgf70d466"><span class="section-number-2">7.</span> Chapter 7: Arrays</h2>
<div class="outline-text-2" id="text-7">
<ul class="org-ul">
<li>本章介绍JavaScript里面的基本数据类型:数组.</li>
<li>JavaScript的数组和其他的编程语言并不完全一样,JavaScript的数组是untyped,也就说数组的每个成员都可以是不同类型的.甚至每个
element都可以是object或者是其他数组</li>
<li>JavaScript的数组是0为index开始,最大长度为32-bit integer</li>
<li>JavaScript的array其实是一种特殊的JavaScript object:只不过array的index刚好是integer类型的property.
当然由于array的index为integer的这个特性,JavaScript进行了优化,使得每次访问array的index比访问object
的property更快</li>
<li>Arrays从Array.prototype里面继承了绝大多数的property,这些property定义了丰富的method</li>
<li>这些method多数都是generic的,所谓generic,意思是他们不仅仅对true array有作用,还会对array-like object起作用</li>
<li>ES6新定义了一系列新的array class,叫做typed array,他们有固定的length,并且成员都是同一种类型</li>
</ul>
</div>
<div id="outline-container-org0c3d1d6" class="outline-3">
<h3 id="org0c3d1d6"><span class="section-number-3">7.1.</span> Creating Arrays</h3>
<div class="outline-text-3" id="text-7-1">
<ul class="org-ul">
<li>在JavaScript里面创建Array的方法有如下几种:
<ul class="org-ul">
<li>Array literal</li>
<li>The &#x2026; spread operator</li>
<li>Array() constructor</li>
<li>Array.of(), Array.from()</li>
</ul></li>
<li>本节下面的内容就是分别介绍这几种方法</li>
</ul>
</div>
<div id="outline-container-orgf3d339a" class="outline-4">
<h4 id="orgf3d339a"><span class="section-number-4">7.1.1.</span> Array Literals</h4>
<div class="outline-text-4" id="text-7-1-1">
<ul class="org-ul">
<li><p>
最简单的创建数组的方法就是array literal啦,前面说过,这种方法还可以内置其他object或者数组,如下
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">empty</span> = <span style="color: #3a81c3;">[]</span>;
<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">misc</span> = <span style="color: #3a81c3;">[</span>1.1, <span style="color: #4e3163;">true</span>, <span style="color: #2d9574;">"a"</span><span style="color: #3a81c3;">]</span>;
<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">b</span> = <span style="color: #3a81c3;">[</span><span style="color: #6c3163;">[</span>1, <span style="color: #2d9574;">{</span> x: 1 <span style="color: #2d9574;">}</span><span style="color: #6c3163;">]</span>, 2<span style="color: #3a81c3;">]</span>;
console.log<span style="color: #3a81c3;">(</span>empty<span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>misc<span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>b<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[]</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[ 1.1, true, 'a' ]</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[ [ 1, { x: 1 } ], 2 ]</span>
</pre>
</div></li>
<li>如果在literal里面有两个逗号,但是中间没有值,我们称之为sparse array
<ul class="org-ul">
<li><p>
例子如下
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">count</span> = <span style="color: #3a81c3;">[</span>1, , 3<span style="color: #3a81c3;">]</span>;
console.log<span style="color: #3a81c3;">(</span>count<span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>count<span style="color: #6c3163;">[</span>1<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[ 1, &lt;1 empty item&gt;, 3 ]</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">undefined</span>
</pre>
</div></li>
<li>我们可以看到,如果用console打印这个数组,能够明确的告诉我们index为1的位置是没有内容的(no value)</li>
<li>但是我们如果一定要打印这个index1,会得到undefined</li>
<li><p>
另外一个有趣的地方是,如果我们整个数组只有两个逗号,那么得到的是一个长度为2(而不是3)的数组,因为第二个逗号是结束符
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">undefs</span> = <span style="color: #3a81c3;">[</span>, ,<span style="color: #3a81c3;">]</span>;
console.log<span style="color: #3a81c3;">(</span>undefs<span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">`|undefs.length| =&gt; ${undefs.length}`</span><span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[ &lt;2 empty items&gt; ]</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">|undefs.length| =&gt; 2</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgfdd9d36" class="outline-4">
<h4 id="orgfdd9d36"><span class="section-number-4">7.1.2.</span> The Spread Operator</h4>
<div class="outline-text-4" id="text-7-1-2">
<ul class="org-ul">
<li>首先明确一下哈spread operator的这个名字operator只不过是一种"约定俗成"的叫法,其实spread operator不
是operator,因为它只能在数组,对象和function 参数列表里面使用</li>
<li><p>
spread operator我们之前在第六章object里面就见识到了,例子如下
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">const</span> <span style="color: #715ab1;">obj1</span> = <span style="color: #3a81c3;">{</span> a: 1, b: 2 <span style="color: #3a81c3;">}</span>;
<span style="color: #3a81c3; font-weight: bold;">const</span> <span style="color: #715ab1;">obj2</span> = <span style="color: #3a81c3;">{</span> ...obj1, c: 3 <span style="color: #3a81c3;">}</span>;
console.log<span style="color: #3a81c3;">(</span>obj2<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">{ a: 1, b: 2, c: 3 }</span>
</pre>
</div></li>
<li><p>
在数组这里spread也是起到同样的左右,那就是"在新位置展开老的数组"
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">a</span> = <span style="color: #3a81c3;">[</span>1, 2, 3<span style="color: #3a81c3;">]</span>;
<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">b</span> = <span style="color: #3a81c3;">[</span>0, ...a, 4, 4<span style="color: #3a81c3;">]</span>;
console.log<span style="color: #3a81c3;">(</span>b<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[ 0, 1, 2, 3, 4, 4 ]</span>
</pre>
</div></li>
<li>在数组中使用spread operator可以很容易的创建一个数组的shallow copy</li>
<li>上面讲到spread在"数组"里面起到的展开作用,我们这里把"数组"加了双引号,因为spread operator是在所有"类
数组"里面都能使用.在JavaScript里面"类数组"有个自己学术的名字,叫做Iterable object</li>
<li>所谓Iterable object,从字面理解,就是所有能够iterate的对象,在JavaScript里面,完整对应能够使用for/of来
遍历的对象,JavaScript里面常见的iterable object有:
<ul class="org-ul">
<li>Array</li>
<li><p>
String, 应用在string上面,会自动的把string按single character进行展开
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">digits</span> = <span style="color: #3a81c3;">[</span>...<span style="color: #2d9574;">"0123456789ABCDEF"</span><span style="color: #3a81c3;">]</span>;
console.log<span style="color: #3a81c3;">(</span>digits<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">//   </span><span style="color: #2aa1ae; background-color: #ecf3ec;">'0', '1', '2', '3',</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">//   </span><span style="color: #2aa1ae; background-color: #ecf3ec;">'4', '5', '6', '7',</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">//   </span><span style="color: #2aa1ae; background-color: #ecf3ec;">'8', '9', 'A', 'B',</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">//   </span><span style="color: #2aa1ae; background-color: #ecf3ec;">'C', 'D', 'E', 'F'</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">]</span>
</pre>
</div></li>
<li>Map</li>
<li><p>
Set: 我们可以利用set的不允许重复的特性和spread operator联合起来,非常轻松的去除重复的character
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">letters</span> = <span style="color: #3a81c3;">[</span>...<span style="color: #2d9574;">"hello world"</span><span style="color: #3a81c3;">]</span>;
console.log<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>...<span style="color: #3a81c3; font-weight: bold;">new</span> <span style="color: #ba2f59; font-weight: bold;">Set</span><span style="color: #2d9574;">(</span>letters<span style="color: #2d9574;">)</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">//   </span><span style="color: #2aa1ae; background-color: #ecf3ec;">'h', 'e', 'l',</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">//   </span><span style="color: #2aa1ae; background-color: #ecf3ec;">'o', ' ', 'w',</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">//   </span><span style="color: #2aa1ae; background-color: #ecf3ec;">'r', 'd'</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">]</span>
</pre>
</div></li>
<li>TypedArray</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org551ccca" class="outline-4">
<h4 id="org551ccca"><span class="section-number-4">7.1.3.</span> The Array() Constructor</h4>
<div class="outline-text-4" id="text-7-1-3">
<ul class="org-ul">
<li>Array()函数有如下三种调用方式:
<ul class="org-ul">
<li><p>
不传参数
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">a</span> = <span style="color: #3a81c3; font-weight: bold;">new</span> <span style="color: #ba2f59; font-weight: bold;">Array</span><span style="color: #3a81c3;">()</span>;
console.log<span style="color: #3a81c3;">(</span>a<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[]</span>
</pre>
</div></li>
<li><p>
传一个参数.并且这参数是number.注意,这种传递方法创建的数组没有任何的value被设置
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">a</span> = <span style="color: #3a81c3; font-weight: bold;">new</span> <span style="color: #ba2f59; font-weight: bold;">Array</span><span style="color: #3a81c3;">(</span>10<span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>a<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[ &lt;10 empty items&gt; ]</span>
</pre>
</div></li>
<li><p>
传递一个非number的参数,或者传两个或者两个以上的参数
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">a</span> = <span style="color: #3a81c3; font-weight: bold;">new</span> <span style="color: #ba2f59; font-weight: bold;">Array</span><span style="color: #3a81c3;">(</span>5, 3, <span style="color: #2d9574;">"testing"</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>a<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[ 5, 3, 'testing' ]</span>
</pre>
</div></li>
</ul></li>
<li>我们可以看到,无论传什么参数,使用Array()总是比Array literal麻烦</li>
</ul>
</div>
</div>
<div id="outline-container-orgd5264b5" class="outline-4">
<h4 id="orgd5264b5"><span class="section-number-4">7.1.4.</span> Array.of()</h4>
<div class="outline-text-4" id="text-7-1-4">
<ul class="org-ul">
<li><p>
上面的Array()函数有个问题,那就是无法创建只有一个numeric element的array.ES6引入了Array.of来解决这个
问题. Array.of的参数就是新数组的所有成员
</p>
<div class="org-src-container">
<pre class="src src-js">console.log<span style="color: #3a81c3;">(</span>Array.<span style="color: #3a81c3; font-weight: bold;">of</span><span style="color: #6c3163;">()</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>Array.<span style="color: #3a81c3; font-weight: bold;">of</span><span style="color: #6c3163;">(</span>1<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>Array.<span style="color: #3a81c3; font-weight: bold;">of</span><span style="color: #6c3163;">(</span>1, 2, 3<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[]</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[ 1 ]</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[ 1, 2, 3 ]</span>
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-org0c1a701" class="outline-4">
<h4 id="org0c1a701"><span class="section-number-4">7.1.5.</span> Array.from()</h4>
<div class="outline-text-4" id="text-7-1-5">
<ul class="org-ul">
<li>Array.from()也是ES6引入的array factory method.</li>
<li>这个函数更加复杂,它可以选择输入不同的参数:
<ul class="org-ul">
<li><p>
如果只有一个参数,那么这个参数必须是一个iterable,也就是Array.from(iterable).这个用法就可以spread
operator[&#x2026;iterable]差不多了.
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">const</span> <span style="color: #715ab1;">str</span> = <span style="color: #2d9574;">"hello"</span>;
<span style="color: #3a81c3; font-weight: bold;">const</span> <span style="color: #715ab1;">result</span> = Array.from<span style="color: #3a81c3;">(</span>str<span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>result<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[ 'h', 'e', 'l', 'l', 'o' ]</span>
</pre>
</div></li>
<li><p>
如果传入两个参数,那么第二个参数是一个function,第一次iterable的每个参数都会被function处理一遍以后,
组成新的array返回(和map函数的处理逻辑差不多)
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">const</span> <span style="color: #715ab1;">set</span> = <span style="color: #3a81c3; font-weight: bold;">new</span> <span style="color: #ba2f59; font-weight: bold;">Set</span><span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>1, 2, 3<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>;
<span style="color: #3a81c3; font-weight: bold;">const</span> <span style="color: #715ab1;">result</span> = Array.from<span style="color: #3a81c3;">(</span>set, <span style="color: #6c3163;">(</span>x<span style="color: #6c3163;">)</span> =&gt; x * 10<span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>result<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[ 10, 20, 30 ]</span>
</pre>
</div></li>
</ul></li>
<li>Array.from()还有一个重要的作用,就是将array-like object进行true-array copy,来创建一个真正的arry</li>
<li>所谓array-like object是web浏览器的一些method返回的object,他们的特点是:
<ul class="org-ul">
<li>是object,而不是array</li>
<li>有length property,结果是number</li>
<li>其他的property都刚好是integer</li>
</ul></li>
<li><p>
我们使用如下的代码来将array-like object转换成true array
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">truearray</span> = Array.from<span style="color: #3a81c3;">(</span>arraylike<span style="color: #3a81c3;">)</span>;
</pre>
</div></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org57509c2" class="outline-3">
<h3 id="org57509c2"><span class="section-number-3">7.2.</span> Reading and Writing Array Elements</h3>
<div class="outline-text-3" id="text-7-2">
<ul class="org-ul">
<li>数组使用[]operator进行访问控制:
<ul class="org-ul">
<li>[]operator右边是我们的数组对象</li>
<li>[]operator里面,是一个expression,它最终能得到一个non-negative integer就可以.</li>
<li><p>
上述方法既可以作为读取的方法,也可以作为写入的方法
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">a</span> = <span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"world"</span><span style="color: #3a81c3;">]</span>;
<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">value</span> = a<span style="color: #3a81c3;">[</span>0<span style="color: #3a81c3;">]</span>;
a<span style="color: #3a81c3;">[</span>1<span style="color: #3a81c3;">]</span> = 3.14;
<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">i</span> = 2;
a<span style="color: #3a81c3;">[</span>i<span style="color: #3a81c3;">]</span> = 3;
a<span style="color: #3a81c3;">[</span>i + 1<span style="color: #3a81c3;">]</span> = <span style="color: #2d9574;">"hello"</span>;
console.log<span style="color: #3a81c3;">(</span>a<span style="color: #3a81c3;">)</span>;
</pre>
</div></li>
</ul></li>
<li>数组其实是specialized kind of object.所以,我们的[]operator其实也可以处理"非non-negative integer",
两者的区别如下:
<ul class="org-ul">
<li><p>
array index: 如果expression得到了一个non-negtive integer(并且小于2**32-1): 这种情况下,Javascript
会先把这个index转换为字符串(比如1-&gt;"1"),然后用这个字符串作为property name来进行读取.除了正常读取
以外,还会根据情况更新length信息.这很重要,这是array index和下面的object property name的主要区别.
需要注意的是expression得到的结果,即便是float类型,如果等于non-negative integer,也会被当做non-negative
integer处理
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">a</span> = <span style="color: #3a81c3;">[</span>0<span style="color: #3a81c3;">]</span>;
a<span style="color: #3a81c3;">[</span>1.0<span style="color: #3a81c3;">]</span> = 1;
console.log<span style="color: #3a81c3;">(</span>a<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[ 0, 1 ]</span>
</pre>
</div></li>
<li><p>
object property name: 如果[]operator里面不是上面的情况,那么就相当于访问普通数组增加一个普通的property
name(这个时候普通数组也就当object来看了)
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">a</span> = <span style="color: #3a81c3;">[</span>1, 2, 3<span style="color: #3a81c3;">]</span>;
a<span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"five"</span><span style="color: #3a81c3;">]</span> = 55;
console.log<span style="color: #3a81c3;">(</span>a<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[ 1, 2, 3, five: 55 ]</span>
</pre>
</div></li>
</ul></li>
<li>由于array index其实就是special type of object property name, 那么Javascript array是不存在"out of bounds"
错误的:
<ul class="org-ul">
<li><p>
一个object如果你试图查询一个不存在的property,那么你不会得到error,只会得到undefined
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">o</span> = <span style="color: #3a81c3;">{}</span>;
console.log<span style="color: #3a81c3;">(</span>o<span style="color: #6c3163;">[</span><span style="color: #2d9574;">"hello"</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">undefined</span>
</pre>
</div></li>
<li><p>
同样的,你查询一个不存在的array index,你也不会得到error,只会得到undefined
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">a</span> = <span style="color: #3a81c3;">[</span><span style="color: #4e3163;">true</span>, <span style="color: #4e3163;">false</span><span style="color: #3a81c3;">]</span>;
console.log<span style="color: #3a81c3;">(</span>a<span style="color: #6c3163;">[</span>2<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>a<span style="color: #6c3163;">[</span>-1<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">undefined</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">undefined</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org7ea985d" class="outline-3">
<h3 id="org7ea985d"><span class="section-number-3">7.3.</span> Sparse Arrays</h3>
<div class="outline-text-3" id="text-7-3">
<ul class="org-ul">
<li>所谓sparse array,就是数组的element不连续有值,这种情况下数组的length大于数组内element的数量</li>
<li>我们有如下几种方式来创建sparse array:
<ul class="org-ul">
<li><p>
使用Array()带一个数字参数
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">a</span> = <span style="color: #3a81c3; font-weight: bold;">new</span> <span style="color: #ba2f59; font-weight: bold;">Array</span><span style="color: #3a81c3;">(</span>5<span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>a<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[ &lt;5 empty items&gt; ]</span>
</pre>
</div></li>
<li><p>
使用array literal,但是两个逗号直接没有值
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">a</span> = <span style="color: #3a81c3;">[</span>1, , 3<span style="color: #3a81c3;">]</span>;
console.log<span style="color: #3a81c3;">(</span>a<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[ 1, &lt;1 empty item&gt;, 3 ]</span>
</pre>
</div></li>
<li><p>
直接给一个array index赋值,且这个array index大于length
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">a</span> = <span style="color: #3a81c3;">[]</span>;
a<span style="color: #3a81c3;">[</span>1000<span style="color: #3a81c3;">]</span> = 1;
console.log<span style="color: #3a81c3;">(</span>a<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[ &lt;1000 empty items&gt;, 1 ]</span>
</pre>
</div></li>
<li>使用delete operator也可以</li>
</ul></li>
<li>理解sparse array对于理解Javascript的array的本质很有作用,但是在工作当中你的代码面对spare array,其实
就相当于面对一个又undefined值的nonsparse array而已</li>
</ul>
</div>
</div>
<div id="outline-container-orgf75319e" class="outline-3">
<h3 id="orgf75319e"><span class="section-number-3">7.4.</span> Array Length</h3>
<div class="outline-text-3" id="text-7-4">
<ul class="org-ul">
<li>每个array都有length这个property,也正是这个property让array区别于object</li>
<li>array的length有一个特性,就是它保证能比任何一个array内部element的index要大,为了维护这个特性,Javascript
有两个特别的行为:
<ul class="org-ul">
<li><p>
如果给一个array赋值,但是index比length还大,那么length里面更改为这个index+1,并且会创建一些没赋值的位置
</p>
<div class="org-src-container">
<pre class="src src-js">a = <span style="color: #3a81c3;">[</span>1, 2, 3, 4, 5<span style="color: #3a81c3;">]</span>;
console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">`|a.length| =&gt; ${a.length}`</span><span style="color: #3a81c3;">)</span>;
a<span style="color: #3a81c3;">[</span>100<span style="color: #3a81c3;">]</span> = 99;
console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">`|a.length| =&gt; ${a.length}`</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>a<span style="color: #3a81c3;">)</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">|a.length| =&gt; 5</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">|a.length| =&gt; 101</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[ 1, 2, 3, 4, 5, &lt;95 empty items&gt;, 99 ]</span>
</pre>
</div></li>
<li><p>
如果你给length赋值为non-negative,但是比当前的length要小,那么和length相等或者更大的index都会被从array中删除
</p>
<div class="org-src-container">
<pre class="src src-js">a = <span style="color: #3a81c3;">[</span>1, 2, 3, 4, 5<span style="color: #3a81c3;">]</span>;
a.length = 3;
console.log<span style="color: #3a81c3;">(</span>a<span style="color: #3a81c3;">)</span>;
a.length = 0;
console.log<span style="color: #3a81c3;">(</span>a<span style="color: #3a81c3;">)</span>;
a.legnth = 5;
console.log<span style="color: #3a81c3;">(</span>a<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[ 1, 2, 3 ]</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[]</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[ legnth: 5 ]</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org99860fa" class="outline-3">
<h3 id="org99860fa"><span class="section-number-3">7.5.</span> Adding and Deleting Array Elements</h3>
<div class="outline-text-3" id="text-7-5">
<ul class="org-ul">
<li><p>
我们可以使用push()来把一个或者多个value添加到array的最后面
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">a</span> = <span style="color: #3a81c3;">[]</span>;
a.push<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"zero"</span><span style="color: #3a81c3;">)</span>;
a.push<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"one"</span>, <span style="color: #2d9574;">"two"</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>a<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[ 'zero', 'one', 'two' ]</span>
</pre>
</div></li>
<li><p>
pop()和push()作用相反,从最后减去一个成员
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">a</span> = <span style="color: #3a81c3;">[</span>1, 2, 3<span style="color: #3a81c3;">]</span>;
a.pop<span style="color: #3a81c3;">()</span>;
console.log<span style="color: #3a81c3;">(</span>a<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[ 1, 2 ]</span>
</pre>
</div></li>
<li><p>
shift()和pop()的作用类似,但是是从最开始减去一个成员,所有成员shift到最开始
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">a</span> = <span style="color: #3a81c3;">[</span>1, 2, 3<span style="color: #3a81c3;">]</span>;
a.unshift<span style="color: #3a81c3;">(</span>0<span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>a<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[ 0, 1, 2, 3 ]</span>
</pre>
</div></li>
<li><p>
delete也可以从数组删除一个成员,只不过delete会产生sparse数组,也就不会更改length
</p>
<div class="org-src-container">
<pre class="src src-js">jlet a = <span style="color: #3a81c3;">[</span>1, 2, 3<span style="color: #3a81c3;">]</span>;
<span style="color: #3a81c3; font-weight: bold;">delete</span> a<span style="color: #3a81c3;">[</span>1<span style="color: #3a81c3;">]</span>;
console.log<span style="color: #3a81c3;">(</span>a<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[ 1, &lt;1 empty item&gt;, 3 ]</span>
</pre>
</div></li>
<li>splice()函数有多个参数,可以删除也可以添加元素:
<ul class="org-ul">
<li><p>
删除元素的例子:
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">fruits</span> = <span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"apple"</span>, <span style="color: #2d9574;">"banana"</span>, <span style="color: #2d9574;">"cherry"</span>, <span style="color: #2d9574;">"date"</span><span style="color: #3a81c3;">]</span>;
<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">removed</span> = fruits.splice<span style="color: #3a81c3;">(</span>1, 2<span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">`|fruits| =&gt; ${fruits}`</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">`|removed| =&gt; ${removed}`</span><span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">|fruits| =&gt; apple,date</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">|removed| =&gt; banana,cherry</span>
</pre>
</div></li>
<li><p>
添加元素的例子:
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">fruits</span> = <span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"apple"</span>, <span style="color: #2d9574;">"date"</span><span style="color: #3a81c3;">]</span>;
fruits.splice<span style="color: #3a81c3;">(</span>1, 0, <span style="color: #2d9574;">"banana"</span>, <span style="color: #2d9574;">"cherry"</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>fruits<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[ 'apple', 'banana', 'cherry', 'date' ]</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org5fb218f" class="outline-3">
<h3 id="org5fb218f"><span class="section-number-3">7.6.</span> Iterating Arrays</h3>
<div class="outline-text-3" id="text-7-6">
<ul class="org-ul">
<li><p>
最简答的loop整个数组的方法,就是for/of了
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">a</span> = <span style="color: #3a81c3;">[</span>1, 2, 3<span style="color: #3a81c3;">]</span>;
<span style="color: #3a81c3; font-weight: bold;">for</span> <span style="color: #3a81c3;">(</span><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">one</span> <span style="color: #3a81c3; font-weight: bold;">of</span> a<span style="color: #3a81c3;">)</span> <span style="color: #3a81c3;">{</span>
  console.log<span style="color: #6c3163;">(</span>one<span style="color: #6c3163;">)</span>;
<span style="color: #3a81c3;">}</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">1</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">2</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">3</span>
</pre>
</div></li>
<li><p>
我们如果想知道loop时候的index,可以借助entries()
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">a</span> = <span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"a"</span>, <span style="color: #2d9574;">"b"</span>, <span style="color: #2d9574;">"c"</span><span style="color: #3a81c3;">]</span>;
<span style="color: #3a81c3; font-weight: bold;">for</span> <span style="color: #3a81c3;">(</span><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #6c3163;">[</span><span style="color: #715ab1;">index</span>, <span style="color: #715ab1;">one</span><span style="color: #6c3163;">]</span> <span style="color: #3a81c3; font-weight: bold;">of</span> a.entries<span style="color: #6c3163;">()</span><span style="color: #3a81c3;">)</span> <span style="color: #3a81c3;">{</span>
  <span style="color: #3a81c3; font-weight: bold;">if</span> <span style="color: #6c3163;">(</span>index % 2 === 0<span style="color: #6c3163;">)</span> <span style="color: #6c3163;">{</span>
    console.log<span style="color: #2d9574;">(</span>index, one<span style="color: #2d9574;">)</span>;
  <span style="color: #6c3163;">}</span>
<span style="color: #3a81c3;">}</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">0 a</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">2 c</span>
</pre>
</div></li>
<li><p>
也可以使用简单的for loop
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">a</span> = <span style="color: #3a81c3;">[</span>1, 2, 3<span style="color: #3a81c3;">]</span>;
<span style="color: #3a81c3; font-weight: bold;">for</span> <span style="color: #3a81c3;">(</span><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">i</span> = 0; i &lt; a.length; i++<span style="color: #3a81c3;">)</span> <span style="color: #3a81c3;">{</span>
  console.log<span style="color: #6c3163;">(</span>a<span style="color: #2d9574;">[</span>i<span style="color: #2d9574;">]</span><span style="color: #6c3163;">)</span>;
<span style="color: #3a81c3;">}</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">1</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">2</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">3</span>
</pre>
</div></li>
<li>上述所有的例子都是基于数组是dense的情况,如果面对sparse array,你可能需要自己处理undefined的情况</li>
<li>我们后面会看到其他的循环方式,比如forEach等,它们可以自动感知sparse array,并跳过没有element的index</li>
</ul>
</div>
</div>
<div id="outline-container-orga650393" class="outline-3">
<h3 id="orga650393"><span class="section-number-3">7.7.</span> Multidimensional Arrays</h3>
<div class="outline-text-3" id="text-7-7">
<ul class="org-ul">
<li>JavaScript本身不支持多维数组,但是可以让数组的每个成员都又是数组来做到多维数组</li>
</ul>
</div>
</div>
<div id="outline-container-org369bb8b" class="outline-3">
<h3 id="org369bb8b"><span class="section-number-3">7.8.</span> Array Methods</h3>
<div class="outline-text-3" id="text-7-8">
</div>
<div id="outline-container-org9e8d445" class="outline-4">
<h4 id="org9e8d445"><span class="section-number-4">7.8.1.</span> Array Iterator Methods</h4>
<div class="outline-text-4" id="text-7-8-1">
<ul class="org-ul">
<li>本节介绍的遍历函数,不仅仅是遍历,而是遍历的同时,为所有的element调用一个函数.所以本节介绍的函数都有如下特点:
<ul class="org-ul">
<li>都会接受一个function作为自己的第一个参数,并且为每个成员都调用一次这个function</li>
<li>如果array是sparse的话,那么第一个参数的function不会去调用那些不存在的element</li>
<li>绝大部分情况下(不是全部),第一个参数的function都会有三个参数:
<ol class="org-ol">
<li>array element的value (多数情况下,只需要处理这一个参数)</li>
<li>array element的index</li>
<li>array自己</li>
</ol></li>
<li>绝大部分情况下(不是全部),第一个参数的function的返回值都不那么重要.当然有些是需要返回值的</li>
<li>绝大多数情况下,第一个参数的function都是以inline的方式创建,所以arrow function是最佳方式.</li>
<li><p>
都会接受一个optional的第二个参数,这个第二个参数一旦设定,我们就默认第一个参数function是这个第二个
参数的method.换句话说,就是function里面的this,就指代第二个参数.这个介绍如此拗口,我们不得不举个例
子来说明
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">multiplier</span> = <span style="color: #3a81c3;">{</span>
  factor: 2,
<span style="color: #3a81c3;">}</span>;

<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">numbers</span> = <span style="color: #3a81c3;">[</span>1, 2, 3<span style="color: #3a81c3;">]</span>;

<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">multipliedNumbers</span> = numbers.map<span style="color: #3a81c3;">(</span><span style="color: #3a81c3; font-weight: bold;">function</span> <span style="color: #6c3163;">(</span><span style="color: #715ab1;">number</span><span style="color: #6c3163;">)</span> <span style="color: #6c3163;">{</span>
  <span style="color: #3a81c3; font-weight: bold;">return</span> number * <span style="color: #4e3163;">this</span>.factor;
<span style="color: #6c3163;">}</span>, multiplier<span style="color: #3a81c3;">)</span>;

console.log<span style="color: #3a81c3;">(</span>multipliedNumbers<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[ 2, 4, 6 ]</span>
</pre>
</div></li>
<li>注意!除了第一个参数function内部更改了数组的成员,我们这些iterator method都是不会更改数组成员的</li>
</ul></li>
</ul>
</div>
<ol class="org-ol">
<li><a id="orgf3396f9"></a>FOREACH()<br />
<div class="outline-text-5" id="text-7-8-1-1">
<ul class="org-ul">
<li><p>
这是最经典的一个iterator method,它会按顺序调用让所有的element作为callbackFn的参数进行调用.函数声明如下
</p>
<div class="org-src-container">
<pre class="src src-js">forEach<span style="color: #3a81c3;">(</span>callbackFn<span style="color: #3a81c3;">)</span>
forEach<span style="color: #3a81c3;">(</span>callbackFn, thisArg<span style="color: #3a81c3;">)</span>
</pre>
</div></li>
<li>callbackFn的参数有三个:
<ul class="org-ul">
<li><p>
element: 当前处理的element,多数情况下,我们function只使用这个参数
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">data</span> = <span style="color: #3a81c3;">[</span>1, 2, 3, 4, 5<span style="color: #3a81c3;">]</span>;
<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">sum</span> = 0;
data.forEach<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">(</span>value<span style="color: #6c3163;">)</span> =&gt; <span style="color: #6c3163;">{</span>
  sum += value;
<span style="color: #6c3163;">}</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">`|sum| =&gt; ${sum}`</span><span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">|sum| =&gt; 15</span>
</pre>
</div></li>
<li>index: element的index.</li>
<li><p>
array: 调用forEach的array,个别情况下,也会用到第二个和第三个参数,如下
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">data</span> = <span style="color: #3a81c3;">[</span>1, 2, 3, 4, 5<span style="color: #3a81c3;">]</span>;
data.forEach<span style="color: #3a81c3;">(</span><span style="color: #3a81c3; font-weight: bold;">function</span> <span style="color: #6c3163;">(</span><span style="color: #715ab1;">v</span>, <span style="color: #715ab1;">i</span>, <span style="color: #715ab1;">a</span><span style="color: #6c3163;">)</span> <span style="color: #6c3163;">{</span>
  a<span style="color: #2d9574;">[</span>i<span style="color: #2d9574;">]</span> = v + 1;
<span style="color: #6c3163;">}</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>data<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[ 2, 3, 4, 5, 6 ]</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="orgf75be0c"></a>MAP()<br />
<div class="outline-text-5" id="text-7-8-1-2">
<ul class="org-ul">
<li><p>
map()会按顺序让所有的element作为callbackFn的参数进行调用,并且所有的callbackFn的返回值作为一个新的array返回.函数声明如下
</p>
<div class="org-src-container">
<pre class="src src-js">map<span style="color: #3a81c3;">(</span>callbackFn<span style="color: #3a81c3;">)</span>
map<span style="color: #3a81c3;">(</span>callbackFn, thisArg<span style="color: #3a81c3;">)</span>
</pre>
</div></li>
<li>callbackFn的参数有三个:
<ul class="org-ul">
<li><p>
element: 当前处理的element,多数情况下,我们function只使用这个参数
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">data</span> = <span style="color: #3a81c3;">[</span>1, 2, 3, 4, 5<span style="color: #3a81c3;">]</span>;
<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">ret</span> = data.map<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">(</span>value<span style="color: #6c3163;">)</span> =&gt; value * value<span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>ret<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[ 1, 4, 9, 16, 25 ]</span>
</pre>
</div></li>
<li>index: element的index.</li>
<li>array: 调用forEach的array,个别情况下,也会用到第二个和第三个参数</li>
</ul></li>
<li>map()和forEach()不同的地方,在于map()的callbackFn是有返回值的,这些返回值会组成一个新的数组返回.这个过程中:
<ul class="org-ul">
<li>原数组是不会被改变的</li>
<li>如果原数组是sparse的,那么function肯定会跳过这些没有element的index.但是返回值组成的新的数组也还是
sparse的.其length和missing element都是一样的</li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org7f7702b"></a>FILTER()<br />
<div class="outline-text-5" id="text-7-8-1-3">
<ul class="org-ul">
<li><p>
filter()会按顺序让所有的element作为callbackFn的参数进行调用,如果callbackFn的返回值为true,那么这个
element会加入到一个新创建的数组,作为整个method的返回值,声明如下
</p>
<div class="org-src-container">
<pre class="src src-js">filter<span style="color: #3a81c3;">(</span>callbackFn<span style="color: #3a81c3;">)</span>
filter<span style="color: #3a81c3;">(</span>callbackFn, thisArg<span style="color: #3a81c3;">)</span>
</pre>
</div></li>
<li>callbackFn的参数有三个:
<ul class="org-ul">
<li><p>
element: 当前处理的element,多数情况下,我们function只使用这个参数
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">data</span> = <span style="color: #3a81c3;">[</span>11, 22, 33, 44, 55<span style="color: #3a81c3;">]</span>;
<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">ret</span> = data.filter<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">(</span>value<span style="color: #6c3163;">)</span> =&gt; value % 2 === 1<span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>ret<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[ 11, 33, 55 ]</span>
</pre>
</div></li>
<li>index: element的index.</li>
<li>array: 调用forEach的array,个别情况下,也会用到第二个和第三个参数</li>
</ul></li>
<li><p>
注意,filter也会跳过sparse 数组的没有值的element的index.所以filter的返回值数组永远是dense的.我们可
以用如下代码来把一个sparse数组变成dense的
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">a</span> = <span style="color: #3a81c3;">[</span>1, , 3<span style="color: #3a81c3;">]</span>;
console.log<span style="color: #3a81c3;">(</span>a<span style="color: #3a81c3;">)</span>;
<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">ret</span> = a.filter<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">()</span> =&gt; <span style="color: #4e3163;">true</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>ret<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[ 1, &lt;1 empty item&gt;, 3 ]</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[ 1, 3 ]</span>
</pre>
</div></li>
</ul>
</div>
</li>
<li><a id="orgd227bbb"></a>FIND() AND FINDINDEX()<br />
<div class="outline-text-5" id="text-7-8-1-4">
<ul class="org-ul">
<li><p>
find()和filter()类似,也是要求callbackFn返回true或者false. 但是find()遇到第一个true的就退出了,后面
不再测试了.换句话说find()只返回一个值(有可能是undefind,而不是返回一个数组)
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">data</span> = <span style="color: #3a81c3;">[</span>11, 22, 33, 44, 55<span style="color: #3a81c3;">]</span>;
<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">ret</span> = data.find<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">(</span>value<span style="color: #6c3163;">)</span> =&gt; value % 2 === 1<span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>ret<span style="color: #3a81c3;">)</span>;

<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">ret2</span> = data.find<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">(</span>value<span style="color: #6c3163;">)</span> =&gt; value === 111<span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>ret2<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">11</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">undefined</span>
</pre>
</div></li>
<li><p>
findIndex()和find()基本一样,只不过findindex()返回index,而不是element
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">data</span> = <span style="color: #3a81c3;">[</span>11, 22, 33, 44, 55<span style="color: #3a81c3;">]</span>;
<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">ret</span> = data.findIndex<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">(</span>value<span style="color: #6c3163;">)</span> =&gt; value % 2 === 1<span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>ret<span style="color: #3a81c3;">)</span>;

<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">ret2</span> = data.findIndex<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">(</span>value<span style="color: #6c3163;">)</span> =&gt; value === 111<span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>ret2<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">0</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">-1</span>
</pre>
</div></li>
</ul>
</div>
</li>
<li><a id="org960fad3"></a>EVERY() AND SOME()<br />
<div class="outline-text-5" id="text-7-8-1-5">
<ul class="org-ul">
<li><p>
every()和find()类似,只不过所有element都满足function的判断条件才返回true,否则返回false
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">data</span> = <span style="color: #3a81c3;">[</span>1, 2, 3, 4, 5<span style="color: #3a81c3;">]</span>;
<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">ret</span> = data.every<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">(</span>x<span style="color: #6c3163;">)</span> =&gt; x &lt; 10<span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">`|ret| =&gt; ${ret}`</span><span style="color: #3a81c3;">)</span>;

<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">ret2</span> = data.every<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">(</span>x<span style="color: #6c3163;">)</span> =&gt; x % 2 === 0<span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">`|ret2| =&gt; ${ret2}`</span><span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">|ret| =&gt; true</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">|ret2| =&gt; false</span>
</pre>
</div></li>
<li><p>
some()和every()类似,只不过不是所有element都满足返回true,而是只要有一个element满足function的判断条
件就返回true,所有element都不满足function判断条件才返回false
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">data</span> = <span style="color: #3a81c3;">[</span>1, 2, 3, 4, 5<span style="color: #3a81c3;">]</span>;
<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">ret</span> = data.some<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">(</span>x<span style="color: #6c3163;">)</span> =&gt; x &lt; 1<span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">`|ret| =&gt; ${ret}`</span><span style="color: #3a81c3;">)</span>;

<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">ret2</span> = data.some<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">(</span>x<span style="color: #6c3163;">)</span> =&gt; x % 2 === 0<span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">`|ret2| =&gt; ${ret2}`</span><span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">|ret| =&gt; false</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">|ret2| =&gt; true</span>
</pre>
</div></li>
<li>注意,对于空数组来说:
<ul class="org-ul">
<li>every()返回true</li>
<li>some()返回false</li>
</ul></li>
</ul>
</div>
</li>
<li><a id="orgdaecbfb"></a>REDUCE() AND REDUCERIGHT()<br />
<div class="outline-text-5" id="text-7-8-1-6">
<ul class="org-ul">
<li><p>
reduce()会合并所有的element,合并的方法由callbackFn提供.注意第二个参数不再是thisArg,而是initialValue,
也就是reduce的初始值(如果不设置默认是第一个element为初始值). 如果实在想获得类似之前thisArg的功能,
可能需要借助Function.bind()
</p>
<div class="org-src-container">
<pre class="src src-js">reduce<span style="color: #3a81c3;">(</span>callbackFn<span style="color: #3a81c3;">)</span>
reduce<span style="color: #3a81c3;">(</span>callbackFn, initialValue<span style="color: #3a81c3;">)</span>
</pre>
</div></li>
<li>callbackFn的参数和之前不一样,变成了四个(主要是多了一个累计值):
<ul class="org-ul">
<li>accumulator: 历史累计的值.所谓历史累计值,就是每次callbackFn的返回值都列在这里,作为下一次循环的起
始值.历史累计值第一次的值为上面的initialValue</li>
<li><p>
currentValue: 当前的element.多数情况下,只使用前两个参数,如下
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">a</span> = <span style="color: #3a81c3;">[</span>1, 2, 3, 4, 5<span style="color: #3a81c3;">]</span>;
<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">ret1</span> = a.reduce<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">(</span>x, y<span style="color: #6c3163;">)</span> =&gt; x + y, 0<span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">`|ret1| =&gt; ${ret1}`</span><span style="color: #3a81c3;">)</span>;
<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">ret2</span> = a.reduce<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">(</span>x, y<span style="color: #6c3163;">)</span> =&gt; x * y, 1<span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">`|ret2| =&gt; ${ret2}`</span><span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">|ret1| =&gt; 15</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">|ret2| =&gt; 120</span>
</pre>
</div></li>
<li>currentIndex: 当前element的index</li>
<li>array: 整个数组</li>
</ul></li>
<li><p>
我们的reduce函数,如果被一个空数组调用,那么就会产生TypeError
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">a</span> = <span style="color: #3a81c3;">[]</span>;
<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">ret</span> = a.reduce<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">(</span>x, y<span style="color: #6c3163;">)</span> =&gt; x + y<span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">`|ret| =&gt; ${ret}`</span><span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">TypeError: Reduce of empty array with no initial value</span>
</pre>
</div></li>
<li><p>
如果调用数只有一个成员,那么无论reduce的callbackFn是什么,总会直接返回这个值
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">a</span> = <span style="color: #3a81c3;">[</span>12<span style="color: #3a81c3;">]</span>;
<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">ret</span> = a.reduce<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">(</span>x, y<span style="color: #6c3163;">)</span> =&gt; x+y, 0<span style="color: #3a81c3;">)</span>
console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">`|ret| =&gt; ${ret}`</span><span style="color: #3a81c3;">)</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">|ret| =&gt; 12</span>
</pre>
</div></li>
<li><p>
reduceRight()和reduce()的参数和使用方法完全一样,只不过,其为从highest index到lowest index计算
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">a</span> = <span style="color: #3a81c3;">[</span>1, 2, 3, 4, 5<span style="color: #3a81c3;">]</span>;
<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">ret</span> = a.reduceRight<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">(</span>acc, val<span style="color: #6c3163;">)</span> =&gt; acc - val<span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>ret<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">-5</span>
</pre>
</div></li>
</ul>
</div>
</li>
</ol>
</div>
<div id="outline-container-orged2615a" class="outline-4">
<h4 id="orged2615a"><span class="section-number-4">7.8.2.</span> Flattening arrays with flat() and flatMap()</h4>
<div class="outline-text-4" id="text-7-8-2">
<ul class="org-ul">
<li><p>
ES2019引入了一个flat()函数,其能够把"数组内部的数组"进行"打平",如下
</p>
<div class="org-src-container">
<pre class="src src-js">console.log<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>1, <span style="color: #2d9574;">[</span>2, 3<span style="color: #2d9574;">]</span><span style="color: #6c3163;">]</span>.flat<span style="color: #6c3163;">()</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>1, <span style="color: #2d9574;">[</span>2, <span style="color: #67b11d;">[</span>3<span style="color: #67b11d;">]</span><span style="color: #2d9574;">]</span><span style="color: #6c3163;">]</span>.flat<span style="color: #6c3163;">()</span><span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[ 1, 2, 3 ]</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[ 1, 2, [ 3 ] ]</span>
</pre>
</div></li>
<li><p>
我们可以看到,flat()默认"打平"一层的嵌套数组,如果要"打平"多层嵌套数组,需要给flat()传入integer类型的参数
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">a</span> = <span style="color: #3a81c3;">[</span>1, <span style="color: #6c3163;">[</span>2, <span style="color: #2d9574;">[</span>3, <span style="color: #67b11d;">[</span>4<span style="color: #67b11d;">]</span><span style="color: #2d9574;">]</span><span style="color: #6c3163;">]</span><span style="color: #3a81c3;">]</span>;
console.log<span style="color: #3a81c3;">(</span>a.flat<span style="color: #6c3163;">(</span>1<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>a.flat<span style="color: #6c3163;">(</span>2<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>a.flat<span style="color: #6c3163;">(</span>3<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>a.flat<span style="color: #6c3163;">(</span>4<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[ 1, 2, [ 3, [ 4 ] ] ]</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[ 1, 2, 3, [ 4 ] ]</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[ 1, 2, 3, 4 ]</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[ 1, 2, 3, 4 ]</span>
</pre>
</div></li>
<li><p>
flatMap()和map()的作用一样,只不过,返回的时候,会把结果"打平".a.flatMap(f)相当于a.map(f).flat()
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">phrases</span> = <span style="color: #3a81c3;">[</span><span style="color: #2d9574;">"hello world"</span>, <span style="color: #2d9574;">"the definitive guide"</span><span style="color: #3a81c3;">]</span>;
<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">words</span> = phrases.flatMap<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">(</span>phrase<span style="color: #6c3163;">)</span> =&gt; phrase.split<span style="color: #6c3163;">(</span><span style="color: #2d9574;">" "</span><span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>words<span style="color: #3a81c3;">)</span>;

<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">ret</span> = phrases.map<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">(</span>phrase<span style="color: #6c3163;">)</span> =&gt; phrase.split<span style="color: #6c3163;">(</span><span style="color: #2d9574;">" "</span><span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>ret<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[ 'hello', 'world', 'the', 'definitive', 'guide' ]</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[ [ 'hello', 'world' ], [ 'the', 'definitive', 'guide' ] ]</span>
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-orgaf850a9" class="outline-4">
<h4 id="orgaf850a9"><span class="section-number-4">7.8.3.</span> Adding arrays with concat()</h4>
<div class="outline-text-4" id="text-7-8-3">
<ul class="org-ul">
<li>concat是在调用数组的后面增加其他元素,注意concat不会更改调用的数组,而是返回一个新的数组.在整个过程
中还会进行一次"打平"</li>
<li>concat优点是不会更改调用者,缺点是整个过程还是优点expsnsive的,所以如果你写出了a = a.concat(x)这种代
码,你应该反思一下是不是改用push()</li>
</ul>
</div>
</div>
<div id="outline-container-org08cc13e" class="outline-4">
<h4 id="org08cc13e"><span class="section-number-4">7.8.4.</span> Stacks and Queues with push(), pop(), shift() and unshift()</h4>
<div class="outline-text-4" id="text-7-8-4">
<ul class="org-ul">
<li><p>
注意,push()是不能"打平"传入的数组的,如果你实在需要push的同时进行"打平",那么你可以使用如下代码
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">a</span> = <span style="color: #3a81c3;">[</span>1, 2, 3<span style="color: #3a81c3;">]</span>;
<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">b</span> = <span style="color: #3a81c3;">[</span>4, 5, 6<span style="color: #3a81c3;">]</span>;
<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">c</span> = <span style="color: #3a81c3;">[</span>7, 8, 9<span style="color: #3a81c3;">]</span>;

a.push<span style="color: #3a81c3;">(</span>c<span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>a<span style="color: #3a81c3;">)</span>;
b.push<span style="color: #3a81c3;">(</span>...c<span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>b<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[ 1, 2, 3, [ 7, 8, 9 ] ]</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[ 4, 5, 6, 7, 8, 9 ]</span>
</pre>
</div></li>
<li><p>
pop()是把最后一个element删除,并返回这个element
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">a</span> = <span style="color: #3a81c3;">[</span>1, 2, 3<span style="color: #3a81c3;">]</span>;
<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">ret</span> = a.pop<span style="color: #3a81c3;">()</span>;
console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">`|a| =&gt; ${a}`</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">`|ret| =&gt; ${ret}`</span><span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">|a| =&gt; 1,2</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">|ret| =&gt; 3</span>
</pre>
</div></li>
<li>push()和pop()两个函数结合起来,让JavaScript array能够作为stack来使用</li>
<li><p>
unshift()和push()相反,是把element加到数组最开始的位置,并且返回新的length
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">a</span> = <span style="color: #3a81c3;">[</span>1, 2, 3, 4, 5<span style="color: #3a81c3;">]</span>;
<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">ret</span> = a.unshift<span style="color: #3a81c3;">(</span>0<span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">`|a| =&gt; ${a}`</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">`|ret| =&gt; ${ret}`</span><span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">|a| =&gt; 0,1,2,3,4,5</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">|ret| =&gt; 6</span>
</pre>
</div></li>
<li><p>
shift()和pop()相反,是把第一位的element删除,并且返回这个element
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">a</span> = <span style="color: #3a81c3;">[</span>11, 2, 3, 4, 5<span style="color: #3a81c3;">]</span>;
<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">ret</span> = a.shift<span style="color: #3a81c3;">()</span>;
console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">`|a| =&gt; ${a}`</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">`|ret| =&gt; ${ret}`</span><span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">|a| =&gt; 2,3,4,5</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">|ret| =&gt; 11</span>
</pre>
</div></li>
<li>push()和shift()两个函数结合起来,让JavaScript array能够作为queue来使用</li>
<li><p>
这些函数里面unshift()比较特别,需要注意:一次加N个和分N次加,顺序不一样(因为每次调用都是放在最前面)
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">a</span> = <span style="color: #3a81c3;">[]</span>;
a.unshift<span style="color: #3a81c3;">(</span>1<span style="color: #3a81c3;">)</span>;
a.unshift<span style="color: #3a81c3;">(</span>2<span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>a<span style="color: #3a81c3;">)</span>;
b = <span style="color: #3a81c3;">[]</span>;
b.unshift<span style="color: #3a81c3;">(</span>1, 2<span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>b<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[ 2, 1 ]</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[ 1, 2 ]</span>
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-orgb5c1f94" class="outline-4">
<h4 id="orgb5c1f94"><span class="section-number-4">7.8.5.</span> Subarrays with slice(), splice(), fill() and copyWithin()</h4>
<div class="outline-text-4" id="text-7-8-5">
</div>
<ol class="org-ol">
<li><a id="org599ce34"></a>SLICE()<br />
<div class="outline-text-5" id="text-7-8-5-1">
<ul class="org-ul">
<li>slice() 会返回一array指定的subarray,或者叫做slice.</li>
<li><p>
slice() 接受两个参数,第一个参数是start的index,第二个参数(可选)是end的index,注意,返回的array不包括
end index
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">a</span> = <span style="color: #3a81c3;">[</span>1, 2, 3, 4, 5<span style="color: #3a81c3;">]</span>;
console.log<span style="color: #3a81c3;">(</span>a.slice<span style="color: #6c3163;">(</span>0, 3<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>a.slice<span style="color: #6c3163;">(</span>3<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>a.slice<span style="color: #6c3163;">(</span>1, -1<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>a.slice<span style="color: #6c3163;">(</span>-3, -2<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[ 1, 2, 3 ]</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[ 4, 5 ]</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[ 2, 3, 4 ]</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[ 3 ]</span>
</pre>
</div></li>
</ul>
</div>
</li>
<li><a id="orgbf23580"></a>SPLICE()<br />
<div class="outline-text-5" id="text-7-8-5-2">
<ul class="org-ul">
<li><p>
splice()有种瑞士军刀的感觉,既能增加,又能删除数据,声明如下
</p>
<div class="org-src-container">
<pre class="src src-js">array.splice<span style="color: #3a81c3;">(</span>start, deleteCount, item1, item2, ..., itemN<span style="color: #3a81c3;">)</span>
</pre>
</div></li>
<li>我们来挨个看参数:
<ol class="org-ol">
<li>start(必填):
<ul class="org-ul">
<li>表示开始修改数组索引的位置</li>
<li>可以为负数,表示从数组末尾开始,类似python的数组index计数</li>
</ul></li>
<li>deleteCount(可选):
<ul class="org-ul">
<li><p>
表要删除的个数
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">a</span> = <span style="color: #3a81c3;">[</span>1, 2, 3, 4, 5<span style="color: #3a81c3;">]</span>;
a.splice<span style="color: #3a81c3;">(</span>1, 3<span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>a<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[ 1, 5 ]</span>
</pre>
</div></li>
<li>如果为0或者负数,则不会删除任何数据</li>
<li><p>
如果省略,或者大于array.length - start,则会删除从start开始到数组末尾的所有元素
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">a</span> = <span style="color: #3a81c3;">[</span>1, 2, 3, 4, 5<span style="color: #3a81c3;">]</span>;
a.splice<span style="color: #3a81c3;">(</span>2<span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>a<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[ 1, 2 ]</span>
</pre>
</div></li>
</ul></li>
<li>item1, item2, &#x2026;., itemN(可选)
<ul class="org-ul">
<li><p>
表示要添加的数据.添加的位置,就是start设置的index
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">a</span> = <span style="color: #3a81c3;">[</span>1, 2, 3, 4, 5<span style="color: #3a81c3;">]</span>;
a.splice<span style="color: #3a81c3;">(</span>1, 3, <span style="color: #2d9574;">"a"</span>, <span style="color: #2d9574;">"b"</span>, <span style="color: #2d9574;">"c"</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>a<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[ 1, 'a', 'b', 'c', 5 ]</span>
</pre>
</div></li>
<li>如果没提供,则只删除元素</li>
</ul></li>
</ol></li>
</ul>
</div>
</li>
<li><a id="org0b5e3e6"></a>FILL()<br />
<div class="outline-text-5" id="text-7-8-5-3">
<ul class="org-ul">
<li><p>
fill()是将数组中部分或者全部的成员填充成指定的静态值,声明如下
</p>
<div class="org-src-container">
<pre class="src src-js">array.fill<span style="color: #3a81c3;">(</span>value, start, end<span style="color: #3a81c3;">)</span>
</pre>
</div></li>
<li>我们挨个来看看参数:
<ol class="org-ol">
<li>value(必填):
<ul class="org-ul">
<li><p>
表示要填充的值
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">a</span> = <span style="color: #3a81c3;">[</span>1, 2, 3, 4, 5<span style="color: #3a81c3;">]</span>;
a.fill<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"b"</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>a<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[ 'b', 'b', 'b', 'b', 'b' ]</span>
</pre>
</div></li>
<li>可以是任意类型</li>
</ul></li>
<li>start(可选):
<ul class="org-ul">
<li><p>
表示填充起始的索引(包含该索引)
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">a</span> = <span style="color: #3a81c3;">[</span>1, 2, 3, 4, 5<span style="color: #3a81c3;">]</span>;
a.fill<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"b"</span>, 3<span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>a<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[ 1, 2, 3, 'b', 'b' ]</span>
</pre>
</div></li>
<li>默认值为0</li>
</ul></li>
<li>end(可选)
<ul class="org-ul">
<li><p>
表示填充结束的位置(不包含该索引)
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">a</span> = <span style="color: #3a81c3;">[</span>1, 2, 3, 4, 5, 6<span style="color: #3a81c3;">]</span>;
a.fill<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"b"</span>, 1, 5<span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>a<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[ 1, 'b', 'b', 'b', 'b', 6 ]</span>

</pre>
</div></li>
<li>默认是array.length</li>
</ul></li>
</ol></li>
</ul>
</div>
</li>
<li><a id="org6bc82fb"></a>COPYWITHIN()<br />
<div class="outline-text-5" id="text-7-8-5-4">
<ul class="org-ul">
<li><p>
copyWith()是将数组的一部分复制到数组的另一个为止,并覆盖目标为止的元素.它不会改变数组长度,声明如下
</p>
<div class="org-src-container">
<pre class="src src-js">array.copyWithin<span style="color: #3a81c3;">(</span>target, start, end<span style="color: #3a81c3;">)</span>
</pre>
</div></li>
<li>参数说明如下:
<ol class="org-ol">
<li>target(必需):
<ul class="org-ul">
<li>表示复制到的目标开始index</li>
<li><p>
因为是唯一必填的,所以只填这个index的情况下,是把整个数组(后面两个默认分别是0,和array.length)覆
盖到这个target index
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">a</span> = <span style="color: #3a81c3;">[</span>1, 2, 3, 4, 5<span style="color: #3a81c3;">]</span>;
a.copyWithin<span style="color: #3a81c3;">(</span>2<span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>a<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[ 1, 2, 1, 2, 3 ]</span>
</pre>
</div></li>
</ul></li>
<li>start(可选):
<ul class="org-ul">
<li>表示复制的起始索引(包含该索引)</li>
<li>默认值为0</li>
</ul></li>
<li>end(可选):
<ul class="org-ul">
<li><p>
表示复制的结束索引(不包含该索引)
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">a</span> = <span style="color: #3a81c3;">[</span>1, 2, 3, 4, 5, 6<span style="color: #3a81c3;">]</span>;
a.copyWithin<span style="color: #3a81c3;">(</span>2, 1, 3<span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>a<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[ 1, 2, 2, 3, 5, 6 ]</span>
</pre>
</div></li>
<li>默认值为array.length</li>
</ul></li>
</ol></li>
<li>返回值为修改后的数组</li>
</ul>
</div>
</li>
</ol>
</div>
<div id="outline-container-org9700967" class="outline-4">
<h4 id="org9700967"><span class="section-number-4">7.8.6.</span> Array Searching and Sorting Methods</h4>
<div class="outline-text-4" id="text-7-8-6">
</div>
<ol class="org-ol">
<li><a id="org96414b3"></a>INDEXOF() AND LASTINDEXOF()<br />
<div class="outline-text-5" id="text-7-8-6-1">
<ul class="org-ul">
<li>indexOf()和lastIndexOf()都是搜索数组,看看某个element是否存在:
<ul class="org-ul">
<li>如果存在,返回第一次遇见的index</li>
<li>如果不存在,返回-1</li>
<li>indexOf()从开始到结束的顺序查找, lastIndexOf()从结束到开始的顺序查找</li>
</ul></li>
<li><p>
indexOf()和lastIndexOf()都是使用===operatror比较,所以object是比较ref,而不是内容
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">a</span> = <span style="color: #3a81c3;">[</span>1, 2, 3, 4, 5, 1, 6<span style="color: #3a81c3;">]</span>;
console.log<span style="color: #3a81c3;">(</span>a.indexOf<span style="color: #6c3163;">(</span>1<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>a.lastIndexOf<span style="color: #6c3163;">(</span>1<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">0</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">5</span>
</pre>
</div></li>
<li><p>
indexOf()和lastIndexOf()还会接受第二个参数来确定开始搜索的位置
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">a</span> = <span style="color: #3a81c3;">[</span>1, 2, 3, 4, 5, 1, 6<span style="color: #3a81c3;">]</span>;
console.log<span style="color: #3a81c3;">(</span>a.indexOf<span style="color: #6c3163;">(</span>1, 2<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>a.lastIndexOf<span style="color: #6c3163;">(</span>1, 2<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">5</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">0</span>
</pre>
</div></li>
</ul>
</div>
</li>
<li><a id="org36453d6"></a>INCLUDES()<br />
<div class="outline-text-5" id="text-7-8-6-2">
<ul class="org-ul">
<li>ES2016引入了includes()来判断某个数组中是否有某个element,返回值为true/false</li>
<li>注意这个includes的查找复杂度是比不上set.has(value)的</li>
<li><p>
incldues()和indexOf()的唯一不同,在于它没有使用===opertor,所以include()认为NaN是和自己equal的,两者
区别见下例
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">a</span> = <span style="color: #3a81c3;">[</span>1, <span style="color: #4e3163;">true</span>, 3, <span style="color: #4e3163;">NaN</span><span style="color: #3a81c3;">]</span>;
console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">`|a.includes(true)| =&gt; ${a.includes(true)}`</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">`|a.includes(2)| =&gt; ${a.includes(2)}`</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">`|a.includes(NaN)| =&gt; ${a.includes(NaN)}`</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">`|a.indexOf(NaN)| =&gt; ${a.indexOf(NaN)}`</span><span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">|a.includes(true)| =&gt; true</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">|a.includes(2)| =&gt; false</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">|a.includes(NaN)| =&gt; true</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">|a.indexOf(NaN)| =&gt; -1</span>
</pre>
</div></li>
</ul>
</div>
</li>
<li><a id="orgbe95838"></a>SORT()<br />
<div class="outline-text-5" id="text-7-8-6-3">
<ul class="org-ul">
<li><p>
sort()是数组中重要的函数,用来把数组的成员排序,这个排序是在原地排序所以会更改原有数组,其函数声明如下
</p>
<div class="org-src-container">
<pre class="src src-js">array.sort<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>compareFunction<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
</pre>
</div></li>
<li>这个函数的返回值也是这个被更改的数组</li>
<li>只有一个可选的参数compareFunction.对于这个参数:
<ul class="org-ul">
<li><p>
如果省略,数组元素会被转换为字符串,然后按照字典顺序排序.注意,number类型这个时候可能会出现意想不到
的结果(因为是先转换为字符串然后排序)
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">numbers</span> = <span style="color: #3a81c3;">[</span>10, 5, 20, 1<span style="color: #3a81c3;">]</span>;
numbers.sort<span style="color: #3a81c3;">()</span>;
console.log<span style="color: #3a81c3;">(</span>numbers<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[ 1, 10, 20, 5 ]</span>
</pre>
</div></li>
<li>如果提供,那么这个函数决定了排序顺序,这个函数接受两个参数(a和b),并且返回如下值:
<ol class="org-ol">
<li><p>
如果a应该排在b前面,那么返回负数.上面number类型排序就可以如下纠正
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">numbers</span> = <span style="color: #3a81c3;">[</span>10, 5, 20, 1<span style="color: #3a81c3;">]</span>;
numbers.sort<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">(</span>a, b<span style="color: #6c3163;">)</span> =&gt; a - b<span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>numbers<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[ 1, 5, 10, 20 ]</span>
</pre>
</div></li>
<li>如果a和b相等,则返回0</li>
<li>如果a应该排在b后面,那么返回正数</li>
</ol></li>
</ul></li>
</ul>
</div>
</li>
<li><a id="org518772d"></a>REVERSE()<br />
<div class="outline-text-5" id="text-7-8-6-4">
<ul class="org-ul">
<li><p>
reverse()把数组的所有成员进行翻转,这个翻转是in place的,所以会更改原有数组.
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">a</span> = <span style="color: #3a81c3;">[</span>1, 2, 3<span style="color: #3a81c3;">]</span>;
a.reverse<span style="color: #3a81c3;">()</span>;
console.log<span style="color: #3a81c3;">(</span>a<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">[ 3, 2, 1 ]</span>
</pre>
</div></li>
</ul>
</div>
</li>
</ol>
</div>
<div id="outline-container-orgb337aa7" class="outline-4">
<h4 id="orgb337aa7"><span class="section-number-4">7.8.7.</span> Array to String Conversions</h4>
<div class="outline-text-4" id="text-7-8-7">
<ul class="org-ul">
<li><p>
string转换为字符串的一个重要的函数是join(). 注意这里转换为字符串是为了debug和打印需求,如果你想让你
的数组先存成字符串,以后还要转换回数组,那么你需要的是序列化,你需要的函数是JSON.stringify()
</p>
<pre class="example" id="orgf5f6b38">
If you want to save the contents of an array in textual form ofr later resue,
serialize the array with JSON.strinify() instead of using the methods
described here
</pre></li>
<li><p>
join()会把数组转换成易于打印的一个字符串,默认用","进行分割.函数声明如下
</p>
<div class="org-src-container">
<pre class="src src-js">array.join<span style="color: #3a81c3;">(</span><span style="color: #6c3163;">[</span>separator<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>
</pre>
</div></li>
<li>下面来介绍下唯一的参数seperator:
<ul class="org-ul">
<li><p>
这个参数可选,如果不传,默认使用","作为分割符
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">a</span> = <span style="color: #3a81c3;">[</span>1, 2, 3<span style="color: #3a81c3;">]</span>;
console.log<span style="color: #3a81c3;">(</span>a.join<span style="color: #6c3163;">()</span><span style="color: #3a81c3;">)</span>

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">1,2,3</span>
</pre>
</div></li>
<li><p>
如果传入空字符串,则元素之间没有分割
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">a</span> = <span style="color: #3a81c3;">[</span>1, 2, 3<span style="color: #3a81c3;">]</span>;
console.log<span style="color: #3a81c3;">(</span>a.join<span style="color: #6c3163;">(</span><span style="color: #2d9574;">""</span><span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">123</span>
</pre>
</div></li>
</ul></li>
<li>返回值为一个字符串,如果数组为空,则返回空字符串</li>
<li>join()的作用是把数组转换为相同separator分割的字符串.而把相同separator分割的字符串转换为数组的函数
是string.split()</li>
<li><p>
和其他对象一样,数组也有toString(),数组的toString()相当于不带参数的join()
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">a</span> = <span style="color: #3a81c3;">[</span>1, 2, 3<span style="color: #3a81c3;">]</span>;

console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">`|a.toString()| =&gt; ${a.toString()}`</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">`|a.join()| =&gt; ${a.join()}`</span><span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">|a.toString()| =&gt; 1,2,3</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">|a.join()| =&gt; 1,2,3</span>
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-org8bdd39b" class="outline-4">
<h4 id="org8bdd39b"><span class="section-number-4">7.8.8.</span> Static Array Function</h4>
<div class="outline-text-4" id="text-7-8-8">
<ul class="org-ul">
<li>除了定义在instance级别的函数,Javascript还在class级别定义了如下两个参数:
<ul class="org-ul">
<li>从任意参数创建数组的Array.of</li>
<li>从array-like对象创建数组的Array.from</li>
</ul></li>
<li><p>
还有一个常用的array的static function是Array.isArray,用来判断一个对象是不是array
</p>
<div class="org-src-container">
<pre class="src src-js">console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">`|Array.isArray([])| =&gt; ${Array.isArray([])}`</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">`|Array.isArray({})| =&gt; ${Array.isArray({})}`</span><span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">|Array.isArray([])| =&gt; true</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">|Array.isArray({})| =&gt; false</span>
</pre>
</div></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgf5b8fb7" class="outline-3">
<h3 id="orgf5b8fb7"><span class="section-number-3">7.9.</span> Array-Like Objects</h3>
<div class="outline-text-3" id="text-7-9">
<ul class="org-ul">
<li>javascript array有一些特殊的feature,是其他object所不具备的,包括:
<ul class="org-ul">
<li>当element加入的时候,length property会自动增减</li>
<li>给length设置一个小于当前值的新值会触发truncate当前的数组</li>
<li>array从Array.prototype继承了很多有用的函数</li>
<li>Array.isArray()总是会返回true</li>
</ul></li>
<li>在实践当中,会有一些"array-like"的object,他们只有如下特性:
<ul class="org-ul">
<li>一个length的property,但是不会自动更新</li>
<li>以non-negative integer为property的成员</li>
</ul></li>
<li>这种"array-like" object,如果被看做是read-only的话(这也就意味着不需要length自动更新),那么其实和array
在使用的时候是没有多大区别的.</li>
<li>JavaScript常见的array-like 对象有:
<ol class="org-ol">
<li>字符串.但是我们最好还是把字符串看成string,因为这对它们更有利</li>
<li>很多和HTML document相关的method都是返回array-like object(主要在client-side JavaScript代码中)
<ul class="org-ul">
<li><p>
下面就是这样一个例子.
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">elements</span> = document.querySelectorAll<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"div"</span><span style="color: #3a81c3;">)</span>; <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&#33719;&#21462;&#25152;&#26377; &lt;div&gt; &#20803;&#32032;</span>
console.log<span style="color: #3a81c3;">(</span>elements<span style="color: #3a81c3;">)</span>; <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&#36755;&#20986;: NodeList [div, div, div, ...]</span>
</pre>
</div></li>
<li>上例中的NodeList就是array-like object: 我们可以通过elements.length获取元素数量,也能elements[0],elements[1]这样访问</li>
<li>由于array-like毕竟没有继承Array.prototype,所以其他特性,比如map(), filter()等函数是不能用的.</li>
<li><p>
但是,由于JavaScript是一种duck-type语言,既然array-like object具备了被map()等调用的条件,我们完全
可以通过Function.call来完成array-like调用map,如下
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">a</span> = <span style="color: #3a81c3;">{</span> 0: <span style="color: #2d9574;">"a"</span>, 1: <span style="color: #2d9574;">"b"</span>, 2: <span style="color: #2d9574;">"c"</span>, length: 3 <span style="color: #3a81c3;">}</span>; <span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">array-like object</span>
console.log<span style="color: #3a81c3;">(</span>a<span style="color: #3a81c3;">)</span>;
<span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">ret</span> = Array.<span style="color: #4e3163;">prototype</span>.map.call<span style="color: #3a81c3;">(</span>a, <span style="color: #6c3163;">(</span>x<span style="color: #6c3163;">)</span> =&gt; x.toUpperCase<span style="color: #6c3163;">()</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">`|ret| =&gt; ${ret}`</span><span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">{ '0': 'a', '1': 'b', '2': 'c', length: 3 }</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">|ret| =&gt; A,B,C</span>
</pre>
</div></li>
</ul></li>
</ol></li>
</ul>
</div>
</div>
<div id="outline-container-orgfb85a24" class="outline-3">
<h3 id="orgfb85a24"><span class="section-number-3">7.10.</span> Strings as Arrays</h3>
<div class="outline-text-3" id="text-7-10">
<ul class="org-ul">
<li><p>
前面说过字符串其实就是array-like object.所以我们也能用"[]"来访问某个element,平替charAt()
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">s</span> = <span style="color: #2d9574;">"ABC"</span>;
console.log<span style="color: #3a81c3;">(</span>s.charAt<span style="color: #6c3163;">(</span>0<span style="color: #6c3163;">)</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>s<span style="color: #6c3163;">[</span>1<span style="color: #6c3163;">]</span><span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">A</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">B</span>
</pre>
</div></li>
<li><p>
由于JavaScript duck-type的特性,我们显然可以利用Function.call的方法,让某些Array.prototype的函数作用
在string上面
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">ret</span> = Array.<span style="color: #4e3163;">prototype</span>.join.call<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"ABC"</span>, <span style="color: #2d9574;">"_"</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>ret<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">A_B_C</span>
</pre>
</div></li>
<li><p>
注意!只能使用那些不改变数组内容的函数,因为字符串本身是immutable的,类似push(), sort()这种函数是不能
使用的,在Node里面这种情况会直接报TypeError错误
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #3a81c3; font-weight: bold;">let</span> <span style="color: #715ab1;">ret</span> = Array.<span style="color: #4e3163;">prototype</span>.reverse.call<span style="color: #3a81c3;">(</span><span style="color: #2d9574;">"ABC"</span>, <span style="color: #2d9574;">"_"</span><span style="color: #3a81c3;">)</span>;
console.log<span style="color: #3a81c3;">(</span>ret<span style="color: #3a81c3;">)</span>;

<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">&lt;====================OUTPUT====================&gt;</span>
<span style="color: #2aa1ae; background-color: #ecf3ec;">// </span><span style="color: #2aa1ae; background-color: #ecf3ec;">TypeError: Cannot assign to read only property '0' of object '[object String]'</span>
</pre>
</div></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgc624609" class="outline-2">
<h2 id="orgc624609"><span class="section-number-2">8.</span> Chapter 8: Functions</h2>
<div class="outline-text-2" id="text-8">
<ul class="org-ul">
<li>function是JavaScript最重要 building block,其首先拥有其他编程语言类似的功能: 在一处定义,多处调用</li>
<li>JavaScript的function也是有参数(parameters)的,这些参数会作为function的local variable使用,当函数使用
的时候会给这些local variable赋值,这些赋的值叫做argument</li>
<li><p>
每次调用(invocation)也会产生一个值:invocation context,它就是this的值
</p>
<pre class="example" id="org3b2f444">
Each invocation has another value -- the invocation context -- that is
the value of the this keyword
</pre></li>
<li>如果一个function被配置为一个object的property,那么这个function就被任命为method. 当function通过object
进行触发,那么object就是invocation context(换句话说,object就是this)</li>
<li>用来初始化一个新的object的function叫做constructor,这个会在第九章进行介绍.</li>
<li>在JavaScript中,function是object,这也就意味着一个function也可以作为argument,赋值给其他function的parameter</li>
<li>由于function是object,你还可以给function配置property,甚至是配置method!</li>
<li>JavaScript function内部还能创建function,内部的function可以访问"创建自己的scope"里面的变量,这也就意
味着JavaScript function是closure.这会带来更多的编程语言特性</li>
</ul>
</div>
<div id="outline-container-org961c554" class="outline-3">
<h3 id="org961c554"><span class="section-number-3">8.1.</span> Defining Functions</h3>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: harrifeng@outlook.com</p>
<p class="date">Created: 2025-01-23 Thu 15:00</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>